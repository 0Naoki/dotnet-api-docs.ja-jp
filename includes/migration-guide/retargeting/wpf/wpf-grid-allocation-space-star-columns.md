### <a name="wpf-grid-allocation-of-space-to-star-columns"></a><span data-ttu-id="83611-101">スター型列に、領域の割り当てを WPF グリッド</span><span class="sxs-lookup"><span data-stu-id="83611-101">WPF Grid allocation of space to star-columns</span></span>

|   |   |
|---|---|
|<span data-ttu-id="83611-102">説明</span><span class="sxs-lookup"><span data-stu-id="83611-102">Details</span></span>|<span data-ttu-id="83611-103">.NET Framework 4.7 以降では、WPF は、アルゴリズムに置き換えられますを<xref:System.Windows.Controls.Grid>を使用してスペースを割り当てる \*-列です。</span><span class="sxs-lookup"><span data-stu-id="83611-103">Starting with the .NET Framework 4.7, WPF replaces the algorithm that <xref:System.Windows.Controls.Grid> uses to allocate space to \*-columns.</span></span> <span data-ttu-id="83611-104">これに割り当てられている実際の幅が変更されます \* のケースの数の列。</span><span class="sxs-lookup"><span data-stu-id="83611-104">This will change the actual width assigned to \*-columns in a number of cases:</span></span><ul><li><span data-ttu-id="83611-105">ときに 1 つまたは複数 \*-列もがある最小値または最大の幅をその列の割り当てを比例をオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="83611-105">When one or more \*-columns also have a minimum or maximum width that overrides the proportional allocation for that colum.</span></span> <span data-ttu-id="83611-106">(最小の幅は MinWidth の明示的な宣言から、または列のコンテンツから取得した、暗黙の型の最小値から派生できます。</span><span class="sxs-lookup"><span data-stu-id="83611-106">(The minimum width can derive from an explicit MinWidth declaration, or from an implicit minimum obtained from the column's content.</span></span> <span data-ttu-id="83611-107">幅の最大値のみで明示的に定義できます、MaxWidth 宣言からです。)</span><span class="sxs-lookup"><span data-stu-id="83611-107">The maximum width can only be defined explicitly, from a MaxWidth declaration.)</span></span></li><li><span data-ttu-id="83611-108">ときに 1 つまたは複数 *-極端に大きな列を宣言 *-weight、10 を超える ^298 です。</span><span class="sxs-lookup"><span data-stu-id="83611-108">When one or more *-columns declare an extremely large *-weight, greater than 10^298.</span></span></li><li><span data-ttu-id="83611-109">ときに、\* の重量は大幅に異なるため、浮動小数点が不安定になる (オーバーフロー、アンダー フロー、精度が失われる) が発生します。</span><span class="sxs-lookup"><span data-stu-id="83611-109">When the \*-weights are sufficiently different to encounter floating-point instability (overflow, underflow, loss of precision).</span></span></li><li><span data-ttu-id="83611-110">レイアウトの丸めが有効で、ディスプレイの実効 DPI が十分に高い場合。</span><span class="sxs-lookup"><span data-stu-id="83611-110">When layout rounding is enabled, and the effective display DPI is sufficiently high.</span></span></li></ul><span data-ttu-id="83611-111">最初の 2 つの場合、新しいアルゴリズムによって生成される幅は大きく異なる、古いアルゴリズムによって生成されることができます。最後の場合の違いはピクセルである最大で 1 つまたは 2 つ。新しいアルゴリズムには、古いアルゴリズム内に存在するいくつかのバグが修正されます。</span><span class="sxs-lookup"><span data-stu-id="83611-111">In the first two cases, the widths produced by the new algorithm can be significantly different from those produced by the old algorithm; in the last case, the difference will be at most one or two pixels.The new algorithm fixes several bugs present in the old algorithm:</span></span><ol><li><span data-ttu-id="83611-112">列への割り当ての合計は、グリッドの幅を超える可能性があります。</span><span class="sxs-lookup"><span data-stu-id="83611-112">Total allocation to columns can exceed the Grid's width.</span></span> <span data-ttu-id="83611-113">この問題は、比例配分が最小サイズ未満の列に領域を割り当てると発生します。</span><span class="sxs-lookup"><span data-stu-id="83611-113">This can occur when allocating space to a column whose proportional share is less than its minimum size.</span></span> <span data-ttu-id="83611-114">このアルゴリズムでは最小サイズが割り当てられるため、他の列に使用できる領域が減ります。</span><span class="sxs-lookup"><span data-stu-id="83611-114">The algorithm allocates the minimum size, which decreases the space available to other columns.</span></span> <span data-ttu-id="83611-115">ある場合ありません \*、列に割り当てる左、割り当ての合計になりますが大きすぎます。</span><span class="sxs-lookup"><span data-stu-id="83611-115">If there are no \*-columns left to allocate, the total allocation will be too large.</span></span></li><li><span data-ttu-id="83611-116">割り当ての合計が、グリッドの幅未満になる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="83611-116">Total allocation can fall short of the Grid's width.</span></span> <span data-ttu-id="83611-117">これは、デュアル 1 が比例配分の列に割り当てがなしで、最大サイズよりも大きい場合に発生する問題 \*-、余裕期間を使用して左の列です。</span><span class="sxs-lookup"><span data-stu-id="83611-117">This is the dual problem to #1, arising when allocating to a column whose proportional share is greater than its maximum size, with no \*-columns left to take up the slack.</span></span></li><li><span data-ttu-id="83611-118">2 つ * の列にない比例割り当てを受け取ることができます、* の重み。</span><span class="sxs-lookup"><span data-stu-id="83611-118">Two *-columns can receive allocations not proportional to their *-weights.</span></span> <span data-ttu-id="83611-119">これは問題 1、2 よりも軽度な問題です。\*-column A、B、C に (この順序で) 割り当てると、B の比例配分共有はその最小値 (または最大値) に違反します。</span><span class="sxs-lookup"><span data-stu-id="83611-119">This is a milder version of #1/#2, arising when allocating to \*-columns A, B, and C (in that order), where B's proportional share violates its min (or max) constraint.</span></span> <span data-ttu-id="83611-120">前述のように、これによって列 C に使用できる領域が変わり、A よりも比例配分の割り当てが少なく (または多く) なります。</span><span class="sxs-lookup"><span data-stu-id="83611-120">As above, this changes the space available to column C, who gets less (or more) proportional allocation than A did,</span></span></li><li><span data-ttu-id="83611-121">非常に大きな重み付けを割り当て列 (&gt; 10 ^298) すべてとして扱われますいました重み 10 ^298 です。</span><span class="sxs-lookup"><span data-stu-id="83611-121">Columns with extremely large weights (&gt; 10^298) are all treated as if they had weight 10^298.</span></span> <span data-ttu-id="83611-122">そのような列 (およびやや小さな重みの列) の比例配分の差は考慮されません。</span><span class="sxs-lookup"><span data-stu-id="83611-122">Proportional differences between them (and between columns with slightly smaller weights) are not honored.</span></span></li><li><span data-ttu-id="83611-123">Inifinte 重みを持つ列は正しく処理されません。</span><span class="sxs-lookup"><span data-stu-id="83611-123">Columns with inifinte weights are not handled correctly.</span></span> <span data-ttu-id="83611-124">[実際には重みを無限大に設定することはできませんが、これは人為的な制限です。</span><span class="sxs-lookup"><span data-stu-id="83611-124">[Actually you can't set a weight to Infinity, but this is an artificial restriction.</span></span> <span data-ttu-id="83611-125">割り当てコードは制限を処理しようとしますが、無効なジョブになります。]</span><span class="sxs-lookup"><span data-stu-id="83611-125">The allocation code was trying to handle it, but doing a bad job.]</span></span></li><li><span data-ttu-id="83611-126">オーバーフロー、アンダーフロー、精度の低下などの浮動小数点精度の問題を回避していますが、いくつかの軽微な問題があります。</span><span class="sxs-lookup"><span data-stu-id="83611-126">Several minor problems while avoiding overflow, underflow, loss of precision and similar floating-point issues.</span></span></li><li><span data-ttu-id="83611-127">十分に高い DPI でレイアウトの丸めの調整が不適切です。</span><span class="sxs-lookup"><span data-stu-id="83611-127">Adjustments for layout rounding are incorrect at sufficiently high DPI.</span></span></li></ol><span data-ttu-id="83611-128">新しいアルゴリズムには、次の基準: A に一致する結果が生成されます。</span><span class="sxs-lookup"><span data-stu-id="83611-128">The new algorithm produces results that meet the following criteria:A.</span></span> <span data-ttu-id="83611-129">割り当てられている実際の幅、\*、列は、小さい最小幅よりも最大幅よりも大きい値ではありません。B.</span><span class="sxs-lookup"><span data-stu-id="83611-129">The actual width assigned to a \*-column is never less than its minimum width nor greater than its maximum width.B.</span></span> <span data-ttu-id="83611-130">各<em>ではない列には、最小値が割り当てられているか、最大の幅には、幅に比例してが割り当てられてその<em>-重み。2 つの列が幅 x で宣言されている場合は、正確に</em>と y</em>それぞれ、およびどちらの列は、その最小値または最大の幅を受信する場合、実際の幅 v と列に割り当てられている w で同じ比率: v/w = = x/y.C.</span><span class="sxs-lookup"><span data-stu-id="83611-130">Each <em>-column that is not assigned its minimum or maximum width is assigned a width proportional to its <em>-weight. To be precise, if two columns are declared with width x</em> and y</em> respectively, and if neither column receives its minimum or maximum width, the actual widths v and w assigned to the columns are in the same proportion: v / w == x / y.C.</span></span> <span data-ttu-id="83611-131">割り当てられた合計幅&quot;比例&quot;*-を制約付きの列に割り当て列が使用可能な領域に等しい (自動修正、および *-列の最小値または最大の幅を割り当てられている)。</span><span class="sxs-lookup"><span data-stu-id="83611-131">The total width allocated to &quot;proportional&quot; *-columns is equal to the space available after allocating to the constrained columns (fixed, auto, and *-columns that are allocated their min or max width).</span></span> <span data-ttu-id="83611-132">たとえば、0 可能性があります、最小の幅の合計が、グリッドの availbable 幅を超える場合。D.</span><span class="sxs-lookup"><span data-stu-id="83611-132">This might be zero, for instance if the sum of the minimum widths exceeds the Grid's availbable width.D.</span></span> <span data-ttu-id="83611-133">これらすべてのステートメントを解釈するのには、&quot;理想的な&quot;レイアウトです。</span><span class="sxs-lookup"><span data-stu-id="83611-133">All these statements are to be interpreted with respect to the &quot;ideal&quot; layout.</span></span> <span data-ttu-id="83611-134">レイアウトの丸めが有効な場合の実際の幅とは異なる最適な幅限り 1 ピクセルずつです。古いアルゴリズムでは、(A) を受け入れられますが、上記で説明したような場合にその他の条件を有効にできませんでした。すべての列と幅がこの記事の内容について言うを行と高さにも適用します。</span><span class="sxs-lookup"><span data-stu-id="83611-134">When layout rounding is in effect, the actual widths can differ from the ideal widths by as much as one pixel.The old algorithm honored (A) but failed to honor the other criteria in the cases outlined above.Everything said about columns and widths in this article applies as well to rows and heights.</span></span>|
|<span data-ttu-id="83611-135">提案される解決策</span><span class="sxs-lookup"><span data-stu-id="83611-135">Suggestion</span></span>|<span data-ttu-id="83611-136">既定では、.NET Framework 4.7 以降の .NET Framework のバージョンを対象に対象とする .NET Framework 4.6.2 または以前のバージョンが古いアルゴリズムを参照して、アプリの中に、新しいアルゴリズムが表示されるアプリです。既定をオーバーライドするには、次の構成設定を使用します。</span><span class="sxs-lookup"><span data-stu-id="83611-136">By default, apps that target versions of the .NET Framework starting with the .NET Framework 4.7 will see the new algorithm, while apps that target the .NET Framework 4.6.2 or earlier versions will see the old algorithm.To override the default, use the following configuration setting:</span></span><pre><code class="language-xml">&lt;runtime&gt;&#13;&#10;&lt;AppContextSwitchOverrides value=&quot;Switch.System.Windows.Controls.Grid.StarDefinitionsCanExceedAvailableSpace=true&quot; /&gt;&#13;&#10;&lt;/runtime&gt;&#13;&#10;</code></pre><span data-ttu-id="83611-137">値 'true' が古いアルゴリズムを選択し、'false' に、新しいアルゴリズムを選択します。</span><span class="sxs-lookup"><span data-stu-id="83611-137">The value 'true' selects the old algorithm, 'false' selects the new algorithm.</span></span>|
|<span data-ttu-id="83611-138">スコープ</span><span class="sxs-lookup"><span data-stu-id="83611-138">Scope</span></span>|<span data-ttu-id="83611-139">マイナー</span><span class="sxs-lookup"><span data-stu-id="83611-139">Minor</span></span>|
|<span data-ttu-id="83611-140">Version</span><span class="sxs-lookup"><span data-stu-id="83611-140">Version</span></span>|<span data-ttu-id="83611-141">4.7</span><span class="sxs-lookup"><span data-stu-id="83611-141">4.7</span></span>|
|<span data-ttu-id="83611-142">型</span><span class="sxs-lookup"><span data-stu-id="83611-142">Type</span></span>|<span data-ttu-id="83611-143">再ターゲット中</span><span class="sxs-lookup"><span data-stu-id="83611-143">Retargeting</span></span>|

