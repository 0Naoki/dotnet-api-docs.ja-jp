<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9ff9e9059e4ce5150d6f6c7e167f04a8c9806c33" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52245189" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>再利用でき、バージョン管理可能で自己記述型の共通言語ランタイム アプリケーションのビルド ブロックであるアセンブリを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Reflection.Assembly>をアセンブリに含まれる型を検出し、それらの型のインスタンスを作成するときに、アセンブリのメタデータと構成要素の部分を調べることに、アセンブリをロードするクラス。  
  
 配列を取得する<xref:System.Reflection.Assembly>オブジェクトを使用して (たとえば、既定のアプリケーション ドメインの単純なプロジェクト)、アプリケーション ドメインに読み込まれる現在のアセンブリを表す、<xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType>メソッド。  
  
 アセンブリを動的に読み込む、<xref:System.Reflection.Assembly>クラスは、次の静的メソッドを提供します。 (`Shared` Visual Basic でのメソッド)。 アセンブリは、読み込み操作が発生するアプリケーション ドメインに読み込まれます。  
  
-   アセンブリを読み込むことをお勧めの方法は使用する、<xref:System.AppDomain.Load%2A>メソッドで、その表示名によって読み込まれるアセンブリを識別します (たとえば、"System.Windows.Forms、バージョン 2.0.0.0、カルチャを = = neutral, PublicKeyToken = b77a5c561934e089")。 アセンブリの検索で説明されている規則に従った[ランタイムがアセンブリを検索する方法](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md)します。  
  
-   <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドを実行ではなく、リフレクションのアセンブリを読み込むことができます。 たとえば、32 ビット プラットフォームで実行されているコードによって、64 ビット プラットフォームを対象とするアセンブリを検証できます。  
  
-   <xref:System.Reflection.Assembly.LoadFile%2A>と<xref:System.Reflection.Assembly.LoadFrom%2A>パスでアセンブリを識別する必要があります、まれなシナリオのメソッドが用意されています。  
  
 取得する、<xref:System.Reflection.Assembly>使用して、現在実行中のアセンブリのオブジェクト、<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>メソッド。  
  
 多くのメンバー、<xref:System.Reflection.Assembly>クラスは、アセンブリに関する情報を提供します。 次に例を示します。  
  
-   <xref:System.Reflection.Assembly.GetName%2A>メソッドが返す、<xref:System.Reflection.AssemblyName>アセンブリの表示名の部分へのアクセスを提供するオブジェクト。  
  
-   <xref:System.Reflection.Assembly.GetCustomAttributes%2A>メソッドは、アセンブリに適用される属性を一覧表示されます。  
  
-   <xref:System.Reflection.Assembly.GetFiles%2A>メソッドは、アセンブリ マニフェスト内のファイルへのアクセスを提供します。  
  
-   <xref:System.Reflection.Assembly.GetManifestResourceNames%2A>メソッドは、アセンブリ マニフェストにリソースの名前を提供します。  
  
 <xref:System.Reflection.Assembly.GetTypes%2A>メソッドは、アセンブリ内のすべての型を一覧表示されます。 <xref:System.Reflection.Assembly.GetExportedTypes%2A>メソッドが呼び出し元アセンブリの外側に表示される種類を一覧表示されます。 <xref:System.Reflection.Assembly.GetType%2A>メソッドは、アセンブリ内の特定の型を検索するために使用できます。 <xref:System.Reflection.Assembly.CreateInstance%2A>を検索し、アセンブリで型のインスタンスを作成するメソッドを使用できます。  
  
 アセンブリの詳細については、「アプリケーション ドメインとアセンブリ」のセクションを参照してください、[アプリケーション ドメイン](~/docs/framework/app-domains/application-domains.md)トピック。  
  
   
  
## Examples  
 次のコード例では、現在実行中のアセンブリを取得し、そのアセンブリに含まれる型のインスタンスを作成し、遅延バインディングの型のメソッドのいずれかを呼び出す方法を示します。 コード例をこの目的のためには、という名前のクラスを定義します`Example`、という名前のメソッドで`SampleMethod`します。 クラスのコンス トラクターは、メソッドの戻り値の計算に使用される整数値を受け入れます。  
  
 コード例の使用にも示します、<xref:System.Reflection.Assembly.GetName%2A>メソッドを取得する、<xref:System.Reflection.AssemblyName>アセンブリの完全名を解析するために使用できるオブジェクト。 例では、アセンブリのバージョン番号が表示されます、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティ、および<xref:System.Reflection.Assembly.EntryPoint%2A>プロパティ。  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承クラスの完全な信頼。 部分的に信頼されたコードでは、このクラスを継承できません。</permission>
    <threadsafe>この型はスレッド セーフです。</threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md">アプリケーション ドメイン</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Assembly" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクターは、構築する際に派生クラスによって呼び出される<xref:System.Reflection.Assembly>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>たとえば <see cref="T:System.Reflection.AssemblyName" /> オブジェクトで、初めに指定されたアセンブリの場所を取得します。</summary>
        <value>初めに指定されたとおりのアセンブリの場所。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み込み済みのマニフェストを含むファイルへの絶対パスを取得する、<xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType>プロパティ代わりにします。  
  
 アセンブリがバイト配列として読み込まれた場合のオーバー ロードを使用して、<xref:System.Reflection.Assembly.Load%2A>バイトの配列を受け取るメソッドでは、このプロパティは、読み込まれたアセンブリの場所ではなく、メソッドの呼び出し元の場所を返します。  
  
   
  
## Examples  
 次の例では、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティ。  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリから型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <summary>大文字小文字を区別する検索を使用してこのアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
        <returns>既定のコンストラクターを使用して作成された指定した型のインスタンス。<paramref name="typeName" /> が見つからない場合は、<see langword="null" />。 型は、既定のバインダーを使用して解決されます。カルチャまたはアクティベーション属性は指定せず、<see cref="T:System.Reflection.BindingFlags" /> を <see langword="Public" /> または <see langword="Instance" /> に設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ランタイムが検索できない場合`typeName`で、<xref:System.Reflection.Assembly>インスタンスが返されます`null`例外をスローする代わりにします。 これは、ために発生する可能性があります。  
  
-   型の完全修飾名を指定していません。  
  
-   完全修飾型名を指定したが、そのケースは、型の場合と一致しません<xref:System.Type.FullName%2A?displayProperty=nameWithType>プロパティ。 大文字と小文字の`typeName`型の完全な名前を使用して呼び出す、<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>オーバー ロードし、指定`true`の`ignoreCase`引数。  
  
-   現在の型が存在しない<xref:System.Reflection.Assembly>インスタンス。  
  
   
  
## Examples  
 次の例では、定義、`Person`クラスと呼び出し、<xref:System.Reflection.Assembly.CreateInstance%28System.String%29>インスタンス化するメソッド。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> が空の文字列 ("") であるか、null 文字で始まる文字列です。  
  
または 
現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターは見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
または 
現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
または 
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>オプションの大文字小文字を区別する検索を使用してこのアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成します。</summary>
        <returns>既定のコンストラクターを使用して作成された指定した型のインスタンス。<paramref name="typeName" /> が見つからない場合は、<see langword="null" />。 型は、既定のバインダーを使用して解決されます。カルチャまたはアクティベーション属性は指定せず、<see cref="T:System.Reflection.BindingFlags" /> を <see langword="Public" /> または <see langword="Instance" /> に設定します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ランタイムが検索できない場合`typeName`で、<xref:System.Reflection.Assembly>インスタンスが返されます`null`例外をスローする代わりにします。 これは、ために発生する可能性があります。  
  
-   型の完全修飾名を指定していません。  
  
-   現在の型が存在しない<xref:System.Reflection.Assembly>インスタンス。  
  
   
  
## Examples  
 次の例では、定義、`Person`クラス。 呼び出して、 <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> 、インスタンス化するメソッドが、大文字と小文字の`typeName`の型の引数と一致しません<xref:System.Type.FullName%2A>プロパティ、メソッドを返します`null`します。 例での同じ文字列のパスと、<xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29>オーバー ロードし、比較は、大文字と小文字があることを指定します、`Person`クラスが見つかると`Person`オブジェクトが正常にインスタンス化します。  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> が空の文字列 ("") であるか、null 文字で始まる文字列です。  
  
または 
現在のアセンブリがリフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> に必要な依存アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
または 
現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
または 
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">検索対象の型の <see cref="P:System.Type.FullName" />。</param>
        <param name="ignoreCase">型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="bindingAttr">検索の実行方法に影響を与えるビットマスク。 値は、<see cref="T:System.Reflection.BindingFlags" /> のビット フラグの組み合わせです。</param>
        <param name="binder">バインディング、引数型の強制変換、メンバーの呼び出し、および、リフレクションによる <see langword="MemberInfo" /> オブジェクトの取得を有効にするオブジェクト。 <paramref name="binder" /> が <see langword="null" /> の場合は、既定のバインダーが使用されます。</param>
        <param name="args">コンストラクターに渡す引数を格納する配列。 この引数の配列は、呼び出すコンストラクターのパラメーターと、数、順序、および型が同じでなければなりません。 既定のコンストラクターを使用する場合は、<paramref name="args" /> を空の配列または <see langword="null" /> にする必要があります。</param>
        <param name="culture">型の強制変換を制御するために使用する <see langword="CultureInfo" /> のインスタンス。 <see langword="null" /> の場合は、現在のスレッドの <see langword="CultureInfo" /> が使用されます。 (これは、たとえば、1000 を表す <see langword="String" /> を <see langword="Double" /> 値に変換する場合に必要です。これは、カルチャによって 1000 の表記が異なるためです。)</param>
        <param name="activationAttributes">アクティべーションに参加できる 1 つ以上の属性の配列。 通常、リモート オブジェクトをアクティブ化するために必要な URL を指定する 1 つの <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> オブジェクトを含む配列。  このパラメーターは、クライアント側でアクティブ化されるオブジェクトに関連しています。 クライアント アクティベーションは、下位互換性のために残されているレガシ テクノロジです。新規の開発には使用しないでください。 分散アプリケーションは、代わりに Windows Communication Foundation (WCF) を使用する必要があります。</param>
        <summary>オプションの大文字小文字を区別する検索を使用して、このアセンブリから指定された型を検索し、システム アクティベーターを使用してこの型のインスタンスを作成し、指定されたカルチャ設定、引数、バインディング属性、およびアクティべーション属性を設定します。</summary>
        <returns>指定した型のインスタンス。<paramref name="typeName" /> が見つからない場合は、<see langword="null" />。 指定された引数は、型を解決するため、およびインスタンスの作成に使用されるコンストラクターをバインドするために使用されます。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> は空の文字列 ("") または null 文字で始まる文字列です。  
  
または 
現在のアセンブリは、リフレクションのみのコンテキストに読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.MissingMethodException">一致するコンストラクターが見つかりませんでした。</exception>
        <exception cref="T:System.NotSupportedException">空でないアクティベーション属性の配列は、<see cref="T:System.MarshalByRefObject" /> から継承されていない型に渡されます。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
または 
現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="typeName" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
または 
 <paramref name="typeName" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">デリゲートのインスタンスを作成します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">アセンブリの表示名。</param>
        <param name="typeName">型の完全名。</param>
        <summary>アセンブリの表示名で修飾された型名を作成します。</summary>
        <returns>アセンブリの表示名で修飾された型の完全名。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される文字列の形式です。  
  
 \<FullTypeName>, \<AssemblyDisplayName>  
  
 参照してください<xref:System.Reflection.AssemblyName>アセンブリの表示名の形式の説明についてはします。  
  
 共通言語ランタイムのバージョンの変更に合わせて、自分で修飾名を構築するのではなく、このメソッドを使用します。  修飾アセンブリ名については、次を参照してください。<xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのカスタム属性を含むコレクションを取得します。</summary>
        <value>このアセンブリのカスタム属性を含むコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリで定義されている型のコレクションを取得します。</summary>
        <value>このアセンブリで定義されている型のコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.DefinedTypes%2A>プロパティに相当する、<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>点を除いて、メソッド、<xref:System.Reflection.Assembly.DefinedTypes%2A>プロパティのコレクションを返します<xref:System.Reflection.TypeInfo>オブジェクト、および<xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>メソッドの配列を返します<xref:System.Type>オブジェクト。  
  
 返される配列には、入れ子にされた型が含まれています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリのエントリ ポイントを取得します。</summary>
        <value>このアセンブリのエントリ ポイントを表すオブジェクト。 エントリ ポイントが見つからない場合 (アセンブリが DLL の場合など) は、<see langword="null" /> が返されます。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">このインスタンスと比較するオブジェクト。</param>
        <summary>このアセンブリと指定したオブジェクトが等しいかどうかを判断します。</summary>
        <returns>
          <paramref name="o" /> がこのインスタンスと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.Equals%2A>メソッドは参照の等価性を判断するためのテストを実行するかどうか、現在のインスタンスと`o`が等しい。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コードベースを表す URI を、エスケープ文字も含めて取得します。</summary>
        <value>エスケープ文字を含んだ URI。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリの証拠を取得します。</summary>
        <value>このアセンブリの証拠。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 証拠とは、セキュリティ ポリシーがアクセス許可を決定するときに使用する一連の情報 (コードにどのようなアクセス許可を付与できるかなど) のことです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型のコレクションを取得します。</summary>
        <value>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型のコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの表示名を取得します。</summary>
        <value>アセンブリの表示名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 参照してください<xref:System.Reflection.AssemblyName>アセンブリの表示名の形式の説明についてはします。  
  
> [!NOTE]
>  表示名を解析するコードを記述することは推奨されません。 代わりに、表示名を渡す、<xref:System.Reflection.AssemblyName.%23ctor%2A>コンス トラクターは、解析し、新しいの適切なフィールドを設定します。<xref:System.Reflection.AssemblyName>します。  
  
 .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 ただし、これが含まれていませんによって返される文字列で、<xref:System.Reflection.Assembly.FullName%2A>互換性のためのプロパティ。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例は、現在実行中のアセンブリの表示名とを含むアセンブリの表示名を取得します。、<xref:System.Int32>型 (`int` c# で`Integer`Visual Basic で)。  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md">完全修飾型名の指定</related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">返されるアセンブリ内の型を表すオブジェクト。</param>
        <summary>指定した型が定義されている、現在読み込み済みのアセンブリを取得します。</summary>
        <returns>指定された型が定義されているアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値を取得するのにはこのメソッドを呼び出す、<xref:System.Type.Assembly?displayProperty=nameWithType>プロパティ。 ただし、<xref:System.Type.Assembly?displayProperty=nameWithType>プロパティが通常よりも優れたパフォーマンスを提供します。  
  
 このメソッドを呼び出すために必要な<xref:System.Type>オブジェクトで、クラスが定義されているアセンブリが読み込む既に必要があることを意味します。  
  
   
  
## Examples  
 次の例を含むアセンブリの取得、<xref:System.Int32>を入力し、その名前とファイルの場所が表示されます。  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のメソッドを呼び出したメソッドの <see cref="T:System.Reflection.Assembly" /> を返します。</summary>
        <returns>現在実行中のメソッドを呼び出したメソッドの <see langword="Assembly" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かどうか、メソッドを呼び出す、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>メソッドは、- イン タイム (JIT) コンパイラによってインラインで展開されるか、呼び出し元がインライン展開の場合は、アセンブリであるによって返される<xref:System.Reflection.Assembly.GetCallingAssembly%2A>が予期せずに異なる場合があります。 たとえば、次のメソッドおよびアセンブリがあるとします。  
  
-   メソッド`M1`アセンブリで`A1`呼び出し<xref:System.Reflection.Assembly.GetCallingAssembly%2A>します。  
  
-   メソッド`M2`アセンブリで`A2`呼び出し`M1`します。  
  
-   メソッド`M3`アセンブリで`A3`呼び出し`M2`します。  
  
 ときに`M1`、インラインでない<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A2`します。 ときに`M1`インライン化される、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A3`します。 同様に、 `M2` 、インラインでない<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A2`します。 ときに`M2`インライン化される、<xref:System.Reflection.Assembly.GetCallingAssembly%2A>返します`A3`します。  
  
 この効果にも発生するとき`M1`から末尾呼び出しとして実行します。 `M2`、または`M2`から末尾呼び出しとして実行します。 `M3`。 JIT コンパイラを防ぐことができますインライン化メソッドを呼び出す<xref:System.Reflection.Assembly.GetCallingAssembly%2A>、適用することで、<xref:System.Runtime.CompilerServices.MethodImplAttribute>属性、<xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType>フラグ、末尾呼び出しを回避するための同様のメカニズムはありません。  
  
   
  
## Examples  
 次の例では、現在のメソッドの呼び出し元のアセンブリを取得します。  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリのカスタム属性を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">
          <see cref="T:System.Reflection.Assembly" /> 型のオブジェクトでは、この引数は無視されます。</param>
        <summary>このアセンブリのすべてのカスタム属性を取得します。</summary>
        <returns>このアセンブリのカスタム属性を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、対応する<xref:System.Reflection.ICustomAttributeProvider>インターフェイス メソッド。 そのため、`inherit`は無視されますは、パラメーターを指定する必要があります。  
  
 擬似属性では、属性が存在する場合に設定する必要があるコア メタデータのビットを示します。 型のメタデータを拡張し、種類と共に保存はカスタム属性とは異なり擬似属性は型のメタデータを変更し、破棄されます。 一部の結果のビットは、既存のリフレクション Api を使用してアクセスできません。  
  
 次の表に、擬似属性とリフレクションで使用できる bits のアクセサーを示します。  
  
|擬似属性|メタデータのビット|リフレクションのアクセサー|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 名|アクセサーはありません PInvokeMap に対する通常メソッド/グローバル メソッドの属性について。<br /><br /> DLL 名のアクセサーはありません。|  
|GuidAttribute|実際のカスタム属性として保存されます。|実際のカスタム属性としてアクセスします。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|Serializableattribute に設定します|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|さまざまな部分です。|アクセサーはありません。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags() します。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags() します。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> パッキングのクラス。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> アクセサーはありません。|  
|FieldOffsetAttribute|フィールドのオフセット。|アクセサーはありません。|  
|AssemblyLoadAttribute|CorAssemblyFlags|アクセサーがないか、列挙子。|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">カスタム属性を返す対象の型。</param>
        <param name="inherit">
          <see cref="T:System.Reflection.Assembly" /> 型のオブジェクトでは、この引数は無視されます。</param>
        <summary>型を指定して、このアセンブリのカスタム属性を取得します。</summary>
        <returns>このアセンブリの <paramref name="attributeType" /> で指定されたカスタム属性を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、対応する<xref:System.Reflection.ICustomAttributeProvider>インターフェイス メソッド。 そのため、`inherit`は無視されますは、パラメーターを指定する必要があります。  
  
 擬似属性では、属性が存在する場合に設定する必要があるコア メタデータのビットを示します。 型のメタデータを拡張し、種類と共に保存はカスタム属性とは異なり擬似属性は型のメタデータを変更し、破棄されます。 一部の結果のビットは、既存のリフレクション Api を使用してアクセスできません。  
  
 次の表に、擬似属性とリフレクションで使用できる bits のアクセサーを示します。  
  
|擬似属性|メタデータのビット|リフレクションのアクセサー|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> DLL 名|アクセサーはありません PInvokeMap に対する通常メソッド/グローバル メソッドの属性について。<br /><br /> DLL 名のアクセサーはありません。|  
|GuidAttribute|実際のカスタム属性として保存されます。|実際のカスタム属性としてアクセスします。|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|Serializableattribute に設定します|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|さまざまな部分です。|アクセサーはありません。|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags() します。OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags() します。OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> パッキングのクラス。|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> アクセサーはありません。|  
|FieldOffsetAttribute|フィールドのオフセット。|アクセサーはありません。|  
|AssemblyLoadAttribute|CorAssemblyFlags|アクセサーがないか、列挙子。|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> がランタイム型ではありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在の <see cref="T:System.Reflection.Assembly" /> に適用されている属性に関する情報を、<see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトとして返します。</summary>
        <returns>現在のアセンブリに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクションのみのコンテキストに読み込まれるコードでカスタム属性そのものが定義されている場合、リフレクションのみのコンテキスト内のコードのカスタム属性を調べるには、このメソッドを使用します。 などのメソッド<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>と<xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType>属性のインスタンスを作成するため、このような場合では使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細と例のコードについて、次を参照してください。、<xref:System.Reflection.CustomAttributeData>クラス。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>既定のアプリケーション ドメインで実行できるプロセスを取得します。 他のアプリケーション ドメインでは、<see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> で実行された最初の実行可能ファイルです。</summary>
        <returns>既定のアプリケーション ドメインで実行できるプロセスであるアセンブリ。または、<see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> で実行された最初の実行可能ファイル。 アンマネージ コードから呼び出された場合は、<see langword="null" /> を返すことができます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Assembly.GetEntryAssembly%2A>メソッドが返す`null`マネージ アセンブリが、アンマネージ アプリケーションから読み込まれたとき。 たとえば、アンマネージ アプリケーションは、c# への呼び出しで記述された COM コンポーネントのインスタンスを作成する場合、<xref:System.Reflection.Assembly.GetEntryAssembly%2A>のため、プロセスのエントリ ポイント マネージ アセンブリではなく、アンマネージ コードは c# コンポーネントからのメソッドが null を返します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在実行中のコードを格納しているアセンブリを取得します。</summary>
        <returns>現在実行中のコードを格納しているアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パフォーマンス上の理由は不明なデザイン時にどのようなアセンブリが現在実行している場合にのみ、このメソッドを呼び出す必要があります。 取得することをお勧めの方法、 <xref:System.Reflection.Assembly> 、現在のアセンブリを表すオブジェクトを使用することです、<xref:System.Type.Assembly%2A?displayProperty=nameWithType>次の例に示すように、アセンブリで型のプロパティが見つかりました。  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 現在実行中のコードと呼ばれるメソッドを含むアセンブリを取得する<xref:System.Reflection.Assembly.GetCallingAssembly%2A>します。  
  
   
  
## Examples  
 次の例では、<xref:System.Type.Assembly%2A?displayProperty=nameWithType>そのアセンブリに含まれる型に基づいて、現在実行中のアセンブリを取得するプロパティ。 呼び出しも、<xref:System.Reflection.Assembly.GetExecutingAssembly%2A>を返すことを表示するメソッド、<xref:System.Reflection.Assembly>同じアセンブリを表すオブジェクト。  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの外側で参照できる、このアセンブリ内で定義されているパブリック型を取得します。</summary>
        <returns>アセンブリの外部で参照できる、このアセンブリ内で定義されている型を表す配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 外部アセンブリから参照できる専用の型は、パブリック型と他のパブリック型内で入れ子になったパブリック型です。  
  
   
  
## Examples  
 次のコード サンプルは、多数のさまざまなアクセス レベル、および呼び出しとクラスを定義します。<xref:System.Reflection.Assembly.GetExportedTypes%2A>アセンブリの外部から表示されているものを表示します。  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">アセンブリが動的アセンブリです。</exception>
        <exception cref="T:System.IO.FileNotFoundException">依存するアセンブリを読み込めません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">指定されたファイルの名前。 ファイルへのパスを含めないでください。</param>
        <summary>このアセンブリのマニフェストのファイル テーブルの指定されたファイルの <see cref="T:System.IO.FileStream" /> を取得します。</summary>
        <returns>指定したファイルを格納するストリーム。ファイルが見つからない場合は、<see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、両方のパブリックおよびプライベートのリソース ファイルで機能します。  
  
 `name`ファイルへのパスを含めることはできません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 ("") になっています。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> が見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> が有効なアセンブリではありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにし、指定したファイルを読み取るためにアクセスします。 列挙体に関連付けられている:<see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />と <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>ファイルを格納するストリームの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
 このオーバー ロードの呼び出しと同じですが、<xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29>オーバー ロードを指定して`false`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">ファイルが有効なアセンブリではありませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、アセンブリ マニフェストのファイル テーブルのファイルを取得します。</summary>
        <returns>ファイルを格納するストリームの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイルが見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">ファイルが有効なアセンブリではありませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>対象のインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、このアセンブリの一部であるすべての読み込み済みモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">リソースの、大文字と小文字が区別される名前。</param>
        <summary>指定されたリソースが永続化された方法に関する情報を返します。</summary>
        <returns>リソースのトポロジに関する情報が設定されたオブジェクト。リソースが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="resourceName" /> パラメーターが空の文字列 ("") です。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリのすべてのリソースの名前を返します。</summary>
        <returns>すべてのリソースの名前を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次のように、このメソッドによって返される配列では、各リソース名を使用できます。  
  
-   リソース名を渡すことができます、<xref:System.Reflection.Assembly.GetManifestResourceInfo%2A>リソースに関する追加情報を取得します。  
  
-   名前は、バイナリ .resources ファイルを識別する場合は、その .resources ファイルの拡張子を削除およびに渡す、<xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType>リソース マネージャーのインスタンスを作成するコンス トラクター。  
  
-   リソース名を渡すことができます、<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を取得するメソッド、<xref:System.IO.Stream>に渡すことができますし、オブジェクト、<xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>コンス トラクター。  
  
-   リソース名を渡すことができます、<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を取得するメソッド、<xref:System.IO.Stream>に渡すことができますし、オブジェクト、<xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType>コンス トラクター。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求されているマニフェスト リソースの、大文字と小文字が区別される名前。</param>
        <summary>このアセンブリから、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>マニフェスト リソース。コンパイル時にリソースが指定されない場合や、リソースが呼び出し元から参照できない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マニフェスト リソースは、コンパイル時にアセンブリに埋め込まれているリソース (イメージ ファイル) などです。 マニフェスト リソースの詳細については、次を参照してください。 [Microsoft .NET Framework リソースの基本](https://go.microsoft.com/fwlink/?LinkId=204554)、MSDN ライブラリ。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>します。  
  
> [!NOTE]
>  このメソッドが戻る`null`別のアセンブリ内のプライベートなリソースにアクセスすると、呼び出し元が<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>フラグ。  
  
 アセンブリ マニフェストには、リソース ファイルが表示されている場合<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を返します、<xref:System.IO.Stream>オブジェクトの場合でも、リソース ファイルは、時間ディスクで検出されたことはできません。 リソース ファイルが見つからない場合、その結果を渡して<xref:System.IO.Stream>オブジェクトを<xref:System.Resources.ResourceReader>コンス トラクターにより、<xref:System.ArgumentException>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> は見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は有効なアセンブリではありません。</exception>
        <exception cref="T:System.NotImplementedException">リソースの長さが <see cref="F:System.Int64.MaxValue" /> より大きくなっています。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">アセンブリ マニフェスト</related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">マニフェスト リソース名のスコープを指定するために名前空間を使用する型。</param>
        <param name="name">要求されているマニフェスト リソースの、大文字と小文字が区別される名前。</param>
        <summary>このアセンブリから、指定された型の名前空間によってスコープが指定されている、指定されたマニフェスト リソースを読み込みます。</summary>
        <returns>マニフェスト リソース。コンパイル時にリソースが指定されない場合や、リソースが呼び出し元から参照できない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 などの完全な名前が指定されている場合`type`"MyNameSpace.MyClasses"と`name`"MyNameSpace.Net"という名前のリソースを検索"Net"、このメソッド オーバー ロードです。  
  
 マニフェスト リソースは、コンパイル時にアセンブリに埋め込まれているリソース (イメージ ファイル) などです。 マニフェスト リソースの詳細については、次を参照してください。 [Microsoft .NET Framework リソースの基本](https://go.microsoft.com/fwlink/?LinkId=204554)、MSDN ライブラリ。  
  
 リソースが、呼び出し元に表示されるか、呼び出し元が場合にのみ、リソース情報が返される<xref:System.Security.Permissions.ReflectionPermission>します。  
  
> [!NOTE]
>  このメソッドが戻る`null`別のアセンブリ内のプライベートなリソースにアクセスすると、呼び出し元が<xref:System.Security.Permissions.ReflectionPermission>で、<xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType>フラグ。  
  
 アセンブリ マニフェストには、リソース ファイルが表示されている場合<xref:System.Reflection.Assembly.GetManifestResourceStream%2A>を返します、<xref:System.IO.Stream>オブジェクトの場合でも、リソース ファイルは、時間ディスクで検出されたことはできません。 リソース ファイルが見つからない場合、その結果を渡して<xref:System.IO.Stream>オブジェクトを<xref:System.Resources.ResourceReader>コンス トラクターにより、<xref:System.ArgumentException>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> は見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> は有効なアセンブリではありません。</exception>
        <exception cref="T:System.NotImplementedException">リソースの長さが <see cref="F:System.Int64.MaxValue" /> より大きくなっています。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">呼び出されたときに遅延バインディング メカニズムを通じてなど<see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md">アセンブリ マニフェスト</related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">要求するモジュールの名前。</param>
        <summary>このアセンブリから指定されたモジュールを取得します。</summary>
        <returns>要求されたモジュール。モジュールが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、ファイル名で機能します。  
  
 クラス、`Reflection.Emit`名前空間は、動的モジュールのスコープ名を出力します。 スコープ名を決定できます、<xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType>プロパティ。 モジュールの種類を渡す`Assembly.GetModule`します。 たとえば、アセンブリ マニフェストを含むモジュールを実行する場合には、モジュールのスコープの名前を渡す`GetModule`します。 それ以外の場合、モジュールのファイル名を渡します。 いずれかで読み込まれたアセンブリ、`Load`を byte[] パラメーターを持つメソッドが 1 つだけのモジュールがあるし、マニフェスト モジュールです。 スコープ名を使用してこれらのモジュールが常にシークします。  
  
 使用して、特定のモジュールから型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>します。 呼び出す`Module.GetType`モジュールのマニフェストを含むは開始されませんアセンブリ全体を検索します。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> は見つかりませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> が有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリの一部であるすべてのモジュールを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの一部であるすべてのモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
> [!NOTE]
>  ファイル名拡張子を持つモジュールを生成する必要があります。  
  
   
  
## Examples  
 次の例では、アセンブリ マニフェストを含む、返される配列で、モジュールの名前が表示されます。  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">読み込むモジュールのファイル名拡張子が指定されていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">リソース モジュールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>リソース モジュールを含めるかどうかを指定して、このアセンブリの一部であるすべてのモジュールを取得します。</summary>
        <returns>モジュールの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリックおよびプライベートのリソース ファイルで機能します。  
  
> [!NOTE]
>  ファイル名拡張子を持つモジュールを生成する必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得します。</summary>
        <returns>このアセンブリのすべて解析された表示名を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アセンブリのパスにアクセスします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">シャドウ コピーの後で <see cref="P:System.Reflection.Assembly.CodeBase" /> にアセンブリの場所を設定する場合は <see langword="true" />。<see cref="P:System.Reflection.Assembly.CodeBase" /> に元の場所を設定する場合は <see langword="false" />。</param>
        <summary>このアセンブリの <see cref="T:System.Reflection.AssemblyName" /> を取得し、<paramref name="copiedName" /> の指定に従ってコードベースを設定します。</summary>
        <returns>このアセンブリのすべて解析された表示名を格納するオブジェクト。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">アセンブリのパスにアクセスします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">シリアル化情報が設定されるオブジェクト。</param>
        <param name="context">シリアル化の対象コンテキスト。</param>
        <summary>シリアル化情報と、このアセンブリの再インスタンス化に必要なすべてのデータを取得します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリが参照するすべてのアセンブリの <see cref="T:System.Reflection.AssemblyName" /> オブジェクトを取得します。</summary>
        <returns>このアセンブリが参照するすべてのアセンブリのすべて解析された表示名を格納する配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  以降では、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>のプロパティ、<xref:System.Reflection.AssemblyName>このメソッドによって返されるオブジェクトが<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType>、参照先アセンブリのハッシュ アルゴリズムがない場合、または参照先アセンブリのハッシュ アルゴリズムがない場合識別される、<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType>列挙体。 .NET Framework の以前のバージョンで、<xref:System.Reflection.AssemblyName.HashAlgorithm%2A>プロパティから返される<xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType>でこのような状況です。  
  
   
  
## Examples  
 次のコード例は、呼び出し元を示します、<xref:System.Reflection.Assembly.GetReferencedAssemblies%2A>メソッド。 このコード例が示されている例の一部、<xref:System.Reflection.Assembly>クラス。  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>サテライト アセンブリを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <summary>指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリには、メイン アプリケーション アセンブリは、ローカライズできない実行可能コードと、既定またはニュートラル カルチャとして機能する単一カルチャ用のリソースを格納、ローカライズされたリソースが含まれます。  
  
 現在のアセンブリ バージョンを使用するには、このメソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" /> は指定されているファイル名とは一致しませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリが有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">指定されたカルチャ。</param>
        <param name="version">サテライト アセンブリのバージョン。</param>
        <summary>指定されたバージョンの指定されたカルチャ設定のサテライト アセンブリを取得します。</summary>
        <returns>指定されたサテライト アセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サテライト アセンブリには、メイン アプリケーション アセンブリは、ローカライズできない実行可能コードと、既定またはニュートラル カルチャとして機能する単一カルチャ用のリソースを格納、ローカライズされたリソースが含まれます。  
  
 呼び出す、<xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29>の現在のアセンブリ バージョンを使用するオーバー ロードします。  
  
 場合`version`は`null`、メイン アセンブリとリソースの両方が署名されている場合、現在のアセンブリのバージョンを使用します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileLoadException">ファイル名が一致するサテライト アセンブリが見つかりましたが、<see langword="CultureInfo" /> またはバージョンが指定されているファイルとは一致しませんでした。</exception>
        <exception cref="T:System.IO.FileNotFoundException">アセンブリが見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">サテライト アセンブリが有効なアセンブリではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定された型を表す <see cref="T:System.Type" /> オブジェクトを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">型の完全名。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトを、アセンブリ インスタンスから取得します。</summary>
        <returns>指定したクラスを表すオブジェクト。クラスが見つからない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。 `name`名前空間、アセンブリではなく、パラメーターが含まれます。 型の他のアセンブリを検索するには、使用、<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>型名の一部としてアセンブリの表示名を含めることができます必要に応じてメソッドのオーバー ロードします。  
  
> [!NOTE]
>  場合は、型は、別のアセンブリに転送されましたが、このメソッドによっても返されます。 型の転送については、次を参照してください。[共通言語ランタイムで型の転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)します。  
  
   
  
## Examples  
 次の例では、抽象`MeansOfTransportation`クラス、`Transportation`名前空間。 呼び出す、<xref:System.Reflection.Assembly.GetType%28System.String%29>取得するメソッドをその<xref:System.Type>オブジェクト、呼び出し、<xref:System.Type.GetProperties%2A?displayProperty=nameWithType>の配列を取得するメソッドを<xref:System.Reflection.PropertyInfo>抽象化のプロパティの型のプロパティを表すオブジェクト、型の情報が表示されます。 なおへの呼び出し、<xref:System.Reflection.Assembly.GetType%28System.String%29>メソッドは、型の完全修飾名 (つまり、その名前空間型の名前と共に) を使用します。  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が無効です。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> に必要な依存アセンブリが見つかりませんでした。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>
          <paramref name="name" /> に必要な依存アセンブリは見つかりましたが、読み込むことができませんでした。  
  
または 
現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
または 
 <paramref name="name" /> には、現在読み込まれているバージョンよりも新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">型の完全名。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトをアセンブリ インスタンスから取得し、型が見つからない場合は、オプションで例外をスローします。</summary>
        <returns>指定されているクラスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。 `name`名前空間、アセンブリではなく、パラメーターが含まれます。 型の他のアセンブリを検索するには、使用、<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>型名の一部としてアセンブリの表示名を含めることができます必要に応じてメソッドのオーバー ロードします。  
  
> [!NOTE]
>  場合は、型は、別のアセンブリに転送されましたが、このメソッドによっても返されます。 型の転送については、次を参照してください。[共通言語ランタイムで型の転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)します。  
  
 `throwOnError`パラメーター型が見つからない場合にのみ影響します。 スローされる可能性があるその他の例外には影響しません。 型が見つかりましたが、読み込みができない場合は、特に<xref:System.TypeLoadException>スローされる場合でも`throwOnError`は`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が無効です。  
  
または 
<paramref name="name" /> の長さが 1024 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
または 
現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
または 
 <paramref name="name" /> には、現在読み込まれているバージョンよりも新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">型の完全名。</param>
        <param name="throwOnError">型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</param>
        <param name="ignoreCase">型名の大文字と小文字の違いを無視する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した名前の <see cref="T:System.Type" /> オブジェクトをアセンブリ インスタンスから取得します。オプションで、大文字と小文字の区別を無視したり、型が見つからない場合は例外をスローしたりできます。</summary>
        <returns>指定されているクラスを表すオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、現在のアセンブリのインスタンスのみを検索します。 `name`名前空間、アセンブリではなく、パラメーターが含まれます。 型の他のアセンブリを検索するには、使用、<xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType>型名の一部としてアセンブリの表示名を含めることができます必要に応じてメソッドのオーバー ロードします。  
  
> [!NOTE]
>  場合は、型は、別のアセンブリに転送されましたが、このメソッドによっても返されます。 型の転送については、次を参照してください。[共通言語ランタイムで型の転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)します。  
  
 `throwOnError`パラメーター型が見つからない場合にのみ影響します。 スローされる可能性があるその他の例外には影響しません。 型が見つかりましたが、読み込みができない場合は、特に<xref:System.TypeLoadException>スローされる場合でも`throwOnError`は`false`。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> が無効です。  
  
または 
<paramref name="name" /> の長さが 1024 文字を超えています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> には、見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
または 
現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="name" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
または 
 <paramref name="name" /> には、現在読み込まれているバージョンよりも新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このアセンブリで定義されている型を取得します。</summary>
        <returns>このアセンブリで定義されているすべての型を格納している配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返される配列には、入れ子にされた型が含まれています。  
  
 場合、<xref:System.Reflection.Assembly.GetTypes%2A>であるアセンブリが読み込まれていない (たとえば、2 つ目のアセンブリの型から派生した) 場合、アセンブリ内の型に依存するアセンブリと型のメソッドが呼び出された、<xref:System.Reflection.ReflectionTypeLoadException>がスローされます。 たとえば、これに最初のアセンブリが読み込まれている場合、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>または<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッド、および 2 つ目のアセンブリは読み込まれませんでした。 使用して読み込まれたアセンブリにも発生しても、<xref:System.Reflection.Assembly.Load%2A>と<xref:System.Reflection.Assembly.LoadFile%2A>メソッドの場合は、2 つ目のアセンブリが見つからない場合に、<xref:System.Reflection.Assembly.GetTypes%2A>メソッドが呼び出されます。  
  
> [!NOTE]
>  型は、別のアセンブリに転送されていますが場合、返される配列には含まれません。 型の転送については、次を参照してください。[共通言語ランタイムで型の転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)します。  
  
 コレクションを取得する<xref:System.Reflection.TypeInfo>オブジェクトの配列ではなく<xref:System.Type>、オブジェクトを使用して、<xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType>プロパティ。  
  
   
  
## Examples  
 次の例では、型指定されたアセンブリ内で 1 つのメソッドのパラメーターが表示されます。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">読み込むことができない型が 1 つ以上アセンブリに含まれています。 この例外の <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> プロパティで返された配列には、読み込まれた各型に対しては <see cref="T:System.Type" /> オブジェクトが格納され、読み込むことができなかった各型に対しては <see langword="null" /> が格納されます。また、<see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> プロパティには、読み込むことができなかった各型の例外が格納されます。</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリがグローバル アセンブリ キャッシュから読み込まれたかどうかを示す値を取得します。</summary>
        <value>アセンブリがグローバル アセンブリ キャッシュから読み込まれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アセンブリの読み込みに使用したホスト コンテキストを取得します。</summary>
        <value>アセンブリの読み込みに使用したホスト コンテキストがある場合は、そのホスト コンテキストを示す <see cref="T:System.Int64" /> 値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納しているファイルに保存された共通言語ランタイム (CLR: common language runtime) のバージョンを表す文字列を取得します。</summary>
        <value>CLR バージョン フォルダー名。 これは完全パスではありません。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 たとえば、v1.1.4322、.NET Framework version 1.1 の値となります。 そのバージョンのバイナリ ファイルは、パスの %windir%\microsoft.net\framework\v1.1.4322 に配置するとします。  
  
 既定では、<xref:System.Reflection.Assembly.ImageRuntimeVersion%2A>アセンブリのビルドに使用されている CLR のバージョンに設定されます。 ただし、これが設定を別の値にコンパイル時にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">このアセンブリでチェックする属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定した属性がアセンブリに適用されているかどうかを示します。</summary>
        <returns>属性がアセンブリに適用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例に適用されます、<xref:System.Reflection.AssemblyTitleAttribute>アセンブリおよび、使用する属性<xref:System.Reflection.Assembly.IsDefined%2A>が適用されたかどうかを示します。 適用されていない属性もテストします。  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> が無効な型を使用しています。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが、現在のプロセスでリフレクション出力を使用して動的に生成されたかどうかを示す値を取得します。</summary>
        <value>現在のアセンブリが現在のプロセスで動的に生成された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動的アセンブリが、派生クラスによって表される<xref:System.Reflection.Emit.AssemblyBuilder>します。  
  
 ディスクに保存されているアセンブリ、動的アセンブリを保存するときに動的ではありません。 保存されたアセンブリが別のアプリケーション ドメインまたはプロセスに読み込まれた場合、<xref:System.Reflection.Assembly.IsDynamic%2A>プロパティが返す`false`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリが完全信頼で読み込まれたかどうかを示す値を取得します。</summary>
        <value>現在のアセンブリが完全信頼で読み込まれた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <summary>生成されたアセンブリを含む COFF (Common Object File Format) ベースのイメージを使用して、アセンブリを読み込みます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して読み込まれるアセンブリの信頼レベルでは、呼び出し元のアセンブリの信頼レベルの場合と同じです。 アプリケーション ドメインの信頼レベルでバイト配列からアセンブリを読み込むには使用、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>メソッドのオーバー ロードします。 証拠のオーバー ロードでの使用の詳細については、<xref:System.Reflection.Assembly.Load%2A>をバイト配列を受け取るメソッドを参照してください、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>メソッドのオーバー ロードします。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
 このメソッドのオーバー ロードが、新しい作成常にことに注意してください。<xref:System.Reflection.Assembly>に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="rawAssembly" /> がコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリを記述するオブジェクト。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 場合にスローされる`assemblyRef`アセンブリの完全な名前と簡単な名前に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーは、単純な名前と一致する他のアセンブリのプローブを続行できません。 既定では、リモート アセンブリのコードの実行が無効になっているため、.NET Framework 4 以降、<xref:System.IO.FileLoadException>場合にスローされるも`assemblyRef`リモート アセンブリを指定します。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。     
  
> [!NOTE]
>  使用しないでください、<xref:System.Reflection.AssemblyName>だけを持つ、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティ セット。 <xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティがいずれかの要素を指定しないアセンブリの id (名前、バージョンなど) のための読み込みは発生しません - id によって負荷の規則に従ってから想像どおり、<xref:System.Reflection.Assembly.Load%2A>メソッド。 代わりに、アセンブリが読み込み元の規則を使用して読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>メソッドのオーバー ロードまたは[アセンブリ読み込みのベスト プラクティス](~/docs/framework/deployment/best-practices-for-assembly-loading.md)します。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`パラメーターは、common object file format (COFF) イメージ、証拠を読み込むには、呼び出し元アセンブリから継承されます。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリース。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 と version 1.1 を使用するときに SP1 がない場合、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`COFF イメージ、証拠を読み込むためのパラメーターを組み合わせます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
> [!NOTE]
>  両方の場合、<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>プロパティと<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用 (によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティ)。 ファイルが見つからない場合<xref:System.Reflection.AssemblyName.CodeBase%2A>アセンブリを検索するために使用します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名のアセンブリが照合されます。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
   
  
## Examples  
 次の例では、インスタンス化、<xref:System.Reflection.AssemblyName>オブジェクトを読み込むことを使用して、`sysglobal.dll`アセンブリ。 アセンブリのパブリック型の完全名を表示します。  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <see href="https://go.microsoft.com/fwlink/?LinkID=247912">Windows ストア アプリ用 .NET</see> または<see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">ポータブル クラス ライブラリ</see>では、基本クラスの例外である <see cref="T:System.IO.IOException" /> を代わりにキャッチします。  
  
</para>
          </block>  
  
 見つかったファイルを読み込むことができませんでした。

または

<paramref name="assemblyRef" /> でリモート アセンブリが指定されていますが、リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> が有効なアセンブリではありません。 または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyRef" /> がコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">ランタイムがアセンブリを検索する方法</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">長い形式のアセンブリ名。</param>
        <summary>長い形式の名前を指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 長い形式のアセンブリ名は、そのバージョン、カルチャ、公開キー トークン、および必要に応じてそのプロセッサ アーキテクチャと単純な名前 ("System"System.dll アセンブリの) などで構成されます。 対応するアセンブリの<xref:System.Reflection.Assembly.FullName%2A>プロパティ。 次の例では、.NET Framework 4 の System.dll アセンブリの読み込みに長い名前の使用を示します。  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException> 場合にスローされる`assemblyString`完全なアセンブリ名と簡易名に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーは、単純な名前と一致する他のアセンブリのプローブを続行できません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`パラメーターは、common object file format (COFF) イメージ、証拠を読み込むには、呼び出し元アセンブリから継承されます。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリース。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 と version 1.1 を使用するときに SP1 がない場合、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`COFF イメージ、証拠を読み込むためのパラメーターを組み合わせます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
 .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、アセンブリ名を指定することをお勧めの方法は、作成するは、<xref:System.Reflection.AssemblyName>オブジェクトし、の適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッド。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
   
  
## Examples  
 次の例では、完全修飾名を指定してアセンブリを読み込み、指定したアセンブリに含まれるすべての型を一覧表示されます。 このコード例を実行するには、完全修飾アセンブリ名を指定する必要があります。 完全修飾アセンブリ名を取得する方法については、次を参照してください。[アセンブリ名](~/docs/framework/app-domains/assembly-names.md)します。  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">検出されたファイルを読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyString" /> がコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">ランタイムがアセンブリを検索する方法</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <summary>生成されたアセンブリが含まれている COFF (Common Object File Format) ベースのイメージを使用して、このアセンブリを読み込みます。アセンブリのシンボルを含めることもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して読み込まれるアセンブリの信頼レベルでは、呼び出し元のアセンブリの信頼レベルの場合と同じです。 アプリケーション ドメインの信頼レベルでバイト配列からアセンブリを読み込むには使用、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29>メソッドのオーバー ロードします。 証拠のオーバー ロードでの使用の詳細については、<xref:System.Reflection.Assembly.Load%2A>をバイト配列を受け取るメソッドを参照してください、<xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29>メソッドのオーバー ロードします。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
 このメソッドのオーバー ロードが、新しい作成常にことに注意してください。<xref:System.Reflection.Assembly>に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="rawAssembly" /> がコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">読み込むアセンブリを記述するオブジェクト。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>
          <see cref="T:System.Reflection.AssemblyName" /> を指定してアセンブリを読み込みます。 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 場合にスローされる`assemblyRef`完全なアセンブリ名と簡易名に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーは、単純な名前と一致する他のアセンブリのプローブを続行できません。  既定では、リモート アセンブリのコードの実行が無効になっているため、.NET Framework 4 以降、<xref:System.IO.FileLoadException>場合にスローされるも`assemblyRef`リモート アセンブリを指定します。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。   
  
> [!NOTE]
>  使用しないでください、<xref:System.Reflection.AssemblyName>だけを持つ、<xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティ セット。 <xref:System.Reflection.AssemblyName.CodeBase%2A>プロパティがいずれかの要素を指定しないアセンブリの id (名前、バージョンなど) のための読み込みは発生しません - id によって負荷の規則に従ってから想像どおり、<xref:System.Reflection.Assembly.Load%2A>メソッド。 代わりに、アセンブリが読み込み元の規則を使用して読み込まれます。 読み込み元コンテキストを使用して、短所については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType>メソッドのオーバー ロードまたは[アセンブリ読み込みのベスト プラクティス](~/docs/framework/deployment/best-practices-for-assembly-loading.md)します。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`パラメーターは、common object file format (COFF) イメージ、証拠を読み込むには、呼び出し元アセンブリから継承されます。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリース。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 と version 1.1 を使用するときに SP1 がない場合、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`COFF イメージ、証拠を読み込むためのパラメーターを組み合わせます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
> [!NOTE]
>  両方の場合、<xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType>プロパティと<xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType>プロパティが設定されて、アセンブリを読み込むには、最初の試行は、表示名を使用 (によって返されるバージョン、カルチャ、およびなどを含む、<xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>プロパティ)。 ファイルが見つからない場合<xref:System.Reflection.AssemblyName.CodeBase%2A>アセンブリを検索するために使用します。 使用して、アセンブリが見つかった場合<xref:System.Reflection.AssemblyName.CodeBase%2A>表示名のアセンブリが照合されます。 一致が見つからない場合、<xref:System.IO.FileLoadException>がスローされます。  
  
 呼び出す場合、<xref:System.Reflection.Assembly.Load%2A>メソッドの 1 回、同じアセンブリでは、さまざまな証拠を指定、共通言語ランタイムをスローしないより、<xref:System.IO.FileLoadException>等しいかどうかと、さまざまな証拠の仕様の整合性をすることはできませんので、決定されます。 最初に成功した証拠は、使用される証拠です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> は有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="assemblyRef" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。

または

<paramref name="assemblyRef" /> でリモート アセンブリが指定されていますが、リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">ランタイムがアセンブリを検索する方法</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">アセンブリの表示名。</param>
        <param name="assemblySecurity">アセンブリを読み込むために必要な証拠。</param>
        <summary>表示名を指定してアセンブリを読み込みます。アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException> 場合にスローされる`assemblyString`完全なアセンブリ名と簡易名に一致する最初のアセンブリが別のバージョン、カルチャ、または公開キー トークンを指定します。 ローダーは、単純な名前と一致する他のアセンブリのプローブを続行できません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`パラメーターは、common object file format (COFF) イメージ、証拠を読み込むには、呼び出し元アセンブリから継承されます。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリース。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 と version 1.1 を使用するときに SP1 がない場合、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`COFF イメージ、証拠を読み込むためのパラメーターを組み合わせます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
 共通言語ランタイムがスローしない場合は、同じアセンブリが異なる証拠を指定に、このメソッドを複数回呼び出す、<xref:System.IO.FileLoadException>異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
 .NET Framework version 2.0 では、プロセッサ アーキテクチャは、アセンブリの id に追加され、アセンブリ名の文字列の一部として指定できます。 たとえば、"ProcessorArchitecture = msil"です。 ただし、アセンブリ名を指定することをお勧めの方法は、作成するは、<xref:System.Reflection.AssemblyName>オブジェクトし、の適切なオーバー ロードに渡す、<xref:System.Reflection.Assembly.Load%2A>メソッド。 「<xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> は有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyString" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。  
  
または 
1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md">ランタイムがアセンブリを検索する方法</related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>生成されたアセンブリが含まれている COFF ベースのイメージを使用して、このアセンブリを読み込みます。アセンブリのシンボルと証拠を含めることもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。 アセンブリのシンボルを表す生バイトも読み込まれます。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.Load%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`COFF イメージ、証拠を読み込むためのパラメーターは、呼び出し元アセンブリから継承されます。 これは、.NET Framework version 1.1 に当てはまります Service Pack 1 (SP1) と今後のリリース。  
  
    > [!NOTE]
    >  .NET Framework version 1.0 と version 1.1 を使用するときに SP1 がない場合、<xref:System.Reflection.Assembly.Load%2A>でメソッドのオーバー ロードを`Byte[]`COFF イメージ、証拠を読み込むためのパラメーターを組み合わせます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.Load%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 C++ 実行可能ファイルにリフレクションをスローする可能性を<xref:System.BadImageFormatException>します。 最も可能性の高い原因は、C++ コンパイラが再配置アドレスまたは`.reloc`実行可能ファイルからセクション。 保持するために、 `.reloc` C++ 実行可能ファイルのアドレスで指定`/fixed:no`リンクしています。  
  
 呼び出す場合、[\]、バイト\<xref:System.Reflection.Assembly.Load%2A > メソッドを 1 回、同じアセンブリでは、さまざまな証拠を指定、共通言語ランタイムをスローしないより、<xref:System.IO.FileLoadException>のため、等しいかどうかと、さまざまな証拠の仕様の整合性を特定できません。 最初に成功した証拠は、使用される証拠です。  
  
 このメソッドのオーバー ロードが、新しい作成常にことに注意してください。<xref:System.Reflection.Assembly>に独自のマッピングを持つオブジェクト。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれていますが、<paramref name="rawAssembly" /> はさらに新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが 2 つの異なる証拠を使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。  既定では、従来の CAS ポリシーは [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] で有効ではありません。有効でない場合、<paramref name="securityEvidence" /> は <see langword="null" /> である必要があります。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供する機能。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> (関連する列挙体) セキュリティ アクション:<see cref="F:System.Security.Permissions.SecurityAction.Demand" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <param name="rawSymbolStore">アセンブリのシンボルを表す生バイトを格納するバイト配列。</param>
        <param name="securityContextSource">セキュリティ コンテキストのソース。</param>
        <summary>生成されたアセンブリが含まれている COFF ベースのイメージを使用して、このアセンブリを読み込みます。シンボルを含めることも、セキュリティ コンテキストのソースを指定することもできます。 このアセンブリは、呼び出し元のアプリケーション ドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アセンブリは、セキュリティ コンテキストの指定したソースを使用して、呼び出し元のアプリケーション ドメインに読み込まれます。 場合`rawSymbolStore`が指定すると、アセンブリのシンボルを表す生バイトも読み込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="rawAssembly" /> がコンパイルされました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="securityContextSource" /> の値がいずれかの列挙値ではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリ ファイルの内容を読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">読み込むファイルの完全修飾パス。</param>
        <summary>指定したパスのアセンブリ ファイルの内容を読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Reflection.Assembly.LoadFile%2A>を読み込み、同じ id を別のパスにあるアセンブリを検証するメソッド。 <xref:System.Reflection.Assembly.LoadFile%2A> ファイルは、読み込み元コンテキストに読み込まれません、として、読み込みパスを使用して依存関係が解決しないと、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドします。 <xref:System.Reflection.Assembly.LoadFile%2A> この限られたシナリオで役に立つため<xref:System.Reflection.Assembly.LoadFrom%2A>アセンブリを読み込むには使用できませんさまざまなパスが同じ id は最初のメッセージだけを読み込むことがこのようなアセンブリ。  

場合は、.NET Framework 4 以降`path`、リモートの場所でアセンブリを指定、既定では、アセンブリの読み込みが無効になっていると、`LoadFile`メソッドがスローされます、<xref:System.IO.FileLoadException>します。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 引数が絶対パスではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。

または

リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> パラメーターが空の文字列 ("") であるか、存在しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> が有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="path" /> がコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">アセンブリ ファイルの絶対パス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>パスを指定してアセンブリを読み込みます。アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Reflection.Assembly.LoadFile%2A>を読み込み、同じ id を別のパスにあるアセンブリを検証するメソッド。 <xref:System.Reflection.Assembly.LoadFile%2A> ファイルを読み込みません、<xref:System.Reflection.Assembly.LoadFrom%2A>コンテキストとして、読み込みパスを使用して依存関係が解決しないと、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドします。 <xref:System.Reflection.Assembly.LoadFile%2A> この限られたシナリオで役に立つため<xref:System.Reflection.Assembly.LoadFrom%2A>アセンブリを読み込むには使用できませんさまざまなパスが同じ id は最初のメッセージだけを読み込むことがこのようなアセンブリ。  

場合は、.NET Framework 4 以降`path`、リモートの場所でアセンブリを指定、既定では、アセンブリの読み込みが無効になっていると、`LoadFile`メソッドがスローされます、<xref:System.IO.FileLoadException>します。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> 引数が絶対パスではありません。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> パラメーターが空の文字列 ("") であるか、存在しません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。

または

リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> が有効なアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれます。また <paramref name="path" /> は新しいバージョでコンパイル済みです。</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> が <see langword="null" /> ではありません。 既定では、従来の CAS ポリシーは [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] で有効ではありません。有効でない場合、<paramref name="securityEvidence" /> は <see langword="null" /> である必要があります。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">ファイルまたはディレクトリからと、パス自体の情報にアクセスするための読み取りにアクセスします。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

.NET Framework 4 以降では、既定の呼び出しでリモートの場所から読み込まれるアセンブリでコードを実行する機能が無効です、`LoadFrom`メソッドがスローされます、<xref:System.IO.FileLoadException>します。 アセンブリを読み込むし、そのコードを実行、する必要がありますか。

- 明示的にアセンブリをサンド ボックスを作成します。 (を参照してください[方法: サンド ボックスで部分信頼コードを実行](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md))。

- アセンブリのコードを設定して完全な信頼で実行、`enabled`の属性、 [ `<loadFromRemoteSources>`構成要素](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)に`true`します。 詳細については、次を参照してください。、 [ `<loadFromRemoteSources>`構成要素](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)記事。

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <summary>ファイル名またはパスを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字のない URI に参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI が指定されている場合`assemblyFile`FTP アドレスは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パスまたは現在のディレクトリに相対する可能性があります、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込むことができるまたは、コンテキストなしで読み込むことができます。  
  
-   読み込みコンテキストに調査して見つかるアセンブリが含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>のアプリケーション ドメイン。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーが調査によって検索されたディレクトリに含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。 

    場合は、.NET Framework 4 以降の URI `assemblyFile` 、リモートの場所を指定します。 既定では、アセンブリの読み込みが無効になっていると`LoadFrom`メソッドがスローされます、 <xref:System.IO.FileLoadException>。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。    
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドはこれらのコードのコンテキストを実行することはできません。  
  
-   ユーザーは、生成されたか、アセンブリが見つかりましたでない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>アセンブリを含むバイト配列を指定し、一時動的アセンブリがリフレクションを使用して作成するには、出力をディスクに保存せずメソッドをします。  
  
 読み込み元コンテキストには、調査には含まれないパスから読み込まれるアセンブリができ、そのパスを見つけ、パス情報がコンテキストによって保持されるため、読み込まれた依存関係ができます。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには、次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 これは、アセンブリがシリアル化解除されたときに発生します。  
  
-   アセンブリが読み込まれている場合<xref:System.Reflection.Assembly.LoadFrom%2A>、プローブ パスに同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合`assemblyFile`は使用されません。 アセンブリをドメインに中立として読み込まれたにすることはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
   
  
## Examples  
 次の例では、そのファイル名またはパスを指定してアセンブリを読み込みます。  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。

または

リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file://" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>ファイル名またはパスを指定してアセンブリを読み込み、セキュリティ証拠を提供します。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字のない URI に参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI が指定されている場合`assemblyFile`FTP アドレスは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パスまたは現在のディレクトリに相対する可能性があります、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込むことができるまたは、コンテキストなしで読み込むことができます。  
  
-   読み込みコンテキストに調査して見つかるアセンブリが含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>のアプリケーション ドメイン。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーが調査によって検索されたディレクトリに含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。

    場合は、.NET Framework 4 以降の URI `assemblyFile` 、リモートの場所を指定します。 既定では、アセンブリの読み込みが無効になっていると`LoadFrom`メソッドがスローされます、 <xref:System.IO.FileLoadException>。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。    
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドはこれらのコードのコンテキストを実行することはできません。  
  
-   ユーザーは、生成されたか、アセンブリが見つかりましたでない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>アセンブリを含むバイト配列を指定し、一時動的アセンブリがリフレクションを使用して作成するには、出力をディスクに保存せずメソッドをします。  
  
 読み込み元コンテキストには、調査には含まれないパスから読み込まれるアセンブリができ、そのパスを見つけ、パス情報がコンテキストによって保持されるため、読み込まれた依存関係ができます。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには、次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 この問題は、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリが読み込まれている場合<xref:System.Reflection.Assembly.LoadFrom%2A>、プローブ パスに同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合`assemblyFile`は使用されません。 アセンブリをドメインに中立として読み込まれたにすることはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   共通言語ランタイムがスローしない場合は、同じアセンブリが異なる証拠を指定に、このメソッドを複数回呼び出す、<xref:System.IO.FileLoadException>異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`common object file format (COFF) イメージ、証拠を読み込むパラメーターが組み合わされます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。  
  
または 
<paramref name="securityEvidence" /> はあいまいではなく、無効であると判断されました。

または

リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file://" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="hashValue">計算されたハッシュ コードの値。</param>
        <param name="hashAlgorithm">ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズム。</param>
        <summary>ファイル名またはパス、ハッシュ値、およびハッシュ アルゴリズムを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字のない URI に参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI が指定されている場合`assemblyFile`FTP アドレスは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パスまたは現在のディレクトリに相対する可能性があります、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込むことができるまたは、コンテキストなしで読み込むことができます。  
  
-   読み込みコンテキストに調査して見つかるアセンブリが含まれています: グローバル アセンブリ キャッシュ内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>のアプリケーション ドメイン。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーでは、プローブには含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。  

    場合は、.NET Framework 4 以降の URI `assemblyFile` 、リモートの場所を指定します。 既定では、アセンブリの読み込みが無効になっていると`LoadFrom`メソッドがスローされます、 <xref:System.IO.FileLoadException>。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。    
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドはこれらのコードのコンテキストを実行することはできません。  
  
-   ユーザーは、生成されたか、アセンブリが見つかりましたでない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>アセンブリを含むバイト配列を指定し、一時動的アセンブリがリフレクションを使用して作成するには、出力をディスクに保存せずメソッドをします。  
  
 読み込み元コンテキストには、調査に含まれていないパスから読み込まれるアセンブリができ、そのパスを見つけ、パス情報がコンテキストによって保持されるため、読み込まれた依存関係ができます。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには、次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 この問題は、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリが読み込まれている場合<xref:System.Reflection.Assembly.LoadFrom%2A>、プローブ パスに同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合`assemblyFile`は使用されません。 アセンブリをドメイン中立として読み込むことはできません。  
  
 アセンブリは、ローダーが提供する証拠を使用して読み込まれます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。

または

リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.Security.SecurityException">"File://" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <param name="hashValue">計算されたハッシュ コードの値。</param>
        <param name="hashAlgorithm">ファイルのハッシュ処理および厳密な名前の生成に使用されるハッシュ アルゴリズム。</param>
        <summary>ファイル名またはパス、セキュリティ証拠、ハッシュ値、およびハッシュ アルゴリズムを指定してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `assemblyFile`パラメーターは、エスケープ文字のない URI に参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
> [!NOTE]
>  ファイル転送プロトコル (FTP) はサポートされていません。 URI が指定されている場合`assemblyFile`FTP アドレスは、アセンブリが読み込まれていません。 例外をスローすることはありません。  
  
 `assemblyFile` 絶対パスまたは現在のディレクトリに相対する可能性があります、アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 アセンブリは、3 つのコンテキストのいずれかに読み込むことができるまたは、コンテキストなしで読み込むことができます。  
  
-   読み込みコンテキストに調査して見つかるアセンブリが含まれています。 GAC 内のホスト アセンブリで、ランタイムがホストされている場合または保存、<xref:System.AppDomainSetup.ApplicationBase%2A>と<xref:System.AppDomainSetup.PrivateBinPath%2A>のアプリケーション ドメイン。 <xref:System.Reflection.Assembly.Load%2A> メソッドのほとんどのオーバーロードは、このコンテキストにアセンブリを読み込みます。  
  
-   読み込み元コンテキストには、ユーザーが調査によって検索されたディレクトリに含まれていないパスを指定したアセンブリが含まれています。 <xref:System.Reflection.Assembly.LoadFrom%2A>、<xref:System.AppDomain.CreateInstanceFrom%2A>、<xref:System.AppDomain.ExecuteAssembly%2A> は、パスを使用して読み込むメソッドの例です。  

    場合は、.NET Framework 4 以降の URI `assemblyFile` 、リモートの場所を指定します。 既定では、アセンブリの読み込みが無効になっていると`LoadFrom`メソッドがスローされます、 <xref:System.IO.FileLoadException>。 リモートの場所から読み込まれたコードの実行を有効にするを使用できます、 [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md)構成要素。    
  
-   リフレクション専用コンテキストに読み込まれたアセンブリが含まれています、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>と<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A>メソッドはこれらのコードのコンテキストを実行することはできません。  
  
-   ユーザーは、生成されたか、アセンブリが見つかりましたでない任意のコンテキスト。 これのオーバー ロードを使用して読み込まれたアセンブリに適用されます、<xref:System.Reflection.Assembly.Load%2A>アセンブリを含むバイト配列を指定し、一時動的アセンブリがリフレクションを使用して作成するには、出力をディスクに保存せずメソッドをします。  
  
 読み込み元コンテキストには、調査には含まれないパスから読み込まれるアセンブリができ、そのパスを見つけ、パス情報がコンテキストによって保持されるため、読み込まれた依存関係ができます。  
  
 <xref:System.Reflection.Assembly.LoadFrom%2A>メソッドには、次の欠点です。 代わりに <xref:System.Reflection.Assembly.Load%2A> を使用することを検討してください。  
  
-   同じ ID を持つアセンブリが既に読み込まれている場合、<xref:System.Reflection.Assembly.LoadFrom%2A> は、別のパスが指定されている場合であっても、読み込み済みのアセンブリを返します。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> を使用してアセンブリを読み込んだ後、同じアセンブリを、読み込みコンテキストにあるアセンブリが表示名で読み込もうとすると、読み込みが失敗します。 この問題は、アセンブリが逆シリアル化されるときに発生します。  
  
-   アセンブリが読み込まれている場合<xref:System.Reflection.Assembly.LoadFrom%2A>、プローブ パスに同じ id が、別の場所でアセンブリが含まれています、 <xref:System.InvalidCastException>、 <xref:System.MissingMethodException>、またはその他の予期しない動作が発生することができます。  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> には、指定したパスに対する <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> および <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>、または <xref:System.Net.WebPermission> が必要です。  
  
-   ネイティブ イメージが存在する場合`assemblyFile`は使用されません。 アセンブリをドメインに中立として読み込まれたにすることはできません。  
  
-   .NET framework version 1.0 および 1.1 では、ポリシーは適用されません。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>なしでメソッド<xref:System.Security.Policy.Evidence>パラメーター、アセンブリの表示はローダーが提供する証拠を使用して読み込まれます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを<xref:System.Security.Policy.Evidence>パラメーターの証拠がマージされます。 引数として指定された証拠、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドは、ローダーによって提供される証拠の部分を置き換えます。  
  
-   共通言語ランタイムがスローしない場合は、同じアセンブリが異なる証拠を指定に、このメソッドを複数回呼び出す、<xref:System.IO.FileLoadException>異なる証拠仕様の整合性と等しいかどうかを判断できないためです。 最初に成功した証拠は、使用される証拠です。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`common object file format (COFF) イメージ、証拠を読み込むパラメーターが組み合わされます。 `Zone`、`Url`と`Site`は呼び出し元のアセンブリから継承されると`Hash`と`StrongName`COFF アセンブリから取得されます。  
  
-   使用すると、<xref:System.Reflection.Assembly.LoadFrom%2A>メソッドを`Byte[]`パラメーターと<xref:System.Security.Policy.Evidence>COFF イメージを読み込むには、指定された証拠のみが使用されます。 呼び出し元のアセンブリの証拠と COFF イメージの証拠が無視されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。  
  
または 
<paramref name="securityEvidence" /> はあいまいではなく、無効であると判断されました。

または

リモート アセンブリ内でコードを実行する機能が無効になっています。 <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see> を参照してください。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリではありません (64 ビット プロセスの 32 ビット アセンブリなど)。 詳細については、例外に関するトピックを参照してください。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file://" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠とアセンブリの読み込み。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>このアセンブリ内部のモジュールを読み込みます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">モジュールの名前です。 この文字列は、このアセンブリのマニフェストのファイル名に対応する必要があります。</param>
        <param name="rawModule">生成されたモジュールを含んだ COFF ベースのイメージまたはリソースになっているバイト配列。</param>
        <summary>生成されたモジュールを含んだ COFF ベースのイメージ、またはリソース ファイルと共に、このアセンブリの内部モジュールを読み込みます。</summary>
        <returns>読み込み済みのモジュール。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> または <paramref name="rawModule" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> がこのアセンブリのマニフェストでファイル エントリと一致しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> は有効なモジュールではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">モジュールの名前です。 この文字列は、このアセンブリのマニフェストのファイル名に対応する必要があります。</param>
        <param name="rawModule">生成されたモジュールを含んだ COFF ベースのイメージまたはリソースになっているバイト配列。</param>
        <param name="rawSymbolStore">モジュールのシンボルを表す生バイトを格納しているバイト配列。 リソース ファイルの場合は <see langword="null" /> です。</param>
        <summary>生成されたモジュールを含んだ COFF ベースのイメージ、またはリソース ファイルと共に、このアセンブリの内部モジュールを読み込みます。 モジュールのシンボルを表す生バイトも読み込まれます。</summary>
        <returns>読み込み済みのモジュール。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> または <paramref name="rawModule" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> がこのアセンブリのマニフェストでファイル エントリと一致しません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> は有効なモジュールではありません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">証拠を提供します。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  オーバー ロード、<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>メソッドは廃止され、旧バージョンとの互換性のために保持されています。 旧式でない代替が必要な場合は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> を使用してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">アセンブリの表示名。</param>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。 <paramref name="partialName" /> が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29>メソッドは廃止され、旧バージョンとの互換性のために残されています。 旧式でない代替が必要な場合は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> を使用してください。  
  
 このメソッドを使用してアセンブリを読み込むアプリケーションは、これらのアセンブリのアップグレードの影響を受けます。 そのため、このメソッドを使用しません。使用するアプリケーションを再設計、<xref:System.Reflection.Assembly.Load%28System.String%29>メソッドのオーバー ロードまたは<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>メソッドのオーバー ロードします。  
  
 このメソッドは、最初<xref:System.Reflection.Assembly.Load%2A>します。 アセンブリが見つからない場合、このメソッドは、同じ簡易名、および最新のバージョン番号を持つグローバル アセンブリ キャッシュからアセンブリを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="partialName" /> がコンパイルされています。</exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">アセンブリの表示名。</param>
        <param name="securityEvidence">アセンブリを読み込むために必要な証拠。</param>
        <summary>アプリケーション ディレクトリまたはグローバル アセンブリ キャッシュから、部分名を使用してアセンブリを読み込みます。 アセンブリは、指定された証拠を使用して、呼び出し元のドメインに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。 <paramref name="partialName" /> が見つからない場合、このメソッドは <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29>メソッドは廃止され、旧バージョンとの互換性のために残されています。 旧式でない代替が必要な場合は、<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> を使用してください。  
  
 証拠とは、セキュリティ ポリシーがアクセス許可を決定するときに使用する一連の情報 (コードにどのようなアクセス許可を付与できるかなど) のことです。  
  
 このメソッドを使用してアセンブリを読み込むアプリケーションは、これらのアセンブリのアップグレードの影響を受けます。 そのため、このメソッドを使用しません。使用するアプリケーションを再設計、<xref:System.Reflection.Assembly.Load%2A>メソッドまたは<xref:System.Reflection.Assembly.LoadFrom%2A>メソッド。  
  
 このメソッドは、最初<xref:System.Reflection.Assembly.Load%2A>します。 アセンブリが見つからない場合、このメソッドは、同じ簡易名、および最新のバージョン番号を持つグローバル アセンブリ キャッシュからアセンブリを返します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">1 つのアセンブリまたはモジュールが、2 つの異なる証拠のセットを使用して 2 回読み込まれました。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partialName" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="partialName" /> がコンパイルされています。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードの呼び出しに証拠を使用してアセンブリを読み込みます。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マニフェストを格納している読み込み済みファイルの完全パスまたは UNC 位置を取得します。</summary>
        <value>マニフェストを格納している読み込み済みファイルの場所。 読み込み済みファイルがシャドウ コピーされている場合、この場所はシャドウ コピーされた後のファイルの場所です。 <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> メソッド オーバーロードを使用したときなど、アセンブリがバイト配列から読み込まれた場合に返される値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ファイルがシャドウ コピーされる前に、場所を取得する、<xref:System.Reflection.Assembly.CodeBase%2A>プロパティ。  
  
   
  
## Examples  
 次の例では、マニフェストを格納する読み込み済みファイルの場所が表示されます。  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">現在のアセンブリは動的アセンブリであり、<see cref="T:System.Reflection.Emit.AssemblyBuilder" /> オブジェクトによって表されます。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスにアクセスします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">アセンブリのシャドウ コピー</related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリのマニフェストを格納しているモジュールを取得します。</summary>
        <value>アセンブリのマニフェストを格納しているモジュール。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム クラス ローダーが、通常の方法で参照をアセンブリの内部モジュールに解決できないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、コールバックに、検索、モジュール自体を読み込み、それを返す機会を与えます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリ内のモジュールを含むコレクションを取得します。</summary>
        <value>このアセンブリのモジュールを含むコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <paramref name="right" /> と比較するアセンブリ。</param>
        <param name="right">
          <paramref name="left" /> と比較するアセンブリ。</param>
        <summary>2 つの <see cref="T:System.Reflection.Assembly" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <paramref name="left" /> が <paramref name="right" /> に等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">
          <paramref name="right" /> と比較するアセンブリ。</param>
        <param name="right">
          <paramref name="left" /> と比較するアセンブリ。</param>
        <summary>2 つの <see cref="T:System.Reflection.Assembly" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <paramref name="left" /> が <paramref name="right" /> と等しくない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアセンブリの許可セットを取得します。</summary>
        <value>現在のアセンブリの許可セット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet> オブジェクトは、パスなどの機密情報を含めることができます。 そのため、これらのオブジェクトにアクセスするには、完全な信頼が必要です。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアセンブリがリフレクションのみのコンテキストに読み込まれたかどうかを示す <see cref="T:System.Boolean" /> 値を取得します。</summary>
        <value>アセンブリが実行コンテキストではなく、リフレクションのみのコンテキストに読み込まれている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、アセンブリがリフレクションのみのコンテキストに読み込まれた場合、<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>メソッド、アセンブリのコードを実行することはできません。 コードを実行するには、アセンブリは実行コンテキストに読み込まれる必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>アセンブリをリフレクションのみのコンテキストに読み込みます。リフレクションのみのコンテキストでは、アセンブリのチェックはできますが、実行はできません。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">生成されたアセンブリを含む COFF ベースのイメージであるバイト配列。</param>
        <summary>生成されたアセンブリを含む COFF (Common Object File Format) ベースのイメージを使用して、アセンブリを読み込みます。 アセンブリは、呼び出し元のアプリケーション ドメインの、リフレクションのみのコンテキストに読み込まれます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 コードを実行するアセンブリ読み込む必要がある同様に、実行コンテキストを使用して、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
 リフレクションのみのコンテキストは、他のコンテキストと変わりありません。 アプリケーション ドメインをアンロードしてのみのコンテキストに読み込まれるアセンブリをアンロードできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> は有効なアセンブリ名ではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="rawAssembly" /> がコンパイルされています。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> を読み込むことができません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">
          <see cref="P:System.Reflection.AssemblyName.FullName" /> プロパティによって返される、アセンブリの表示名。</param>
        <summary>表示名を指定して、アセンブリをリフレクションのみのコンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係は、リフレクション専用コンテキストに自動的に読み込まれません。  
  
 リフレクション専用コンテキストに読み込まれたアセンブリからコードを実行することはできません。 コードを実行するアセンブリ読み込む必要がある同様に、実行コンテキストを使用して、<xref:System.Reflection.Assembly.Load%2A>メソッド。  
  
 アセンブリに対して特定のアクセス許可を付与するかどうかは、証拠に基づいて決定されます。 アセンブリとマージのセキュリティ証拠の規則は次のとおりです。  
  
> [!NOTE]
>  C++ でコンパイルされた実行可能ファイルにリフレクションをスローする可能性を<xref:System.IO.FileLoadException>します。 これはほとんどの場合、再配置アドレスまたは .reloc セクション、実行可能ファイルから、C++ コンパイラ発生します。 .Reloc アドレスを保持するために次のように指定します。`/fixed:no`リンクしています。  
  
 リフレクションのみのコンテキストは、他のコンテキストと変わりありません。 アプリケーション ドメインをアンロードしてのみのコンテキストに読み込まれるアセンブリをアンロードできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> が空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> が見つかりません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> が見つかりましたが、読み込めません。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> が有効なアセンブリではありません。  
  
または 
現在、Version 2.0 以降の共通言語ランタイムが読み込まれていますが、それよりも新しいバージョンを使用して <paramref name="assemblyString" /> がコンパイルされています。</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルのパス。</param>
        <summary>パスを指定して、アセンブリをリフレクションのみのコンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係は、リフレクション専用コンテキストに自動的に読み込まれません。 依存関係を自動的に読み込むには、処理、<xref:System.AppDomain.ReflectionOnlyAssemblyResolve>イベントと load イベント ハンドラー内の依存関係。  
  
 リフレクションのみのコンテキストに読み込まれたアセンブリからコードを実行することはできません。 使用してアセンブリを読み込むコードを実行する、<xref:System.Reflection.Assembly.LoadFile%2A>メソッド。  
  
 `assemblyFile`パラメーターは、エスケープ文字のない URI に参照する必要があります。 このメソッドは、URI 内のすべての無効な文字のエスケープ文字を提供します。  
  
 指定されたパス`assemblyFile`現在のディレクトリに対する相対パスです。 アセンブリは、呼び出し元のドメインに読み込まれます。  
  
 リフレクションのみのコンテキストは、他のコンテキストと変わりありません。 アプリケーション ドメインをアンロードしてのみのコンテキストに読み込まれるアセンブリをアンロードできます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> が見つかりましたが、読み込めませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は正しいアセンブリではありません。  
  
または 
共通言語ランタイムのバージョン 2.0 以降が現在読み込まれています。<paramref name="assemblyFile" /> は、より新しいバージョンでコンパイルされています。</exception>
        <exception cref="T:System.Security.SecurityException">"file://" 以外で始まるコードベースが指定されましたが、必要な <see cref="T:System.Net.WebPermission" /> がありません。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名がシステム定義の最大長を超えています。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> が空の文字列 ("") です。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">file:// で始まる URI を読み取る。 列挙体に関連付けられている: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />、 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">file:// で始まらないする URI を読み取る。</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>共通言語ランタイム (CLR: Common Language Runtime) によってこのアセンブリに適用されるセキュリティ規則のセットを示す値を取得します。</summary>
        <value>CLR によってこのアセンブリに適用されるセキュリティ規則のセット。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定で指定してコンパイルしたアセンブリ、[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]代わりに明示的に行うには、透過性があります。 .NET Framework の以前のバージョンでコンパイルされたアセンブリでは、レベル 1 の透過性があります。  
  
 「[セキュリティの変更](~/docs/framework/security/security-changes.md)」をご覧ください。  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md">透過的セキュリティ コード</related>
        <related type="Article" href="~/docs/framework/security/security-changes.md">.NET Framework 4 におけるセキュリティの変更</related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のインスタンスの型を返します。</summary>
        <returns>
          <see cref="T:System.Reflection.Assembly" /> 型を表すオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アセンブリの完全名を返します。この名前は表示名とも呼ばれます。</summary>
        <returns>アセンブリの完全名。アセンブリの完全名を判断できない場合は、クラス名。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">アセンブリのマニフェストを格納しているファイルの名前またはパス。</param>
        <summary>一部のセキュリティ チェックをバイパスして、アセンブリを読み込み元コンテキストに読み込みます。</summary>
        <returns>読み込み済みのアセンブリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用して、オペレーティング システムが (たとえば、一時ファイル、インターネットまたはイントラネットからダウンロードされた) Web から読み込まれたものとしてフラグが立てられてローカル アセンブリを読み込みます。 前に、 [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]、このようなアセンブリがサンド ボックス アプリケーション ドメインに自動的に読み込まれます。 以降では、 [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]、完全な信頼で読み込まれます。  
  
 このメソッドを使用する代わりに、適用することができます、 [ &lt;NetFx40_LegacySecurityPolicy&gt;要素](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md)アプリケーション構成ファイル。 これにより、共通言語ランタイムのセキュリティ ポリシーに戻すには、[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]します。  
  
> [!CAUTION]
>  これらのソリューションのいずれかを使用する場合は、する必要がありますに読み込んでも安全である`assemblyFile`完全に信頼します。  
  
 読み込みコンテキスト、読み込み元コンテキストなどの詳細については、次を参照してください。、<xref:System.Reflection.Assembly.LoadFrom%28System.String%29>メソッドのオーバー ロードします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> が見つからないか、または読み込もうとしているモジュールにファイル名拡張子が指定されていません。</exception>
        <exception cref="T:System.IO.FileLoadException">見つかったファイルを読み込むことができませんでした。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> は有効なアセンブリ名ではありません。  
  
または 
 現在読み込まれているバージョンよりも新しいバージョンの共通言語ランタイムで、<paramref name="assemblyFile" /> がコンパイルされました。</exception>
        <exception cref="T:System.Security.SecurityException">"File://" で始まっていないコードベースが、必須の <see cref="T:System.Net.WebPermission" /> なしで指定されました。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> パラメーターが空の文字列 ("") です。</exception>
        <exception cref="T:System.IO.PathTooLongException">アセンブリ名がシステム定義の最大長を超えています。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されたまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
  </Members>
</Type>