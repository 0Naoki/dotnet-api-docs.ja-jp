<Type Name="Module" FullName="System.Reflection.Module">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="99434ae0ca2ae257e847cbb424c20883be128c2c" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30480476" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Module, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Module extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Module, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Module" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Module&#xA;Implements _Module, ICustomAttributeProvider, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Module abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Module, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Module</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Module))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>モジュールにリフレクションを実行します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 モジュールは、種類が.dll またはクラスとインターフェイスの 1 つ以上から成る application.exe などのポータブル実行可能ファイルです。 複数の名前空間が、単一モジュールに含まれることがあります。また、1 つの名前空間が複数のモジュールにまたがることもあります。  
  
 1 つの単位として配置される 1 つ以上のモジュールによってアセンブリが構成されます。 1 つ以上のモジュールにアセンブリを作成する方法の詳細については、次を参照してください。[マルチファイル アセンブリ](~/docs/framework/app-domains/multifile-assemblies.md)です。  
  
 .NET Framework モジュールはありません、プログラマが関数や、アプリケーションでのサブルーチンを整理するために使用する Visual Basic でのモジュールと同じに注意してください。  
  
   
  
## Examples  
 次のコード例では、リフレクションを使用して、モジュールに関する情報を取得する方法を示します。  
  
 [!code-csharp[System.Reflection.Module#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module/CS/source.cs#1)]
 [!code-vb[System.Reflection.Module#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">継承時の完全な信頼。 部分信頼コードでこのクラスは継承できません。</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Module ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Module();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Module" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 構築中にこのコンス トラクターが派生クラスによって呼び出された<xref:System.Reflection.Module>オブジェクト。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Reflection.Module" /> のこのインスタンスの適切な <see cref="T:System.Reflection.Assembly" /> を取得します。</summary>
        <value>
          <see langword="Assembly" /> オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、指定したモジュールに指定したアセンブリの完全な名前が表示されます。  
  
 [!code-cpp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.Assembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.Assembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.Assembly Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このモジュールのカスタム属性を含むコレクションを取得します。</summary>
        <value>このモジュールのカスタム属性を含むコレクション。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">このインスタンスと比較するオブジェクト。</param>
        <summary>このモジュールと指定したオブジェクトが等しいかどうかを判断します。</summary>
        <returns>
          <paramref name="o" /> がこのインスタンスと等しい場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FilterTypeName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeName" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeName As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に基づいて、このモジュールで定義された型の一覧をフィルター処理する <see langword="TypeFilter" /> オブジェクト。 このフィールドは大文字と小文字を区別し、読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィルターは、末尾をサポートしています"*"ワイルドカードです。  
  
   
  
## Examples  
 次の例では、指定した検索条件に一致するモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FilterTypeNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.TypeFilter FilterTypeNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.TypeFilter FilterTypeNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterTypeNameIgnoreCase As TypeFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::TypeFilter ^ FilterTypeNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>名前に基づいて、このモジュールで定義された型の一覧をフィルター処理する <see langword="TypeFilter" /> オブジェクト。 このフィールドは大文字と小文字の区別をせず、読み取り専用です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フィルターは、末尾をサポートしています"*"ワイルドカードです。  
  
   
  
## Examples  
 次の例では、大文字と小文字を無視して、指定した検索条件に一致するモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeNameIgnoreCase Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeNameIgnoreCase Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FindTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] FindTypes (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindTypes(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.FindTypes(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindTypes (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindTypes(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">クラスのフィルター処理に使用するデリゲート。</param>
        <param name="filterCriteria">クラスをフィルター処理するために使用するオブジェクト。</param>
        <summary>指定したフィルターとフィルター条件で受け入れられたクラスの配列を返します。</summary>
        <returns>フィルターが受け入れたクラスを格納している <see langword="Type" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.ReflectionTypeLoadException> 特殊クラスの読み込み例外です。 `ReflectionTypeLoadException.Types`プロパティには、モジュールで定義されたされ、読み込まれたクラスの配列が含まれています。 この配列は、null 値を含めることがあります。 `ReflectionTypeLoadException.LoaderExceptions`プロパティをクラス ローダーによってスローされた例外を表す例外の配列です。 クラスの配列の穴は、例外を整列します。  
  
 によって指定されたデリゲート`filter`モジュールでは、渡すには、各クラスに対して呼び出されます、`Type`クラスを表すオブジェクトだけでなく、指定された`filterCriteria`です。 場合`filter`返す特定のクラス、クラスが返される配列に含まれることです。 場合`filter`返します`null`、すべてのクラスが返されると`filterCriteria`は無視されます。  
  
 `FindTypes` パラメーター化された型の配列などの検索に使用できません。  
  
   
  
## Examples  
 次の例で、`FindTypes`メソッドです。  
  
 [!code-cpp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FilterTypeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FilterTypeName Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">モジュールの 1 つまたは複数のクラスを読み込むことができませんでした。</exception>
        <altmember cref="F:System.Reflection.Module.FilterTypeName" />
        <altmember cref="F:System.Reflection.Module.FilterTypeNameIgnoreCase" />
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="FullyQualifiedName">
      <MemberSignature Language="C#" Value="public virtual string FullyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.FullyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このモジュールの完全修飾名とパスを表す文字列を取得します。</summary>
        <value>モジュールの完全修飾名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 名前を取得する、パスを含まない、<xref:System.Reflection.Module.Name%2A>です。  
  
 このモジュールのアセンブリがバイト配列から読み込まれたかどうか、`FullyQualifiedName`モジュールが表示されます:\<不明な >。  
  
> [!NOTE]
>  モジュール名の大文字と小文字は、プラットフォームによって異なります。  
  
   
  
## Examples  
 次の例では、指定したモジュールの完全修飾名を表示します。  
  
 [!code-cpp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.FullyQualifiedName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.FullyQualifiedName/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスの情報にアクセスします。 <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>カスタム属性を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>すべてのカスタム属性を返します。</summary>
        <returns>すべてのカスタム属性が格納されている <see langword="Object" /> の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、指定した検索条件に一致するモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">取得する属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定された型のカスタム属性を取得します。</summary>
        <returns>指定された型のすべてのカスタム属性を格納している <see langword="Object" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、指定した検索条件に一致する指定した種類のモジュール名を表示します。  
  
 [!code-cpp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetCustomAttributes 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetCustomAttributes 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>リフレクションのみのコンテキストで使用できる、現在のモジュールの <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのリストを返します。</summary>
        <returns>現在のモジュールに適用されている属性に関するデータを表す <see cref="T:System.Reflection.CustomAttributeData" /> オブジェクトのジェネリック リスト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 リフレクション専用コンテキストに読み込まれるコードでカスタム属性自体が定義されている場合、リフレクションのみのコンテキストでコードのカスタム属性を調べるには、このメソッドを使用します。 などのメソッド<xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType>と<xref:System.Reflection.Module.GetCustomAttributes%2A?displayProperty=nameWithType>属性のインスタンスを作成するため、このようなケースでは使用できません。 リフレクションのみのコンテキストでコードを実行できません。 詳細とコード例は、次を参照してください。、<xref:System.Reflection.CustomAttributeData>クラスです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したフィールドを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">フィールド名。</param>
        <summary>指定された名前のフィールドを返します。</summary>
        <returns>指定した名前の <see langword="FieldInfo" /> オブジェクト。フィールドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">フィールド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグのいずれか。</param>
        <summary>指定された名前とバインド属性を持つフィールドを返します。</summary>
        <returns>指定した名前とバインド属性を持つ <see langword="FieldInfo" /> オブジェクト。フィールドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> パラメーターが <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>モジュールで定義されたグローバル フィールドを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>モジュールで定義されたグローバル フィールドを返します。</summary>
        <returns>モジュールで定義されているグローバル フィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクトの配列。グローバル フィールドがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Module.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 その順序が異なるので、コードは、フィールドが返される順序に依存しない必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">検索を制限する <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したバインディング フラグと一致するモジュールで定義されているグローバル フィールドを返します。</summary>
        <returns>指定したバインディング フラグと一致するモジュールで定義されているグローバル フィールドを表す <see cref="T:System.Reflection.FieldInfo" /> 型の配列。バインディング フラグに一致するグローバル フィールドがない場合は、空の配列が返されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Module.GetFields%2A>メソッドで返されないフィールドを特定の順序など、アルファベットまたは宣言の順序。 その順序が異なるので、コードは、フィールドが返される順序に依存しない必要があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このインスタンスのハッシュ コードを返します。</summary>
        <returns>32 ビット符号付き整数ハッシュ コード。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した基準のメソッドを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <summary>指定された名前のメソッドを返します。</summary>
        <returns>指定した名前を持つ <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="types">検索対象のパラメーター型。</param>
        <summary>指定した名前とパラメーター型のメソッドを返します。</summary>
        <returns>指定した条件に一致する <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> か、<paramref name="types" /> が <see langword="null" /> か、<paramref name="types" /> (i) が <see langword="null" /> です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグのいずれか。</param>
        <param name="binder">このメソッドに関連するプロパティが含まれ、<see langword="Binder" /> を実装するオブジェクト。</param>
        <param name="callConvention">メソッドの呼び出し規則。</param>
        <param name="types">検索対象のパラメーター型。</param>
        <param name="modifiers">型が変更されているパラメーター シグネチャでバインドを機能させるために使われるパラメーター修飾子の配列。</param>
        <summary>指定された名前、バインド情報、呼び出し規則、パラメーターの型と修飾子を持つメソッドを返します。</summary>
        <returns>指定した条件に一致する <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> が <see langword="null" /> か、<paramref name="types" /> が <see langword="null" /> か、<paramref name="types" /> (i) が <see langword="null" /> です。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">メソッド名。</param>
        <param name="bindingAttr">検索を制御するために使用される <see langword="BindingFlags" /> ビット フラグのいずれか。</param>
        <param name="binder">このメソッドに関連するプロパティが含まれ、<see langword="Binder" /> を実装するオブジェクト。</param>
        <param name="callConvention">メソッドの呼び出し規則。</param>
        <param name="types">検索対象のパラメーター型。</param>
        <param name="modifiers">型が変更されているパラメーター シグネチャでバインドを機能させるために使われるパラメーター修飾子の配列。</param>
        <summary>指定した基準に一致するメソッド実装を返します。</summary>
        <returns>指定した条件の実装情報を格納した <see langword="MethodInfo" /> オブジェクト。メソッドが存在しない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <paramref name="types" /> は <see langword="null" />です。</exception>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>モジュールで定義されたグローバル メソッドを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>モジュールで定義されたグローバル メソッドを返します。</summary>
        <returns>モジュールで定義されているすべてのグローバル メソッドを表す <see cref="T:System.Reflection.MethodInfo" /> オブジェクトの配列。グローバル メソッドがない場合は、空の配列が返されます。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingFlags" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingFlags">検索を制限する <see cref="T:System.Reflection.BindingFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したバインディング フラグと一致するモジュールで定義されているグローバル メソッドを返します。</summary>
        <returns>指定したバインディング フラグと一致するモジュールで定義されているグローバル メソッドを表す <see cref="T:System.Reflection.MethodInfo" /> 型の配列。バインディング フラグに一致するグローバル メソッドがない場合は、空の配列が返されます。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">オブジェクトのシリアル化または逆シリアル化に必要な情報およびデータ。</param>
        <param name="context">シリアル化のコンテキスト。</param>
        <summary>シリアル化されたオブジェクトに対して、<see cref="T:System.Runtime.Serialization.ISerializable" /> 実装を提供します。</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> は <see langword="null" />です。</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">直前の呼び出し元に対する完全な信頼が必要です。 このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</permission>
      </Docs>
    </Member>
    <Member MemberName="GetPEKind">
      <MemberSignature Language="C#" Value="public virtual void GetPEKind (out System.Reflection.PortableExecutableKinds peKind, out System.Reflection.ImageFileMachine machine);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetPEKind([out] valuetype System.Reflection.PortableExecutableKinds&amp; peKind, [out] valuetype System.Reflection.ImageFileMachine&amp; machine) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetPEKind(System.Reflection.PortableExecutableKinds@,System.Reflection.ImageFileMachine@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetPEKind (ByRef peKind As PortableExecutableKinds, ByRef machine As ImageFileMachine)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetPEKind([Runtime::InteropServices::Out] System::Reflection::PortableExecutableKinds % peKind, [Runtime::InteropServices::Out] System::Reflection::ImageFileMachine % machine);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="peKind" Type="System.Reflection.PortableExecutableKinds&amp;" RefType="out" />
        <Parameter Name="machine" Type="System.Reflection.ImageFileMachine&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="peKind">このメソッドから制御が戻る場合、モジュール内のコードの性質を示す <see cref="T:System.Reflection.PortableExecutableKinds" /> 値の組み合わせ。</param>
        <param name="machine">このメソッドから制御が戻る場合、モジュールの対象プラットフォームを示す <see cref="T:System.Reflection.ImageFileMachine" /> 値の 1 つ。</param>
        <summary>モジュール内のコードの性質およびモジュールの対象プラットフォームを示す値のペアを取得します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSignerCertificate">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetSignerCertificate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSignerCertificate () As X509Certificate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::X509Certificates::X509Certificate ^ GetSignerCertificate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509Certificate</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このモジュールが属すアセンブリの Authenticode 署名に含まれた、証明書に対応する <see langword="X509Certificate" /> オブジェクトを返します。 アセンブリに Authenticode 署名がない場合は <see langword="null" /> が返されます。</summary>
        <returns>
          <see langword="X509Certificate" /> オブジェクト。このモジュールが属すアセンブリに Authenticode 署名がない場合は <see langword="null" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="className">検索対象の型の名前。 この名前は、名前空間を含む完全修飾名であることが必要です。</param>
        <summary>大文字小文字を区別する検索を実行して、指定された型を返します。</summary>
        <returns>型がこのモジュールに含まれている場合は、指定された型を表す <see langword="Type" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 使用して、特定のモジュールから型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>です。 呼び出す<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>マニフェストが含まれているモジュールには検索されません全体のアセンブリ。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>です。  
  
   
  
## Examples  
 次の例は、指定したモジュール内の型の名前を表示します。  
  
 [!code-cpp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 1Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 1Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、例外がスローされます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 - または -  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="className" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 - または -  
  
 <paramref name="className" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">検索対象の型の名前。 この名前は、名前空間を含む完全修飾名であることが必要です。</param>
        <param name="ignoreCase">
          大文字小文字を区別しない検索を行う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定された大文字と小文字の区別でモジュールを検索し、指定された型を返します。</summary>
        <returns>型がこのモジュールに含まれている場合は、指定された型を表す <see langword="Type" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 使用して、特定のモジュールから型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>です。 呼び出す<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>マニフェストが含まれているモジュールには検索されません全体のアセンブリ。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>です。  
  
   
  
## Examples  
 次の例は、指定したモジュールの種類の名前を表示を指定する`false`の`ignoreCase`パラメーターの場合は無視しないようにします。  
  
 [!code-cpp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 2Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 2Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、例外がスローされます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 - または -  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="className" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 - または -  
  
 <paramref name="className" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string className, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string className, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (className As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ className, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="className" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="className">検索対象の型の名前。 この名前は、名前空間を含む完全修飾名であることが必要です。</param>
        <param name="throwOnError">
          型が見つからなかったときに例外をスローする場合は <see langword="true" />。<see langword="false" /> を返す場合は <see langword="null" />。</param>
        <param name="ignoreCase">
          大文字小文字を区別しない検索を行う場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>大文字小文字を区別したモジュール検索を実行するかどうか、および型が見つからない場合に例外をスローするかどうかを指定して、指定された型を返します。</summary>
        <returns>型がこのモジュールで宣言されている場合は、指定された型を表す <see cref="T:System.Type" /> オブジェクト。それ以外の場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `throwOnError`パラメーターは、型が見つからないときの動作のみに影響します。 スローされる可能性がありますのあるその他の例外には影響しません。 特に場合は、型が見つかりましたが、アンロードすることはできません<xref:System.TypeLoadException>スローできる場合でも`throwOnError`は`false`します。  
  
> [!NOTE]
>  種類は、別のアセンブリに転送されましたが場合、このメソッドからが返されます。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 使用して、特定のモジュールから型を取得できる<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>です。 呼び出す<xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>マニフェストが含まれているモジュールには検索されません全体のアセンブリ。 呼び出す必要がありますが、どのモジュールに関係なく、アセンブリから型を取得する<xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>です。  
  
   
  
## Examples  
 次の例は、指定したモジュール内の型の名前を表示します。 `throwOnError`と`ignoreCase`としてパラメーターが指定されて`false`です。  
  
 [!code-cpp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.GetType 3Arg Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.GetType 3Arg Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="className" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">クラスの初期化子が呼び出され、例外がスローされます。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="className" /> は長さゼロの文字列です。</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> が <see langword="true" /> であり、型が見つかりません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="className" /> には見つからなかった依存アセンブリが必要です。</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="className" /> には、見つかったものの読み込めなかった依存アセンブリが必要です。  
  
 - または -  
  
 現在のアセンブリはリフレクションのみのコンテキストに読み込まれましたが、<paramref name="className" /> には事前に読み込まれていない依存アセンブリが必要です。</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="className" /> には依存アセンブリが必要ですが、ファイルは有効なアセンブリではありません。  
  
 - または -  
  
 <paramref name="className" /> には、現在読み込まれているバージョンより新しいバージョンのランタイム用にコンパイルされた依存アセンブリが必要です。</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>このモジュール内で定義されたすべての型を返します。</summary>
        <returns>このインスタンスがリフレクションされたモジュール内で定義された型を格納する <see langword="Type" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ReflectionTypeLoadException` 特別な読み込み例外が発生します。 `ReflectionTypeLoadException.Types`プロパティには、読み込まれたモジュールで定義された型の配列が含まれています。 この配列は、null 値を含めることがあります。 `ReflectionTypeLoadException.LoaderExceptions`プロパティを表すローダーによってスローされた例外の例外の配列です。 クラスの配列の穴は、例外を整列します。  
  
 たとえば、クラスのいずれかのクラスの初期化中に例外をスローした場合は、読み込み、`TargetInvocationException`の対応する要素に格納された、`LoaderExceptions`配列。  
  
> [!NOTE]
>  型は、別のアセンブリに転送されましたが場合、返される配列には含まれません。 型の転送については、次を参照してください。[型の共通言語ランタイムで転送](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">モジュールの 1 つまたは複数のクラスを読み込むことができませんでした。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し元に、必要なアクセス許可がありません。</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">現在のモジュールのリフレクション権限です。</permission>
        <altmember cref="T:System.Reflection.ReflectionTypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">テストするカスタム属性の型。</param>
        <param name="inherit">この型のオブジェクトでは、この引数は無視されます。</param>
        <summary>指定された属性型がこのモジュールに適用されているかどうかを示す値を返します。</summary>
        <returns>
          このモジュールに <paramref name="attributeType" /> のインスタンスが 1 つ以上適用されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例での使用、`IsDefined`メソッドです。  
  
 [!code-cpp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsDefined Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsDefined Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />は、ランタイムによって提供された <see cref="T:System.Type" /> オブジェクトではありません。 たとえば、<paramref name="attributeType" /> は <see cref="T:System.Reflection.Emit.TypeBuilder" /> オブジェクトです。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsResource">
      <MemberSignature Language="C#" Value="public virtual bool IsResource ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsResource() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.IsResource" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsResource () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsResource();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>オブジェクトがリソースかどうかを示す値を取得します。</summary>
        <returns>
          オブジェクトがリソースである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例での使用、`IsResource`メソッドです。  
  
 [!code-cpp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.IsResource Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.IsResource Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.IsResource Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MDStreamVersion">
      <MemberSignature Language="C#" Value="public virtual int MDStreamVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MDStreamVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MDStreamVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MDStreamVersion As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MDStreamVersion { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ ストリーム バージョンを取得します。</summary>
        <value>メタデータ ストリーム バージョンを表す 32 ビットの整数。 上位 2 バイトはメジャー バージョン番号を表し、下位 2 バイトはマイナー バージョン番号を表します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  メタデータ ヘッダーの詳細については、共通言語基盤 (CLI) ドキュメントで「Partition II:: Metadata Definition and Semantics」を参照してください。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MetadataToken">
      <MemberSignature Language="C#" Value="public virtual int MetadataToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MetadataToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.MetadataToken" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MetadataToken As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MetadataToken { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>メタデータ内のモジュールを識別するトークンを取得します。</summary>
        <value>メタデータ内の現在モジュールを識別する整数トークン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して取得したトークンは、アンマネージのリフレクション API に渡すことができます。 詳細については、次を参照してください。[アンマネージ リフレクション API](http://msdn.microsoft.com/library/0c5bb9de-0cf6-438d-ba47-134e6c775fb8)です。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleHandle">
      <MemberSignature Language="C#" Value="public ModuleHandle ModuleHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.ModuleHandle ModuleHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ModuleHandle As ModuleHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ModuleHandle ModuleHandle { ModuleHandle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ModuleHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールのハンドルを取得します。</summary>
        <value>現在のモジュールの <see cref="T:System.ModuleHandle" /> 構造体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleVersionId">
      <MemberSignature Language="C#" Value="public virtual Guid ModuleVersionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid ModuleVersionId" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ModuleVersionId" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ModuleVersionId As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Guid ModuleVersionId { Guid get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールの 2 つのバージョンを区別するために使用できる汎用一意識別子 (UUID) を取得します。</summary>
        <value>モジュールの 2 つのバージョンを区別するために使用できる <see cref="T:System.Guid" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 アンマネージ メタデータで GUID がによって返される、<xref:System.Reflection.Module.ModuleVersionId%2A>プロパティと呼びます、 `mvid`、され、GUID ヒープに格納されます。  
  
> [!NOTE]
>  メタデータの詳細については、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールの名前をパスを削除した状態で表す <see langword="String" /> を取得します。</summary>
        <value>パスを含まないモジュール名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Name` プラットフォームに依存する文字列です。  
  
 このモジュールのアセンブリがバイト配列から読み込まれたかどうか、`FullyQualifiedName`モジュールが表示されます:\<不明な >。  
  
 名前とパスを取得する<xref:System.Reflection.Module.FullyQualifiedName%2A>です。  
  
   
  
## Examples  
 この例の効果を示しています、 `ScopeName`、 `FullyQualifiedName`、および`Name`プロパティです。  
  
 [!code-cpp[Classic Module.Name Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.Name Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.Name Example/CS/source.cs#1)]
 [!code-vb[Classic Module.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.Name Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Equality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Reflection.Module" /> オブジェクトが等しいかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> に等しい場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Module left, System.Reflection.Module right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Module left, class System.Reflection.Module right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.op_Inequality(System.Reflection.Module,System.Reflection.Module)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Module, right As Module) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Module ^ left, System::Reflection::Module ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Module" />
        <Parameter Name="right" Type="System.Reflection.Module" />
      </Parameters>
      <Docs>
        <param name="left">比較する最初のオブジェクト。</param>
        <param name="right">比較する 2 番目のオブジェクト。</param>
        <summary>2 つの <see cref="T:System.Reflection.Module" /> オブジェクトが等しくないかどうかを示します。</summary>
        <returns>
          <see langword="true" /> が <paramref name="left" /> と等しくない場合は <paramref name="right" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンで識別されるフィールドを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo ResolveField (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveField (metadataToken As Integer) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ ResolveField(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のフィールドを識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンで識別されるフィールドを返します。</summary>
        <returns>指定したメタデータ トークンで識別されるフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 親フィールドを識別するメタデータ トークンを解決するのには`TypeSpec`要素型を含むシグネチャを持つ`ELEMENT_TYPE_VAR`または`ELEMENT_TYPE_MVAR`を使用して、<xref:System.Reflection.Module.ResolveField%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッド オーバー ロードで、必要なコンテキストを指定することができます。 ジェネリック型や、トークンが埋め込まれたジェネリック メソッドのジェネリック型パラメーターに依存するフィールドのメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 トークンの解像度を示すコードは汎用コンテキスト (つまりのジェネリック型パラメーター、ジェネリック型またはジェネリック メソッドのトークンが埋め込まれている) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれるフィールドのトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、親の <see langword="TypeSpec" /> に要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含む署名が存在するフィールドを識別します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveField">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.FieldInfo ResolveField (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo ResolveField(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveField(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveField (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ ResolveField(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のフィールドを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別されるフィールドを返します。</summary>
        <returns>指定したメタデータ トークンで識別されるフィールドを表す <see cref="T:System.Reflection.FieldInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッドで`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 トークンの解像度を示すコードは汎用コンテキスト (つまりのジェネリック型パラメーター、ジェネリック型またはジェネリック メソッドのトークンが埋め込まれている) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれるフィールドのトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、親 <see langword="TypeSpec" /> が要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含む署名を持つフィールドを識別しますが、必要なジェネリック型引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" /> の両方またはいずれかに提供されていません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンで識別される型またはメンバーを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo ResolveMember (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMember (metadataToken As Integer) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MemberInfo ^ ResolveMember(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型またはメンバーを識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンで識別される型またはメンバーを返します。</summary>
        <returns>指定したメタデータ トークンで識別される型またはメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メタデータ トークンを解決するのには、`MethodSpec`または`TypeSpec`要素の型を含むシグネチャを持つ`ELEMENT_TYPE_VAR`または`ELEMENT_TYPE_MVAR`を使用して、<xref:System.Reflection.Module.ResolveMember%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッド オーバー ロードで、必要なコンテキストを指定することができます。 ジェネリック型や、トークンが埋め込まれたジェネリック メソッドのジェネリック型パラメーターに依存するメンバーのメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 トークンの解像度を示すコードは汎用コンテキスト (つまりのジェネリック型パラメーター、ジェネリック型またはジェネリック メソッドのトークンが埋め込まれている) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープ内の型またはメンバーのトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含む署名が存在する <see langword="MethodSpec" /> または <see langword="TypeSpec" /> です。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、プロパティまたはイベントを識別します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo ResolveMember (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo ResolveMember(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMember(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMember (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MemberInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MemberInfo ^ ResolveMember(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型またはメンバーを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別される型またはメンバーを返します。</summary>
        <returns>指定したメタデータ トークンで識別される型またはメンバーを表す <see cref="T:System.Reflection.MemberInfo" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッドで`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 トークンの解像度を示すコードは汎用コンテキスト (つまりのジェネリック型パラメーター、ジェネリック型またはジェネリック メソッドのトークンが埋め込まれている) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープ内の型またはメンバーのトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャを持つ <see langword="MethodSpec" /> または <see langword="TypeSpec" /> ですが、必要なジェネリック型の引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" /> の両方またはいずれかに提供されていません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、プロパティまたはイベントを識別します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンで識別されるメソッドを返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodBase ResolveMethod (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveMethod (metadataToken As Integer) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodBase ^ ResolveMethod(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">メソッドまたはモジュール内のコンス トラクターを識別するメタデータ トークン。</param>
        <summary>メソッドまたは指定したメタデータ トークンによって識別されるコンス トラクターを返します。</summary>
        <returns>指定したメタデータ トークンで識別されるメソッドまたはコンストラクターを表す <see cref="T:System.Reflection.MethodBase" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メタデータ トークンを解決するのには、`MethodSpec`要素の型を含むシグネチャを持つ`ELEMENT_TYPE_VAR`または`ELEMENT_TYPE_MVAR`を使用して、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッド オーバー ロードで、必要なコンテキストを指定することができます。 ジェネリック型のジェネリック型パラメーターに依存しているメソッドや、トークンが埋め込まれたジェネリック メソッドのメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
   
  
## Examples  
 次の例の 2 つのオーバー ロードを使用する方法を示しています、<xref:System.Reflection.Module.ResolveMethod%2A>ジェネリックと非ジェネリックのコンテキスト内のメソッドの呼び出しからのメタデータ トークンを解決するのにはサイトします。  
  
 このコード例は、次の 2 つのジェネリック型を定義`G1<Tg1>`と`G2<Tg2>`(`G1(Of Tg1)`と`G2(Of Tg2)`Visual Basic で)、それぞれが持つジェネリック メソッドです。 `G1<Tg1>` 型パラメーターを使用する非ジェネリック メソッドもあります`Tg1`そのパラメーターにします。 ジェネリック メソッド`GM2<Tgm2>`型`G2<Tg2>`いくつかのメソッド呼び出しが含まれています。  
  
-   ケース 1: ジェネリック メソッド`GM1<Tgm1>`の型パラメーターを使用して、呼び出された`G2<Tg2>`と`GM2<Tgm2>`型引数として。 つまり、呼び出されたメソッドのパラメーターの型によって異なりますの種類の定義からのクローズ ジェネリック型を構築するために使用される型`G2<Tg2>`です。  
  
-   ケース 2: 非ジェネリック メソッド`M1`と呼びます。 このメソッドのパラメーターは、型の定義の型パラメーターを使用して`G1<Tg1>`、外側の型の型パラメーターでこのケースで置き換え`G2<Tg2>`です。  
  
-   ケース 3: ジェネリック メソッド`GM1<Tgm1>`が呼び出されると、指定する<xref:System.Int32>と<xref:System.Object>ジェネリック型とジェネリック メソッドの型引数をそれぞれします。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
-   ケース 4: 非ジェネリック メソッド`M1`の`Example`クラスが呼び出されます。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
 さらに、非ジェネリックの定義例では、`Example`クラスです。 このクラスには、メソッド`M`ジェネリック メソッドの呼び出しを行います。  
  
-   5 の場合: ジェネリック メソッド`GM1`が呼び出されると、指定する<xref:System.Int32>と<xref:System.Object>ジェネリック型とジェネリック メソッドの型引数をそれぞれします。 それを囲むこのメソッドのコンテキストを持たないジェネリック型またはジェネリック メソッドです。  
  
 各ケースの例では、まずを構築、 <xref:System.Reflection.MethodInfo> 、呼び出されたメソッドを表し、トークンを使用して、、解決される、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッド オーバー ロードを使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>と<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>の値を取得するメソッドを`genericTypeArguments`と`genericMethodArguments`パラメーター。 メソッドを返すために、すべての場合、この手法は<xref:System.Type.EmptyTypes?displayProperty=nameWithType>の非ジェネリックのコンテキスト。 例では、比較は解決された<xref:System.Reflection.MethodInfo>で構築された<xref:System.Reflection.MethodInfo>です。  
  
 この例では使用を試みます、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29>トークンを解決するのには、メソッドのオーバー ロードします。 これにより、このメソッドの呼び出しは汎用のコンテキストに依存しないために、3、4、および 5 の場合は動作します。 1 と 2 の場合、トークンを解決するのには不十分な情報があるために、例外がスローされます。  
  
 メタデータ トークンの値は、列挙体としてハード コードされます。 このコード例を変更すると、トークンの値は変更される可能性がします。 新しいトークンの値を確認するのには、コードをコンパイルし、Ildasm.exe を使用して、 **/tokens**アセンブリを確認するにはオプションです。 トークンは、呼び出しの時点で確認できます。 列挙体に新しい値を挿入し、例を再コンパイルします。  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれるメソッドまたはコンストラクターのトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャが存在する <see langword="MethodSpec" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase ResolveMethod (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase ResolveMethod(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveMethod(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveMethod (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBase ^ ResolveMethod(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">メソッドまたはモジュール内のコンス トラクターを識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別されるメソッドまたはコンストラクターを返します。</summary>
        <returns>指定したメタデータ トークンで識別されるメソッドを表す <see cref="T:System.Reflection.MethodBase" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッドで`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericMethodArguments`です。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
   
  
## Examples  
 次の例の 2 つのオーバー ロードを使用する方法を示しています、<xref:System.Reflection.Module.ResolveMethod%2A>ジェネリックと非ジェネリックのコンテキスト内のメソッドの呼び出しからのメタデータ トークンを解決するのにはサイトします。  
  
 このコード例は、次の 2 つのジェネリック型を定義`G1<Tg1>`と`G2<Tg2>`、それぞれが持つジェネリック メソッドです。 `G1<Tg1>` 型パラメーターを使用する非ジェネリック メソッドもあります`Tg1`そのパラメーターにします。 ジェネリック メソッド`GM2<Tgm2>`型`G2<Tg2>`いくつかのメソッド呼び出しが含まれています。  
  
-   ケース 1: ジェネリック メソッド`GM1<Tgm1>`の型パラメーターを使用して、呼び出された`G2<Tg2>`と`GM2<Tgm2>`型引数として。 つまり、呼び出されたメソッドのパラメーターの型によって異なりますの種類の定義からのクローズ ジェネリック型を構築するために使用される型`G2<Tg2>`です。  
  
-   ケース 2: 非ジェネリック メソッド`M1`と呼びます。 このメソッドのパラメーターは、型の定義の型パラメーターを使用して`G1<Tg1>`、外側の型の型パラメーターでこのケースで置き換え`G2<Tg2>`です。  
  
-   ケース 3: ジェネリック メソッド`GM1<Tgm1>`が呼び出されると、指定する<xref:System.Int32>と<xref:System.Object>ジェネリック型とジェネリック メソッドの型引数をそれぞれします。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
-   ケース 4: 非ジェネリック メソッド`M1`の`Example`クラスが呼び出されます。 このメソッドの呼び出しは、外側の型またはメソッドの型パラメーターには依存しません。  
  
 さらに、非ジェネリックの定義例では、`Example`クラスです。 このクラスには、メソッド`M`ジェネリック メソッドの呼び出しを行います。  
  
-   5 の場合: ジェネリック メソッド`GM1<Tgm1>`が呼び出されると、指定する<xref:System.Int32>と<xref:System.Object>ジェネリック型とジェネリック メソッドの型引数をそれぞれします。 それを囲むこのメソッドのコンテキストを持たないジェネリック型またはジェネリック メソッドです。  
  
 各ケースの例では、まずを構築、 <xref:System.Reflection.MethodInfo> 、呼び出されたメソッドを表し、トークンを使用して、、解決される、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッド オーバー ロードを使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>と<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>の値を取得するメソッドを`genericTypeArguments`と`genericMethodArguments`パラメーター。 メソッドを返すために、すべての場合、この手法は<xref:System.Type.EmptyTypes?displayProperty=nameWithType>の非ジェネリックのコンテキスト。 例では、比較は解決された<xref:System.Reflection.MethodInfo>で構築された<xref:System.Reflection.MethodInfo>です。  
  
 この例では使用を試みます、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%29>トークンを解決するのには、メソッドのオーバー ロードします。 これにより、このメソッドの呼び出しは汎用のコンテキストに依存しないために、3、4、および 5 の場合は動作します。 1 と 2 の場合、トークンを解決するのには不十分な情報があるために、例外がスローされます。  
  
 メタデータ トークンの値は、列挙体としてハード コードされます。 このコード例を変更すると、トークンの値は変更される可能性がします。 新しいトークンの値を確認するのには、コードをコンパイルし、Ildasm.exe を使用して、 **/tokens**アセンブリを確認するにはオプションです。 トークンは、呼び出しの時点で確認できます。 列挙体に新しい値を挿入し、例を再コンパイルします。  
  
 [!code-csharp[Module.MethodResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/Module.MethodResolve/cs/source.cs#1)]
 [!code-vb[Module.MethodResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Module.MethodResolve/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれるメソッドまたはコンストラクターのトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャを持つ <see langword="MethodSpec" /> ですが、必要なジェネリック型引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />.の両方またはいずれかに提供されていません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveSignature">
      <MemberSignature Language="C#" Value="public virtual byte[] ResolveSignature (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ResolveSignature(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveSignature(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveSignature (metadataToken As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ ResolveSignature(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内のシグネチャを識別するメタデータ トークン。</param>
        <summary>メタデータ トークンで識別されるシグネチャ BLOB を返します。</summary>
        <returns>シグネチャ BLOB を表すバイトの配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  メタデータ トークンと署名に関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効な <see langword="MemberRef" />、<see langword="MethodDef" />、<see langword="TypeSpec" />、シグネチャ、または <see langword="FieldDef" /> トークンではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveString">
      <MemberSignature Language="C#" Value="public virtual string ResolveString (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveString(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveString(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveString (metadataToken As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ResolveString(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュールの文字列ヒープ内の文字列を識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンで識別される文字列を返します。</summary>
        <returns>メタデータの文字列ヒープの文字列値を格納する <see cref="T:System.String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープ内の文字列のトークンではありません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>メタデータ トークンで識別される型を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public Type ResolveType (int metadataToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type ResolveType(int32 metadataToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveType (metadataToken As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ ResolveType(int metadataToken);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型を識別するメタデータ トークン。</param>
        <summary>指定したメタデータ トークンで識別される型を返します。</summary>
        <returns>指定したメタデータ トークンで識別される型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メタデータ トークンを解決するのには、`TypeSpec`含むシグネチャを持つ`ELEMENT_TYPE_VAR`または`ELEMENT_TYPE_MVAR`を使用して、<xref:System.Reflection.Module.ResolveType%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッド オーバー ロードで、必要なコンテキストを指定することができます。 ジェネリック型や、トークンが埋め込まれたジェネリック メソッドのジェネリック型パラメーターに依存する型のメタデータ トークンを解決する場合は、これらの型パラメーターを指定できるオーバー ロードを使用する必要があります。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれる型のトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャが存在する <see langword="TypeSpec" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveType">
      <MemberSignature Language="C#" Value="public virtual Type ResolveType (int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type ResolveType(int32 metadataToken, class System.Type[] genericTypeArguments, class System.Type[] genericMethodArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ResolveType(System.Int32,System.Type[],System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ResolveType (metadataToken As Integer, genericTypeArguments As Type(), genericMethodArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ ResolveType(int metadataToken, cli::array &lt;Type ^&gt; ^ genericTypeArguments, cli::array &lt;Type ^&gt; ^ genericMethodArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="metadataToken" Type="System.Int32" />
        <Parameter Name="genericTypeArguments" Type="System.Type[]" />
        <Parameter Name="genericMethodArguments" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="metadataToken">モジュール内の型を識別するメタデータ トークン。</param>
        <param name="genericTypeArguments">トークンがスコープ内にある型のジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。その型がジェネリックではない場合は <see langword="null" />。</param>
        <param name="genericMethodArguments">トークンがスコープ内にあるメソッドのジェネリック型引数を表す <see cref="T:System.Type" /> オブジェクトの配列。そのメソッドがジェネリックではない場合は <see langword="null" />。</param>
        <summary>指定したジェネリック型パラメーターで定義されたコンテキストの、指定したメタデータ トークンで識別される型を返します。</summary>
        <returns>指定したメタデータ トークンで識別される型を表す <see cref="T:System.Type" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>型のメソッドで`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 使用して、<xref:System.Reflection.MethodInfo.GetGenericArguments%2A?displayProperty=nameWithType>メソッドのメソッド、`metadataToken`のジェネリック型引数の配列を取得するスコープに`genericTypeArguments`です。 必要でない場合でも、これらの引数を用意することは常にします。  
  
> [!NOTE]
>  メタデータ トークンに関する情報は、共通言語基盤 (CLI) ドキュメント、特に「Partition II:: Metadata Definition and Semantics」にあります。 このドキュメントはオンラインです。参照してください[ECMA c# および共通言語基盤規格](http://go.microsoft.com/fwlink/?LinkID=99212)msdn および[標準 ECMA 335 - 共通言語基盤 (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) ECMA Web サイトです。  
  
 トークンの解像度を示すコードは汎用コンテキスト (つまりのジェネリック型パラメーター、ジェネリック型またはジェネリック メソッドのトークンが埋め込まれている) を使用して参照してください、<xref:System.Reflection.Module.ResolveMethod%28System.Int32%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%29>メソッドです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープに含まれる型のトークンではありません。  
  
 - または -  
  
 <paramref name="metadataToken" /> は、要素型 <see langword="var" /> (ジェネリック型の型パラメーター) または <see langword="mvar" /> (ジェネリック メソッドの型パラメーター) を含むシグネチャを持つ <see langword="TypeSpec" /> ですが、必要なジェネリック型引数が <paramref name="genericTypeArguments" /> と <paramref name="genericMethodArguments" />.の両方またはいずれかに提供されていません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="metadataToken" /> は、現在のモジュールのスコープで有効なトークンではありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ScopeName">
      <MemberSignature Language="C#" Value="public virtual string ScopeName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ScopeName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Module.ScopeName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ScopeName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ScopeName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>モジュールの名前を表す文字列を取得します。</summary>
        <value>モジュール名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ScopeName`プロパティは、共通言語ランタイムでは使用されませんが、これを使用して、メタデータ Api を使用してモジュールを生成するときに、プロパティで使用文字列を格納することができます。 リフレクション自身設定はできません、`ScopeName`プロパティです。  
  
   
  
## Examples  
 この例の効果を示しています、 `ScopeName`、 `FullyQualifiedName`、および`Name`プロパティです。  
  
 [!code-cpp[Classic Module.ScopeName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Module.ScopeName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/CS/source.cs#1)]
 [!code-vb[Classic Module.ScopeName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Module.ScopeName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Module.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Module.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Module::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="rgszNames">マッピング対象として渡される名前の配列。</param>
        <param name="cNames">マッピングされる名前のカウント。</param>
        <param name="lcid">名前を解釈するロケール コンテキスト。</param>
        <param name="rgDispId">名前に対応する ID を受け取る、呼び出し元割り当て済み配列。</param>
        <summary>一連の名前を対応する一連のディスパッチ識別子に割り当てます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetIDsOfNames`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Module.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">返される型情報。</param>
        <param name="lcid">型情報のロケール ID。</param>
        <param name="ppTInfo">要求された型情報オブジェクトへのポインターを取得します。</param>
        <summary>オブジェクトの型情報を取得します。この型情報を使用して、インターフェイスの型情報を取得できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfo`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Module.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Module.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Module::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">オブジェクトにより提供される型タイプ情報インターフェイスの数を受け取る場所を指定します。</param>
        <summary>オブジェクトが提供する型情報インターフェイスの数 (0 または 1) を取得します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::GetTypeInfoCount`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Module.Invoke">
      <MemberSignature Language="C#" Value="void _Module.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Module.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.System#Runtime#InteropServices#_Module#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Module.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Module.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Module::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Module.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">メンバーを識別します。</param>
        <param name="riid">将来使用するために予約されています。 IID_NULL にする必要があります。</param>
        <param name="lcid">引数を解釈する対象のロケール コンテキスト。</param>
        <param name="wFlags">呼び出しのコンテキストを記述するフラグ。</param>
        <param name="pDispParams">引数の配列、名前付き引数の DISPID の配列、配列内の要素数のカウントを格納している構造体へのポインター。</param>
        <param name="pVarResult">結果が格納される場所へのポインター。</param>
        <param name="pExcepInfo">例外情報を格納する構造体へのポインター。</param>
        <param name="puArgErr">エラーが存在する最初の引数のインデックス。</param>
        <summary>オブジェクトによって公開されたプロパティおよびメソッドへのアクセスを提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ コードからマネージ クラスにアクセスするため、およびマネージ コードから呼び出すことはできません。 詳細については`IDispatch::Invoke`、MSDN ライブラリを参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">COM <c>IDispatch</c> インターフェイスを使用した遅延バインディング アクセスはサポートされていません。</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Module.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>モジュールの名前を返します。</summary>
        <returns>このモジュールの名前を表す <see langword="String" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例での使用、`ToString`メソッドです。  
  
 [!code-cpp[System.Reflection.Module.ToString Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Reflection.Module.ToString Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/CS/class1.cs#1)]
 [!code-vb[System.Reflection.Module.ToString Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Module.ToString Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>