<Type Name="Application" FullName="System.Windows.Forms.Application">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a01dc9504b39cc7d10b7733f09143ac76f57264d" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57929028" /></Metadata><TypeSignature Language="C#" Value="public sealed class Application" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Application extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Application" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Application" />
  <TypeSignature Language="C++ CLI" Value="public ref class Application sealed" />
  <TypeSignature Language="F#" Value="type Application = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Windows メッセージを処理するために、アプリケーションを開始および停止するメソッドや、アプリケーションの情報を取得するためのプロパティなど、アプリケーションを管理するための <see langword="static" /> メソッドおよびプロパティを提供します。 このクラスは継承できません。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application>クラスのアプリケーションとスレッドを開始および停止して、次のように、Windows メッセージを処理するメソッドがあります。  
  
-   <xref:System.Windows.Forms.Application.Run%2A> 現在のスレッドで、アプリケーション メッセージ ループを開始し、必要に応じて、フォームを表示します。  
  
-   <xref:System.Windows.Forms.Application.Exit%2A> または<xref:System.Windows.Forms.Application.ExitThread%2A>メッセージ ループを停止します。  
  
-   <xref:System.Windows.Forms.Application.DoEvents%2A> ループになっているプログラムは、メッセージを処理します。  
  
-   <xref:System.Windows.Forms.Application.AddMessageFilter%2A> Windows メッセージを監視するアプリケーション メッセージ ポンプにメッセージ フィルターを追加します。  
  
-   <xref:System.Windows.Forms.IMessageFilter> により、イベントの発生を停止またはイベント ハンドラーを呼び出す前に特別な操作を実行できます。  
  
 このクラスは<xref:System.Windows.Forms.Application.CurrentCulture%2A>と<xref:System.Windows.Forms.Application.CurrentInputLanguage%2A>カルチャの現在のスレッドの情報を取得または設定するプロパティ。  
  
 このクラスのインスタンスを作成することはできません。  
  
   
  
## Examples  
 次のコード例は、フォームのリスト ボックス内の番号を一覧表示します。 クリックするたびに`button1`アプリケーションの一覧に別の番号を追加します。  
  
 `Main`メソッド呼び出し<xref:System.Windows.Forms.Application.Run%2A>フォームを作成すると、アプリケーションを起動する`listBox1`と`button1`します。 ユーザーがクリックすると`button1`、`button1_Click`メソッドが表示されます、<xref:System.Windows.Forms.MessageBox>します。 ユーザーがクリックした場合`No`上、 <xref:System.Windows.Forms.MessageBox>、`button1_Click`メソッドの一覧に数値を追加します。 ユーザーがクリックした場合`Yes`、アプリケーション呼び出し<xref:System.Windows.Forms.Application.Exit%2A>をキューに残りのすべてのメッセージを処理し、終了します。  
  
> [!NOTE]
>  呼び出し<xref:System.Windows.Forms.Application.Exit%2A>部分信頼では失敗します。  
  
 [!code-cpp[Classic Application Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application Example/CS/source.cs#1)]
 [!code-vb[Classic Application Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddMessageFilter">
      <MemberSignature Language="C#" Value="public static void AddMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member AddMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.AddMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">インストールする <see cref="T:System.Windows.Forms.IMessageFilter" /> インターフェイスの実装。</param>
        <summary>メッセージ フィルターを追加して、ルーティング先にルーティングされる Windows メッセージを監視します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定のイベントが発生していることを防ぐために、またはイベントをイベント ハンドラーに渡される前に特別な操作を実行するメッセージ フィルターを使用します。 メッセージ フィルターは、特定のスレッドに固有です。  
  
 メッセージがディスパッチされていることを防ぐために、`value`このメソッドに渡すパラメーターのインスタンスをオーバーライドする必要があります、<xref:System.Windows.Forms.IMessageFilter.PreFilterMessage%2A>メッセージを処理するコードを持つメソッド。 メソッドは `false`を返します。  
  
> [!CAUTION]
>  アプリケーションのメッセージ ポンプにメッセージ フィルターを追加すると、パフォーマンスが低下することができます。  
  
   
  
## Examples  
 次のコード例と呼ばれるメッセージ フィルターを作成する`TestMessageFilter`します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。 メッセージ フィルターを使用するには、実装を提供する必要があります、<xref:System.Windows.Forms.IMessageFilter>インターフェイス。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AllowQuit">
      <MemberSignature Language="C#" Value="public static bool AllowQuit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool AllowQuit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.AllowQuit" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property AllowQuit As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool AllowQuit { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AllowQuit : bool" Usage="System.Windows.Forms.Application.AllowQuit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し元がこのアプリケーションを終了できるかどうかを示す値を取得します。</summary>
        <value>呼び出し元がこのアプリケーションを終了できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`false`から呼び出された場合、 <xref:System.Windows.Forms.Control> Web ブラウザー内でホストされています。 つまり、<xref:System.Windows.Forms.Control>を終了できません、<xref:System.Windows.Forms.Application>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplicationExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ApplicationExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ApplicationExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ApplicationExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ApplicationExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ApplicationExit;" />
      <MemberSignature Language="F#" Value="member this.ApplicationExit : EventHandler " Usage="member this.ApplicationExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションをシャットダウンしようとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ハンドラーをアタッチする必要があります、`ApplicationExit`ハンドルされていないを実行するアプリケーションの実行が停止する前にタスクが必要です。 このアプリケーション、またはガベージ コレクションがクリアされなかったオブジェクトの破棄によって開かれたファイルを閉じることができます。  
  
 これは、静的イベントであるためで、このイベントにアタッチされているすべてのイベント ハンドラーをデタッチする必要があります、`ApplicationExit`イベント ハンドラー自体。 これらのハンドラーを接続解除しないでイベントに接続したまま、され、メモリを消費する続行されます。  
  
   
  
## Examples  
 次のコード例では、2 つのフォームを表示し、両方のフォームが閉じられたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例では、`ApplicationExit`を知り、フォームの位置は、ファイルに永続化するとき、およびイベント、`FileStream`閉じる必要があります。  
  
 クラスは、`MyApplicationContext`継承<xref:System.Windows.Forms.ApplicationContext>各フォームが閉じられるし、はどちらも、ときに、現在のスレッドを終了するときの追跡とします。 クラスが閉じているときに、各フォームの位置を記憶します。 ときに、`ApplicationExit`イベントが発生する、クラスでは、ユーザーのそれぞれの位置をファイルに書き込みます。 フォームの位置データがという名前のファイルに格納されている`appdata.txt`によって決定の場所に作成される<xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。 `Main`メソッド呼び出し`Application.Run(context)`に基づいてアプリケーションを開始する、<xref:System.Windows.Forms.ApplicationContext>します。  
  
 このコードは、抜粋の例に示すように、<xref:System.Windows.Forms.ApplicationContext>クラスの概要。 参照してください<xref:System.Windows.Forms.ApplicationContext>全体のコードの一覧。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataPath">
      <MemberSignature Language="C#" Value="public static string CommonAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommonAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommonAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataPath : string" Usage="System.Windows.Forms.Application.CommonAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーが共有するアプリケーション データのパスを取得します。</summary>
        <value>すべてのユーザーが共有するアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスが存在しない場合は、次の形式で 1 つ作成されます。  
  
 *基本パス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> メインの実行可能ファイルを含むアセンブリが含まれているが最初に検索、`AssemblyInformationalVersion`属性。 この属性が存在する場合は、両方の使用<xref:System.Windows.Forms.Application.ProductVersion%2A>と<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>します。 両方のプロパティをこの属性が存在しない場合、実行可能ファイルのバージョンが代わりに使用します。  
  
 Windows フォーム アプリケーションの配置を使用しているかどうかによって異なる、パスになります[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings でユーザーごとのアプリケーション キャッシュに格納されている\\*username*ディレクトリ。 詳細については、次を参照してください。[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="CommonAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey CommonAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey CommonAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommonAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ CommonAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommonAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.CommonAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>すべてのユーザーが共有するアプリケーション データのレジストリ キーを取得します。</summary>
        <value>すべてのユーザーが共有するアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーが存在しない場合は、次の形式で作成されます。  
  
 LocalMachine\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public static string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Application.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションに関連付けられている会社名を取得します。</summary>
        <value>会社名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります`textBox1`がフォームに配置されています。  
  
 [!code-cpp[Classic Application.CompanyName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CompanyName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CompanyName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CompanyName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CompanyName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="T:System.Reflection.AssemblyCompanyAttribute" />
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public static System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Windows.Forms.Application.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドのカルチャ情報を取得または設定します。</summary>
        <value>現在のスレッドのカルチャ情報を表す <see cref="T:System.Globalization.CultureInfo" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります`textBox1`がフォームに配置されています。  
  
 [!code-cpp[Classic Application.CurrentCulture Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentCulture Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentCulture Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentCulture Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティを設定するすべてのウィンドウ。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="CurrentInputLanguage">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.InputLanguage CurrentInputLanguage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.InputLanguage CurrentInputLanguage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentInputLanguage As InputLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::InputLanguage ^ CurrentInputLanguage { System::Windows::Forms::InputLanguage ^ get(); void set(System::Windows::Forms::InputLanguage ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentInputLanguage : System.Windows.Forms.InputLanguage with get, set" Usage="System.Windows.Forms.Application.CurrentInputLanguage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のスレッドの現在の入力言語を取得または設定します。</summary>
        <value>現在のスレッドの現在の入力言語を表す <see cref="T:System.Windows.Forms.InputLanguage" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります`textBox1`がフォームに配置されています。  
  
 [!code-cpp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/CS/source.cs#1)]
 [!code-vb[Classic Application.CurrentInputLanguage Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.CurrentInputLanguage Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Windows.Forms.InputLanguage" />
      </Docs>
    </Member>
    <Member MemberName="DoEvents">
      <MemberSignature Language="C#" Value="public static void DoEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DoEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.DoEvents" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub DoEvents ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void DoEvents();" />
      <MemberSignature Language="F#" Value="static member DoEvents : unit -&gt; unit" Usage="System.Windows.Forms.Application.DoEvents " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>メッセージ キューに現在ある Windows メッセージをすべて処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォームを実行するときにイベントを処理するを待機し、新しいフォームを作成します。 フォームは、イベントを処理するたびに、そのイベントに関連付けられているすべてのコードを処理します。 その他のすべてのイベントは、キューで待機します。 コードでは、イベントを処理するときに、アプリケーションは応答しません。 たとえば、ウィンドウが再描画されない別のウィンドウが手前にドラッグした場合。  
  
 呼び出す場合<xref:System.Windows.Forms.Application.DoEvents%2A>コードでは、アプリケーションが他のイベントを処理できます。 例では、データを追加するフォームがある場合、<xref:System.Windows.Forms.ListBox>追加<xref:System.Windows.Forms.Application.DoEvents%2A>上にある別のウィンドウがドラッグされると、コードに、フォームを再描画します。 削除する場合<xref:System.Windows.Forms.Application.DoEvents%2A>、コードから、フォームが再描画されないボタンの click イベント ハンドラーが完了するまで実行します。 メッセージングの詳細については、次を参照してください。 [Windows フォームでのユーザー入力](~/docs/framework/winforms/user-input-in-windows-forms.md)します。  
  
 Visual Basic 6.0 とは異なり、<xref:System.Windows.Forms.Application.DoEvents%2A>メソッドは呼び出しません、<xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType>メソッド。  
  
 通常、メッセージを処理するループ内でこのメソッドを使用します。  
  
> [!CAUTION]
>  このメソッドを呼び出すと、現在のスレッドを待機しているウィンドウのすべてのメッセージの処理中に中断するが、します。 メッセージにによりトリガーされるようにイベントが、アプリケーション コードの他の領域は実行可能性があります。 これには、アプリケーションをデバッグするが困難な予期しない動作が発生する可能性があります。 操作または長い時間がかかる計算を実行する場合は、新しいスレッド上でこれらの操作を実行することをお勧めは多くの場合。 非同期プログラミングの詳細については、次を参照してください。[非同期プログラミング モデル (APM)](~/docs/standard/asynchronous-programming-patterns/asynchronous-programming-model-apm.md)します。  
  
   
  
## Examples  
 次のコード例に示しますを使用して、<xref:System.Windows.Forms.Application.DoEvents%2A>メソッド。 ユーザーがからグラフィック ファイルを選択できる例を実行すると、<xref:System.Windows.Forms.OpenFileDialog>します。 選択したファイルは、フォームに表示されます。 <xref:System.Windows.Forms.Application.DoEvents%2A>メソッド強制的に開いている各グラフィックス ファイルのフォームの再描画します。 この例を実行するには、格納しているフォームに次のコードを貼り付け、<xref:System.Windows.Forms.PictureBox>という名前の`PictureBox1`、<xref:System.Windows.Forms.OpenFileDialog>という名前`OpenFileDialog1`、という名前のボタンと`fileButton`します。 呼び出す、`InitializePictureBox`と`InitializeOpenFileDialog`フォームのコンス トラクターのメソッドまたは`Load`メソッド。  
  
> [!NOTE]
>  追加する場合、Visual Studio で、<xref:System.Windows.Forms.OpenFileDialog>をドラッグ操作を使用してフォームには、次のように変更する必要が`InitializeOpenFileDialog`メソッドの新しいインスタンスを作成する行を削除することによって<xref:System.Windows.Forms.OpenFileDialog>します。  
  
 例もする必要があります、<xref:System.Windows.Forms.Control.Click?displayProperty=nameWithType>のイベント、<xref:System.Windows.Forms.Button>コントロールと<xref:System.Windows.Forms.FileDialog.FileOk>のイベント、<xref:System.Windows.Forms.OpenFileDialog>の例で定義されているイベント ハンドラーに接続しています。 例が実行されている場合は、ボタンをクリックして、ダイアログ ボックスを表示します。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#1)]
 [!code-csharp[System.Windows.Forms.FileDialog#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#1)]
 [!code-vb[System.Windows.Forms.FileDialog#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
      </Docs>
    </Member>
    <Member MemberName="EnableVisualStyles">
      <MemberSignature Language="C#" Value="public static void EnableVisualStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnableVisualStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.EnableVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnableVisualStyles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnableVisualStyles();" />
      <MemberSignature Language="F#" Value="static member EnableVisualStyles : unit -&gt; unit" Usage="System.Windows.Forms.Application.EnableVisualStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションで visual スタイルを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アプリケーションの visual スタイルを使用します。 Visual スタイルでは、色、フォント、およびオペレーティング システムのテーマを形成する他のビジュアル要素が。 Visual スタイルを使用して、コントロールと、オペレーティング システムがサポートしている場合は、コントロールが描画されます。 影響を与えるに<xref:System.Windows.Forms.Application.EnableVisualStyles>は、アプリケーションでコントロールを作成する前に呼び出す必要があります通常、<xref:System.Windows.Forms.Application.EnableVisualStyles>の最初の行には、`Main`関数。 個別のマニフェストを呼び出すときに visual スタイルを有効にする必要はありません<xref:System.Windows.Forms.Application.EnableVisualStyles>します。  
  
> [!NOTE]
>  .NET Framework 2.0 では、前に、`FlatStyle`プロパティから派生するコントロールなど、一部のコントロールの<xref:System.Windows.Forms.ButtonBase>に設定する必要がある<xref:System.Windows.Forms.FlatStyle.System?displayProperty=nameWithType>visual スタイルで描画するコントロールの順序で。 .NET Framework 2.0 で記述されたアプリケーションでは、必要に応じてこれはありません。  
  
> [!NOTE]
>  このメソッドには、Internet Explorer でホストされているコントロールの効果はありません。  
  
   
  
## Examples  
 次のコード例は、呼び出し元を示します<xref:System.Windows.Forms.Application.EnableVisualStyles%2A>で、`Main`アプリケーションの visual スタイルを有効にする関数。  
  
 [!code-cpp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Application.EnableVisualStyles#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Application.EnableVisualStyles/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
        <altmember cref="P:System.Windows.Forms.Application.VisualStyleState" />
        <altmember cref="T:System.Windows.Forms.FlatStyle" />
      </Docs>
    </Member>
    <Member MemberName="EnterThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler EnterThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnterThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.EnterThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event EnterThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ EnterThreadModal;" />
      <MemberSignature Language="F#" Value="member this.EnterThreadModal : EventHandler " Usage="member this.EnterThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークが発生するとき、イベント ハンドラーをデタッチする必要があります。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Application.EnterThreadModal>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行する Windows フォームに貼り付けることと、イベント ハンドラーに関連付けられていることを確認、<xref:System.Windows.Forms.Application.EnterThreadModal>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#3)]
 [!code-vb[System.Windows.Forms.EventExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">必要があります<see cref="P:System.Security.Permissions.SecurityPermissionAttribute.UnmanagedCode" />イベントをリッスンするアクセス許可。</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecutablePath">
      <MemberSignature Language="C#" Value="public static string ExecutablePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ExecutablePath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ExecutablePath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ExecutablePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ExecutablePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutablePath : string" Usage="System.Windows.Forms.Application.ExecutablePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルのパスを、ファイル名を含めて取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパスおよびファイル名。  
  
このパスは、Windows フォーム アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して配置されているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings でユーザーごとのアプリケーション キャッシュに格納されている\\*username*ディレクトリ。 詳細については、次を参照してください。[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスを取得します。 関連付けられた列挙体。 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Exit">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit();" />
      <MemberSignature Language="F#" Value="static member Exit : unit -&gt; unit" Usage="System.Windows.Forms.Application.Exit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.Exit%2A>メソッドは、すべてのスレッドで実行中のすべてのメッセージ ループを停止して、アプリケーションのすべてのウィンドウを閉じます。 このメソッドは、アプリケーションを終了するを必ずしも強制しません。 <xref:System.Windows.Forms.Application.Exit%2A>とメッセージ ループ内でメソッドの呼び出し元通常<xref:System.Windows.Forms.Application.Run%2A>を返します。 現在のスレッドのみのメッセージ ループを終了するには、呼び出す<xref:System.Windows.Forms.Application.ExitThread%2A>します。  
  
 <xref:System.Windows.Forms.Application.Exit%2A> 次のイベントが発生し、関連付けられている条件付きアクションを実行します。  
  
-   A<xref:System.Windows.Forms.Form.FormClosing>によって表されるすべてのフォームのイベントは、<xref:System.Windows.Forms.Application.OpenForms%2A>プロパティ。 このイベントは、設定によって取り消されることができます、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.Windows.Forms.FormClosingEventArgs>パラメーターを`true`します。  
  
-   イベントをキャンセルの 1 つ以上のハンドラーのかどうかは<xref:System.Windows.Forms.Application.Exit%2A>せず、さらにアクションを返します。 それ以外の場合、<xref:System.Windows.Forms.Form.FormClosed>すべてのフォームのイベントが発生し、実行中のすべてのメッセージ ループとフォームが閉じられます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Application.Exit%2A>メソッドを発生させない、<xref:System.Windows.Forms.Form.Closed>と<xref:System.Windows.Forms.Form.Closing>としての廃止のイベント[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]します。  
  
   
  
## Examples  
 次のコード例は、フォームのリスト ボックス内の番号を一覧表示します。 クリックするたびに`button1`アプリケーションの一覧に別の番号を追加します。  
  
 `Main`メソッド呼び出し<xref:System.Windows.Forms.Application.Run%2A>フォームを作成すると、アプリケーションを起動する`listBox1`、および`button1`します。 ユーザーがクリックすると`button1`、`button1_Click`メソッドは、リスト ボックスには、1 ~ 3 の番号を追加し、表示、<xref:System.Windows.Forms.MessageBox>します。 ユーザーがクリックした場合**いいえ**上、 <xref:System.Windows.Forms.MessageBox>、`button1_Click`メソッドの一覧に別の番号を追加します。 ユーザーがクリックした場合 **[はい]**、アプリケーション呼び出し<xref:System.Windows.Forms.Application.Exit%2A>キューに残りのすべてのメッセージを処理し、終了します。  
  
 この例では、する必要があります`listBox1`と`button1`インスタンス化され、フォーム上に配置します。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.Run" />
        <altmember cref="P:System.Windows.Forms.Application.OpenForms" />
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Exit(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member Exit : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="System.Windows.Forms.Application.Exit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">アプリケーション内の <see cref="T:System.Windows.Forms.Form" /> が終了をキャンセルしたかどうかを示す値を返します。</param>
        <summary>終了する必要があるすべてのメッセージ ポンプを通知し、メッセージが処理されると、すべてのアプリケーション ウィンドウを閉じます。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityException">実行を終了するためのアクセス許可をアプリケーション スレッドです。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="ExitThread">
      <MemberSignature Language="C#" Value="public static void ExitThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExitThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.ExitThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExitThread ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExitThread();" />
      <MemberSignature Language="F#" Value="static member ExitThread : unit -&gt; unit" Usage="System.Windows.Forms.Application.ExitThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドのメッセージ ループを終了し、スレッドのウィンドウをすべて閉じます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、現在のスレッドのメッセージ ループを終了します。 このメソッドの呼び出しは、<xref:System.Windows.Forms.Application.Run%2A>を返す現在のスレッドにします。 アプリケーション全体を終了するには、呼び出す<xref:System.Windows.Forms.Application.Exit%2A>します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
      </Docs>
    </Member>
    <Member MemberName="FilterMessage">
      <MemberSignature Language="C#" Value="public static bool FilterMessage (ref System.Windows.Forms.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool FilterMessage(valuetype System.Windows.Forms.Message&amp; message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.FilterMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FilterMessage (ByRef message As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool FilterMessage(System::Windows::Forms::Message % message);" />
      <MemberSignature Language="F#" Value="static member FilterMessage :  -&gt; bool" Usage="System.Windows.Forms.Application.FilterMessage message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="message">フィルター処理の対象となる Windows イベント メッセージ。</param>
        <summary>ウィンドウ メッセージに対してフィルターを実行し、変更したメッセージのコピーを返します。</summary>
        <returns>フィルターが処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Idle">
      <MemberSignature Language="C#" Value="public static event EventHandler Idle;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Idle" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.Idle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event Idle As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ Idle;" />
      <MemberSignature Language="F#" Value="member this.Idle : EventHandler " Usage="member this.Idle : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが処理を完了し、アイドル状態に入ろうとすると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ために必要なタスクがある場合、スレッドがアイドル状態になると、前にこのイベントに添付します。  
  
> [!CAUTION]
>  静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークが発生するとき、イベント ハンドラーをデタッチする必要があります。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Application.Idle>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行する Windows フォームに貼り付けることと、イベント ハンドラーに関連付けられていることを確認、<xref:System.Windows.Forms.Application.Idle>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#2)]
 [!code-vb[System.Windows.Forms.EventExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LeaveThreadModal">
      <MemberSignature Language="C#" Value="public static event EventHandler LeaveThreadModal;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LeaveThreadModal" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.LeaveThreadModal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event LeaveThreadModal As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ LeaveThreadModal;" />
      <MemberSignature Language="F#" Value="member this.LeaveThreadModal : EventHandler " Usage="member this.LeaveThreadModal : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションがモーダル状態を終了するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークが発生するとき、イベント ハンドラーをデタッチする必要があります。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Application.LeaveThreadModal>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行する Windows フォームに貼り付けることと、イベント ハンドラーに関連付けられていることを確認、<xref:System.Windows.Forms.Application.LeaveThreadModal>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#4)]
 [!code-vb[System.Windows.Forms.EventExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalUserAppDataPath">
      <MemberSignature Language="C#" Value="public static string LocalUserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string LocalUserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LocalUserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ LocalUserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalUserAppDataPath : string" Usage="System.Windows.Forms.Application.LocalUserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカルで非ローミング ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ローカルで非ローミング ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ローカル ユーザーは、ユーザー プロファイルを持つが、ユーザーがログオンをシステムに格納されているいずれかです。 パスが存在しない場合は、次の形式で 1 つ作成されます。  
  
 *基本パス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 通常の基本パスは C:\Documents and Settings\\*username*\Local Settings\Application データ。 このパスになります、ただしを使用して、Windows フォーム アプリケーションがデプロイされている場合[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] その他のすべてのアプリケーションから分離された独自のアプリケーション データ ディレクトリを作成します。 詳細については、次を参照してください。[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。  
  
   
  
## Examples  
 次のコード例では、2 つのフォームを表示し、両方のフォームが閉じられたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例を使用して、 <xref:System.Windows.Forms.Application.UserAppDataPath%2A> 、ユーザーのアプリケーション データを格納するプロパティ、<xref:System.Windows.Forms.Application.LocalUserAppDataPath%2A>代わりに使用できます。  
  
 `MyApplicationContext`クラスから継承<xref:System.Windows.Forms.ApplicationContext>し、各フォームが閉じられるし、はどちらも、ときに、現在のスレッドを終了するときは常に追跡します。 クラスは、ユーザーの各フォームの位置を格納します。 フォームの位置データがという名前のファイルに格納されている`Appdata.txt`によって決定の場所に作成される<xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。 `Main`メソッド呼び出し`Application.Run(context)`に基づいてアプリケーションを開始する、<xref:System.Windows.Forms.ApplicationContext>します。  
  
 このコードは、抜粋の例に示すように、<xref:System.Windows.Forms.ApplicationContext>クラスの概要。 いくつかのコードは、簡潔さを優先するためには表示されません。 参照してください<xref:System.Windows.Forms.ApplicationContext>全体のコードの一覧。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MessageLoop">
      <MemberSignature Language="C#" Value="public static bool MessageLoop { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MessageLoop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.MessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MessageLoop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MessageLoop { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.MessageLoop : bool" Usage="System.Windows.Forms.Application.MessageLoop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このスレッドにメッセージ ループが存在するかどうかを示す値を取得します。</summary>
        <value>メッセージ ループが存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非管理対象のアプリケーションなどの他の環境で Windows フォームをホストするときにこのプロパティは常に返します`false`します。 使用<xref:System.Windows.Forms.Application.RegisterMessageLoop%2A>にホスティング環境がまだアクティブなメッセージ ループをかどうかに Windows フォームを指示します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OleRequired">
      <MemberSignature Language="C#" Value="public static System.Threading.ApartmentState OleRequired ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.ApartmentState OleRequired() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OleRequired" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OleRequired () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::ApartmentState OleRequired();" />
      <MemberSignature Language="F#" Value="static member OleRequired : unit -&gt; System.Threading.ApartmentState" Usage="System.Windows.Forms.Application.OleRequired " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで OLE を初期化します。</summary>
        <returns><see cref="T:System.Threading.ApartmentState" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す前にこのメソッドを呼び出す`Microsoft.Win32`OLE を必要とするメソッド。 <xref:System.Windows.Forms.Application.OleRequired%2A> まず、現在のスレッドで OLE が初期化されているかどうかを確認します。 それ以外の場合は、ole、スレッドを初期化します。  
  
> [!NOTE]
>  スレッドは、直接 OLE メソッドを呼び出す、しない限り、このメソッドを呼び出す必要はありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnThreadException">
      <MemberSignature Language="C#" Value="public static void OnThreadException (Exception t);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void OnThreadException(class System.Exception t) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.OnThreadException(System.Exception)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub OnThreadException (t As Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void OnThreadException(Exception ^ t);" />
      <MemberSignature Language="F#" Value="static member OnThreadException : Exception -&gt; unit" Usage="System.Windows.Forms.Application.OnThreadException t" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="t" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="t">スローされた例外を表す <see cref="T:System.Exception" />。</param>
        <summary><see cref="E:System.Windows.Forms.Application.ThreadException" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す<xref:System.Windows.Forms.Application.OnThreadException%2A>アプリケーションの処理が停止する例外が発生します。  
  
 <xref:System.Windows.Forms.Application>クラスには、<xref:System.Windows.Forms.Application.ThreadException>イベント。 未処理の例外に必要なカスタム処理を実行するには、このイベントにイベント ハンドラーをアタッチできます。 イベント ハンドラーをアタッチしない場合<xref:System.Windows.Forms.Application.OnThreadException%2A>されていると、エラーをユーザーに通知するダイアログ ボックスを表示する必要があります。 既定の動作を実行します。  
  
 <xref:System.Windows.Forms.Application.OnThreadException%2A> Windows フォームによって所有されているスレッドのみ発生する未処理の例外の既定の例外動作を実装します。 他のスレッドで未処理の例外は、<xref:System.AppDomain.UnhandledException>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenForms">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.FormCollection OpenForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.FormCollection OpenForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.OpenForms" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OpenForms As FormCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::FormCollection ^ OpenForms { System::Windows::Forms::FormCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OpenForms : System.Windows.Forms.FormCollection" Usage="System.Windows.Forms.Application.OpenForms" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションが所有している、開かれたフォームのコレクションを取得します。</summary>
        <value>アプリケーションによって所有されている、現在開いているすべてのフォームが格納された <see cref="T:System.Windows.Forms.FormCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Application.OpenForms%2A>プロパティは、アプリケーションによって所有されているフォームの読み取り専用コレクションを表します。 インデックスの位置またはこのコレクションを検索することができます、<xref:System.Windows.Forms.Control.Name%2A>の<xref:System.Windows.Forms.Form>します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">呼び出し元で定義されているすべてのウィンドウにアクセスするためのアクセス許可が必要、<see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />の値、<see cref="T:System.Security.Permissions.UIPermissionWindow" />列挙体。</permission>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="T:System.Windows.Forms.FormCollection" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public static string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Application.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品名を取得します。</summary>
        <value>製品名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ProductName` 現在のアプリケーションのメイン フォームを含むアセンブリのメタデータから取得されます。 これを設定するには設定を<xref:System.Reflection.AssemblyProductAttribute>アセンブリ マニフェスト内で。 詳細については、「[アセンブリ マニフェスト](~/docs/framework/app-domains/assembly-manifest.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります`textBox1`がフォームに配置されています。  
  
 [!code-cpp[Classic Application.ProductName Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductName Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductName Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductVersion" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyProductAttribute" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public static string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Application.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このアプリケーションに関連付けられている製品のバージョンを取得します。</summary>
        <value>製品のバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、バージョン番号として表示されます*メジャー番号*。 *。マイナー番号*.*ビルド番号*.*プライベート パート番号*します。 アセンブリ マニフェスト内でアセンブリのバージョンを設定して明示的に設定できます。 詳細については、「[アセンブリ マニフェスト](~/docs/framework/app-domains/assembly-manifest.md)」を参照してください。  
  
 <xref:System.Windows.Forms.Application.ProductVersion%2A> メインの実行可能ファイルを含むアセンブリが含まれているが最初に検索、`AssemblyInformationalVersion`属性。 この属性が存在する場合は、両方の使用<xref:System.Windows.Forms.Application.ProductVersion%2A>と<xref:System.Windows.Forms.Application.CommonAppDataPath%2A>します。 両方のプロパティをこの属性が存在しない場合、実行可能ファイルのバージョンが代わりに使用します。  
  
   
  
## Examples  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります`textBox1`がフォームに配置されています。  
  
 [!code-cpp[Classic Application.ProductVersion Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ProductVersion Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ProductVersion Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ProductVersion Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ProductVersion Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.ProductName" />
        <altmember cref="P:System.Windows.Forms.Application.CompanyName" />
        <altmember cref="T:System.Reflection.AssemblyVersionAttribute" />
      </Docs>
    </Member>
    <Member MemberName="RaiseIdle">
      <MemberSignature Language="C#" Value="public static void RaiseIdle (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RaiseIdle(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RaiseIdle(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RaiseIdle (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RaiseIdle(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member RaiseIdle : EventArgs -&gt; unit" Usage="System.Windows.Forms.Application.RaiseIdle e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="T:System.EventArgs" /> イベントに渡す <see cref="E:System.Windows.Forms.Application.Idle" /> オブジェクト。</param>
        <summary>ホストされているシナリオで <see cref="E:System.Windows.Forms.Application.Idle" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ アプリケーションなどの別の環境で Windows フォームをホストする場合に使用されます。 呼び出す必要があります<xref:System.Windows.Forms.Application.RaiseIdle%2A>ホスト アプリケーションがアイドル状態に入ったとき。 これにより、一部の Windows フォーム コントロールおよびユーザーがアプリケーションと対話していないときに、重要なバック グラウンド処理を実行するコンポーネント。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Application.Idle" />
      </Docs>
    </Member>
    <Member MemberName="RegisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void RegisterMessageLoop (System.Windows.Forms.Application.MessageLoopCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterMessageLoop(class System.Windows.Forms.Application/MessageLoopCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterMessageLoop (callback As Application.MessageLoopCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterMessageLoop(System::Windows::Forms::Application::MessageLoopCallback ^ callback);" />
      <MemberSignature Language="F#" Value="static member RegisterMessageLoop : System.Windows.Forms.Application.MessageLoopCallback -&gt; unit" Usage="System.Windows.Forms.Application.RegisterMessageLoop callback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Windows.Forms.Application+MessageLoopCallback" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="callback">ホスト環境が依然としてメッセージを送信しているかどうかを Windows フォームでチェックする必要がある場合に呼び出すメソッド。</param>
        <summary>メッセージ ループがホストされている環境で実行されているかどうかをチェックするためのコールバックを登録します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、アンマネージ アプリケーションなどの別の環境で Windows フォームをホストする場合に使用されます。 ホストの環境では、<xref:System.Windows.Forms.Application.MessageLoop%2A>プロパティは常に Windows フォームでは、メッセージは処理されていない場合は false に返します。 このコールバックを使用して、ホスティング環境がまだメッセージを処理してかどうかを Windows フォームに通知します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Application.MessageLoopCallback" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMessageFilter">
      <MemberSignature Language="C#" Value="public static void RemoveMessageFilter (System.Windows.Forms.IMessageFilter value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMessageFilter(class System.Windows.Forms.IMessageFilter value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.RemoveMessageFilter(System.Windows.Forms.IMessageFilter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMessageFilter (value As IMessageFilter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMessageFilter(System::Windows::Forms::IMessageFilter ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveMessageFilter : System.Windows.Forms.IMessageFilter -&gt; unit" Usage="System.Windows.Forms.Application.RemoveMessageFilter value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.IMessageFilter" />
      </Parameters>
      <Docs>
        <param name="value">アプリケーションから削除する <see cref="T:System.Windows.Forms.IMessageFilter" /> の実装。</param>
        <summary>アプリケーションのメッセージ ポンプからメッセージ フィルターを削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ディスパッチされる前に、Windows メッセージをキャプチャする必要がなくなったときに、メッセージ フィルターを削除できます。  
  
   
  
## Examples  
 メッセージ フィルターを使用するには、実装を提供する必要があります、<xref:System.Windows.Forms.IMessageFilter>インターフェイス。 次のクラスと呼ばれるメッセージ フィルターを作成する`TestMessageFilter`します。 このフィルターは、マウスの左ボタンに関連するすべてのメッセージをブロックします。  
  
 [!code-cpp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/CS/source.cs#1)]
 [!code-vb[Classic Application.RemoveMessageFilter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.RemoveMessageFilter Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.AddMessageFilter(System.Windows.Forms.IMessageFilter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderWithVisualStyles">
      <MemberSignature Language="C#" Value="public static bool RenderWithVisualStyles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool RenderWithVisualStyles" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property RenderWithVisualStyles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool RenderWithVisualStyles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderWithVisualStyles : bool" Usage="System.Windows.Forms.Application.RenderWithVisualStyles" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のアプリケーションが visual スタイルを使用してコントロールを描画しているかどうかを示す値を取得します。</summary>
        <value>アプリケーション ウィンドウのクライアント領域のコントロールで visual スタイルが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 カスタム コントロールを描画する場合は、このプロパティを使用して、外観は、アプリケーションでは、他のコントロールと一貫性のあるように、visual スタイルの有無にコントロールを描画するかどうかを決定します。  
  
 次の表に、4 つの条件を満たす必要がある<xref:System.Windows.Forms.Application.RenderWithVisualStyles%2A>を返す`true`します。  
  
|条件|説明|  
|---------------|-----------------|  
|オペレーティング システムが visual スタイルをサポートしています|この条件を個別に確認するには、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsSupportedByOS%2A> クラスの <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> プロパティを使用します。|  
|ユーザーがオペレーティング システムで visual スタイルを有効に|この条件を個別に確認するには、 <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation.IsEnabledByUser%2A> クラスの <xref:System.Windows.Forms.VisualStyles.VisualStyleInformation> プロパティを使用します。|  
|アプリケーションで視覚スタイルが有効になっています。|アプリケーションで視覚スタイルを有効にするには、 <xref:System.Windows.Forms.Application.EnableVisualStyles> メソッドを呼び出すか、ComCtl32.dll バージョン 6 以降をコントロールの描画に使用することを指定するアプリケーション マニフェストを使用します。|  
|Visual スタイルは、アプリケーション ウィンドウのクライアント領域を描画するために使用されています|この条件を個別に確認するには、 <xref:System.Windows.Forms.Application.VisualStyleState%2A> クラスの <xref:System.Windows.Forms.Application> プロパティを使用し、その値が <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAreaEnabled?displayProperty=nameWithType> または <xref:System.Windows.Forms.VisualStyles.VisualStyleState.ClientAndNonClientAreasEnabled?displayProperty=nameWithType>になっていることを確認します。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Restart">
      <MemberSignature Language="C#" Value="public static void Restart ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Restart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Restart" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Restart ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Restart();" />
      <MemberSignature Language="F#" Value="static member Restart : unit -&gt; unit" Usage="System.Windows.Forms.Application.Restart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>アプリケーションをシャット ダウンし、直後に新しいインストールを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出し元の最も一般的な理由`Restart`からダウンロードしたアプリケーションの新しいバージョンを開始する[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]を使用して、`Update`または`UpdateAsync`メソッド。  
  
 最初に実行されるコンテキストでは、アプリケーションが再起動されます。 アプリケーションのメイン実行可能ファイルを直接指し示す URL を使用して、アプリケーションを起動した場合、同じ URL に再起動されます。 アプリケーションの場合、[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]アプリケーションを使用して、再起動は[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。  
  
 最初に実行されたときに、アプリケーションがコマンド ライン オプションが指定されていた場合<xref:System.Windows.Forms.Application.Restart%2A>と同じオプションを使用してアプリケーションを起動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows フォーム アプリケーションのコードではありません。 このコンテキストではこのメソッドを呼び出すことはできません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">必要があります<see cref="M:System.Security.Permissions.SecurityPermission.IsUnrestricted" />権限。</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run();" />
      <MemberSignature Language="F#" Value="static member Run : unit -&gt; unit" Usage="System.Windows.Forms.Application.Run " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を、フォームなしで開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Win32 ベースまたは Windows フォームで、アプリケーション メッセージ ループは、マウス クリックやキーボード入力などのユーザー イベントを処理するコード内のルーチンです。 すべて実行中の Windows ベースのアプリケーションでは、メイン メッセージ ループと呼ばれる、アクティブなメッセージ ループが必要です。 メイン メッセージ ループが閉じられたときに、アプリケーションを終了します。 Windows フォームでは、このループを閉じたときに、<xref:System.Windows.Forms.Application.Exit%2A>メソッドが呼び出されたとき、または、<xref:System.Windows.Forms.Application.ExitThread%2A>メイン メッセージ ループを実行しているスレッドでメソッドが呼び出されます。  
  
 ほとんどの Windows フォーム開発者は、このバージョンのメソッドを使用する必要はありません。 使用する必要があります、<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.Form%29>メイン フォームが閉じられたときに、アプリケーションが終了するように、メイン フォーム アプリケーションを起動するオーバー ロードします。 その他のすべての状況では、使用、<xref:System.Windows.Forms.Application.Run%28System.Windows.Forms.ApplicationContext%29>の指定をサポートする、オーバー ロード、<xref:System.Windows.Forms.ApplicationContext>オブジェクト、アプリケーションの有効期間の制御を強化します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既にこのスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.ApplicationContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.ApplicationContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.ApplicationContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (context As ApplicationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::ApplicationContext ^ context);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.ApplicationContext -&gt; unit" Usage="System.Windows.Forms.Application.Run context" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Windows.Forms.ApplicationContext" />
      </Parameters>
      <Docs>
        <param name="context">アプリケーションが実行される <see cref="T:System.Windows.Forms.ApplicationContext" />。</param>
        <summary><see cref="T:System.Windows.Forms.ApplicationContext" /> を使用して、現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メッセージ ループの実行まで<xref:System.Windows.Forms.Application.Exit%2A>または<xref:System.Windows.Forms.Application.ExitThread%2A>と呼びますまたは<xref:System.Windows.Forms.Application.ThreadExit>コンテキスト オブジェクトでイベントが発生します。  
  
   
  
## Examples  
 例では、2 つの形式を表示し、両方のフォームが閉じられたときにアプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例では、使用、 <xref:System.Windows.Forms.ApplicationContext>、と共に、`Application.Run(context)`メソッドは、アプリケーションの起動時に、複数のフォームを表示します。  
  
 クラスは、`MyApplicationContext`継承<xref:System.Windows.Forms.ApplicationContext>し、各フォームが閉じられるし、はどちらも、ときに、現在のスレッドを終了するときは常に追跡します。 クラスは、ユーザーの各フォームの位置を格納します。 フォームの位置データがという名前のファイルに格納されている`Appdata.txt`によって決定の場所に作成される<xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。 `Main`メソッド呼び出し`Application.Run(context)`に基づいてアプリケーションを開始する、<xref:System.Windows.Forms.ApplicationContext>します。  
  
 コードを`AppForm1`と`AppForm2`簡略にするためのフォームが示されていません。 参照してください、<xref:System.Windows.Forms.ApplicationContext>コード全体のクラスの概要。  
  
 [!code-cpp[Application#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#2)]
 [!code-csharp[Application#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#2)]
 [!code-vb[Application#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既にこのスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.Windows.Forms.Form mainForm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.Windows.Forms.Form mainForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.Run(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (mainForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::Windows::Forms::Form ^ mainForm);" />
      <MemberSignature Language="F#" Value="static member Run : System.Windows.Forms.Form -&gt; unit" Usage="System.Windows.Forms.Application.Run mainForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mainForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="mainForm">表示するフォームを表す <see cref="T:System.Windows.Forms.Form" />。</param>
        <summary>現在のスレッドで標準のアプリケーション メッセージ ループの実行を開始し、指定したフォームを表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、アプリケーションの main 関数では、このメソッドを呼び出すし、アプリケーションのメイン ウィンドウを渡します。  
  
 このメソッドは、イベント ハンドラーを追加、`mainForm`のパラメーター、<xref:System.Windows.Forms.Form.Closed>イベント。 イベント ハンドラー呼び出し<xref:System.Windows.Forms.Application.ExitThread%2A>アプリケーションをクリーンアップします。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Dispose%2A>のメソッド、<xref:System.Windows.Forms.Form>クラスがこのメソッドの戻り値の前に呼び出されます。  
  
   
  
## Examples  
 次のコード例は、フォームのリスト ボックス内の番号を一覧表示します。 クリックするたびに`button1`アプリケーションの一覧に別の番号を追加します。  
  
 `Main`メソッド呼び出し<xref:System.Windows.Forms.Application.Run%2A>フォームを作成すると、アプリケーションを起動する`listBox1`、および`button1`します。 ユーザーがクリックすると`button1`、`button1_Click`メソッドは、リスト ボックスには、1 ~ 3 の番号を追加し、表示、<xref:System.Windows.Forms.MessageBox>します。 ユーザーがクリックした場合**いいえ**上、 <xref:System.Windows.Forms.MessageBox>、`button1_Click`メソッドの一覧に別の番号を追加します。 ユーザーがクリックした場合 **[はい]**、アプリケーション呼び出し<xref:System.Windows.Forms.Application.Exit%2A>をキューに残りのすべてのメッセージを処理し、終了します。  
  
 この例では、する必要があります`listBox1`と`button1`作成して、フォーム上に配置します。  
  
 [!code-cpp[Classic Application.Exit Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.Exit Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.Exit Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.Exit Example/CS/source.cs#1)]
 [!code-vb[Classic Application.Exit Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.Exit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メイン メッセージ ループが既に現在のスレッドで実行中です。</exception>
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
        <altmember cref="M:System.Windows.Forms.Application.DoEvents" />
      </Docs>
    </Member>
    <Member MemberName="SafeTopLevelCaptionFormat">
      <MemberSignature Language="C#" Value="public static string SafeTopLevelCaptionFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string SafeTopLevelCaptionFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property SafeTopLevelCaptionFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SafeTopLevelCaptionFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SafeTopLevelCaptionFormat : string with get, set" Usage="System.Windows.Forms.Application.SafeTopLevelCaptionFormat" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>警告見出しと共に表示された場合にトップレベル ウィンドウのキャプションに適用する書式指定文字列を取得または設定します。</summary>
        <value>トップレベル ウィンドウのキャプションに適用する書式指定文字列。</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティを設定するすべてのウィンドウ。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCompatibleTextRenderingDefault">
      <MemberSignature Language="C#" Value="public static void SetCompatibleTextRenderingDefault (bool defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCompatibleTextRenderingDefault(bool defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCompatibleTextRenderingDefault (defaultValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCompatibleTextRenderingDefault(bool defaultValue);" />
      <MemberSignature Language="F#" Value="static member SetCompatibleTextRenderingDefault : bool -&gt; unit" Usage="System.Windows.Forms.Application.SetCompatibleTextRenderingDefault defaultValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="defaultValue">新しいコントロールに適用する既定値。 <see langword="true" /> の場合、<c>UseCompatibleTextRendering</c> をサポートする新しいコントロールは、テキスト レンダリングに [!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)] ベースの <see cref="T:System.Drawing.Graphics" /> クラスを使用します。<see langword="false" /> の場合、新しいコントロールは [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] ベースの <see cref="T:System.Windows.Forms.TextRenderer" /> クラスを使用します。</param>
        <summary>特定のコントロールで定義された <c>UseCompatibleTextRendering</c> プロパティにアプリケーション全体で有効な既定値を設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 特定の Windows フォーム コントロールは、いずれかを使用して、テキストを描画できます、<xref:System.Windows.Forms.TextRenderer>クラスに基づく、[!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]グラフィックス ライブラリ、または<xref:System.Drawing.Graphics>クラスに基づいています、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]グラフィックス ライブラリ。 この変更が行われた、[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]パフォーマンスとローカリゼーションの問題が原因[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]します。 使用<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>の既定値を設定する、`UseCompatibleTextRendering`サポートしているコントロールのプロパティ。  
  
 `UseCompatibleTextRendering`プロパティは、そのレンダリング テキストを使用して Windows フォーム コントロールの間のビジュアルの互換性を提供するためのもの、<xref:System.Windows.Forms.TextRenderer>クラスと[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]と[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]を使用してカスタムのテキストレンダリングを実行するアプリケーション<xref:System.Drawing.Graphics>クラス。 ほとんどの場合、アプリケーションはからアップグレードされていない場合に[!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)]または[!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)]、しておくことをお勧め`UseCompatibleTextRendering`の既定値に設定`false`します。  
  
 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)]ベース<xref:System.Windows.Forms.TextRenderer>クラスで導入された、[!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)]パフォーマンスを向上させることをテキストの外観を改善、および国際対応フォントのサポートを改善します。 以前のバージョンので、 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]、[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]ベース<xref:System.Drawing.Graphics>クラスを使用してすべてのテキスト レンダリングを実行します。 [!INCLUDE[ndptecgdi](~/includes/ndptecgdi-md.md)] 文字の空白文字と単語から異なる方法での折り返しを計算[!INCLUDE[ndptecgdiplus](~/includes/ndptecgdiplus-md.md)]します。 使用する Windows フォーム アプリケーションで、<xref:System.Drawing.Graphics>クラスのテキストを表示するために、これが原因で使用するコントロールのテキスト<xref:System.Windows.Forms.TextRenderer>に、アプリケーションの他のテキストは異なります。 この非互換性を解決するには、設定することができます、`UseCompatibleTextRendering`プロパティを`true`します。 設定する`UseCompatibleTextRendering`に`true`アプリケーションでサポートされているすべてのコントロールを呼び出し、<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>メソッドのパラメーターを持つ`true`します。  
  
 Internet Explorer などの別のアプリケーションで、Windows フォームのコードがホストされている場合、このメソッドを呼び出すことはありません必要があります。 スタンドアロンの Windows フォーム アプリケーションでは、このメソッドを呼び出すだけです。  
  
   
  
## Examples  
  
> [!IMPORTANT]
>  既定値を設定する`UseCompatibleTextRendering`で[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]後を参照してください。 または<xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering%2A?displayProperty=nameWithType>します。  
  
 [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]以降への呼び出し<xref:System.Windows.Forms.Application.SetCompatibleTextRenderingDefault%2A>Program.cs ファイルが自動的に生成します。 既定のテキスト レンダリングを変更するには、生成されたコードを変更します。  
  
```scr  
static class Program  
{  
    /// <summary>  
    /// The main entry point for the application.  
    /// </summary>  
    [STAThread]  
    static void Main()  
    {  
        Application.EnableVisualStyles();  
        Application.SetCompatibleTextRenderingDefault(false);  
        Application.Run(new Form1());  
    }  
}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">このメソッドは、Windows フォーム アプリケーションによって最初のウィンドウが作成される前にしか呼び出すことができません。</exception>
        <altmember cref="P:System.Windows.Forms.ButtonBase.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.CheckedListBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.GroupBox.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.Label.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.LinkLabel.UseCompatibleTextRendering" />
        <altmember cref="P:System.Windows.Forms.PropertyGrid.UseCompatibleTextRendering" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UseCompatibleTextRendering" />
        <altmember cref="M:System.Drawing.Text.PrivateFontCollection.AddMemoryFont(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetSuspendState">
      <MemberSignature Language="C#" Value="public static bool SetSuspendState (System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetSuspendState(valuetype System.Windows.Forms.PowerState state, bool force, bool disableWakeEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetSuspendState(System.Windows.Forms.PowerState,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetSuspendState (state As PowerState, force As Boolean, disableWakeEvent As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetSuspendState(System::Windows::Forms::PowerState state, bool force, bool disableWakeEvent);" />
      <MemberSignature Language="F#" Value="static member SetSuspendState : System.Windows.Forms.PowerState * bool * bool -&gt; bool" Usage="System.Windows.Forms.Application.SetSuspendState (state, force, disableWakeEvent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Windows.Forms.PowerState" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="force" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="disableWakeEvent" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="state">移行後の電源の動作モードを示す <see cref="T:System.Windows.Forms.PowerState" />。</param>
        <param name="force">すぐに、強制的に中断モードにする場合は <see langword="true" />。Windows からすべてのアプリケーションに中断の要求が送られるようにする場合は <see langword="false" />。</param>
        <param name="disableWakeEvent">システムの電源ステータスの復元が wake イベントでアクティブにならないようにするには <see langword="true" />。システムの電源ステータスの復元が wake イベントでアクティブになるようにするには <see langword="false" />。</param>
        <summary>システムを中断または休止状態にするか、システムが中断または休止状態になるよう要求します。</summary>
        <returns>システムが中断中の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 20 秒以内、アプリケーションが中断の要求に応答しない場合、Windows は、応答のない状態であると、アプリケーションするスリープ状態にするか、終了を決定します。 後のアプリケーションは、中断の要求に応答するただし、かかるリソースをクリーンアップして、アクティブなプロセスをシャット ダウンする必要がある任意の時間。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.PowerState" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetUnhandledExceptionMode">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の発生する例外のイベント ハンドラーを設定します。 設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションによって処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと<xref:System.AppDomain.UnhandledException>非 UI スレッドの例外を処理するイベントです。 <xref:System.AppDomain.UnhandledException>アプリケーションを防ぐことはできませんの終了、例では、単にエラーがログに終了する前に、アプリケーション イベント ログ。  
  
 この例では、2 つを定義した<xref:System.Windows.Forms.Button>コントロール、`button1`と`button2`の<xref:System.Windows.Forms.Form>クラス。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <summary>未処理の例外への対応方法をアプリケーションに指示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべての Windows フォームによってスローされた例外をキャッチするがよくあります。 このメソッドを使用して、Windows フォーム コンポーネントによってスローされたすべての未処理の例外をキャッチして操作を続行するかどうか、または、それらをユーザーに公開して実行を停止するかどうか、アプリケーションに指示できます。  
  
 呼び出す<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>を使用して、アプリケーションのメイン フォームのインスタンスを作成する前に、<xref:System.Windows.Forms.Application.Run%2A>メソッド。  
  
 作成していないスレッドで発生する例外をキャッチし、使用して、Windows フォームによって所有されている、<xref:System.AppDomain.UnhandledException>イベント ハンドラー。  
  
   
  
## Examples  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の発生する例外のイベント ハンドラーを設定します。 設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションによって処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと<xref:System.AppDomain.UnhandledException>非 UI スレッドの例外を処理するイベントです。 <xref:System.AppDomain.UnhandledException>アプリケーションを防ぐことはできませんの終了、例では、単にエラーがログに終了する前に、アプリケーション イベント ログ。  
  
 この例では、2 つを定義した<xref:System.Windows.Forms.Button>コントロール、`button1`と`button2`の<xref:System.Windows.Forms.Form>クラス。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後に、例外モードを設定することはできません。</exception>
        <altmember cref="T:System.Windows.Forms.UnhandledExceptionMode" />
      </Docs>
    </Member>
    <Member MemberName="SetUnhandledExceptionMode">
      <MemberSignature Language="C#" Value="public static void SetUnhandledExceptionMode (System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetUnhandledExceptionMode(valuetype System.Windows.Forms.UnhandledExceptionMode mode, bool threadScope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.SetUnhandledExceptionMode(System.Windows.Forms.UnhandledExceptionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetUnhandledExceptionMode (mode As UnhandledExceptionMode, threadScope As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetUnhandledExceptionMode(System::Windows::Forms::UnhandledExceptionMode mode, bool threadScope);" />
      <MemberSignature Language="F#" Value="static member SetUnhandledExceptionMode : System.Windows.Forms.UnhandledExceptionMode * bool -&gt; unit" Usage="System.Windows.Forms.Application.SetUnhandledExceptionMode (mode, threadScope)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.UnhandledExceptionMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="threadScope" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode">キャッチされない例外がスローされた場合に必要なアプリケーションの動作方法を説明する <see cref="T:System.Windows.Forms.UnhandledExceptionMode" /> 値。</param>
        <param name="threadScope">スレッド例外モードを設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>未処理の例外に応答する方法をアプリケーションに指示し、オプションでスレッド固有の動作を適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべての Windows フォームによってスローされた例外をキャッチするがよくあります。 このメソッドを使用して、Windows フォーム コンポーネントによってスローされたすべての未処理の例外をキャッチして操作を続行するかどうか、または、それらをユーザーに公開して実行を停止するかどうか、アプリケーションに指示できます。  
  
 呼び出す<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>を使用して、アプリケーションのメイン フォームのインスタンスを作成する前に、<xref:System.Windows.Forms.Application.Run%2A>メソッド。  
  
 ときに`threadScope`は`true`、スレッド例外モードを設定します。 スレッド例外モードが場合、アプリケーション例外モードをオーバーライド`mode`に設定されていない<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>します。  
  
 ときに`threadScope`は`false`、アプリケーション例外モードを設定します。 含まれるすべてのスレッドのアプリケーション例外モードが使用される、<xref:System.Windows.Forms.UnhandledExceptionMode.Automatic>モード。 アプリケーション例外モードを設定しても、現在のスレッドの設定には影響しません。  
  
 作成していないスレッドで発生する例外をキャッチし、使用して、Windows フォームによって所有されている、<xref:System.AppDomain.UnhandledException>イベント ハンドラー。  
  
   
  
## Examples  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の発生する例外のイベント ハンドラーを設定します。 設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションによって処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと<xref:System.AppDomain.UnhandledException>非 UI スレッドの例外を処理するイベントです。 <xref:System.AppDomain.UnhandledException>アプリケーションを防ぐことはできませんの終了、例では、単にエラーがログに終了する前に、アプリケーション イベント ログ。  
  
 この例では、2 つを定義した<xref:System.Windows.Forms.Button>コントロール、`button1`と`button2`の<xref:System.Windows.Forms.Form>クラス。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">アプリケーションが最初のウィンドウを作成した後に、例外モードを設定することはできません。</exception>
      </Docs>
    </Member>
    <Member MemberName="StartupPath">
      <MemberSignature Language="C#" Value="public static string StartupPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StartupPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.StartupPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StartupPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StartupPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StartupPath : string" Usage="System.Windows.Forms.Application.StartupPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションを開始した実行可能ファイルの、ファイル名を含まないパスを取得します。</summary>
        <value>アプリケーションを開始した実行可能ファイルのパス。  
  
このパスは、Windows フォーム アプリケーションが [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] を使用して配置されているかどうかによって異なります。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] アプリケーションは、C:\Documents and Settings でユーザーごとのアプリケーション キャッシュに格納されている\\*username*ディレクトリ。 詳細については、次を参照してください。[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、このプロパティを取得し、テキスト ボックスにその値を表示します。 この例では、する必要があります`textBox1`がフォームに配置されています。  
  
 [!code-cpp[Classic Application.StartupPath Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.StartupPath Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.StartupPath Example/CS/source.cs#1)]
 [!code-vb[Classic Application.StartupPath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.StartupPath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">パスを取得します。 関連付けられた列挙体。 <see cref="T:System.Security.Permissions.FileIOPermissionAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadException">
      <MemberSignature Language="C#" Value="public static event System.Threading.ThreadExceptionEventHandler ThreadException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Threading.ThreadExceptionEventHandler ThreadException" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadException As ThreadExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event System::Threading::ThreadExceptionEventHandler ^ ThreadException;" />
      <MemberSignature Language="F#" Value="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " Usage="member this.ThreadException : System.Threading.ThreadExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>トラップされないスレッドの例外がスローされると、発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、Windows フォーム スレッドで発生する例外を未処理のハンドルのそれ以外の場合に、Windows フォーム アプリケーションを使用します。 イベント ハンドラーをアタッチ、<xref:System.Windows.Forms.Application.ThreadException>不明な状態でアプリケーションにそのままにこれらの例外を処理するイベントです。 可能であれば、構造化例外処理ブロックで例外を処理する必要があります。  
  
 このコールバックは、Windows フォーム スレッドのハンドルされない例外を設定して使用するかどうかを変更する<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>します。 作成していないスレッドで発生する例外をキャッチし、使用して、Windows フォームによって所有されている、<xref:System.AppDomain.UnhandledException>イベント ハンドラー。  
  
> [!NOTE]
>  呼び出す前にこのイベントのアクティブ化が欠落しないことを保証するハンドラーをアタッチする必要があります<xref:System.Windows.Application.Run%2A?displayProperty=nameWithType>します。  
  
> [!CAUTION]
>  静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークが発生するとき、イベント ハンドラーをデタッチする必要があります。  
  
   
  
## Examples  
 次のコード例では、Windows フォーム スレッドと他のスレッドで発生する例外の発生する例外のイベント ハンドラーを設定します。 設定<xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A>すべての例外は、アプリケーションのユーザー構成ファイルの設定に関係なく、アプリケーションによって処理されるようにします。 使用して、 <xref:System.Windows.Forms.Application.ThreadException> UI スレッドの例外を処理するイベントと<xref:System.AppDomain.UnhandledException>非 UI スレッドの例外を処理するイベントです。 <xref:System.AppDomain.UnhandledException>アプリケーションを防ぐことはできませんの終了、例では、単にエラーがログに終了する前に、アプリケーション イベント ログ。  
  
 この例では、2 つを定義した<xref:System.Windows.Forms.Button>コントロール、`button1`と`button2`の<xref:System.Windows.Forms.Form>クラス。  
  
 [!code-cpp[Classic Application.ThreadException Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Application.ThreadException Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Application.ThreadException Example/CS/source.cs#1)]
 [!code-vb[Classic Application.ThreadException Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Application.ThreadException Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">このイベントにハンドラーを追加するときに、アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ThreadExit">
      <MemberSignature Language="C#" Value="public static event EventHandler ThreadExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ThreadExit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Application.ThreadExit" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event ThreadExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler ^ ThreadExit;" />
      <MemberSignature Language="F#" Value="member this.ThreadExit : EventHandler " Usage="member this.ThreadExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スレッドをシャットダウンしようとすると発生します。 アプリケーションのメイン スレッドをシャットダウンしようとするとこのイベントが発生し、続いて <see cref="E:System.Windows.Forms.Application.ApplicationExit" /> イベントが発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベント ハンドラーをアタッチする必要があります、<xref:System.Windows.Forms.Application.ThreadExit>を実行するイベントがハンドルされていない、必須のタスクを実行しているスレッドを停止する前にします。 このスレッド、またはガベージ コレクターがクリアされなかったオブジェクトの破棄によって開かれたファイルを閉じます。  
  
> [!CAUTION]
>  静的イベントであるため、アプリケーションが破棄されると、またはメモリ リークが発生するとき、イベント ハンドラーをデタッチする必要があります。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Application.ThreadExit>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行する Windows フォームに貼り付けることと、イベント ハンドラーに関連付けられていることを確認、<xref:System.Windows.Forms.Application.ThreadExit>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#6)]
 [!code-vb[System.Windows.Forms.EventExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Application.ExitThread" />
      </Docs>
    </Member>
    <Member MemberName="UnregisterMessageLoop">
      <MemberSignature Language="C#" Value="public static void UnregisterMessageLoop ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void UnregisterMessageLoop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Application.UnregisterMessageLoop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub UnregisterMessageLoop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void UnregisterMessageLoop();" />
      <MemberSignature Language="F#" Value="static member UnregisterMessageLoop : unit -&gt; unit" Usage="System.Windows.Forms.Application.UnregisterMessageLoop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Application.RegisterMessageLoop(System.Windows.Forms.Application.MessageLoopCallback)" /> によって行われたメッセージ ループ コールバックを登録解除します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UserAppDataPath">
      <MemberSignature Language="C#" Value="public static string UserAppDataPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserAppDataPath" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataPath" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserAppDataPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataPath : string" Usage="System.Windows.Forms.Application.UserAppDataPath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのパスを取得します。</summary>
        <value>ユーザーのアプリケーション データのパス。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 パスが存在しない場合は、次の形式で 1 つ作成されます。  
  
 *基本パス*\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>  
  
 このパスに格納されたデータは、ローミングが有効になっているユーザー プロファイルの一部です。 ローミング ユーザーは、ネットワーク内の 1 つ以上のコンピューターで動作します。 ローミング ユーザーのユーザー プロファイルは、ネットワーク上のサーバーに保持され、ユーザーがログオンしたときに、システムに読み込まれます。 、ローミングと見なすユーザー プロファイルのオペレーティング システムは、ローミング プロファイルをサポートする必要があり、それを有効にする必要があります。  
  
 通常の基本パスは C:\Documents and Settings\\*username*\Application Data です。 このパスになります、ただしを使用して、Windows フォーム アプリケーションがデプロイされている場合[!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)]します。 [!INCLUDE[ndptecclick](~/includes/ndptecclick-md.md)] その他のすべてのアプリケーションから分離された独自のアプリケーション データ ディレクトリを作成します。 詳細については、次を参照してください。[ローカルへのアクセスとリモート データには、ClickOnce アプリケーション](https://msdn.microsoft.com/library/be5cbe12-6cb6-49c9-aa59-a1624e1eef3d)します。  
  
   
  
## Examples  
 次のコード例では、2 つのフォームを表示し、両方のフォームが閉じられたときに、アプリケーションを終了します。 アプリケーションを起動し、終了、各フォームの位置が記憶されます。 この例では、<xref:System.Windows.Forms.Application.UserAppDataPath%2A>ユーザーのアプリケーション データを格納するプロパティ。  
  
 クラスは、`MyApplicationContext`継承<xref:System.Windows.Forms.ApplicationContext>し、各フォームが閉じられるし、はどちらも、ときに、現在のスレッドを終了するときは常に追跡します。 クラスは、ユーザーの各フォームの位置を格納します。 フォームの位置データがという名前のファイルに格納されている`Appdata.txt`によって決定の場所に作成される<xref:System.Windows.Forms.Application.UserAppDataPath%2A>します。 `Main`メソッド呼び出し`Application.Run(context)`に基づいてアプリケーションを開始する、<xref:System.Windows.Forms.ApplicationContext>します。  
  
 このコードは、抜粋の例に示すように、<xref:System.Windows.Forms.ApplicationContext>クラスの概要。 いくつかのコードは、簡潔さを優先するためには表示されません。 参照してください<xref:System.Windows.Forms.ApplicationContext>全体のコードの一覧。  
  
 [!code-cpp[Application#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Application/CPP/source.cpp#5)]
 [!code-csharp[Application#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Application/CS/source.cs#5)]
 [!code-vb[Application#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Application/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      </Docs>
    </Member>
    <Member MemberName="UserAppDataRegistry">
      <MemberSignature Language="C#" Value="public static Microsoft.Win32.RegistryKey UserAppDataRegistry { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class Microsoft.Win32.RegistryKey UserAppDataRegistry" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserAppDataRegistry As RegistryKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Microsoft::Win32::RegistryKey ^ UserAppDataRegistry { Microsoft::Win32::RegistryKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserAppDataRegistry : Microsoft.Win32.RegistryKey" Usage="System.Windows.Forms.Application.UserAppDataRegistry" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.RegistryKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーのアプリケーション データのレジストリ キーを取得します。</summary>
        <value>ユーザー固有のアプリケーション データのレジストリ キーを表す <see cref="T:Microsoft.Win32.RegistryKey" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーが存在しない場合は、次の形式で作成されます。  
  
 CurrentUser\Software\\<xref:System.Windows.Forms.Application.CompanyName%2A>\\<xref:System.Windows.Forms.Application.ProductName%2A>\\<xref:System.Windows.Forms.Application.ProductVersion%2A>   
  
 このキーに格納されたデータは、ローミングが有効になっているユーザー プロファイルの一部です。 ローミング ユーザーは、ネットワーク内の 1 つ以上のコンピューターで動作します。 ローミング ユーザーのユーザー プロファイルは、ネットワーク上のサーバーに保持され、ユーザーがログオンしたときに、システムに読み込まれます。 、ローミングと見なすユーザー プロファイルのオペレーティング システムは、ローミング プロファイルをサポートする必要があり、それを有効にする必要があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public static bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Application.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションの開いているフォームすべてに待機カーソルを使用するかどうかについて、取得または設定します。</summary>
        <value>すべての開いているフォームで待機カーソルが使用される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定すると`true`、<xref:System.Windows.Forms.Control.UseWaitCursor%2A>アプリケーション内のすべての開いているフォームのプロパティに設定する`true`します。 この呼び出しは、すべてのフォームにこのプロパティが設定されるまでは返されません。 実行時間の長い操作、およびすべてのアプリケーション形式で、操作がまだ処理されていることを指定するした場合は、このプロパティを使用します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualStyleState">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.VisualStyles.VisualStyleState VisualStyleState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Application.VisualStyleState" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property VisualStyleState As VisualStyleState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::VisualStyles::VisualStyleState VisualStyleState { System::Windows::Forms::VisualStyles::VisualStyleState get(); void set(System::Windows::Forms::VisualStyles::VisualStyleState value); };" />
      <MemberSignature Language="F#" Value="member this.VisualStyleState : System.Windows.Forms.VisualStyles.VisualStyleState with get, set" Usage="System.Windows.Forms.Application.VisualStyleState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.VisualStyles.VisualStyleState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーション ウィンドウに visual スタイルをどのように適用するかを指定する値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.VisualStyles.VisualStyleState" /> 値のビットごとの組み合わせ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、<xref:System.Windows.Forms.Application.VisualStyleState%2A>プロパティは、クライアント領域やアプリケーション ウィンドウの非クライアント領域で visual スタイルが有効かどうかを決定します。 メイン フォームのコンス トラクター内で一般的には、このプロパティを設定する必要がありますまたは<xref:System.Windows.Forms.Form.Load>イベント ハンドラー。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Application.VisualStyleState%2A>プロパティのいずれかを<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>内の値、<xref:System.Windows.Forms.Control.Click>のイベント ハンドラーを<xref:System.Windows.Forms.Button>コントロール。 このコード例が示されている例の一部、<xref:System.Windows.Forms.VisualStyles.VisualStyleState?displayProperty=nameWithType>列挙体。  
  
 [!code-cpp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/cpp/visualstylestate.cpp#10)]
 [!code-csharp[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/CS/visualstylestate.cs#10)]
 [!code-vb[System.Windows.Forms.VisualStyles.VisualStyleState#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.VisualStyles.VisualStyleState/VB/visualstylestate.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>