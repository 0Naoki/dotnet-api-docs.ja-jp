<Type Name="Control" FullName="System.Windows.Forms.Control">
  <Metadata><Meta Name="ms.openlocfilehash" Value="452c0fac5d3e301514559f624e7be5a559acf13b" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57957221" /></Metadata><TypeSignature Language="C#" Value="public class Control : System.ComponentModel.Component, IDisposable, System.ComponentModel.ISynchronizeInvoke, System.Windows.Forms.IBindableComponent, System.Windows.Forms.IDropTarget, System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Control extends System.ComponentModel.Component implements class System.ComponentModel.IComponent, class System.ComponentModel.ISynchronizeInvoke, class System.IDisposable, class System.Windows.Forms.IBindableComponent, class System.Windows.Forms.IDropTarget, class System.Windows.Forms.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Control" />
  <TypeSignature Language="VB.NET" Value="Public Class Control&#xA;Inherits Component&#xA;Implements IBindableComponent, IDisposable, IDropTarget, ISynchronizeInvoke, IWin32Window" />
  <TypeSignature Language="C++ CLI" Value="public ref class Control : System::ComponentModel::Component, IDisposable, System::ComponentModel::ISynchronizeInvoke, System::Windows::Forms::IBindableComponent, System::Windows::Forms::IDropTarget, System::Windows::Forms::IWin32Window" />
  <TypeSignature Language="F#" Value="type Control = class&#xA;    inherit Component&#xA;    interface IDropTarget&#xA;    interface ISynchronizeInvoke&#xA;    interface IWin32Window&#xA;    interface IComponent&#xA;    interface IDisposable&#xA;    interface IBindableComponent" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ISynchronizeInvoke</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IBindableComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IDropTarget</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Forms.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("System.Windows.Forms.Design.ControlCodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.ControlDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>視覚的に表現されるコンポーネントであるコントロールの基本クラスを定義します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 継承するコントロール クラスを作成、 <xref:System.Windows.Forms.UserControl>、<xref:System.Windows.Forms.Control>クラス、またはその他の Windows フォームからコントロールを提供します。 カスタム コントロールを作成する方法の詳細については、次を参照してください。[カスタム Windows フォーム コントロールの開発、.NET Framework と共に](~/docs/framework/winforms/controls/developing-custom-windows-forms-controls.md)します。  
  
 <xref:System.Windows.Forms.Control>クラスは、ユーザーに情報を表示するクラスに必要な非常に基本的な機能を実装します。 キーボードとポインティング デバイスによるユーザー入力を処理します。 メッセージのルーティングとセキュリティを処理します。 描画を実装しませんが、(その位置とサイズ) のコントロールの境界を定義します。 ウィンドウ ハンドルを提供します (`hWnd`)。  
  
 Windows フォーム コントロールは、子コントロールは、周囲の環境のように表示できるように、アンビエント プロパティを使用します。 *アンビエント プロパティ*いない場合、そのコントロールのプロパティは、設定、親コントロールから取得されます。 コントロールがない場合、 <xref:System.Windows.Forms.Control.Parent%2A>、およびプロパティが設定されていない、アンビエント プロパティの値を決定しようとしているコントロール、<xref:System.Windows.Forms.Control.Site%2A>プロパティ。 場合は、サイトがアンビエント プロパティをサポートしていない場合、コントロールは配置されませんが、またはプロパティに設定されていない場合、<xref:System.Windows.Forms.AmbientProperties>コントロールが既定値を使用します。 通常、コントロールの特性を表しますアンビエント プロパティなど<xref:System.Windows.Forms.Control.BackColor%2A>は子コントロールに伝達します。 たとえば、<xref:System.Windows.Forms.Button>が、同じ<xref:System.Windows.Forms.Control.BackColor%2A>親として<xref:System.Windows.Forms.Form>既定では。 によって提供されるアンビエント プロパティ、<xref:System.Windows.Forms.Control>クラスが含まれます: <xref:System.Windows.Forms.Control.Cursor%2A>、 <xref:System.Windows.Forms.Control.Font%2A>、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.ForeColor%2A>、および<xref:System.Windows.Forms.Control.RightToLeft%2A>します。  
  
> [!NOTE]
>  Windows フォーム アプリケーションを visual スタイルをサポートするために、必ず設定して、<xref:System.Windows.Forms.FlatStyle>プロパティを`System`され、実行可能ファイルを含むマニフェストが含まれます。 マニフェストは、アプリケーション実行可能ファイル内のリソースとして、または実行可能ファイルと同じディレクトリ内にある別のファイルとして含まれている XML ファイルです。 マニフェストの例では、例を参照してください、<xref:System.Windows.Forms.FlatStyle>列挙体。 詳細については、visual スタイルを使用して、次を参照してください。[視覚スタイル](https://msdn.microsoft.com/library/windows/desktop/bb773187.aspx)します。  
  
 Windows フォームが組み込まれており、ユーザー補助のサポートと、音声入力ユーティリティは、画面、キーボード、画面拡大ツールとレビュー担当者のユーティリティなどのユーザー補助クライアント アプリケーションを使用することができる、アプリケーションに関する情報を提供します代替入力デバイス、およびキーボード拡張ユーティリティ。 ユーザー補助クライアント アプリケーションに追加の情報を提供することがあります。 この追加情報を提供するための 2 つの方法はあります。 設定することができます、 <xref:System.Windows.Forms.Control.AccessibleName%2A>、 <xref:System.Windows.Forms.Control.AccessibleDescription%2A>、 <xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>、および<xref:System.Windows.Forms.Control.AccessibleRole%2A>プロパティの値は、ユーザー補助クライアント アプリケーションに報告されます。 このメソッドは通常、既存のコントロールの制限付きのユーザー補助情報の提供に使用します。 派生する独自のクラスを記述する代わりに、<xref:System.Windows.Forms.AccessibleObject>または<xref:System.Windows.Forms.Control.ControlAccessibleObject>のために必要な限り多くのユーザー補助情報を提供するクラス。  
  
> [!NOTE]
>  優れたパフォーマンスを維持するには、コンス トラクターで、コントロールのサイズを設定しないでください。 推奨される方法は、オーバーライドする、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ。  
  
> [!NOTE]
>  データ バインドを追加すれば、<xref:System.Windows.Forms.Control>コンス トラクター内。 そうと、コード生成でエラーが発生、望ましくない動作が発生することができます。  
  
 ほとんどのコントロールの<xref:System.Windows.Forms>名前空間をベースとして開発に基になる Windows のコモン コントロールを利用します。 Windows コモン コントロールの詳細については、次を参照してください。[全般コントロール リファレンス](https://msdn.microsoft.com/library/windows/desktop/bb775497.aspx)します。  
  
 別のプロセスからの Windows フォーム コントロールを識別するために、標準を使用して、`SendMessage`標準への呼び出し。 標準は、言語と Windows の階層に依存しません。 詳細については、トピックでは、"推奨ソリューションの Windows Forms"を参照してください。[を自動化する Windows フォーム](https://msdn.microsoft.com/library/ms996405.aspx)します。  
  
 使用して、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティを複数のスレッドからコントロールへのアクセスを同期します。 マルチ スレッドの Windows フォーム コントロールの詳細については、次を参照してください。[方法。Windows フォーム コントロールのスレッド セーフな呼び出しを行う](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)  
  
 ]]></format>
    </remarks>
    <threadsafe>次のメンバーはスレッド セーフであるだけ: <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />、 <see cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />、 <see cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />、 <see cref="P:System.Windows.Forms.Control.InvokeRequired" />、および<see cref="M:System.Windows.Forms.Control.CreateGraphics" />コントロールのハンドルが既に作成されている場合。 呼び出す<see cref="M:System.Windows.Forms.Control.CreateGraphics" />コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。</threadsafe>
    <altmember cref="T:System.Windows.Forms.Form" />
    <altmember cref="T:System.Windows.Forms.ScrollableControl" />
    <altmember cref="T:System.Windows.Forms.ContainerControl" />
    <altmember cref="T:System.ComponentModel.Component" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを既定の設定で初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用されるすべてのコントロールの基本クラスです。 クラスのインスタンスを作成するこのクラスが通常使用しないため、このコンス トラクターは通常直接呼び出されることがなくは、代わりに派生クラスによって呼び出されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control text" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <summary>テキストを指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用されるすべてのコントロールの基本クラスです。 クラスのインスタンスを作成するこのクラスが通常使用しないため、このコンス トラクターは通常直接呼び出されることがなくは、代わりに派生クラスによって呼び出されます。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="parent">コントロールの親である <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <summary>テキストを指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを子コントロールとして初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用されるすべてのコントロールの基本クラスです。 クラスのインスタンスを作成するこのクラスが通常使用しないため、このコンス トラクターは通常直接呼び出されることがなくは、代わりに派生クラスによって呼び出されます。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。 コンス トラクターを親コントロールのコントロールを追加することも<xref:System.Windows.Forms.Control.ControlCollection>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <param name="left">コントロールのコンテナーの左端からのコントロールの <see cref="P:System.Drawing.Point.X" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Left" /> プロパティに代入されます。</param>
        <param name="top">コントロールのコンテナーの上端からのコントロールの <see cref="P:System.Drawing.Point.Y" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Top" /> プロパティに代入されます。</param>
        <param name="width">コントロールの幅 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Width" /> プロパティに代入されます。</param>
        <param name="height">コントロールの高さ (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Height" /> プロパティに代入されます。</param>
        <summary>テキスト、サイズ、および位置を指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用されるすべてのコントロールの基本クラスです。 クラスのインスタンスを作成するこのクラスが通常使用しないため、このコンス トラクターは通常直接呼び出されることがなくは、代わりに派生クラスによって呼び出されます。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。 初期<xref:System.Windows.Forms.Control.Size%2A>と<xref:System.Windows.Forms.Control.Location%2A>によって決まりますが、コントロールの`left`、 `top`、`width`と`height`パラメーターの値。  
  
> [!NOTE]
>  優れたパフォーマンスを維持するには、コンス トラクターで、コントロールのサイズを設定しないでください。 推奨される方法は、オーバーライドする、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control (System.Windows.Forms.Control parent, string text, int left, int top, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.Forms.Control parent, string text, int32 left, int32 top, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.#ctor(System.Windows.Forms.Control,System.String,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (parent As Control, text As String, left As Integer, top As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Control(System::Windows::Forms::Control ^ parent, System::String ^ text, int left, int top, int width, int height);" />
      <MemberSignature Language="F#" Value="new System.Windows.Forms.Control : System.Windows.Forms.Control * string * int * int * int * int -&gt; System.Windows.Forms.Control" Usage="new System.Windows.Forms.Control (parent, text, left, top, width, height)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parent" Type="System.Windows.Forms.Control" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="parent">コントロールの親である <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="text">コントロールによって表示されるテキスト。</param>
        <param name="left">コントロールのコンテナーの左端からのコントロールの <see cref="P:System.Drawing.Point.X" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Left" /> プロパティに代入されます。</param>
        <param name="top">コントロールのコンテナーの上端からのコントロールの <see cref="P:System.Drawing.Point.Y" /> 位置 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Top" /> プロパティに代入されます。</param>
        <param name="width">コントロールの幅 (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Width" /> プロパティに代入されます。</param>
        <param name="height">コントロールの高さ (ピクセル単位)。 値は <see cref="P:System.Windows.Forms.Control.Height" /> プロパティに代入されます。</param>
        <summary>テキスト、サイズ、および位置を指定して、<see cref="T:System.Windows.Forms.Control" /> クラスの新しいインスタンスを子コントロールとして初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control>クラスは、Windows フォーム アプリケーションで使用されるすべてのコントロールの基本クラスです。 クラスのインスタンスを作成するこのクラスが通常使用しないため、このコンス トラクターは通常直接呼び出されることがなくは、代わりに派生クラスによって呼び出されます。  
  
 このバージョンの<xref:System.Windows.Forms.Control.%23ctor%2A>コンス トラクターに初期設定<xref:System.Windows.Forms.Control.Text%2A>プロパティの値を`text`パラメーターの値。 コンス トラクターを親コントロールのコントロールを追加することも<xref:System.Windows.Forms.Control.ControlCollection>します。 初期<xref:System.Windows.Forms.Control.Size%2A>と<xref:System.Windows.Forms.Control.Location%2A>によって決まりますが、コントロールの`left`、 `top`、`width`と`height`パラメーターの値。  
  
> [!NOTE]
>  優れたパフォーマンスを維持するには、コンス トラクターで、コントロールのサイズを設定しないでください。 推奨される方法は、オーバーライドする、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AccessibilityNotifyClients">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>ユーザー補助クライアント アプリケーションに <see cref="T:System.Windows.Forms.AccessibleEvents" /> を通知します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected internal void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" />
        <Parameter Name="childID" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="accEvent">ユーザー補助クライアント アプリケーションに通知する <see cref="T:System.Windows.Forms.AccessibleEvents" />。</param>
        <param name="childID">ユーザー補助対象のイベントを通知する子 <see cref="T:System.Windows.Forms.Control" />。</param>
        <summary>指定した子コントロールの指定した <see cref="T:System.Windows.Forms.AccessibleEvents" /> をユーザー補助クライアント アプリケーションに通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す必要があります、<xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A?displayProperty=nameWithType>メソッドごとに<xref:System.Windows.Forms.AccessibleEvents>ユーザー補助クライアント アプリケーションの通知されます。 <xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A>プロパティは、設定または内からメソッドを呼び出して通常、イベント ハンドラー。 たとえばを呼び出す、<xref:System.Windows.Forms.Control.ControlAccessibleObject.NotifyClients%2A>メソッドを渡します、<xref:System.Windows.Forms.AccessibleEvents>の値`Hide`からのイベント ハンドラー内で、<xref:System.Windows.Forms.Control.VisibleChanged?displayProperty=nameWithType>イベント。  
  
   
  
## Examples  
 ユーザー補助対応のグラフの作成を次のコード例に示しますを使用して、制御、<xref:System.Windows.Forms.AccessibleObject>と<xref:System.Windows.Forms.Control.ControlAccessibleObject>アクセス可能な情報を公開するクラス。 コントロールは、凡例と共に 2 つの曲線をプロットします。 `ChartControlAccessibleObject`から派生したクラス`ControlAccessibleObject`で使用されて、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>グラフ コントロールのカスタムのアクセス可能な情報を提供するメソッド。 グラフの凡例は、実際はないため<xref:System.Windows.Forms.Control>-ベースの制御が描画される代わりに、グラフ コントロールではなく組み込みアクセス可能な情報。 このため、`ChartControlAccessibleObject`オーバーライド、<xref:System.Windows.Forms.AccessibleObject.GetChild%2A>を返すメソッドを`CurveLegendAccessibleObject`凡例の各部分にアクセスできる情報を表します。 ユーザー補助対応アプリケーションでは、このコントロールを使用すると、コントロールは、アクセスに必要な情報を提供できます。  
  
 このコードの抜粋は、呼び出し元を示します、<xref:System.Windows.Forms.Control.AccessibilityNotifyClients%2A>メソッド。 参照してください、<xref:System.Windows.Forms.AccessibleObject>完全なコード例では、クラスの概要。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#5)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#5)]
 [!code-vb[System.Windows.Forms.AccessibleObject#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleEvents" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="AccessibilityNotifyClients">
      <MemberSignature Language="C#" Value="protected void AccessibilityNotifyClients (System.Windows.Forms.AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AccessibilityNotifyClients(valuetype System.Windows.Forms.AccessibleEvents accEvent, int32 objectID, int32 childID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.AccessibilityNotifyClients(System.Windows.Forms.AccessibleEvents,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub AccessibilityNotifyClients (accEvent As AccessibleEvents, objectID As Integer, childID As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void AccessibilityNotifyClients(System::Windows::Forms::AccessibleEvents accEvent, int objectID, int childID);" />
      <MemberSignature Language="F#" Value="member this.AccessibilityNotifyClients : System.Windows.Forms.AccessibleEvents * int * int -&gt; unit" Usage="control.AccessibilityNotifyClients (accEvent, objectID, childID)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="accEvent" Type="System.Windows.Forms.AccessibleEvents" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="objectID" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="childID" Type="System.Int32" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="accEvent">ユーザー補助クライアント アプリケーションに通知する <see cref="T:System.Windows.Forms.AccessibleEvents" />。</param>
        <param name="objectID"><see cref="T:System.Windows.Forms.AccessibleObject" /> の識別子。</param>
        <param name="childID">ユーザー補助対象のイベントを通知する子 <see cref="T:System.Windows.Forms.Control" />。</param>
        <summary>指定した子コントロールの指定した <see cref="T:System.Windows.Forms.AccessibleEvents" /> をユーザー補助クライアント アプリケーションに通知します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessibilityObject">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleObject AccessibilityObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.AccessibleObject AccessibilityObject" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibilityObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AccessibilityObject As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleObject ^ AccessibilityObject { System::Windows::Forms::AccessibleObject ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AccessibilityObject : System.Windows.Forms.AccessibleObject" Usage="System.Windows.Forms.Control.AccessibilityObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに割り当てられた <see cref="T:System.Windows.Forms.AccessibleObject" /> を取得します。</summary>
        <value>コントロールに割り当てられた <see cref="T:System.Windows.Forms.AccessibleObject" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドから返されるインスタンスを制御するには、オーバーライド、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>メソッド。  
  
 コントロールに現在割り当てられている <xref:System.Windows.Forms.AccessibleObject> がない場合は、コントロールの新しいインスタンスが作成されます。  
  
> [!NOTE]
>  取得または設定する、<xref:System.Windows.Forms.Control.AccessibilityObject%2A>プロパティへの参照を追加する必要があります、`Accessibility`と一緒にインストールされたアセンブリ、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]します。  
  
 ユーザー補助オブジェクトの詳細については、次を参照してください。 [Active Accessibility](https://msdn.microsoft.com/library/windows/desktop/dd373592.aspx)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDefaultActionDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDefaultActionDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDefaultActionDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDefaultActionDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDefaultActionDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDefaultActionDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アクセシビリティ クライアント アプリケーションで使用されるコントロールの既定のアクションの説明を取得または設定します。</summary>
        <value>ユーザー補助クライアント アプリケーションによって使用される、コントロールの既定のアクションの説明。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトの<xref:System.Windows.Forms.Control.AccessibleDefaultActionDescription%2A>プロパティが、ユーザーの視点から、操作のオブジェクトの主な方法について説明します。 このプロパティは、動詞または動詞の短い語句にする必要があります。  
  
> [!NOTE]
>  すべてのオブジェクトが、既定の操作があるし、一部のオブジェクトは既定のアクションに関連付けられている必要があります、<xref:System.Windows.Forms.AccessibleObject.Value%2A?displayProperty=nameWithType>プロパティは、次の例のようにします。  
  
-   チェック ボックスがオン、オフ「に」の既定のアクションと値の「オン」にします。  
  
-   チェック ボックスをオフに「確認」の既定のアクションと値の"オフ"にした場合。  
  
-   "Print"というラベルのボタンでは、「キーを押して、」の既定のアクションを持つ値はありません。  
  
-   ラベルまたは"Printer"を表示するテキスト ボックス コントロールは、既定のアクションはありませんが、「プリンター」の値は  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。[説明的なプロパティのコンテンツ](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.DefaultAction" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleDescription">
      <MemberSignature Language="C#" Value="public string AccessibleDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleDescription" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleDescription : string with get, set" Usage="System.Windows.Forms.Control.AccessibleDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー補助クライアント アプリケーションによって使用される、コントロールの説明を取得または設定します。</summary>
        <value>ユーザー補助クライアント アプリケーションによって使用されるコントロールの説明。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オブジェクトの<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティは、オブジェクトの視覚的な外観の説明テキストを提供します。 説明は、視覚や視覚障碍のあるユーザーでは、大きいコンテキストを提供する、主に使用しますが、コンテキスト検索やその他のアプリケーションも使用できます。  
  
 <xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティが、説明では、明らかな場合に必要なか冗長である場合は、オブジェクトに基づく<xref:System.Windows.Forms.Control.AccessibleName%2A>、 <xref:System.Windows.Forms.Control.AccessibleRole%2A>、 <xref:System.Windows.Forms.AccessibleObject.State%2A>、および<xref:System.Windows.Forms.AccessibleObject.Value%2A>プロパティ。 たとえば、"OK"のボタンでは、追加の情報は必要はありませんが、サボテンの画像を表示するボタンは。 <xref:System.Windows.Forms.Control.AccessibleName%2A>、および<xref:System.Windows.Forms.Control.AccessibleRole%2A>(とおそらく<xref:System.Windows.Forms.AccessibleObject.Help%2A>) サボテン ボタンのプロパティは、その目的をについて説明しますが、<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティが「サボテンの画像を表示するボタン」などの小さい具体的な情報を伝える。  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。[説明的なプロパティのコンテンツ](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)します。  
  
   
  
## Examples  
 次のコード例のインスタンスを作成する、<xref:System.Windows.Forms.CheckBox>派生クラスで`MyCheckBox`、割り当てます、<xref:System.Drawing.Image>にその<xref:System.Windows.Forms.ButtonBase.Image%2A>プロパティとセット、<xref:System.Windows.Forms.Control.AccessibleName%2A>と<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティ、ため、 <xref:System.Windows.Forms.Control.Text%2A>プロパティは`null`します。 この例が必要です、<xref:System.Windows.Forms.Form>という`MyForm`します。  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Description" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleName">
      <MemberSignature Language="C#" Value="public string AccessibleName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AccessibleName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleName" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AccessibleName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleName : string with get, set" Usage="System.Windows.Forms.Control.AccessibleName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー補助クライアント アプリケーションによって使用されるコントロールの名前を取得または設定します。</summary>
        <value>ユーザー補助クライアント アプリケーションによって使用されるコントロールの名前。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleName%2A>プロパティは、簡単な説明し、内のテキストなど、コンテナー内のオブジェクトを識別するラベルを<xref:System.Windows.Forms.Button>の名前、 <xref:System.Windows.Forms.MenuItem>、または横に表示されるラベルを<xref:System.Windows.Forms.TextBox>コントロール。  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。、"[説明的なプロパティのコンテンツ](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)します。  
  
   
  
## Examples  
 次のコード例のインスタンスを作成する、<xref:System.Windows.Forms.CheckBox>派生クラスで`MyCheckBox`、割り当てます、<xref:System.Drawing.Image>にその<xref:System.Windows.Forms.ButtonBase.Image%2A>プロパティとセット、<xref:System.Windows.Forms.Control.AccessibleName%2A>と<xref:System.Windows.Forms.Control.AccessibleDescription%2A>プロパティ、<xref:System.Windows.Forms.Control.Text%2A>プロパティ`null`します。 この例が必要です、<xref:System.Windows.Forms.Form>という`MyForm`します。  
  
 [!code-cpp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CPP/controlaccessibility.cpp#2)]
 [!code-csharp[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/CS/controlaccessibility.cs#2)]
 [!code-vb[Windows.Forms.Control.ControlAccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.ControlAccessibleObject/VB/controlaccessibility.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Name" />
      </Docs>
    </Member>
    <Member MemberName="AccessibleRole">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AccessibleRole AccessibleRole { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AccessibleRole AccessibleRole" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AccessibleRole" />
      <MemberSignature Language="VB.NET" Value="Public Property AccessibleRole As AccessibleRole" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AccessibleRole AccessibleRole { System::Windows::Forms::AccessibleRole get(); void set(System::Windows::Forms::AccessibleRole value); };" />
      <MemberSignature Language="F#" Value="member this.AccessibleRole : System.Windows.Forms.AccessibleRole with get, set" Usage="System.Windows.Forms.Control.AccessibleRole" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleRole</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのアクセスできる役割を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.AccessibleRole" /> の値の 1 つ。 既定値は、<see langword="Default" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.AccessibleRole%2A> プロパティは、オブジェクトがどのような種類のユーザー インターフェイス要素であるかを説明します。 コントロールの役割が決定できない場合、<xref:System.Windows.Forms.Control.AccessibleRole%2A> プロパティは `Default` に設定されます。  
  
 ユーザー補助オブジェクトのプロパティの詳細については、次を参照してください。[説明的なプロパティのコンテンツ](https://msdn.microsoft.com/library/windows/desktop/dd318025.aspx)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">代入された値が、<see cref="T:System.Windows.Forms.AccessibleRole" /> 値ではありません。</exception>
        <altmember cref="T:System.Windows.Forms.AccessibleRole" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDescription" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleName" />
        <altmember cref="P:System.Windows.Forms.Control.AccessibleDefaultActionDescription" />
        <altmember cref="P:System.Windows.Forms.AccessibleObject.Role" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public virtual bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.Control.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがコントロールにドラッグしたデータを、そのコントロールが受け入れることができるかどうかを示す値を取得または設定します。</summary>
        <value>コントロールでドラッグ アンド ドロップ操作を実行できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例で、イメージまたはイメージ ファイルをフォームにドラッグして、上の点で、表示するユーザーが削除されます。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームが描画されるたびに、イメージを再描画する。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドをフォームにドラッグされるデータの種類を決定および適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合イベント処理メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値は、画面座標、例では、<xref:System.Windows.Forms.Control.PointToClient%2A>クライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティを設定への無制限のクリップボード アクセスの<see langword="true" />します。 列挙型に関連付けられている:<see langword="AllClipboard" />の値 <see cref="T:System.Security.Permissions.UIPermissionClipboard" /></permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.AllowDrop" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.AllowDrop" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.AllowDrop" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.DragEventArgs" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      </Docs>
    </Member>
    <Member MemberName="Anchor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.AnchorStyles Anchor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AnchorStyles Anchor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Anchor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Anchor As AnchorStyles" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AnchorStyles Anchor { System::Windows::Forms::AnchorStyles get(); void set(System::Windows::Forms::AnchorStyles value); };" />
      <MemberSignature Language="F#" Value="member this.Anchor : System.Windows.Forms.AnchorStyles with get, set" Usage="System.Windows.Forms.Control.Anchor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AnchorStyles</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがバインドされるコンテナーの端を取得または設定し、親のサイズ変更時に、コントロールのサイズがどのように変化するかを決定します。</summary>
        <value><see cref="T:System.Windows.Forms.AnchorStyles" /> 値のビットごとの組み合わせ。 既定値は <see langword="Top" /> および <see langword="Left" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.Anchor%2A>プロパティをコントロールが自動的にサイズ変更、親コントロールのサイズを変更します。 親コントロールにコントロールを固定すると、アンカーの端の親コントロールがサイズ変更されると、親コントロールの端を基準と同じ位置に保つことができます。  
  
 そのコンテナーの端を 1 つまたは複数のコントロールを固定することができます。 ある場合など、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Button>が<xref:System.Windows.Forms.Control.Anchor%2A>プロパティの値に設定されて`Top`と`Bottom`、<xref:System.Windows.Forms.Button>固定、の上端と下端の端までの距離を維持するために拡大<xref:System.Windows.Forms.Form>として、<xref:System.Windows.Forms.Control.Height%2A>の<xref:System.Windows.Forms.Form>が増加します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A>と<xref:System.Windows.Forms.Control.Dock%2A>プロパティは相互に排他的です。 一度に 1 つだけを設定でき、最後に、設定が優先されます。  
  
   
  
## Examples  
 次のコード例を追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の一般的なプロパティを設定します。 例は、フォームのサイズと、その相対位置が維持されるように、フォームの右下隅にあるボタンを固定します。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズにボタンのサイズを変更し、<xref:System.Drawing.Image>します。 設定し、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティ。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベント。 この例が必要です、<xref:System.Windows.Forms.ImageList>という`imageList1`します。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.Anchor" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.Anchor" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.Anchor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.AnchorStyles" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="AutoScrollOffset">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Point AutoScrollOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point AutoScrollOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScrollOffset As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Point AutoScrollOffset { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.AutoScrollOffset : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.AutoScrollOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Point), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.ScrollableControl.ScrollControlIntoView(System.Windows.Forms.Control)" /> でのこのコントロールのスクロール先を取得または設定します。</summary>
        <value>スクロール位置を指定する <see cref="T:System.Drawing.Point" />。 既定値は、コントロールの左上隅です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public virtual bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.Control.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このクラスでは、このプロパティは使用されません。</summary>
        <value>有効である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このプロパティは使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.AutoSizeChanged : EventHandler " Usage="member this.AutoSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このクラスでは、このイベントは使用されません。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このイベントは使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.BackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-501)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの背景色を取得または設定します。</summary>
        <value>コントロールの背景色を表す <see cref="T:System.Drawing.Color" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultBackColor" /> プロパティの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.BackColor%2A>プロパティが透明色をサポートしていない場合を除き、`SupportsTransparentBackColor`の値<xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType>に設定されている`true`します。  
  
 <xref:System.Windows.Forms.Control.BackColor%2A>プロパティは、アンビエント プロパティです。 アンビエントのプロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>が、同じ<xref:System.Windows.Forms.Control.BackColor%2A>親として<xref:System.Windows.Forms.Form>既定では。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Control.BackColor%2A>と<xref:System.Windows.Forms.Control.ForeColor%2A>の既定のシステム カラーをコントロールします。 コードを再帰的には、コントロールに子コントロールがある場合は自分自身を呼び出します。 このコード例が必要です、<xref:System.Windows.Forms.Form>を少なくとも 1 つの子コントロールでただし、子コンテナーを制御するような<xref:System.Windows.Forms.Panel>または<xref:System.Windows.Forms.GroupBox>、わかりやすく示すためコントロールが、再帰、独自の子にします。  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.BackColor" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.BackColor" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.BackColor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.AmbientProperties" />
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="BackColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackColorChanged;" />
      <MemberSignature Language="F#" Value="member this.BackColorChanged : EventHandler " Usage="member this.BackColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackColor" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.BackColor%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ*PropertyName* `Changed`にある場合に発生します、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.Control.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに表示される背景イメージを取得または設定します。</summary>
        <value>コントロールの背景に表示するイメージを表す <see cref="T:System.Drawing.Image" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   使用して、<xref:System.Windows.Forms.Control.BackgroundImage%2A>プロパティをコントロールにグラフィック イメージを配置します。  
  
> [!NOTE]
>  背景画像として、色が半透明または透過的なイメージは Windows フォーム コントロールでサポートされていません。  
>   
>  このプロパティでサポートされていないいる子コントロール<xref:System.Windows.Forms.Form.RightToLeftLayout%2A>プロパティは`true`。  
  
   
  
## Examples  
 次のコード例を追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の一般的なプロパティを設定します。 例は、フォームのサイズと、その相対位置が維持されるように、フォームの右下隅にあるボタンを固定します。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズにボタンのサイズを変更し、<xref:System.Drawing.Image>します。 設定し、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティ。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベント。 この例が必要です、<xref:System.Windows.Forms.ImageList>という`imageList1`します。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.BackgroundImage" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.BackgroundImage" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.BackgroundImage" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Drawing.Image" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackgroundImage" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.BackgroundImage%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ*PropertyName* `Changed`にある場合に発生します、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Image" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.Control.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.ImageLayout" /> 列挙型で定義される背景画像のレイアウトを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.ImageLayout" /> の値の 1 つ (<see cref="F:System.Windows.Forms.ImageLayout.Center" />、<see cref="F:System.Windows.Forms.ImageLayout.None" />、<see cref="F:System.Windows.Forms.ImageLayout.Stretch" />、<see cref="F:System.Windows.Forms.ImageLayout.Tile" />、または <see cref="F:System.Windows.Forms.ImageLayout.Zoom" />)。 既定値は <see cref="F:System.Windows.Forms.ImageLayout.Tile" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>プロパティをコントロールに配置したイメージの動作と位置を指定します。 <xref:System.Windows.Forms.Control.BackgroundImageLayout%2A> 場合にのみ有効になります、<xref:System.Windows.Forms.Control.BackgroundImage%2A>プロパティを設定します。  
  
 設定した場合は、大きなイメージのパフォーマンスを向上できます<xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>以外のものに<xref:System.Windows.Forms.ImageLayout.Tile>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">指定した列挙値が存在しません。</exception>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackgroundImageLayout" /> プロパティが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.BackgroundImageLayout%2A>プログラム、またはユーザーの操作によってプロパティが変更されました。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.BackgroundImageLayoutChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#9)]
 [!code-vb[System.Windows.Forms.EventExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginInvoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールの基になるハンドルが作成されたスレッド上で、非同期的にデリゲートを実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginInvoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginInvoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.BeginInvoke : Delegate -&gt; IAsyncResult" Usage="control.BeginInvoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">パラメーターをとらないメソッドへのデリゲート。</param>
        <summary>コントロールの基になるハンドルが作成されたスレッド上で、指定したデリゲートを非同期的に実行します。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 操作の結果を表す <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートを非同期的に呼び出され、このメソッドがすぐに返します。 このメソッドは、コントロールのハンドルを所有するスレッドからでも、任意のスレッドから呼び出すことができます。 コントロールのハンドルがまだ存在しない場合、このメソッドは、コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、コントロールの親チェーンを検索します。 適切なハンドルが見つからない場合<xref:System.Windows.Forms.Control.BeginInvoke%2A>例外がスローされます。 デリゲート メソッド内で例外がトラップされ、アプリケーションの例外トラップ ハンドラーに送信されますと見なされます。  
  
 呼び出すことができます<xref:System.Windows.Forms.Control.EndInvoke%2A>によりが、これが必要ない場合、デリゲートから戻り値を取得します。 <xref:System.Windows.Forms.Control.EndInvoke%2A> 戻り値を取得するまでブロックされます。  
  
> [!NOTE]
>  コントロールのほとんどのメソッドのみ呼び出せるスレッドからコントロールが作成されました。 加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティはスレッド セーフであるコントロールの 4 つの方法があります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しにはコントロールのスレッドへの呼び出しをマーシャ リングするのに invoke メソッドのいずれかを使用する必要があります。 Invoke メソッドは、常にコントロールのスレッドでコールバックを呼び出します。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされます。  
  
   
  
## Examples  
 次のコード例に示しますを使用して、<xref:System.Windows.Forms.Control.BeginInvoke%2A>メソッド。  
  
 [!code-cpp[Control_BeginInvoke#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#2)]
 [!code-csharp[Control_BeginInvoke#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#2)]
 [!code-vb[Control_BeginInvoke#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">適切なウィンドウ ハンドルが見つかりません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BeginInvoke">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginInvoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginInvoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginInvoke (method As Delegate, ParamArray args As Object()) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IAsyncResult ^ BeginInvoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member BeginInvoke : Delegate * obj[] -&gt; IAsyncResult&#xA;override this.BeginInvoke : Delegate * obj[] -&gt; IAsyncResult" Usage="control.BeginInvoke (method, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.BeginInvoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><paramref name="args" /> パラメーターに指定されている数および型と同じ数および型のパラメーターをとるメソッドへのデリゲート。</param>
        <param name="args">特定のメソッドに引数として渡すオブジェクトの配列。 引数が必要ない場合は、<see langword="null" /> を指定できます。</param>
        <summary>コントロールの基になるハンドルが作成されたスレッド上で、指定した引数で指定したデリゲートを非同期的に実行します。</summary>
        <returns><see cref="T:System.IAsyncResult" /> 操作の結果を表す <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートを非同期的に呼び出され、このメソッドがすぐに返します。 このメソッドは、コントロールのハンドルを所有するスレッドからでも、任意のスレッドから呼び出すことができます。 コントロールのハンドルがまだ存在しない場合、このメソッドは、コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、コントロールの親チェーンを検索します。 適切なハンドルが見つからない場合<xref:System.Windows.Forms.Control.BeginInvoke%2A>例外がスローされます。 デリゲート メソッド内で例外がトラップされ、アプリケーションの例外トラップ ハンドラーに送信されますと見なされます。  
  
 呼び出すことができます<xref:System.Windows.Forms.Control.EndInvoke%2A>によりが、これが必要ない場合、デリゲートから戻り値を取得します。 <xref:System.Windows.Forms.Control.EndInvoke%2A> 戻り値を取得するまでブロックされます。  
  
> [!NOTE]
>  コントロールのほとんどのメソッドのみ呼び出せるスレッドからコントロールが作成されました。 加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティはスレッド セーフであるコントロールの 4 つの方法があります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しにはコントロールのスレッドへの呼び出しをマーシャ リングするのに invoke メソッドのいずれかを使用する必要があります。 Invoke メソッドは、常にコントロールのスレッドでコールバックを呼び出します。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされます。  
  
   
  
## Examples  
 次のコード例に示しますを使用して、<xref:System.Windows.Forms.Control.BeginInvoke%2A>メソッド。  
  
 [!code-cpp[Control_BeginInvoke#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_BeginInvoke/CPP/control_begininvoke.cpp#1)]
 [!code-csharp[Control_BeginInvoke#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_BeginInvoke/CS/control_begininvoke.cs#1)]
 [!code-vb[Control_BeginInvoke#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_BeginInvoke/VB/control_begininvoke.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">適切なウィンドウ ハンドルが見つかりません。</exception>
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.CreateGraphics" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="BindingContext">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.BindingContext BindingContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.BindingContext BindingContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.BindingContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property BindingContext As BindingContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::BindingContext ^ BindingContext { System::Windows::Forms::BindingContext ^ get(); void set(System::Windows::Forms::BindingContext ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BindingContext : System.Windows.Forms.BindingContext with get, set" Usage="System.Windows.Forms.Control.BindingContext" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.BindingContext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BindingContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの <see cref="T:System.Windows.Forms.BindingContext" /> を取得または設定します。</summary>
        <value>コントロールの <see cref="T:System.Windows.Forms.BindingContext" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.BindingContext>の<xref:System.Windows.Forms.Control>、1 つを返すために使用<xref:System.Windows.Forms.BindingManagerBase>に含まれるすべてのデータ バインド コントロールの<xref:System.Windows.Forms.Control>します。 <xref:System.Windows.Forms.BindingManagerBase>同期されている同じデータ ソースにバインドされているすべてのコントロールを保持します。 たとえば、設定、<xref:System.Windows.Forms.BindingManagerBase.Position%2A>のプロパティ、<xref:System.Windows.Forms.BindingManagerBase>すべてのデータ バインド コントロールをポイントする基になるリストの項目を指定します。  
  
 新たに作成の詳細については<xref:System.Windows.Forms.BindingContext>に割り当てることと、<xref:System.Windows.Forms.Control.BindingContext%2A>プロパティを参照してください、<xref:System.Windows.Forms.BindingContext.%23ctor%2A>します。  
  
   
  
## Examples  
 次のコード例では、4 つ作成します<xref:System.Windows.Forms.Binding>5 つのコントロールをバインドするオブジェクト、<xref:System.Windows.Forms.DateTimePicker>と 4 つ<xref:System.Windows.Forms.TextBox>いくつかのデータ ソースへのコントロール。 <xref:System.Windows.Forms.BindingContext>を取得するを使用して、<xref:System.Windows.Forms.BindingManagerBase>データ ソースごとにします。  
  
 [!code-cpp[Classic BindingContext Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic BindingContext Example/CPP/source.cpp#1)]
 [!code-csharp[Classic BindingContext Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic BindingContext Example/CS/source.cs#1)]
 [!code-vb[Classic BindingContext Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic BindingContext Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.BindingContext" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.BindingContext" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.BindingContext" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="BindingContextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BindingContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BindingContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.BindingContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BindingContextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BindingContextChanged;" />
      <MemberSignature Language="F#" Value="member this.BindingContextChanged : EventHandler " Usage="member this.BindingContextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.BindingContext" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 新しい追加<xref:System.Windows.Forms.BindingContext>を<xref:System.Windows.Forms.Control>を通じて、<xref:System.Windows.Forms.Control.BindingContext%2A>プロパティを参照してください、<xref:System.Windows.Forms.BindingContext.%23ctor%2A>コンス トラクター。  
  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.BindingContext%2A>プロパティが変更されたプログラムの変更、またはユーザーの操作によってです。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例を追加、<xref:System.EventHandler>に委任、<xref:System.Windows.Forms.Control.BindingContextChanged>のイベントを<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.BindingContextChanged Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/CS/source.cs#1)]
 [!code-vb[Classic Control.BindingContextChanged Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.BindingContextChanged Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
        <altmember cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Bottom">
      <MemberSignature Language="C#" Value="public int Bottom { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Bottom" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bottom" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Bottom As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Bottom { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Bottom : int" Usage="System.Windows.Forms.Control.Bottom" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの下端とコンテナーのクライアント領域の上端の間の距離をピクセルで取得します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの下端とコンテナーのクライアント領域の上端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値がの合計に等しい、<xref:System.Windows.Forms.Control.Top%2A>プロパティの値、および<xref:System.Windows.Forms.Control.Height%2A>プロパティの値。  
  
 <xref:System.Windows.Forms.Control.Bottom%2A>プロパティは読み取り専用プロパティです。 値を変更することでこのプロパティの値を操作することができます、<xref:System.Windows.Forms.Control.Top%2A>または<xref:System.Windows.Forms.Control.Height%2A>プロパティまたは呼び出す、 <xref:System.Windows.Forms.Control.SetBounds%2A>、 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>、 <xref:System.Windows.Forms.Control.UpdateBounds%2A>、または<xref:System.Windows.Forms.Control.SetClientSizeCore%2A>メソッド。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Bottom%2A>の下限を定義するプロパティを<xref:System.Windows.Forms.TextBox>コントロール コンテナーのクライアント領域を基準とします。  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
      </Docs>
    </Member>
    <Member MemberName="Bounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle Bounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle Bounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Bounds" />
      <MemberSignature Language="VB.NET" Value="Public Property Bounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle Bounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberSignature Language="F#" Value="member this.Bounds : System.Drawing.Rectangle with get, set" Usage="System.Windows.Forms.Control.Bounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>クライアント以外の要素を含むコントロールの、親コントロールに対する相対的なサイズおよび位置をピクセル単位で取得または設定します。</summary>
        <value>クライアント以外の要素を含むコントロールの、親コントロールに対する相対的なサイズおよび位置を表す <see cref="T:System.Drawing.Rectangle" /> (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの境界には、スクロール バー、罫線、タイトル バー、メニューなどの非クライアント要素が含まれます。 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>を設定するメソッドが呼び出される、<xref:System.Windows.Forms.Control.Bounds%2A>プロパティ。 <xref:System.Windows.Forms.Control.Bounds%2A>プロパティは、常にでは変更されませんその`set`メソッドをオーバーライドするため、 <xref:System.Windows.Forms.Control.SetBoundsCore%2A> 、コードが実行されることを確認する方法と、<xref:System.Windows.Forms.Control.Bounds%2A>プロパティを設定します。  
  
   
  
## Examples  
 次のコード例では、3 つを作成<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用して、そのサイズと位置を設定します。 この例が必要です、<xref:System.Windows.Forms.Form>少なくとも 300 ピクセルの高さ、幅を持ちます。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Top" />
        <altmember cref="P:System.Windows.Forms.Control.Left" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="BringToFront">
      <MemberSignature Language="C#" Value="public void BringToFront ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringToFront() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.BringToFront" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringToFront ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringToFront();" />
      <MemberSignature Language="F#" Value="member this.BringToFront : unit -&gt; unit" Usage="control.BringToFront " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを z オーダーの最前面へ移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールは、z オーダーの最前面に移動されます。 コントロールが別のコントロールの子である場合は、子コントロールは、z オーダーの最前面に移動されます。 <xref:System.Windows.Forms.Control.BringToFront%2A> コントロールをトップレベル コントロールでは、または発生しないことをしないのは、<xref:System.Windows.Forms.Control.Paint>イベント。  
  
   
  
## Examples  
 次のコード例は、確実、<xref:System.Windows.Forms.Label>が呼び出すことによって表示されるその<xref:System.Windows.Forms.Control.BringToFront%2A>メソッド。 この例が必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Panel>という名前`panel1`、および<xref:System.Windows.Forms.Label>という名前`label1`します。  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SendToBack" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="CanEnableIme">
      <MemberSignature Language="C#" Value="protected virtual bool CanEnableIme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanEnableIme" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanEnableIme" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CanEnableIme As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanEnableIme { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanEnableIme : bool" Usage="System.Windows.Forms.Control.CanEnableIme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ImeMode" /> プロパティをアクティブな値に設定して、IME サポートを有効にできるかどうかを示す値を取得します。</summary>
        <value>常に <see langword="true" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスを返すには、このプロパティをオーバーライドできます`false`IME がサポートされていない場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFocus">
      <MemberSignature Language="C#" Value="public bool CanFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanFocus : bool" Usage="System.Windows.Forms.Control.CanFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを受け取ることができるかどうかを示す値を取得します。</summary>
        <value>コントロールがフォーカスを受け取ることができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールが入力フォーカスを受け取るためには、コントロールがそれに割り当てられているハンドルを持つ必要があります、<xref:System.Windows.Forms.Control.Visible%2A>と<xref:System.Windows.Forms.Control.Enabled%2A>両方の設定が必要`true`コントロールとそのすべての親コントロールとコントロールの両方がフォームにする必要があります、またはコントロールの最も外側にある親フォームがあります。  
  
   
  
## Examples  
 次のコード例を指定したフォーカスを設定する<xref:System.Windows.Forms.Control>フォーカスを受け取ることができます。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="CanRaiseEvents">
      <MemberSignature Language="C#" Value="protected override bool CanRaiseEvents { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRaiseEvents" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CanRaiseEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool CanRaiseEvents { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRaiseEvents : bool" Usage="System.Windows.Forms.Control.CanRaiseEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールでイベントが発生するかどうかを決定します。</summary>
        <value>コントロールが、イベントが固定されていない ActiveX コントロールとしてホストされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かどうか、このコントロールは、ActiveX コントロールとしてホストされているが、このプロパティを返します`false`ActiveX コントロールにそのイベントが固定されている場合。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSelect">
      <MemberSignature Language="C#" Value="public bool CanSelect { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CanSelect" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanSelect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanSelect { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanSelect : bool" Usage="System.Windows.Forms.Control.CanSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを選択できるかどうかを示す値を取得します。</summary>
        <value>コントロールを選択できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`場合、 `Selectable` @property<xref:System.Windows.Forms.ControlStyles?displayProperty=nameWithType>に設定されている`true`の別のコントロールに含まれるコントロール自体が表示され、有効になっている、およびすべての親コントロールが表示され、有効になっています。  
  
 次の一覧での Windows フォーム コントロールが選択できずの値を返す`false`の<xref:System.Windows.Forms.Control.CanSelect%2A>プロパティ。 これらのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (この場合、コントロール内にリンクすることはありません)  
  
   
  
## Examples  
 次のコード例を指定した選択<xref:System.Windows.Forms.Control>が選択可能な場合。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
 [!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
 [!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
      </Docs>
    </Member>
    <Member MemberName="Capture">
      <MemberSignature Language="C#" Value="public bool Capture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Capture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Capture" />
      <MemberSignature Language="VB.NET" Value="Public Property Capture As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Capture { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Capture : bool with get, set" Usage="System.Windows.Forms.Control.Capture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがマウスをキャプチャしたかどうかを示す値を取得または設定します。</summary>
        <value>コントロールがマウスをキャプチャした場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールは、マウスをキャプチャしたら、カーソルがその境界内にあるかどうかを示すマウス入力を受け取ります。 通常、マウスがドラッグ操作中にのみキャプチャされます。  
  
 前面のウィンドウには、マウスをキャプチャできます。 背景ウィンドウがようにしようとすると、ウィンドウは、マウス カーソルがウィンドウの表示部分内に発生するマウス イベントにのみメッセージを受信します。 また、前面のウィンドウがマウスをキャプチャした場合でも、ユーザー クリックできます別のウィンドウへの前景色。  
  
 マウスをキャプチャしたら、ショートカット キーは動作しません。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Windows.Forms.Control.Capture%2A>プロパティ。 格納しているフォームに貼り付けを次のコードのこの例を実行する、 <xref:System.Windows.Forms.Label> label1 と 2 という<xref:System.Windows.Forms.ListBox>listbox1 と listbox2 という名前のコントロール。 フォームおよびコントロールの<xref:System.Windows.Forms.Control.MouseDown>イベントは、この例では、メソッドに関連付けられています。  
  
 [!code-cpp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlCapture#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlCapture#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlCapture/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を設定するすべてのウィンドウ。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidation">
      <MemberSignature Language="C#" Value="public bool CausesValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CausesValidation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CausesValidation" />
      <MemberSignature Language="VB.NET" Value="Public Property CausesValidation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CausesValidation { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CausesValidation : bool with get, set" Usage="System.Windows.Forms.Control.CausesValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>そのコントロールが原因で、フォーカスを受け取ると検証が必要なコントロールに対して、検証が実行されるかどうかを示す値を取得または設定します。</summary>
        <value>そのコントロールが原因で、フォーカスを受け取ると検証が必要なコントロールに対して検証が実行される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 <xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティの値は通常に設定`false`ヘルプ ボタンなどのコントロール。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.TextBox>しユーザーが入力した電子メール アドレスを検証します。 標準形式の電子メール アドレスがない場合 (を含む"@" and ".")、検証に失敗、<xref:System.Windows.Forms.ErrorProvider>アイコンが表示され、イベントが取り消されました。 フォームのボタンのいずれかがその<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定`false`します。 クリックするか、このボタンにフォーカスの設定は、検証をトリガーしません。 この例では、する必要があります、 <xref:System.Windows.Forms.TextBox>、<xref:System.Windows.Forms.ErrorProvider>コントロール、および<xref:System.Windows.Forms.Button>フォームで作成されました。  
  
 [!code-cpp[Control.Validating#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#2)]
 [!code-csharp[Control.Validating#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#2)]
 [!code-vb[Control.Validating#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="CausesValidationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CausesValidationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CausesValidationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CausesValidationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CausesValidationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CausesValidationChanged;" />
      <MemberSignature Language="F#" Value="member this.CausesValidationChanged : EventHandler " Usage="member this.CausesValidationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.CausesValidation" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.CausesValidation%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="ChangeUICues">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.UICuesEventHandler ChangeUICues;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.UICuesEventHandler ChangeUICues" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ChangeUICues" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ChangeUICues As UICuesEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::UICuesEventHandler ^ ChangeUICues;" />
      <MemberSignature Language="F#" Value="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " Usage="member this.ChangeUICues : System.Windows.Forms.UICuesEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.UICuesEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>フォーカスまたはキーボードのユーザー インターフェイス (UI) キューが変更されるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.ChangeUICues>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.ChangeUICues>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#67](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#67)]
 [!code-vb[System.Windows.Forms.EventExamples#67](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="CheckForIllegalCrossThreadCalls">
      <MemberSignature Language="C#" Value="public static bool CheckForIllegalCrossThreadCalls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CheckForIllegalCrossThreadCalls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CheckForIllegalCrossThreadCalls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CheckForIllegalCrossThreadCalls : bool with get, set" Usage="System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>アプリケーションのデバッグ中に、コントロールの <see cref="P:System.Windows.Forms.Control.Handle" /> プロパティにアクセスする間違ったスレッドによる呼び出しをキャッチするかどうかを示す値を取得または設定します。</summary>
        <value>間違ったスレッドによる呼び出しをキャッチする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのスレッドの作成以外のスレッドがそのコントロールのメソッドまたはプロパティのいずれかにアクセスしようとすると、予期しない結果に多くの場合、つながります。 一般的な無効なスレッドのアクティビティは、コントロールにアクセスする間違ったスレッドで呼び出し<xref:System.Windows.Forms.Control.Handle%2A>プロパティ。 設定<xref:System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls%2A>に`true`を発見し、デバッグ中に、このスレッドのアクティビティをより簡単に診断します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : EventHandler " Usage="member this.Click : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがクリックされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Click>イベントを渡します、<xref:System.EventArgs>がイベント ハンドラーにこれを示しているだけクリックが発生したことです。 使用して、具体的なマウス情報 (ボタンを数回のクリック、ホイールを回転、または場所の数) が必要な場合、<xref:System.Windows.Forms.Control.MouseClick>イベント。 ただし、<xref:System.Windows.Forms.Control.MouseClick>以外、マウス、ENTER キーを押すなどのアクションによって、クリックが発生した場合、イベントは発生しません。  
  
 ダブルクリックは、ユーザーのオペレーティング システムのマウス設定によって決まります。 ユーザーは、2 回のクリックではなくダブルクリックと見なされるマウス ボタンのクリック間隔を設定できます。 <xref:System.Windows.Forms.Control.Click>たびに、コントロールがダブルクリックされたイベントが発生します。 などのイベント ハンドラーがある場合、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>のイベントを<xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>フォームをダブルクリックし、両方のメソッドが呼び出されるイベントが発生します。 コントロールがダブルクリックされたかどうか、コントロールがサポートされていないこと、 <xref:System.Windows.Forms.Control.DoubleClick> 、イベント、<xref:System.Windows.Forms.Control.Click>イベントを 2 回発生する可能性があります。  
  
 設定する必要があります、`StandardClick`の値<xref:System.Windows.Forms.ControlStyles>に`true`このイベントが発生します。  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
## <a name="notes-to-inheritors"></a>継承時の注意

標準の Windows フォーム コントロールから継承して、変更、`StandardClick`または`StandardDoubleClick`値<xref:System.Windows.Forms.ControlStyles>に`true`予期しない動作が発生したり、影響を与えるありませんすべてのコントロールがサポートされていない場合、<xref:System.Windows.Forms.Control.Click>または<xref:System.Windows.Forms.Control.DoubleClick>イベント。
  
次の表に、Windows フォーム コントロールとイベント (<xref:System.Windows.Forms.Control.Click>または<xref:System.Windows.Forms.Control.DoubleClick>) で指定したマウス アクションへの応答が発生します。

| コントロール | マウスの左クリック | マウスの左ダブル クリックします | マウスの右クリックします | マウスの右ダブル クリックします | マウスの中央クリック | マウスの中央をダブルクリックします。 | XButton1 マウスのクリック | マウスの XButton1 ダブルクリック | XButton2 マウスのクリック | XButton2 マウスのダブルクリック | 
| ------- | ---------------- | ----------------------- | ----------------- | ------------------------ | ------------------ | ------------------------- | -------------------- | --------------------------- | -------------------- | --------------------------- |
| <xref:System.Windows.Forms.MonthCalendar>, <xref:System.Windows.Forms.DateTimePicker>, <xref:System.Windows.Forms.HScrollBar>, <xref:System.Windows.Forms.VScrollBar> | none | none | none | none | none | none | none | none | none | none |
| <xref:System.Windows.Forms.Button>, <xref:System.Windows.Forms.CheckBox>, <xref:System.Windows.Forms.RichTextBox>, <xref:System.Windows.Forms.RadioButton> | ここを | をクリックしてください | none | none | none | none | none | none | none | none |
| <xref:System.Windows.Forms.ListBox>、 <xref:System.Windows.Forms.CheckedListBox>、 <xref:System.Windows.Forms.ComboBox> | ここを | クリック、ダブルクリック | none | none | none | none | none | none | none | none |
| <xref:System.Windows.Forms.TextBox>、 <xref:System.Windows.Forms.DomainUpDown>、 <xref:System.Windows.Forms.NumericUpDown> | ここを | クリック、ダブルクリック | none | none | none | none | none | none | none | none |
| \* <xref:System.Windows.Forms.TreeView>, \* <xref:System.Windows.Forms.ListView> | ここを | クリック、ダブルクリック | ここを | クリック、ダブルクリック | none | none | none | none | none | none |
| <xref:System.Windows.Forms.ProgressBar>、 <xref:System.Windows.Forms.TrackBar> | ここを | をクリックしてください | ここを | をクリックしてください | ここを | をクリックしてください | ここを | をクリックしてください | ここを | をクリックしてください |
| <xref:System.Windows.Forms.Form>, <xref:System.Windows.Forms.DataGrid>, <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.LinkLabel>, <xref:System.Windows.Forms.Panel>, <xref:System.Windows.Forms.GroupBox>, <xref:System.Windows.Forms.PictureBox>, <xref:System.Windows.Forms.Splitter>, <xref:System.Windows.Forms.StatusBar>, <xref:System.Windows.Forms.ToolBar>, <xref:System.Windows.Forms.TabPage>, \*\* <xref:System.Windows.Forms.TabControl> | ここを | クリック、ダブルクリック | ここを | クリック、ダブルクリック | ここを | クリック、ダブルクリック | ここを | クリック、ダブルクリック | ここを | クリック、ダブルクリック |

\* 子オブジェクトの上にマウス ポインターがある必要があります (<xref:System.Windows.Forms.TreeNode>または<xref:System.Windows.Forms.ListViewItem>)。  
  
 * *、<xref:System.Windows.Forms.TabControl>が少なくとも 1 つ<xref:System.Windows.Forms.TabPage>でその<xref:System.Windows.Forms.TabControl.TabPages>コレクション。

## Examples  
 次のコード例は、<xref:System.Windows.Forms.Control.Click>イベント ハンドラーでイベント。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのクライアント領域を表す四角形を取得します。</summary>
        <value>コントロールのクライアント領域を表す <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのクライアント領域は、スクロール バー、罫線、タイトル バー、メニューなどの非クライアント要素マイナス、コントロールの境界です。  
  
 クライアント座標では、コントロールのクライアント領域の左上隅に対して相対的であるために、このプロパティによって返される四角形の左上隅の座標は、(0, 0) になります。 このプロパティを使用して、コントロールの表面の描画などのタスクに対して、コントロールのクライアント領域の座標とサイズを取得することができます。  
  
 コントロールの描画に関する詳細については、次を参照してください。 [Windows フォーム コントロールのレンダリング](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)します。  
  
   
  
## Examples  
 次のコード例は、フォームでの自動スクロールを有効、フォームのサイズを変更して、により、フォームのサイズが変更された後、ボタンが表示されるようになります。 この例が必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Button>という名前の`button2`にします。  
  
 [!code-cpp[Windows.Forms.Control Member5#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#2)]
 [!code-csharp[Windows.Forms.Control Member5#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#2)]
 [!code-vb[Windows.Forms.Control Member5#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.ClientSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.ClientSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのクライアント領域の高さと幅を取得または設定します。</summary>
        <value>コントロールのクライアント領域の大きさを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのクライアント領域は、スクロール バー、罫線、タイトル バー、メニューなどの非クライアント要素マイナス、コントロールの境界です。 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A>を設定するメソッドが呼び出される、<xref:System.Windows.Forms.Control.ClientSize%2A>プロパティ。 <xref:System.Windows.Forms.Control.ClientSize%2A>プロパティは、常にでは変更されませんその`set`メソッドをオーバーライドするため、 <xref:System.Windows.Forms.Control.SetClientSizeCore%2A> 、コードが実行されることを確認する方法と、<xref:System.Windows.Forms.Control.ClientSize%2A>プロパティを設定します。  
  
 <xref:System.Drawing.Size.Width%2A?displayProperty=nameWithType>と<xref:System.Drawing.Size.Height%2A?displayProperty=nameWithType>プロパティは、コントロールのクライアント領域の高さと幅を表します。 このプロパティを使用して、コントロールの表面の描画などのタスクのコントロールのクライアント領域のサイズを取得することができます。  
  
 コントロールの描画に関する詳細については、次を参照してください。 [Windows フォーム コントロールのレンダリング](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)します。  
  
> [!NOTE]
>  アプリケーションの設定は、このプロパティにバインドすることはできません。 アプリケーションの設定の詳細については、次を参照してください。[アプリケーション設定の概要](~/docs/framework/winforms/advanced/application-settings-overview.md)します。  
  
   
  
## Examples  
 次のコード例では、コントロールは、その書式設定されたテキストを可能になりますので、指定したコントロールがサイズ変更します。 書式設定されたテキストは、<xref:System.Windows.Forms.Control.Text%2A>コントロールとプロパティの割り当て済み<xref:System.Windows.Forms.Control.Font%2A>テキストに適用します。 `AutoSizeControl`この例ではメソッドがあります、`textPadding`コントロールのすべての端に適用する余白を表すパラメーター。 埋め込みをするためには、文字列を揃えます。、<xref:System.Drawing.ContentAlignment.MiddleCenter?displayProperty=nameWithType>値、コントロールがサポートされている場合。  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="T:System.Windows.Forms.DrawMode" />
      </Docs>
    </Member>
    <Member MemberName="ClientSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ClientSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ClientSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ClientSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ClientSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ClientSizeChanged;" />
      <MemberSignature Language="F#" Value="member this.ClientSizeChanged : EventHandler " Usage="member this.ClientSizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ClientSize" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.ClientSizeChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.ClientSizeChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#12)]
 [!code-vb[System.Windows.Forms.EventExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompanyName">
      <MemberSignature Language="C#" Value="public string CompanyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CompanyName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CompanyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CompanyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CompanyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CompanyName : string" Usage="System.Windows.Forms.Control.CompanyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Description("ControlCompanyNameDescr")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを含んでいるアプリケーションの会社または作成者の名前を取得します。</summary>
        <value>コントロールを含んでいるアプリケーションの会社または作成者の名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CompanyName%2A>プロパティは読み取り専用プロパティです。 このプロパティの値を変更するには、設定、<xref:System.Reflection.AssemblyCompanyAttribute.Company%2A>プロパティの値、<xref:System.Reflection.AssemblyCompanyAttribute>します。 次の C# コードのセットの行、<xref:System.Windows.Forms.Control.CompanyName%2A>プロパティ。  
  
```csharp  
[assembly: AssemblyCompany("Microsoft")]  
```  
  
> [!NOTE]
>  アプリの会社名、製品名、および製品バージョンを提供することを強くお勧めします。  
  
   
  
## Examples  
 次のコード例で、アプリケーションに関する情報を表示する、<xref:System.Windows.Forms.Label>に含まれる、<xref:System.Windows.Forms.Form>します。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.CompanyName%2A>、<xref:System.Windows.Forms.Control.ProductName%2A>と<xref:System.Windows.Forms.Control.ProductVersion%2A>が設定されています。  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyCompanyAttribute.Company" />
        <altmember cref="P:System.Diagnostics.FileVersionInfo.CompanyName" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (System.Windows.Forms.Control ctl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(class System.Windows.Forms.Control ctl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Contains(System.Windows.Forms.Control)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (ctl As Control) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::Windows::Forms::Control ^ ctl);" />
      <MemberSignature Language="F#" Value="member this.Contains : System.Windows.Forms.Control -&gt; bool" Usage="control.Contains ctl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
      </Parameters>
      <Docs>
        <param name="ctl">評価する <see cref="T:System.Windows.Forms.Control" />。</param>
        <summary>指定したコントロールが、コントロールの子かどうかを示す値を取得します。</summary>
        <returns>指定したコントロールがコントロールの子である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、確実、<xref:System.Windows.Forms.Label>が呼び出すことによって表示されるその<xref:System.Windows.Forms.Control.BringToFront%2A>メソッド。 この例が必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.Panel>という名前`panel1`、および<xref:System.Windows.Forms.Label>という名前`label1`します。  
  
 [!code-cpp[Windows.Forms.Control Members4#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members4#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#1)]
 [!code-vb[Windows.Forms.Control Members4#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ControlCollection.Contains(System.Windows.Forms.Control)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="ContainsFocus">
      <MemberSignature Language="C#" Value="public bool ContainsFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContainsFocus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ContainsFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ContainsFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsFocus : bool" Usage="System.Windows.Forms.Control.ContainsFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール、またはその子コントロールの 1 つに、現在入力フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>コントロール、またはその子コントロールの 1 つに、現在入力フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを使用して、コントロール、またはそれに含まれるコントロールのいずれかに入力フォーカスがあるかどうかを判断することができます。 コントロールにフォーカスがあるかどうかの子コントロールのいずれかに関係なく、フォーカスがあるかどうかを判断するには使用、<xref:System.Windows.Forms.Control.Focused%2A>プロパティ。 コントロールに入力フォーカスを移すを使用して、<xref:System.Windows.Forms.Control.Focus%2A>または<xref:System.Windows.Forms.Control.Select%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenu ^ ContextMenu { System::Windows::Forms::ContextMenu ^ get(); void set(System::Windows::Forms::ContextMenu ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenu : System.Windows.Forms.ContextMenu with get, set" Usage="System.Windows.Forms.Control.ContextMenu" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに関連付けられたショートカット メニューを取得または設定します。</summary>
        <value>コントロールに関連付けられたショートカット メニューを表す <see cref="T:System.Windows.Forms.ContextMenu" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ショートカット メニューを使用して、コントロールを右クリックすると、特定のコンテキスト メニュー オプションをユーザーに付与します。  
  
   
  
## Examples  
 次のコード例が表示されます、<xref:System.Windows.Forms.ContextMenu>に割り当てられている、<xref:System.Windows.Forms.TreeView>がマウスの右ボタンのクリックされた場合と解放します。 このコードが必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.TreeView>にします。 必要ですが、<xref:System.Windows.Forms.TreeView>が、<xref:System.Windows.Forms.ContextMenu>に割り当てられているその<xref:System.Windows.Forms.Control.ContextMenu%2A>プロパティ。  
  
 [!code-cpp[Windows.Forms.Control Properties2#5](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#5)]
 [!code-csharp[Windows.Forms.Control Properties2#5](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#5)]
 [!code-vb[Windows.Forms.Control Properties2#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.ContextMenu" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.ContextMenu" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.ContextMenu" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuChanged : EventHandler " Usage="member this.ContextMenuChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ContextMenu" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.ContextMenu%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、ショートカット メニューに変更が発生したときに、メッセージが表示されます。  
  
 [!code-cpp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CPP/control_contextmenu_creategraphics.cpp#2)]
 [!code-csharp[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/CS/control_contextmenu_creategraphics.cs#2)]
 [!code-vb[Control_ContextMenu_CreateGraphics#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_ContextMenu_CreateGraphics/VB/control_contextmenu_creategraphics.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
        <altmember cref="T:System.Windows.Forms.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStrip">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.ContextMenuStrip ContextMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ContextMenuStrip ContextMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ContextMenuStrip As ContextMenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ContextMenuStrip ^ ContextMenuStrip { System::Windows::Forms::ContextMenuStrip ^ get(); void set(System::Windows::Forms::ContextMenuStrip ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStrip : System.Windows.Forms.ContextMenuStrip with get, set" Usage="System.Windows.Forms.Control.ContextMenuStrip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContextMenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられている <see cref="T:System.Windows.Forms.ContextMenuStrip" /> を取得または設定します。</summary>
        <value>このコントロールの <see cref="T:System.Windows.Forms.ContextMenuStrip" />。<see langword="null" /> がない場合は <see cref="T:System.Windows.Forms.ContextMenuStrip" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、 <xref:System.Windows.Forms.ContextMenu> 、コントロールに割り当てられても、<xref:System.Windows.Forms.ContextMenu>よりも優先、<xref:System.Windows.Forms.ContextMenuStrip>します。  
  
   
  
## Examples  
 次のコード例は、3 つ追加する方法を示します<xref:System.Windows.Forms.ToolStripMenuItem>オブジェクトを<xref:System.Windows.Forms.ContextMenuStrip>します。 さらに設定を示します、<xref:System.Windows.Forms.Control.ContextMenuStrip%2A>フォームのプロパティ。  
  
 [!code-csharp[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.ContextMenuStrip#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.ContextMenuStrip/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuStripChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ContextMenuStripChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContextMenuStripChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ContextMenuStripChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuStripChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ContextMenuStripChanged;" />
      <MemberSignature Language="F#" Value="member this.ContextMenuStripChanged : EventHandler " Usage="member this.ContextMenuStripChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ContextMenuStrip" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.ContextMenuStripChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.ContextMenuStripChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#14)]
 [!code-vb[System.Windows.Forms.EventExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ControlAdded">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlAdded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlAdded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlAdded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlAdded As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlAdded;" />
      <MemberSignature Language="F#" Value="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlAdded : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>新しいコントロールが <see cref="T:System.Windows.Forms.Control.ControlCollection" /> に追加されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlAdded>をフォームにコントロールを追加するで追加したコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>します。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ControlRemoved">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ControlEventHandler ControlRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ControlEventHandler ControlRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ControlRemoved" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ControlRemoved As ControlEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ControlEventHandler ^ ControlRemoved;" />
      <MemberSignature Language="F#" Value="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " Usage="member this.ControlRemoved : System.Windows.Forms.ControlEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.Control.ControlCollection" /> からコントロールが削除されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlRemoved>フォームからコントロールを削除するで削除されたコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>します。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control/ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Controls" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Controls As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control::ControlCollection ^ Controls { System::Windows::Forms::Control::ControlCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Controls : System.Windows.Forms.Control.ControlCollection" Usage="System.Windows.Forms.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール内に格納されているコントロールのコレクションを取得します。</summary>
        <value>コントロール内に格納されているコントロールのコレクションを表す <see cref="T:System.Windows.Forms.Control.ControlCollection" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.Forms.Control>コントロールのコレクションの親として機能できます。 たとえば、いくつかのコントロールが追加されたときに、<xref:System.Windows.Forms.Form>のメンバーである各コントロール、<xref:System.Windows.Forms.Control.ControlCollection>に割り当てられている、<xref:System.Windows.Forms.Control.Controls%2A>から派生すると、フォームのプロパティ、<xref:System.Windows.Forms.Control>クラス。  
  
 内のコントロールを操作することができます、<xref:System.Windows.Forms.Control.ControlCollection>に割り当てられている、<xref:System.Windows.Forms.Control.Controls%2A>プロパティで使用できるメソッドを使用して、<xref:System.Windows.Forms.Control.ControlCollection>クラス。  
  
 いくつかのコントロールを親コントロールを追加する場合は、呼び出すことをお勧めしますが、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを追加するコントロールを初期化する前にします。 親コントロールにコントロールを追加した後、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド。 そうと、多くのコントロールを持つアプリケーションのパフォーマンスが向上します。  
  
 使用して、<xref:System.Windows.Forms.Control.Controls%2A>を入れ子になったコントロールを含む、フォームのコントロールすべてを反復処理するプロパティ。 使用して、<xref:System.Windows.Forms.Control.GetNextControl%2A>タブ オーダーの前または次の子コントロールを取得します。 使用して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティを取得またはコンテナー コントロールのアクティブなコントロールを設定します。  
  
   
  
## Examples  
 次のコード例の削除、<xref:System.Windows.Forms.Control>から、<xref:System.Windows.Forms.Control.ControlCollection>派生クラスの<xref:System.Windows.Forms.Panel>コレクションのメンバーである場合。 例では、作成済みである必要があります、 <xref:System.Windows.Forms.Panel>、 <xref:System.Windows.Forms.Button>、少なくとも 1 つと<xref:System.Windows.Forms.RadioButton>の control 権限、 <xref:System.Windows.Forms.Form>。 <xref:System.Windows.Forms.RadioButton>にコントロールを追加、<xref:System.Windows.Forms.Panel>コントロール、および<xref:System.Windows.Forms.Panel>に追加されたコントロール、<xref:System.Windows.Forms.Form>します。 ラジオ ボタンの名前、ボタンがクリックされたときに`removeButton`から削除されて、<xref:System.Windows.Forms.Control.ControlCollection>します。  
  
 [!code-cpp[ControlCollection#4](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlCollection/CPP/controlcollection.cpp#4)]
 [!code-csharp[ControlCollection#4](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlCollection/CS/controlcollection.cs#4)]
 [!code-vb[ControlCollection#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlCollection/VB/controlcollection.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
      </Docs>
    </Member>
    <Member MemberName="CreateAccessibilityInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject CreateAccessibilityInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject CreateAccessibilityInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateAccessibilityInstance () As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ CreateAccessibilityInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.CreateAccessibilityInstance : unit -&gt; System.Windows.Forms.AccessibleObject" Usage="control.CreateAccessibilityInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの新しいユーザー補助オブジェクトを作成します。</summary>
        <returns>コントロールの新しい <see cref="T:System.Windows.Forms.AccessibleObject" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 明示的に <xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A> メソッドを呼び出さない場合は、<xref:System.Windows.Forms.Control.AccessibilityObject%2A> プロパティが参照されると呼び出されます。  
  
> [!NOTE]
>  取得または設定する、<xref:System.Windows.Forms.Control.AccessibilityObject%2A>プロパティへの参照を追加する必要があります、`Accessibility`と一緒にインストールされたアセンブリ、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]します。  
  
   
  
## Examples  
 ユーザー補助対応のグラフの作成を次のコード例に示しますを使用して、制御、<xref:System.Windows.Forms.AccessibleObject>と<xref:System.Windows.Forms.Control.ControlAccessibleObject>アクセス可能な情報を公開するクラス。 コントロールは、凡例と共に 2 つの曲線をプロットします。 `ChartControlAccessibleObject`から派生したクラス`ControlAccessibleObject`で使用されて、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>グラフ コントロールのカスタムのアクセス可能な情報を提供するメソッド。 グラフの凡例は、実際はないため<xref:System.Windows.Forms.Control>-ベースの制御が描画される代わりに、グラフ コントロールではなく組み込みアクセス可能な情報。 このため、`ChartControlAccessibleObject`オーバーライド、<xref:System.Windows.Forms.AccessibleObject.GetChild%2A>を返すメソッドを`CurveLegendAccessibleObject`凡例の各部分にアクセスできる情報を表します。 ユーザー補助対応アプリケーションでは、このコントロールを使用すると、コントロールは、アクセスに必要な情報を提供できます。  
  
 このコードの抜粋を示しますのオーバーライド、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>メソッド。 参照してください、<xref:System.Windows.Forms.AccessibleObject>完全なコード例では、クラスの概要。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#2)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#2)]
 [!code-vb[System.Windows.Forms.AccessibleObject#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />、派生クラスでない呼び出すのでは、基本クラスの<see cref="M:System.Windows.Forms.Control.CreateAccessibilityInstance" />メソッド。</para></block>
        <altmember cref="T:System.Windows.Forms.Control.ControlAccessibleObject" />
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="CreateControl">
      <MemberSignature Language="C#" Value="public void CreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControl" />
      <MemberSignature Language="VB.NET" Value="Public Sub CreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CreateControl();" />
      <MemberSignature Language="F#" Value="member this.CreateControl : unit -&gt; unit" Usage="control.CreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>ハンドルおよび子コントロールの作成を含めて、強制的に表示子コントロールを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateControl%2A>メソッドは、コントロールとその子コントロールの作成を識別するハンドルを強制します。 コントロールまたはその子の操作のためのハンドルが直ちに必要時にこのメソッドが使用されます。単に呼び出し元コントロールのコンス トラクターは作成されません、<xref:System.Windows.Forms.Control.Handle%2A>します。  
  
 <xref:System.Windows.Forms.Control.CreateControl%2A> 場合、コントロール ハンドルを作成できませんが、コントロールの<xref:System.Windows.Forms.Control.Visible%2A>プロパティは`false`。 いずれかの呼び出し、<xref:System.Windows.Forms.Control.CreateHandle%2A>メソッドまたはアクセス、<xref:System.Windows.Forms.Control.Handle%2A>プロパティ、コントロールの作成を処理、コントロールの可視性に関係なくが、今回は、ウィンドウ ハンドルは、コントロールの子を作成します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberSignature Language="F#" Value="abstract member CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection&#xA;override this.CreateControlsInstance : unit -&gt; System.Windows.Forms.Control.ControlCollection" Usage="control.CreateControlsInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのコントロール コレクションの新しいインスタンスを作成します。</summary>
        <returns>コントロールに割り当てられた <see cref="T:System.Windows.Forms.Control.ControlCollection" /> の新しいインスタンス。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このメソッドの基本クラスのバージョンは、派生クラスによって呼び出されませんする必要があります。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="Created">
      <MemberSignature Language="C#" Value="public bool Created { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Created" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Created" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Created As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Created { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Created : bool" Usage="System.Windows.Forms.Control.Created" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが作成されているかどうかを示す値を取得します。</summary>
        <value>コントロールが作成されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Created%2A>プロパティが返す`true`場合、<xref:System.Windows.Forms.Control>場合でも、コントロールのハンドル可能性がありますいない作成または再作成がまだ正常に作成されました。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.OnCreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="CreateGraphics">
      <MemberSignature Language="C#" Value="public System.Drawing.Graphics CreateGraphics ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Drawing.Graphics CreateGraphics() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateGraphics" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateGraphics () As Graphics" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Graphics ^ CreateGraphics();" />
      <MemberSignature Language="F#" Value="member this.CreateGraphics : unit -&gt; System.Drawing.Graphics" Usage="control.CreateGraphics " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Graphics</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの <see cref="T:System.Drawing.Graphics" /> を作成します。</summary>
        <returns>コントロールの <see cref="T:System.Drawing.Graphics" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Graphics>を通じて取得するオブジェクト、<xref:System.Windows.Forms.Control.CreateGraphics%2A>メソッドは通常は保持されません、現在の Windows メッセージの処理が完了した後 WM_PAINT メッセージを次にそのオブジェクトで描画されるものが消去されるため、します。 そのためキャッシュすることはできません、<xref:System.Drawing.Graphics>などのメソッドを非表示に使用する以外、再利用するためのオブジェクト<xref:System.Drawing.Graphics.MeasureString%2A?displayProperty=nameWithType>します。 代わりに、呼び出す必要がある<xref:System.Windows.Forms.Control.CreateGraphics%2A>を使用するたびに、<xref:System.Drawing.Graphics>オブジェクトを呼び出して<xref:System.Drawing.Graphics.Dispose%2A>使用が終了したら。 Windows メッセージの詳細については、次を参照してください。<xref:System.Windows.Forms.Control.WndProc%2A>します。  
  
 仕様上、<xref:System.Windows.Forms.Control.CreateGraphics%2A>所有権を呼び出し元のスレッドに設定し、他のスレッドで呼び出される場合は失敗します。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティはスレッド セーフであるコントロールの 4 つの方法があります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しにはコントロールのスレッドへの呼び出しをマーシャ リングするのに invoke メソッドのいずれかを使用する必要があります。  
  
   
  
## Examples  
 次のコード例では、コントロールは、その書式設定されたテキストを可能になりますので、指定したコントロールがサイズ変更します。 書式設定されたテキストは、<xref:System.Windows.Forms.Control.Text%2A>コントロールとプロパティの割り当て済み<xref:System.Windows.Forms.Control.Font%2A>テキストに適用します。 `AutoSizeControl`この例ではメソッドがあります、`textPadding`コントロールのすべての端に適用する余白を表すパラメーター。 等しく見える埋め込みをするためには、文字列を揃えます。、 `MiddleCenter` @property<xref:System.Drawing.ContentAlignment?displayProperty=nameWithType>コントロールでサポートされている場合。  
  
 [!code-cpp[Windows.Forms.Control Member5#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CPP/controlmembers5.cpp#1)]
 [!code-csharp[Windows.Forms.Control Member5#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Member5/CS/controlmembers5.cs#1)]
 [!code-vb[Windows.Forms.Control Member5#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Member5/VB/controlmembers5.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すセーフ サブウィンドウします。 列挙型に関連付けられている: <see langword="SafeSubWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="T:System.Drawing.Graphics" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected virtual void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CreateHandle();" />
      <MemberSignature Language="F#" Value="abstract member CreateHandle : unit -&gt; unit&#xA;override this.CreateHandle : unit -&gt; unit" Usage="control.CreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのハンドルを作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、呼び出す必要はありません、<xref:System.Windows.Forms.Control.CreateHandle%2A>メソッドを直接します。 優先メソッドを呼び出すことです、<xref:System.Windows.Forms.Control.CreateControl%2A>メソッドで、強制的にコントロールが作成されたときに、コントロールとその子コントロールの作成を識別するハンドル。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">オブジェクトは破棄された状態です。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.CreateHandle" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.CreateHandle" />ハンドルが作成されるようにするメソッド。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.Control.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール ハンドルが作成されるときに必要な作成パラメーターを取得します。</summary>
        <value>コントロールを識別するハンドルを作成するときに必要な作成パラメーターを格納している <see cref="T:System.Windows.Forms.CreateParams" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.CreateParams%2A>プロパティがオーバーライドされ、派生コントロールのプロパティを調整するために使用しない必要があります。 などのプロパティ、 <xref:System.Windows.Forms.CreateParams.Caption%2A?displayProperty=nameWithType>、 <xref:System.Windows.Forms.CreateParams.Width%2A?displayProperty=nameWithType>、および<xref:System.Windows.Forms.CreateParams.Height%2A?displayProperty=nameWithType>などのコントロールでの対応するプロパティを設定する必要があります<xref:System.Windows.Forms.Control.Text%2A?displayProperty=nameWithType>、<xref:System.Windows.Forms.Control.Width%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.Control.Height%2A?displayProperty=nameWithType>します。 <xref:System.Windows.Forms.CreateParams>標準の Windows コントロール クラスをラップするか、スタイルを設定するには Windows フォームの名前空間で指定されていない場合にのみ拡張する必要があります。 コントロールのパラメーターを作成する方法の詳細については、次を参照してください。、`CreateWindow`と`CreateWindowEx`関数と[CREATESTRUCT](https://msdn.microsoft.com/library/windows/desktop/ms632603.aspx)ドキュメントの構造体。  
  
   
  
## Examples  
 次のコード例では拡張、<xref:System.Windows.Forms.Control.CreateParams%2A>のプロパティを<xref:System.Windows.Forms.Button>クラスを派生します。 <xref:System.Windows.Forms.CreateParams.Style%2A?displayProperty=nameWithType>プロパティを変更すると、それが原因で表示するボタン、<xref:System.Drawing.Icon>なく<xref:System.Drawing.Image>します。 この例では、継承するクラスが必要です、<xref:System.Windows.Forms.Button>クラス。  
  
 [!code-cpp[CreateParams#3](~/samples/snippets/cpp/VS_Snippets_Winforms/CreateParams/CPP/createparams.cpp#3)]
 [!code-csharp[CreateParams#3](~/samples/snippets/csharp/VS_Snippets_Winforms/CreateParams/CS/createparams.cs#3)]
 [!code-vb[CreateParams#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/CreateParams/VB/createparams.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">プロパティ値を取得するときに、アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.CreateParams" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.CreateParams" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。</para></block>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Cursor ^ Cursor { System::Windows::Forms::Cursor ^ get(); void set(System::Windows::Forms::Cursor ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Cursor : System.Windows.Forms.Cursor with get, set" Usage="System.Windows.Forms.Control.Cursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロールの上にあるときに表示されるカーソルを取得または設定します。</summary>
        <value>マウス ポインターがコントロールの上にあるときに表示されるカーソルを表す <see cref="T:System.Windows.Forms.Cursor" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 割り当てる、<xref:System.Windows.Forms.Cursor>を<xref:System.Windows.Forms.Control.Cursor%2A>マウス ポインターがコントロールに表示されるカーソルを変更するコントロールのプロパティ。 設定、アプリケーションのすべてのコントロールのマウス カーソルを一時的に変更する、<xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>プロパティ。 通常は設定、<xref:System.Windows.Forms.Cursor.Current%2A?displayProperty=nameWithType>プロパティを設定するときに待機カーソルを<xref:System.Windows.Forms.ComboBox>ファイルの読み込みまたは保存します。  
  
 <xref:System.Windows.Forms.Control.Cursor%2A>プロパティは、アンビエント プロパティです。 アンビエントのプロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>が、同じ<xref:System.Windows.Forms.Control.BackColor%2A>親として<xref:System.Windows.Forms.Form>既定では。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要。  
  
   
  
## Examples  
 次のコード例の塗りつぶしを<xref:System.Windows.Forms.ComboBox>ユーザーの利用可能な論理ドライブとします。 コンボ ボックスの設定も<xref:System.Windows.Forms.Cursor>プロパティのため、<xref:System.Windows.Forms.Cursors.Hand%2A?displayProperty=nameWithType>ドロップダウン ボタンの上にマウス ポインターがときに、カーソルが表示されます。 このコードが必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.ComboBox>にします。  
  
 [!code-cpp[Windows.Forms.Control Properties2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を設定するセーフ サブウィンドウします。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeSubWindows" /></permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.Cursor" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.Cursor" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のメソッド、<see cref="P:System.Windows.Forms.Control.Cursor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursors" />
      </Docs>
    </Member>
    <Member MemberName="CursorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler CursorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CursorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.CursorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event CursorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ CursorChanged;" />
      <MemberSignature Language="F#" Value="member this.CursorChanged : EventHandler " Usage="member this.CursorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Cursor" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Cursor%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 マウス カーソルを使用して、変更する次のコード例に示します、<xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType>プロパティ、<xref:System.Windows.Forms.Cursor>クラス、および<xref:System.Windows.Forms.Cursors>クラス。 例を含むフォームを作成します、<xref:System.Windows.Forms.ComboBox>コントロール、<xref:System.Windows.Forms.Panel>コントロール、および<xref:System.Windows.Forms.ListView>コントロール。 <xref:System.Windows.Forms.ComboBox>によって提供されるすべてのカーソルが含まれています、<xref:System.Windows.Forms.Cursors>クラス。 ユーザーがマウス カーソルを選択すると、 <xref:System.Windows.Forms.ComboBox>、<xref:System.Windows.Forms.Control.Cursor%2A?displayProperty=nameWithType>のカーソルの更新、選択されたカーソルに設定されて、<xref:System.Windows.Forms.Panel>します。 <xref:System.Windows.Forms.ListView>たびに、更新は、<xref:System.Windows.Forms.Control.CursorChanged?displayProperty=nameWithType>イベントが発生します。  
  
 [!code-cpp[System.Windows.Forms.Cursors#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CPP/cursorexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.Cursors#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Cursors/CS/cursorexample.cs#1)]
 [!code-vb[System.Windows.Forms.Cursors#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Cursors/VB/cursorexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
        <altmember cref="T:System.Windows.Forms.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="DataBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ControlBindingsCollection DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ControlBindingsCollection DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DataBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DataBindings As ControlBindingsCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ControlBindingsCollection ^ DataBindings { System::Windows::Forms::ControlBindingsCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DataBindings : System.Windows.Forms.ControlBindingsCollection" Usage="System.Windows.Forms.Control.DataBindings" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IBindableComponent.DataBindings</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.All)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ControlBindingsCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのデータ連結を取得します。</summary>
        <value>コントロールの <see cref="T:System.Windows.Forms.ControlBindingsCollection" /> オブジェクトを格納している <see cref="T:System.Windows.Forms.Binding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.DataBindings%2A>プロパティにアクセスする、<xref:System.Windows.Forms.ControlBindingsCollection>します。 追加することで<xref:System.Windows.Forms.Binding>コレクションにオブジェクトをオブジェクトのプロパティに、コントロールのプロパティをバインドすることができます。  
  
   
  
## Examples  
 次のコード例を追加<xref:System.Windows.Forms.Binding>オブジェクトを<xref:System.Windows.Forms.ControlBindingsCollection>5 つのコントロール: 4 つ<xref:System.Windows.Forms.TextBox>コントロールと<xref:System.Windows.Forms.DateTimePicker>コントロール。 <xref:System.Windows.Forms.ControlBindingsCollection> には、<xref:System.Windows.Forms.Control.DataBindings%2A> クラスの <xref:System.Windows.Forms.Control> プロパティを使用してアクセスします。  
  
 [!code-cpp[Classic Control.DataBindings Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.DataBindings Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.DataBindings Example/CS/source.cs#1)]
 [!code-vb[Classic Control.DataBindings Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.DataBindings Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.BindingContext" />
        <altmember cref="T:System.Windows.Forms.Binding" />
        <altmember cref="T:System.Windows.Forms.BindingManagerBase" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBackColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultBackColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultBackColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBackColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の背景色を取得します。</summary>
        <value>コントロールの既定の背景の <see cref="T:System.Drawing.Color" />。 既定値は、<see cref="P:System.Drawing.SystemColors.Control" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、既定値<xref:System.Windows.Forms.Control.BackColor%2A>汎用トップレベル コントロールのプロパティの値。 派生クラスには、既定値は異なることができます。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>、 <xref:System.Windows.Forms.Control.DefaultFont%2A>、および<xref:System.Windows.Forms.Control.DefaultForeColor%2A>メンバー。 例を実行するには、格納しているフォームに次のコードを貼り付け、 <xref:System.Windows.Forms.ListBox> ListBox1 と呼ばれます。 呼び出す、`Populate_ListBox`フォームのコンス トラクターのメソッドまたは<xref:System.Windows.Forms.Form.Load>イベント処理メソッド。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultCursor">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Cursor DefaultCursor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Cursor DefaultCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultCursor" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultCursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Cursor ^ DefaultCursor { System::Windows::Forms::Cursor ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCursor : System.Windows.Forms.Cursor" Usage="System.Windows.Forms.Control.DefaultCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のカーソルを取得または設定します。</summary>
        <value>現在の既定のカーソルを表す <see cref="T:System.Windows.Forms.Cursor" /> 型のオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オーバーライド<xref:System.Windows.Forms.Control.DefaultCursor%2A>コントロールの既定のカーソルを構成します。 これは、コントロールのコンス トラクターでカーソルを設定するよりも効率的であり、特定のカーソルに関連するデザイナー関数の自動サポートを提供します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultFont">
      <MemberSignature Language="C#" Value="public static System.Drawing.Font DefaultFont { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Drawing.Font DefaultFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultFont" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Font ^ DefaultFont { System::Drawing::Font ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultFont : System.Drawing.Font" Usage="System.Windows.Forms.Control.DefaultFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のフォントを取得します。</summary>
        <value>コントロールの既定の <see cref="T:System.Drawing.Font" />。 返される値は、ユーザーのオペレーティング システム、およびシステムのローカル カルチャの設定によって異なります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 次の表に、によって返される値<xref:System.Windows.Forms.Control.DefaultFont%2A>オペレーティング システムやローカル カルチャによって異なります。  
  
|システム/、またはカルチャ|フォント|  
|----------------------------|----------|  
|X、日本語版の Windows NT 4|MS UI Gothic、9 ポイント。|  
|アラビア語の Windows|Tahoma、8 ポイント。|  
|その他のオペレーティング システム/カルチャ|MS Shell Dlg の論理フォント、通常 Microsoft San Serif 8 ポイントです。|  
  
 MS Shell Dlg フォント、システム レジストリの設定にマップします。  
  
 上記のフォントがインストールされていない場合、既定のフォントは、Tahoma、8 ポイントは。 Tahoma、8 ポイントがインストールされていない場合<xref:System.Windows.Forms.Control.DefaultFont%2A>の値を返します、<xref:System.Drawing.FontFamily.GenericSansSerif%2A>プロパティ  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>、 <xref:System.Windows.Forms.Control.DefaultFont%2A>、および<xref:System.Windows.Forms.Control.DefaultForeColor%2A>メンバー。 例を実行するには、格納しているフォームに次のコードを貼り付け、 <xref:System.Windows.Forms.ListBox> ListBox1 と呼ばれます。 呼び出す、`Populate_ListBox`フォームのコンス トラクターのメソッドまたは<xref:System.Windows.Forms.Form.Load>イベント処理メソッド。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">既定のフォントまたは地域設定の代替フォントが、クライアント コンピューターにインストールされていません。</exception>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="DefaultForeColor">
      <MemberSignature Language="C#" Value="public static System.Drawing.Color DefaultForeColor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Color DefaultForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Color DefaultForeColor { System::Drawing::Color get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultForeColor : System.Drawing.Color" Usage="System.Windows.Forms.Control.DefaultForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の前景色を取得します。</summary>
        <value>コントロールの既定の前景の <see cref="T:System.Drawing.Color" />。 既定値は、<see cref="P:System.Drawing.SystemColors.ControlText" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、既定値<xref:System.Windows.Forms.Control.ForeColor%2A>親のないコントロールのプロパティの値。 派生クラスには、既定値は異なることができます。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、 <xref:System.Windows.Forms.Control.DefaultBackColor%2A>、 <xref:System.Windows.Forms.Control.DefaultFont%2A>、および<xref:System.Windows.Forms.Control.DefaultForeColor%2A>メンバー。 例を実行するには、格納しているフォームに次のコードを貼り付け、 <xref:System.Windows.Forms.ListBox> ListBox1 と呼ばれます。 呼び出す、`Populate_ListBox`フォームのコンス トラクターのメソッドまたは<xref:System.Windows.Forms.Form.Load>イベント処理メソッド。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.DefaultImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがサポートしている既定の IME (Input Method Editor) モードを取得します。</summary>
        <value><see cref="T:System.Windows.Forms.ImeMode" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入力方式エディター (IME) は、標準キーボードを使用して複雑な文字と日本語の漢字などの記号を入力するようにするプログラムです。  
  
 実装されている、<xref:System.Windows.Forms.Control>クラスに、このプロパティは常に返します、<xref:System.Windows.Forms.ImeMode.Inherit?displayProperty=nameWithType>値。 <xref:System.Windows.Forms.ImeMode.Inherit>値では、IME モードが、親コントロールから継承されたことを指定します。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.DefaultImeMode%2A>オフ入力方式エディターを有効にするプロパティ。  
  
 [!code-cpp[Windows.Forms.Control Properties2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#4)]
 [!code-csharp[Windows.Forms.Control Properties2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#4)]
 [!code-vb[Windows.Forms.Control Properties2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.DefaultImeMode" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.DefaultImeMode" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。</para></block>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultMargin">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultMargin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMargin" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMargin As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultMargin { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMargin : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール間に既定で指定されている空白をピクセル単位で取得します。</summary>
        <value>コントロール間の既定の空白を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMaximumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMaximumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMaximumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の最大サイズとして指定されている長さおよび高さをピクセル単位で取得します。</summary>
        <value>コントロールのサイズを表す <see cref="M:System.Drawing.Point.#ctor(System.Drawing.Size)" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMinimumSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultMinimumSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultMinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultMinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultMinimumSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMinimumSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultMinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定の最小サイズとして指定されている長さおよび高さをピクセル単位で取得します。</summary>
        <value>コントロールのサイズを表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultPadding">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.Padding DefaultPadding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding DefaultPadding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultPadding" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultPadding As Padding" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::Padding DefaultPadding { System::Windows::Forms::Padding get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultPadding : System.Windows.Forms.Padding" Usage="System.Windows.Forms.Control.DefaultPadding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの内容の内部間隔をピクセル単位で取得します。</summary>
        <value>コントロールの内容の内部間隔を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの既定のサイズを取得します。</summary>
        <value>コントロールの既定の <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティを表します、<xref:System.Drawing.Size>のコントロールを最初から作成されているときにします。 コントロールのサイズを調整するには設定してその<xref:System.Windows.Forms.Control.Size%2A>プロパティの値。  
  
> [!NOTE]
>  優れたパフォーマンスを維持する設定しないで、<xref:System.Drawing.Size>コントロールのコンス トラクター。 推奨される方法は、オーバーライドする、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ。  
  
> [!NOTE]
>  Windows Server 2003 システムでのサイズ、<xref:System.Windows.Forms.Form>最大ピクセル幅と、モニターの高さによって制限されます。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ、なりフォーム 500 ピクセルの正方形の既定のサイズ。  
  
 [!code-cpp[Windows.Forms.Control Properties2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CPP/misccontrolproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties2/CS/misccontrolproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties2/VB/misccontrolproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="P:System.Windows.Forms.Control.DefaultSize" />派生クラスでプロパティは、返されることをお勧めです、<see cref="T:System.Drawing.Size" />目的のサイズではなく、すべての実装をオーバーライドします。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="T:System.Drawing.Size" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected virtual void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member DefWndProc :  -&gt; unit&#xA;override this.DefWndProc :  -&gt; unit" Usage="control.DefWndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理対象の Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>指定したメッセージを既定のウィンドウ プロシージャに送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows メッセージの処理に関する詳細については、次を参照してください。、 [WindowProc 関数](https://go.microsoft.com/fwlink/?LinkId=181565)します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DestroyHandle">
      <MemberSignature Language="C#" Value="protected virtual void DestroyHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DestroyHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DestroyHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub DestroyHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void DestroyHandle();" />
      <MemberSignature Language="F#" Value="abstract member DestroyHandle : unit -&gt; unit&#xA;override this.DestroyHandle : unit -&gt; unit" Usage="control.DestroyHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールに関連付けられたハンドルを破棄します。</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.DestroyHandle" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.DestroyHandle" />ハンドルが破棄されたことを確認するメソッド。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="DeviceDpi">
      <MemberSignature Language="C#" Value="public int DeviceDpi { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 DeviceDpi" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DeviceDpi" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DeviceDpi As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int DeviceDpi { int get(); };" />
      <MemberSignature Language="F#" Value="member this.DeviceDpi : int" Usage="System.Windows.Forms.Control.DeviceDpi" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが現在表示されているディスプレイ デバイスの DPI 値を取得します。</summary>
        <value>ディスプレイ デバイスの DPI 値。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DisplayRectangle">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Rectangle DisplayRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DisplayRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DisplayRectangle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DisplayRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Rectangle DisplayRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.DisplayRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.Control.DisplayRectangle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.Layout.IArrangedElement.DisplayRectangle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの表示領域を表す四角形を取得します。</summary>
        <value>コントロールの表示領域を表す <see cref="T:System.Drawing.Rectangle" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DisplayRectangle%2A>プロパティは、コントロールの表示領域のクライアントの四角形を返します。 基本コントロール クラスの場合これは、クライアントの四角形と等しいです。 ただし、コントロールを継承するときに、クライアント領域の表示領域が異なる場合、この変更が必要な場合があります。 表示する四角形が最も<xref:System.Drawing.Rectangle>コントロールを囲むこと、およびコントロールをレイアウトするために使用します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.DisplayRectangle" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.DisplayRectangle" />基本実装を拡張するプロパティ。 または、すべての実装を提供する必要があります。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="control.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Windows.Forms.Control" /> とその子コントロールが使用しているアンマネージド リソースを解放します。オプションで、マネージド リソースも解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドと<xref:System.Object.Finalize%2A>メソッド。`Dispose()` 保護された起動`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`します。 <xref:System.Object.Finalize%2A> 呼び出す`Dispose`で`disposing`に設定`false`します。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Windows.Forms.Control> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 オーバーライドするときに<see langword="Dispose(Boolean)" />の事前に呼び出したで以前破棄されたオブジェクトを参照しないように注意する<see langword="Dispose" />します。 実装する方法についての詳細は<see langword="Dispose(Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。  
  
詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Finalize メソッドをオーバーライドする](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Disposing">
      <MemberSignature Language="C#" Value="public bool Disposing { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Disposing" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Disposing" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Disposing As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Disposing { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Disposing : bool" Usage="System.Windows.Forms.Control.Disposing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基本 <see cref="T:System.Windows.Forms.Control" /> クラスが破棄処理中かどうかを示す値を取得します。</summary>
        <value>基本 <see cref="T:System.Windows.Forms.Control" /> クラスが破棄処理中の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返す場合`true`、基本<xref:System.Windows.Forms.Control>クラスが破棄処理中です。 コントロールが破棄されると、後に、有効な Windows のコントロールとして参照されなくなったことができます。 コントロールのインスタンスが破棄されると、場合でもガベージ コレクションをメモリから削除されるまでメモリにまだ保持がされます。 呼び出すことはできませんのコントロールが破棄されると、その<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="Dock">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.DockStyle Dock { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DockStyle Dock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Dock" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Dock As DockStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::DockStyle Dock { System::Windows::Forms::DockStyle get(); void set(System::Windows::Forms::DockStyle value); };" />
      <MemberSignature Language="F#" Value="member this.Dock : System.Windows.Forms.DockStyle with get, set" Usage="System.Windows.Forms.Control.Dock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DockStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの境界のうち、親コントロールにドッキングする境界を取得または設定します。また、コントロールのサイズが親コントロール内でどのように変化するかを決定します。</summary>
        <value><see cref="T:System.Windows.Forms.DockStyle" /> 値のいずれか。 既定値は、<see cref="F:System.Windows.Forms.DockStyle.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.Dock%2A>プロパティをコントロールが自動的にサイズ変更、親コントロールのサイズを変更します。 たとえば、設定<xref:System.Windows.Forms.Control.Dock%2A>に<xref:System.Windows.Forms.DockStyle.Left?displayProperty=nameWithType>により、コントロール自体を親コントロールの左端と連携させると、親コントロールのサイズを変更します。 コントロールをドッキングするは、Z オーダーで (深度) のフォームの z 軸に沿ってフォーム上のコントロールのビジュアル層である場合。  
  
 コントロールは、その親コンテナーの 1 辺にドッキングできる、またはすべての端にドッキングできるし、親コンテナーを入力します。  
  
 設定、<xref:System.Windows.Forms.Control.Margin%2A>ドッキングされたコントロールのプロパティは、そのコンテナーの端からの距離に影響を与えません。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Anchor%2A>と<xref:System.Windows.Forms.Control.Dock%2A>プロパティは相互に排他的です。 一度に 1 つだけを設定でき、最後に、設定が優先されます。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>および一部の一般的なプロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>フォームの上部に、グループ ボックス ドッキングし、グループ ボックスのプロパティ。 グループ ボックスを無効に設定して、最後に、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックス内に含まれるすべてのコントロール。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">代入された値が、<see cref="T:System.Windows.Forms.DockStyle" /> 値ではありません。</exception>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.Dock" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.Dock" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のメソッド、<see cref="P:System.Windows.Forms.Control.Dock" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.DockStyle" />
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="T:System.Windows.Forms.ScrollableControl.DockPaddingEdges" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="DockChanged">
      <MemberSignature Language="C#" Value="public event EventHandler DockChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DockChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DockChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DockChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DockChanged;" />
      <MemberSignature Language="F#" Value="member this.DockChanged : EventHandler " Usage="member this.DockChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Dock" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Dock%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ*PropertyName* `Changed`にある場合に発生します、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="T:System.Windows.Forms.DockStyle" />
      </Docs>
    </Member>
    <Member MemberName="DoDragDrop">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DragDropEffects DoDragDrop (object data, System.Windows.Forms.DragDropEffects allowedEffects);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DragDropEffects DoDragDrop(object data, valuetype System.Windows.Forms.DragDropEffects allowedEffects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
      <MemberSignature Language="VB.NET" Value="Public Function DoDragDrop (data As Object, allowedEffects As DragDropEffects) As DragDropEffects" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DragDropEffects DoDragDrop(System::Object ^ data, System::Windows::Forms::DragDropEffects allowedEffects);" />
      <MemberSignature Language="F#" Value="member this.DoDragDrop : obj * System.Windows.Forms.DragDropEffects -&gt; System.Windows.Forms.DragDropEffects" Usage="control.DoDragDrop (data, allowedEffects)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragDropEffects</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="allowedEffects" Type="System.Windows.Forms.DragDropEffects" />
      </Parameters>
      <Docs>
        <param name="data">ドラッグするデータ。</param>
        <param name="allowedEffects"><see cref="T:System.Windows.Forms.DragDropEffects" /> 値のいずれか。</param>
        <summary>ドラッグ アンド ドロップ操作を開始します。</summary>
        <returns>ドラッグ アンド ドロップ操作中に実行された最終的な効果を表す、<see cref="T:System.Windows.Forms.DragDropEffects" /> 列挙体からの値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `allowedEffects`操作を実行できるどのドラッグを判別します。 データは、基本のマネージ クラスがありますが別のプロセス内のアプリケーションと相互運用するドラッグ操作が必要な場合 (<xref:System.String>、 <xref:System.Drawing.Bitmap>、または<xref:System.Drawing.Imaging.Metafile>)、または実装するオブジェクトを<xref:System.Runtime.Serialization.ISerializable>または<xref:System.Windows.Forms.IDataObject>します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ先であるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップの効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするイベントが発生し、データをドロップして、ドラッグを継続するかどうかを決定します。 または、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>します。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果でイベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>これにより、ユーザーがマウスの位置で最新のフィードバックを指定してマウスをドロップ先の間で移動、されたイベントはペアになっています。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`ソース アプリケーションでは、ソース データに対して適切な操作を実行できるように、データの切り取り、移動、操作だった場合、ドロップ効果の値がソースに返されます。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、すべての例外をキャッチし、次のセキュリティまたは重大な例外のみを再スローします。  
  
-   SecurityException  
  
-   NullReferenceException  
  
-   StackOverflowException  
  
-   OutOfMemoryException  
  
-   ThreadAbortException  
  
-   ExecutionEngineException  
  
-   IndexOutOfRangeException  
  
-   AccessViolationException  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 例では、<xref:System.Windows.Forms.Control.DoDragDrop%2A>ドラッグ操作の開始メソッド。 ドラッグ操作の開始、マウスが移動した場合は、複数の<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、カスタム カーソルをドラッグ アンド ドロップ操作を使用しても示しています。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタム ドラッグ用のアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタム カーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がチェックされます。 カスタム カーソルが設定されて、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価される、<xref:System.Windows.Forms.Control.DragOver>右側のイベント ハンドラー`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL + ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されますが、ドロップが発生、`DragOver`イベント。 削除するデータがない場合、 `String`、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>します。 ドロップダウンの状態を表示する最後に、 `DropLocationLabel` <xref:System.Windows.Forms.Label>します。  
  
 右側のドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`します。 ドラッグ操作が、フォームの境界の外側に移動しでドラッグ アンド ドロップ操作を取り消したかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#1)]  
  
 次のコード例を使用する方法を示しています、<xref:System.Windows.Forms.DragDropEffects>ドラッグ アンド ドロップ操作に関連するコントロールの間でデータを転送する方法を指定する列挙体。 この例では、フォームが含まれている必要があります、<xref:System.Windows.Forms.RichTextBox>コントロールと<xref:System.Windows.Forms.ListBox>制御し、<xref:System.Windows.Forms.ListBox>コントロールには、有効なファイル名の一覧が表示されます。 ユーザーが上にファイル名をドラッグすると、<xref:System.Windows.Forms.RichTextBox>コントロール、コントロールの<xref:System.Windows.Forms.Control.DragEnter>イベントが発生します。 イベント ハンドラー内で、<xref:System.Windows.Forms.DragEventArgs.Effect%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>に初期化されます<xref:System.Windows.Forms.DragDropEffects>にファイル パスで参照されるデータをコピーする必要があるかを示す、<xref:System.Windows.Forms.RichTextBox>コントロール。  
  
 [!code-cpp[RichTextDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextDragDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextDragDrop/CS/form1.cs#1)]
 [!code-vb[RichTextDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextDragDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.AllowDrop" />
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected virtual bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.DoubleBuffered" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property DoubleBuffered As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool DoubleBuffered { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DoubleBuffered : bool with get, set" Usage="System.Windows.Forms.Control.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ちらつきを軽減または回避するために、2 次バッファーを使用してコントロールの表面を再描画するかどうかを示す値を取得または設定します。</summary>
        <value>ダブル バッファリングを使用してコントロールの表面を再描画する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バッファリングされたグラフィックスを軽減またはが表示される画面の部分のプログレッシブ再描画によるちらつきを除去します。 バッファリングされたグラフィックスでは、更新されたグラフィックス データが、バッファーに書き込まれた最初ことが必要です。 グラフィックス バッファーのデータには迅速に表示される表面のメモリに書き込まれます。 通常、表示されるグラフィックス メモリの比較的すばやく切り替えるには、それ以外の場合に発生するちらつきが減少します。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.DoubleBuffered%2A> バインド可能なプロパティではありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.BufferedGraphics" />
        <altmember cref="T:System.Drawing.BufferedGraphicsContext" />
        <altmember cref="T:System.Drawing.BufferedGraphicsManager" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.OptimizedDoubleBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event EventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : EventHandler " Usage="member this.DoubleClick : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがダブルクリックされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ダブルクリックは、ユーザーのオペレーティング システムのマウス設定によって決まります。 ユーザーは、2 回のクリックではなくダブルクリックと見なされるマウス ボタンのクリック間隔を設定できます。 <xref:System.Windows.Forms.Control.Click>たびに、コントロールがダブルクリックされたイベントが発生します。 などのイベント ハンドラーがある場合、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>のイベントを<xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Control.Click>と<xref:System.Windows.Forms.Control.DoubleClick>フォームをダブルクリックし、両方のメソッドが呼び出されるイベントが発生します。 コントロールがダブルクリックされたかどうか、コントロールがサポートされていないこと、 <xref:System.Windows.Forms.Control.DoubleClick> 、イベント、<xref:System.Windows.Forms.Control.Click>イベントを 2 回発生する可能性があります。  
  
 設定する必要があります、`StandardDoubleClick`と`StandardClick`の値<xref:System.Windows.Forms.ControlStyles>に`true`このイベントが発生します。 これらの値を設定することがあります既に`true`既存のものから継承している場合は Windows フォームを制御します。  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.DoubleClick>のイベントを<xref:System.Windows.Forms.ListBox>が記載されたテキスト ファイルを読み込む、<xref:System.Windows.Forms.ListBox>に、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>標準の Windows フォーム コントロールから継承して、変更、<see langword="StandardClick" />または<see langword="StandardDoubleClick" />値<see cref="T:System.Windows.Forms.ControlStyles" />に<see langword="true" />予期しない動作が発生したり、影響を与えるありませんすべてのコントロールがサポートされていない場合、<see cref="E:System.Windows.Forms.Control.Click" />または<see cref="E:System.Windows.Forms.Control.DoubleClick" />イベント。  
  
次の表に、Windows フォーム コントロールとイベント (<see cref="E:System.Windows.Forms.Control.Click" />または<see cref="E:System.Windows.Forms.Control.DoubleClick" />) で指定したマウス アクションへの応答が発生します。  
  
 <list type="table"><listheader><term> コントロール 
 </term><description> マウスの左クリック 
 </description><description> マウスの左ダブル クリックします 
 </description><description> マウスの右クリックします 
 </description><description> マウスの右ダブル クリックします 
 </description><description> マウスの中央クリック 
 </description><description> マウスの中央をダブルクリックします。 
 </description><description> XButton1 マウスのクリック 
 </description><description> マウスの XButton1 ダブルクリック 
 </description><description> XButton2 マウスのクリック 
 </description><description> XButton2 マウスのダブルクリック 
 </description></listheader><item><term><see cref="T:System.Windows.Forms.MonthCalendar" />、 
 <see cref="T:System.Windows.Forms.DateTimePicker" />、 
 <see cref="T:System.Windows.Forms.RichTextBox" />、 
 <see cref="T:System.Windows.Forms.HScrollBar" />、 
 <see cref="T:System.Windows.Forms.VScrollBar" /></term><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description></item><item><term><see cref="T:System.Windows.Forms.Button" />、 
 <see cref="T:System.Windows.Forms.CheckBox" />、 
 <see cref="T:System.Windows.Forms.RadioButton" /></term><description> ここを 
 </description><description> をクリックしてください 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description></item><item><term><see cref="T:System.Windows.Forms.ListBox" />、 
 <see cref="T:System.Windows.Forms.CheckedListBox" />、 
 <see cref="T:System.Windows.Forms.ComboBox" /></term><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description></item><item><term><see cref="T:System.Windows.Forms.TextBox" />、 
 <see cref="T:System.Windows.Forms.DomainUpDown" />、 
 <see cref="T:System.Windows.Forms.NumericUpDown" /></term><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description></item><item><term> * <see cref="T:System.Windows.Forms.TreeView" />, 
\* <see cref="T:System.Windows.Forms.ListView" /></term><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description><description> none 
 </description></item><item><term><see cref="T:System.Windows.Forms.ProgressBar" />、 
 <see cref="T:System.Windows.Forms.TrackBar" /></term><description> ここを 
 </description><description> をクリックしてください 
 </description><description> ここを 
 </description><description> をクリックしてください 
 </description><description> ここを 
 </description><description> をクリックしてください 
 </description><description> ここを 
 </description><description> をクリックしてください 
 </description><description> ここを 
 </description><description> をクリックしてください 
 </description></item><item><term><see cref="T:System.Windows.Forms.Form" />、 
 <see cref="T:System.Windows.Forms.DataGrid" />、 
 <see cref="T:System.Windows.Forms.Label" />、 
 <see cref="T:System.Windows.Forms.LinkLabel" />、 
 <see cref="T:System.Windows.Forms.Panel" />、 
 <see cref="T:System.Windows.Forms.GroupBox" />、 
 <see cref="T:System.Windows.Forms.PictureBox" />、 
 <see cref="T:System.Windows.Forms.Splitter" />、 
 <see cref="T:System.Windows.Forms.StatusBar" />、 
 <see cref="T:System.Windows.Forms.ToolBar" />、 
 <see cref="T:System.Windows.Forms.TabPage" />、 
 ** <see cref="T:System.Windows.Forms.TabControl" /></term><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description><description> ここを 
 </description><description> クリック、ダブルクリック 
 </description></item></list>  

 \* 子オブジェクトの上にマウス ポインターがある必要があります (<see cref="T:System.Windows.Forms.TreeNode" />または<see cref="T:System.Windows.Forms.ListViewItem" />)。  
  
* *、<see cref="T:System.Windows.Forms.TabControl" />が少なくとも 1 つ<see cref="T:System.Windows.Forms.TabPage" />でその<see cref="P:System.Windows.Forms.TabControl.TabPages" />コレクション。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardClick" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.StandardDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="DpiChangedAfterParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedAfterParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedAfterParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedAfterParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedAfterParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedAfterParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedAfterParent : EventHandler " Usage="member this.DpiChangedAfterParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親コントロールまたはフォームの DPI が変更された後に、コントロールの DPI 設定がプログラムで変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="public event EventHandler DpiChangedBeforeParent;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DpiChangedBeforeParent" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DpiChangedBeforeParent" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChangedBeforeParent As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DpiChangedBeforeParent;" />
      <MemberSignature Language="F#" Value="member this.DpiChangedBeforeParent : EventHandler " Usage="member this.DpiChangedBeforeParent : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親コントロールまたはフォームの DPI 変更イベントが発生する前に、コントロールの DPI 設定がプログラムで変更されたときに発生します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が完了したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DragEventArgs.X%2A>と<xref:System.Windows.Forms.DragEventArgs.Y%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>は、画面座標をクライアント座標ではありません。 Visual C# コードの次の行をクライアントに、プロパティを変換します<xref:System.Drawing.Point>します。  
  
```  
Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
```  
  
> [!NOTE]
>  バージョンよりも前[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]を配置する場合を<xref:System.Windows.Forms.UserControl>で<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>Windows フォーム上のイベントしドラッグ アンド ドロップに何か、 <xref:System.Windows.Forms.UserControl> 、デザイン時に、`DropDrop`と`DropEnter`イベントは、発生します。 ただし、ときに閉じて、ソリューション、<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>イベントが再び発生しません。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragDrop>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッド。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#5)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
        <altmember cref="M:System.Windows.Forms.Control.DoDragDrop(System.Object,System.Windows.Forms.DragDropEffects)" />
        <altmember cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトがコントロールの境界内にドラッグされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragEnter>ユーザー最初がドラッグすると、マウス カーソルをコントロール上でドラッグ アンド ドロップ操作中にイベントが発生します。  
  
> [!NOTE]
>  バージョンよりも前[!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)]を配置する場合を<xref:System.Windows.Forms.UserControl>で<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>Windows フォーム上のイベントしドラッグ アンド ドロップに何か、 <xref:System.Windows.Forms.UserControl> 、デザイン時に、`DropDrop`と`DropEnter`イベントは、発生します。 ただし、ときに閉じて、ソリューション、<xref:System.Windows.Forms.Control.DragEnter>と<xref:System.Windows.Forms.Control.DragDrop>イベントが再び発生しません。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ先であるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップの効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするイベントが発生し、データをドロップして、ドラッグを継続するかどうかを決定します。 または、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>します。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果でイベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>これにより、ユーザーがマウスの位置で最新のフィードバックを指定してマウスをドロップ先の間で移動、されたイベントはペアになっています。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`ソース アプリケーションでは、ソース データに対して適切な操作を実行できるように、データの切り取り、移動、操作だった場合、ドロップ効果の値がソースに返されます。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.DragEventArgs.X%2A>と<xref:System.Windows.Forms.DragEventArgs.Y%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>は、画面座標をクライアント座標ではありません。 Visual C# コードの次の行をクライアントに、プロパティを変換します<xref:System.Drawing.Point>します。  
  
    ```  
    Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
    ```  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 例では、<xref:System.Windows.Forms.Control.DoDragDrop%2A>ドラッグ操作の開始メソッド。 ドラッグ操作の開始、マウスが移動した場合は、複数の<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、カスタム カーソルをドラッグ アンド ドロップ操作を使用しても示しています。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタム ドラッグ用のアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタム カーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がチェックされます。 カスタム カーソルが設定されて、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価される、<xref:System.Windows.Forms.Control.DragOver>右側のイベント ハンドラー`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL + ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されますが、ドロップが発生、`DragOver`イベント。 削除するデータがない場合、 `String`、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>します。 ドロップダウンの状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>します。  
  
 右側のドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`します。 ドラッグ操作が、フォームの境界の外側に移動しでドラッグ アンド ドロップ操作を取り消したかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragEnter>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッド。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#7)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#7)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトがコントロールの境界外にドラッグされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragLeave>ユーザーは、コントロールのカーソルをドラッグすると、ユーザーが現在のドラッグ アンド ドロップ操作をキャンセル イベントが発生します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ先であるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップの効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするイベントが発生し、データをドロップして、ドラッグを継続するかどうかを決定します。 または、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>します。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果でイベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>これにより、ユーザーがマウスの位置で最新のフィードバックを指定してマウスをドロップ先の間で移動、されたイベントはペアになっています。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`ソース アプリケーションでは、ソース データに対して適切な操作を実行できるように、データの切り取り、移動、操作だった場合、ドロップ効果の値がソースに返されます。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 例では、<xref:System.Windows.Forms.Control.DoDragDrop%2A>ドラッグ操作の開始メソッド。 ドラッグ操作の開始、マウスが移動した場合は、複数の<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、カスタム カーソルをドラッグ アンド ドロップ操作を使用しても示しています。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタム ドラッグ用のアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタム カーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がチェックされます。 カスタム カーソルが設定されて、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価される、<xref:System.Windows.Forms.Control.DragOver>右側のイベント ハンドラー`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL + ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されますが、ドロップが発生、`DragOver`イベント。 削除するデータがない場合、 `String`、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>します。 ドロップダウンの状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>します。  
  
 右側のドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`します。 ドラッグ操作が、フォームの境界の外側に移動しでドラッグ アンド ドロップ操作を取り消したかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragLeave>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッド。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#8)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>オブジェクトがコントロールの境界を越えてドラッグされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DragOver>ドラッグ アンド ドロップ操作中に、コントロールの境界内でマウス カーソルが移動したときにイベントが発生します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ先であるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップの効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするイベントが発生し、データをドロップして、ドラッグを継続するかどうかを決定します。 または、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>します。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>値は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果でイベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>これにより、ユーザーがマウスの位置で最新のフィードバックを指定してマウスをドロップ先の間で移動、されたイベントはペアになっています。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`ソース アプリケーションでは、ソース データに対して適切な操作を実行できるように、データの切り取り、移動、操作だった場合、ドロップ効果の値がソースに返されます。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.DragEventArgs.X%2A>と<xref:System.Windows.Forms.DragEventArgs.Y%2A>のプロパティ、<xref:System.Windows.Forms.DragEventArgs>は、画面座標をクライアント座標ではありません。 次の C# コード行をクライアントに、プロパティを変換します<xref:System.Drawing.Point>:  
    >   
    >  Point clientPoint = targetControl.PointToClient(new Point(de.X, de.Y));  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 例では、<xref:System.Windows.Forms.Control.DoDragDrop%2A>ドラッグ操作の開始メソッド。 ドラッグ操作の開始、マウスが移動した場合は、複数の<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、カスタム カーソルをドラッグ アンド ドロップ操作を使用しても示しています。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタム ドラッグ用のアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタム カーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がチェックされます。 カスタム カーソルが設定されて、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価される、<xref:System.Windows.Forms.Control.DragOver>右側のイベント ハンドラー`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL + ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されますが、ドロップが発生、`DragOver`イベント。 削除するデータがない場合、 `String`、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>します。 ドロップダウンの状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>します。  
  
 右側のドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`します。 ドラッグ操作が、フォームの境界の外側に移動しでドラッグ アンド ドロップ操作を取り消したかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.DragOver>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッド。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#4)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="member this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="control.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bitmap">描画されるビットマップ。</param>
        <param name="targetBounds">コントロールが描画される範囲。</param>
        <summary>指定したビットマップへのレンダリングをサポートします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A> ActiveX コントロールのメソッドがサポートされていません。 オーバーライドすることができます、<xref:System.Windows.Forms.Control.OnPrint%2A>イベントと、必要な場合は、カスタム印刷ロジックを提供します。  
  
 <xref:System.Windows.Forms.Control.DrawToBitmap%2A>メソッドには、次の制限。  
  
-   <xref:System.ArgumentException>大きなビットマップのスローされる可能性があります。 最大許容サイズは、コンピューターによって異なります。  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> サポートしていません、 `Ink` Windows XP Tablet PC Edition 2005 のオペレーティング システムのコントロール。  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> 子を描画しない<xref:System.Windows.Forms.TextBox>場合、<xref:System.Windows.Forms.Control.Visible%2A>のプロパティ、<xref:System.Windows.Forms.TextBox>に設定されている`false`します。  
  
-   コンテナー内のコントロールは、逆の順序で表示されます。  
  
-   <xref:System.Windows.Forms.Control.DrawToBitmap%2A> 完全に機能することはありません、 <xref:System.Windows.Forms.RichTextBox>; のみビットマップの境界線が描画されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.Control.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-514)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがユーザーとの対話に応答できるかどうかを示す値を取得または設定します。</summary>
        <value>コントロールがユーザーとの対話に応答できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Enabled%2A>プロパティを有効にするまたは実行時にコントロールを無効にすることができます。 たとえば、アプリケーションの現在の状態には適用されませんコントロールを無効にできます。 使用を制限するコントロールを無効にすることもできます。 たとえば、ユーザーがクリックすることを防ぐために、ボタンを無効にできます。 コントロールが無効になっている場合は選択できません。  
  
> [!IMPORTANT]
>  設定、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`アプリケーション ウィンドウがフォーカスを取得するを防ぐまたはアプリケーションのコントロールのボックスを無効にしません。  
  
 コンテナー コントロールが、有効なプロパティに設定を持っている場合`false`もその格納されているすべてのコントロールが無効にします。 たとえば、ユーザーが 無効なに含まれるコントロールのいずれかの<xref:System.Windows.Forms.GroupBox>コントロール、イベントは発生しません。  
  
> [!NOTE]
>  スクロール可能なコントロールを無効にすると、スクロール バーも無効にします。 たとえば、複数行テキスト ボックスに無効になっているはスクロールすると、すべての行のテキストを表示できません。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>および一部の一般的なプロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>フォームの上部に、グループ ボックス ドッキングし、グループ ボックスのプロパティ。 グループ ボックスを無効に設定して、最後に、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックス内に含まれるすべてのコントロール。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ScrollableControl" />
      </Docs>
    </Member>
    <Member MemberName="EnabledChanged">
      <MemberSignature Language="C#" Value="public event EventHandler EnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler EnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.EnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event EnabledChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ EnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.EnabledChanged : EventHandler " Usage="member this.EnabledChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Enabled" /> プロパティ値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Enabled%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例を使用して 2 つ<xref:System.Windows.Forms.RadioButton>コントロールを示すために、<xref:System.Windows.Forms.Control.EnabledChanged>イベント。 値を変更する 1 つのボタンをクリックすると、<xref:System.Windows.Forms.Control.Enabled%2A>するその他のボタンのプロパティ`false`し、表示、<xref:System.Windows.Forms.MessageBox>します。  
  
 [!code-csharp[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.EnabledChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.EnabledChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="EndInvoke">
      <MemberSignature Language="C#" Value="public object EndInvoke (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object EndInvoke(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.EndInvoke(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndInvoke (asyncResult As IAsyncResult) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ EndInvoke(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="abstract member EndInvoke : IAsyncResult -&gt; obj&#xA;override this.EndInvoke : IAsyncResult -&gt; obj" Usage="control.EndInvoke asyncResult" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.EndInvoke(System.IAsyncResult)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><see cref="T:System.IAsyncResult" /> を呼び出したときに返された、特定の呼び出しの非同期操作を表す<see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />。</param>
        <summary>渡された <see cref="T:System.IAsyncResult" /> によって表される、非同期操作の戻り値を取得します。</summary>
        <returns>非同期操作によって生成された <see cref="T:System.Object" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期操作が完了していない場合、この関数は、結果が利用可能になるまでブロックします。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティはスレッド セーフであるコントロールの 4 つの方法があります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しにはコントロールのスレッドへの呼び出しをマーシャ リングするのに invoke メソッドのいずれかを使用する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> パラメーター値が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> オブジェクトが、同じコントロールからの先行する <see cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" /> メソッドの呼び出しによって作成されていません。</exception>
        <altmember cref="M:System.Windows.Forms.Control.BeginInvoke(System.Delegate)" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public event EventHandler Enter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Enter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Enter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Enter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Enter;" />
      <MemberSignature Language="F#" Value="member this.Enter : EventHandler " Usage="member this.Enter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが入力されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 フォーカスを変更すると、マウスを使用して、または呼び出すことによって、<xref:System.Windows.Forms.Control.Focus%2A>メソッドでは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>によってイベントが抑制されます、<xref:System.Windows.Forms.Form>クラス。 同等のイベント、<xref:System.Windows.Forms.Form>クラスは、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>イベントを階層し、適切なコントロールに到達するまで、親のチェーンを上下に伝播します。 たとえば、ある場合、<xref:System.Windows.Forms.Form>の 2 つ<xref:System.Windows.Forms.GroupBox>コントロール、および各<xref:System.Windows.Forms.GroupBox>コントロールが 1 つ<xref:System.Windows.Forms.TextBox>コントロール。 1、カレットを移動するとき<xref:System.Windows.Forms.TextBox>、他の<xref:System.Windows.Forms.Control.Leave>のイベントは、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.Control.Enter>イベントは、他の<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.TextBox>。  
  
> [!CAUTION]
>  内からフォーカスを設定しないで、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションまたはオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 `WM_KILLFOCUS` "キーボード入力リファレンス"セクションとの"メッセージ デッドロック"セクションのトピック、[についてメッセージとメッセージ キュー](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)トピック。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Enter>の前景色と背景色を変更するイベントを<xref:System.Windows.Forms.TextBox>特定の条件下でします。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="FindForm">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form FindForm ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Form FindForm() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FindForm" />
      <MemberSignature Language="VB.NET" Value="Public Function FindForm () As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Form ^ FindForm();" />
      <MemberSignature Language="F#" Value="member this.FindForm : unit -&gt; System.Windows.Forms.Form" Usage="control.FindForm " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールがあるフォームを取得します。</summary>
        <returns>コントロールがある <see cref="T:System.Windows.Forms.Form" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの<xref:System.Windows.Forms.Control.Parent%2A>プロパティの値と同じである可能性がありますいない、<xref:System.Windows.Forms.Form>によって返される<xref:System.Windows.Forms.Control.FindForm%2A>メソッド。 などの場合、<xref:System.Windows.Forms.RadioButton>内でコントロールが含まれています、<xref:System.Windows.Forms.GroupBox>コントロールと<xref:System.Windows.Forms.GroupBox>では、 <xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.RadioButton>コントロールの<xref:System.Windows.Forms.Control.Parent%2A>は、<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.GroupBox>コントロール<xref:System.Windows.Forms.Control.Parent%2A>は、<xref:System.Windows.Forms.Form>します。  
  
   
  
## Examples  
 次のコード例では、指定したボタンを含むフォームを検索します。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; bool" Usage="control.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールに入力フォーカスを設定します。</summary>
        <returns>入力フォーカス要求が成功した場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Focus%2A>メソッドを返します。`true`コントロールが正常に入力フォーカスを受け取った場合。 コントロールは、フォーカスのあるビジュアル キューが表示されないときに入力フォーカスを持つことができます。 次に、選択できないコントロールでこの動作が観察された主にかから派生したすべてのコントロールにします。  
  
 コントロールが選択できるし、次のすべてに該当する場合は、入力フォーカスを受け取る:`Selectable`値<xref:System.Windows.Forms.ControlStyles>に設定されている`true`、別のコントロールに含まれていると、すべての親コントロールが両方表示して有効にします。  
  
 次の一覧に Windows フォーム コントロールは、選択可能ではありません。 これらのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.LinkLabel> (この場合、コントロール内にリンクすることはありません)  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Focus%2A> 低レベルのメソッドは、主にカスタム コントロールを作成します。 代わりに、アプリケーション プログラマが使用する必要があります、<xref:System.Windows.Forms.Control.Select%2A>メソッドまたは<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>、子コントロールのプロパティまたは<xref:System.Windows.Forms.Form.Activate%2A>フォームのメソッド。  
  
   
  
## Examples  
 次のコード例を指定したフォーカスを設定する<xref:System.Windows.Forms.Control>フォーカスを受け取ることができます。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#1)]
 [!code-csharp[Windows.Forms.ControlMembers6#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#1)]
 [!code-vb[Windows.Forms.ControlMembers6#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
        <altmember cref="P:System.Windows.Forms.Control.Focused" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public virtual bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Focused" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Focused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Focused : bool" Usage="System.Windows.Forms.Control.Focused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに入力フォーカスがあるかどうかを示す値を取得します。</summary>
        <value>コントロールにフォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例を無効にする<xref:System.Windows.Forms.MenuItem>場合、<xref:System.Windows.Forms.TextBox>にフォーカスがないです。 この例が必要です、<xref:System.Windows.Forms.Form>で、<xref:System.Windows.Forms.TextBox>という`textBox1`と 2 つ<xref:System.Windows.Forms.MenuItem>という名前のオブジェクト`menuItemEdit`と`menuItemEditInsertCustomerInfo`。  
  
 [!code-cpp[Windows.FOrms.Control Members2#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#4)]
 [!code-csharp[Windows.FOrms.Control Members2#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#4)]
 [!code-vb[Windows.FOrms.Control Members2#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.Focused" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.Focused" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="P:System.Windows.Forms.Control.CanSelect" />
        <altmember cref="P:System.Windows.Forms.Control.ContainsFocus" />
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.Control.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-512)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールによって表示されるテキストのフォントを取得または設定します。</summary>
        <value>コントロールによって表示されるテキストに適用される <see cref="T:System.Drawing.Font" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultFont" /> プロパティの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Font%2A>プロパティは、アンビエント プロパティです。 アンビエントのプロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>が、同じ<xref:System.Windows.Forms.Control.BackColor%2A>親として<xref:System.Windows.Forms.Form>既定では。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要。  
  
 <xref:System.Drawing.Font>は変更できません (つまり、そのプロパティのいずれかを調整できません)、割り当てることができますのみ、 <xref:System.Windows.Forms.Control.Font%2A> 、新しいプロパティ<xref:System.Drawing.Font>します。 ただし、既存のフォントで新しいフォントを作成できます。  
  
 [Visual Basic、 C#]  
  
 太字にする既存のフォントを調整する方法の例を次に示します。  
  
```csharp  
myControl.Font = new Font(myControl.Font,   
    myControl.Font.Style | FontStyle.Bold);  
```  
  
```vb  
MyControl.Font = New Font(MyControl.Font, _   
    MyControl.Font.Style Or FontStyle.Bold)  
```  
  
   
  
## Examples  
 次のコード例が表示されます、 <xref:System.Windows.Forms.FontDialog> 、ユーザーと変更を<xref:System.Drawing.Font>の<xref:System.Windows.Forms.DateTimePicker>コントロール。 この例が必要です、<xref:System.Windows.Forms.Form>で<xref:System.Windows.Forms.Button>と<xref:System.Windows.Forms.DateTimePicker>にします。  
  
 [!code-cpp[Control_Font#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Font/CPP/control_font.cpp#1)]
 [!code-csharp[Control_Font#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Font/CS/control_font.cs#1)]
 [!code-vb[Control_Font#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Font/VB/control_font.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.Font" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.Font" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.Font" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontChanged">
      <MemberSignature Language="C#" Value="public event EventHandler FontChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler FontChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.FontChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FontChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ FontChanged;" />
      <MemberSignature Language="F#" Value="member this.FontChanged : EventHandler " Usage="member this.FontChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Font" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Font%2A>プロパティを変更すると、プログラムの変更によって、または相互作用使用します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Windows.Forms.Control.FontChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.FontChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.FontChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Font" />
        <altmember cref="T:System.Drawing.Font" />
      </Docs>
    </Member>
    <Member MemberName="FontHeight">
      <MemberSignature Language="C#" Value="protected int FontHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 FontHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.FontHeight" />
      <MemberSignature Language="VB.NET" Value="Protected Property FontHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int FontHeight { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.FontHeight : int with get, set" Usage="System.Windows.Forms.Control.FontHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのフォントの高さを取得または設定します。</summary>
        <value>コントロールの <see cref="T:System.Drawing.Font" /> の高さ (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.FontHeight%2A>コントロールの以外の値を設定しないでプロパティ<xref:System.Drawing.Font.Height%2A?displayProperty=nameWithType>値または-1。 設定<xref:System.Windows.Forms.Control.FontHeight%2A>を-1 にオフにすると、キャッシュされた高さの値の効果があり、値は、プロパティが参照されている次回再計算されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Font.Height" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.Control.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-513)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの前景色を取得または設定します。</summary>
        <value>コントロールの前景の <see cref="T:System.Drawing.Color" />。 既定値は <see cref="P:System.Windows.Forms.Control.DefaultForeColor" /> プロパティの値です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ForeColor%2A>プロパティは、アンビエント プロパティです。 アンビエントのプロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>が、同じ<xref:System.Windows.Forms.Control.BackColor%2A>親として<xref:System.Windows.Forms.Form>既定では。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Control.BackColor%2A>と<xref:System.Windows.Forms.Control.ForeColor%2A>の既定のシステム カラーをコントロールします。 コードを再帰的には、コントロールに子コントロールがある場合は自分自身を呼び出します。 このコード例が必要です、<xref:System.Windows.Forms.Form>を少なくとも 1 つの子コントロールでただし、子コンテナーを制御するような<xref:System.Windows.Forms.Panel>または<xref:System.Windows.Forms.GroupBox>、わかりやすく示すためコントロールが、再帰、独自の子にします。  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.ForeColor" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.ForeColor" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.ForeColor" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="ForeColorChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ForeColorChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ForeColorChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ForeColorChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ForeColorChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ForeColorChanged;" />
      <MemberSignature Language="F#" Value="member this.ForeColorChanged : EventHandler " Usage="member this.ForeColorChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ForeColor" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.ForeColor%2A>プロパティを変更すると、プログラムの変更によって、または相互作用使用します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ*PropertyName* `Changed`にある場合に発生します、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ForeColor" />
        <altmember cref="T:System.Drawing.Color" />
      </Docs>
    </Member>
    <Member MemberName="FromChildHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromChildHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromChildHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromChildHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromChildHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromChildHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromChildHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromChildHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">検索する対象となるウィンドウ ハンドル (<see langword="HWND" />)。</param>
        <summary>指定したハンドルを格納しているコントロールを取得します。</summary>
        <returns>指定したハンドルに関連付けられたコントロールを表す <see cref="T:System.Windows.Forms.Control" />。指定したハンドルを持つコントロールが見つからない場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コントロールに関連付けられているハンドルが見つかるまで、ウィンドウ ハンドルの親チェーンを検索します。 このメソッドより信頼性が高く、<xref:System.Windows.Forms.Control.FromHandle%2A>メソッド、1 つ以上のハンドルを所有するコントロールを正しく返すためです。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="FromHandle">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Control FromHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Forms.Control FromHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.FromHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHandle (handle As IntPtr) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Forms::Control ^ FromHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="static member FromHandle : nativeint -&gt; System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.FromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle">検索する対象となるウィンドウ ハンドル (<see langword="HWND" />)。</param>
        <summary>指定したハンドルに現在関連付けられているコントロールを返します。</summary>
        <returns>指定したハンドルに関連付けられたコントロールを表す <see cref="T:System.Windows.Forms.Control" />。指定したハンドルを持つコントロールが見つからない場合は <see langword="null" /> を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.FromChildHandle%2A>メソッドは、複数のハンドルを所有するコントロールを返す必要がある場合。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetAccessibilityObjectById">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.AccessibleObject GetAccessibilityObjectById (int objectId);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Forms.AccessibleObject GetAccessibilityObjectById(int32 objectId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAccessibilityObjectById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetAccessibilityObjectById (objectId As Integer) As AccessibleObject" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Forms::AccessibleObject ^ GetAccessibilityObjectById(int objectId);" />
      <MemberSignature Language="F#" Value="abstract member GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject&#xA;override this.GetAccessibilityObjectById : int -&gt; System.Windows.Forms.AccessibleObject" Usage="control.GetAccessibilityObjectById objectId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AccessibleObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objectId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="objectId">取得する <see langword="Int32" /> を識別する <see cref="T:System.Windows.Forms.AccessibleObject" />。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.AccessibleObject" /> を取得します。</summary>
        <returns>指定された <see cref="T:System.Windows.Forms.AccessibleObject" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.AutoSizeMode GetAutoSizeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.AutoSizeMode GetAutoSizeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetAutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetAutoSizeMode () As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::AutoSizeMode GetAutoSizeMode();" />
      <MemberSignature Language="F#" Value="member this.GetAutoSizeMode : unit -&gt; System.Windows.Forms.AutoSizeMode" Usage="control.GetAutoSizeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.AutoSize" /> プロパティが有効なときのコントロールの動作を示す値を取得します。</summary>
        <returns><see cref="T:System.Windows.Forms.AutoSizeMode" /> 値のいずれか。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetChildAtPoint">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した位置の子コントロールを取得します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">コントロールを検索する座標を格納している <see cref="T:System.Drawing.Point" />。 座標は、コントロールのクライアント領域の左上隅に対する相対座標として表されます。</param>
        <summary>指定した座標にある子コントロールを取得します。</summary>
        <returns>指定したポイントにあるコントロールを表す <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された位置に子コントロールがない場合、<xref:System.Windows.Forms.Control.GetChildAtPoint%2A>メソッドを返します。`null`します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">コントロールが返された場合は、このメソッドを呼び出すすべての windows でないコントロールの子。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="GetChildAtPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetChildAtPoint (System.Drawing.Point pt, System.Windows.Forms.GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetChildAtPoint(valuetype System.Drawing.Point pt, valuetype System.Windows.Forms.GetChildAtPointSkip skipValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetChildAtPoint(System.Drawing.Point,System.Windows.Forms.GetChildAtPointSkip)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildAtPoint (pt As Point, skipValue As GetChildAtPointSkip) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetChildAtPoint(System::Drawing::Point pt, System::Windows::Forms::GetChildAtPointSkip skipValue);" />
      <MemberSignature Language="F#" Value="member this.GetChildAtPoint : System.Drawing.Point * System.Windows.Forms.GetChildAtPointSkip -&gt; System.Windows.Forms.Control" Usage="control.GetChildAtPoint (pt, skipValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="skipValue" Type="System.Windows.Forms.GetChildAtPointSkip" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="pt">コントロールを検索する座標を格納している <see cref="T:System.Drawing.Point" />。 座標は、コントロールのクライアント領域の左上隅に対する相対座標として表されます。</param>
        <param name="skipValue">特定の種類の子コントロールを無視するかどうかを決定する <see cref="T:System.Windows.Forms.GetChildAtPointSkip" /> の値の 1 つ。</param>
        <summary>特定の種類の子コントロールを無視するかどうかを指定して、指定した座標にある子コントロールを取得します。</summary>
        <returns>指定した座標にある子 <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetContainerControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IContainerControl GetContainerControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.IContainerControl GetContainerControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetContainerControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetContainerControl () As IContainerControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::IContainerControl ^ GetContainerControl();" />
      <MemberSignature Language="F#" Value="member this.GetContainerControl : unit -&gt; System.Windows.Forms.IContainerControl" Usage="control.GetContainerControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IContainerControl</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの親チェインの 1 つ上の <see cref="T:System.Windows.Forms.ContainerControl" /> を返します。</summary>
        <returns><see cref="T:System.Windows.Forms.IContainerControl" /> の親を表す <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="T:System.Windows.Forms.IContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="GetNextControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control GetNextControl (System.Windows.Forms.Control ctl, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.Control GetNextControl(class System.Windows.Forms.Control ctl, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetNextControl(System.Windows.Forms.Control,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextControl (ctl As Control, forward As Boolean) As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::Control ^ GetNextControl(System::Windows::Forms::Control ^ ctl, bool forward);" />
      <MemberSignature Language="F#" Value="member this.GetNextControl : System.Windows.Forms.Control * bool -&gt; System.Windows.Forms.Control" Usage="control.GetNextControl (ctl, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">検索を開始する <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="forward">タブ オーダー内を前方に検索する場合は <see langword="true" />。後方に検索する場合は <see langword="false" />。</param>
        <summary>子コントロールのタブ オーダー内の 1 つ前または 1 つ後ろのコントロールを取得します。</summary>
        <returns>タブ オーダー内の次の <see cref="T:System.Windows.Forms.Control" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GetNextControl%2A>メソッドは、タブ オーダーに依存します。 入れ子になったコントロールなど、フォームのコントロールすべてを反復処理するには、使用、<xref:System.Windows.Forms.Control.Controls%2A>プロパティ。 取得または設定コンテナー コントロールのアクティブなコントロールを使用、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティ。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="GetPreferredSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size GetPreferredSize (System.Drawing.Size proposedSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Drawing.Size GetPreferredSize(valuetype System.Drawing.Size proposedSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetPreferredSize (proposedSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Drawing::Size GetPreferredSize(System::Drawing::Size proposedSize);" />
      <MemberSignature Language="F#" Value="abstract member GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.GetPreferredSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.GetPreferredSize proposedSize" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.Layout.IArrangedElement.GetPreferredSize(System.Drawing.Size)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="proposedSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="proposedSize">コントロールのカスタム サイズ領域。</param>
        <summary>コントロールが収まる四角形の領域のサイズを取得します。</summary>
        <returns>四角形の幅と高さを表す、順序を付与した <see cref="T:System.Drawing.Size" /> 型のペア。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 動作<xref:System.Windows.Forms.Control.GetPreferredSize%2A>コントロールによって異なります。 <xref:System.Windows.Forms.Control.LayoutEngine%2A>コントロールに返されるサイズを割り当てることができない可能性があります。 示される制約よりも大きいサイズを返すことができます、`proposedSize`パラメーターが`proposedSize`減少するように制約が減少します。 たとえば、`GetPreferredSize(new Size(100, 0))`よりも広いしないで`GetPreferredSize(new Size(200, 0))`します。 例外は、 `proposedSize` 0 または`Size.Empty`、制約として定義されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle&#xA;override this.GetScaledBounds : System.Drawing.Rectangle * System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; System.Drawing.Rectangle" Usage="control.GetScaledBounds (bounds, factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="2" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="bounds">ディスプレイの範囲の取得条件となる領域を指定する <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="factor">コントロールの境界の高さおよび幅。</param>
        <param name="specified">コントロールのサイズと位置を定義するときに使用するコントロールの境界を指定する <see cref="T:System.Windows.Forms.BoundsSpecified" /> の値の 1 つ。</param>
        <summary>コントロールのスケールが設定される境界を取得します。</summary>
        <returns>コントロールのスケールが設定される境界を表す <see cref="T:System.Drawing.Rectangle" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これはヘルパー メソッドによって呼び出される<xref:System.Windows.Forms.Control.ScaleControl%2A>コントロールがスケーリングされる境界を取得します。 再利用するには、このメソッドをオーバーライドすることができます、<xref:System.Windows.Forms.Control.ScaleControl%2A>スケーリング ロジックしますが、独自の境界を指定する必要があります。 既定の実装は、アカウントに、スケールの範囲を返します、`specified`境界、コントロールが最上位のレベルであるかどうかどうか、コントロールが固定幅または自動サイズ調整と表示要素のコントロールがあります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
      </Docs>
    </Member>
    <Member MemberName="GetStyle">
      <MemberSignature Language="C#" Value="protected bool GetStyle (System.Windows.Forms.ControlStyles flag);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetStyle(valuetype System.Windows.Forms.ControlStyles flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetStyle (flag As ControlStyles) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetStyle(System::Windows::Forms::ControlStyles flag);" />
      <MemberSignature Language="F#" Value="member this.GetStyle : System.Windows.Forms.ControlStyles -&gt; bool" Usage="control.GetStyle flag" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
      </Parameters>
      <Docs>
        <param name="flag">値を返す <see cref="T:System.Windows.Forms.ControlStyles" /> ビット。</param>
        <summary>コントロールの指定したコントロール スタイル ビットの値を取得します。</summary>
        <returns>指定したコントロール スタイル ビットが <see langword="true" /> に設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール スタイル ビット フラグは、サポートされている動作の分類に使用されます。 コントロールがスタイルを有効に呼び出すことによって、<xref:System.Windows.Forms.Control.SetStyle%2A>メソッドを適切な渡して<xref:System.Windows.Forms.ControlStyles>ビットとビットを設定するブール値。 指定したに割り当てられている値を決定する<xref:System.Windows.Forms.ControlStyles>ビットを使用して、<xref:System.Windows.Forms.Control.GetStyle%2A>メソッドを渡します、<xref:System.Windows.Forms.ControlStyles>を評価するメンバー。  
  
   
  
## Examples  
 ダブル バッファリングの関連するスタイルの値のビットを次のコード例を返される、<xref:System.Windows.Forms.Form>します。 この例を返します`true`すべてのスタイル ビットが設定されている場合にのみ`true`します。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#4](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#4)]
 [!code-csharp[Windows.Forms.ControlMembers6#4](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#4)]
 [!code-vb[Windows.Forms.ControlMembers6#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="GetTopLevel">
      <MemberSignature Language="C#" Value="protected bool GetTopLevel ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool GetTopLevel() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.GetTopLevel" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetTopLevel () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool GetTopLevel();" />
      <MemberSignature Language="F#" Value="member this.GetTopLevel : unit -&gt; bool" Usage="control.GetTopLevel " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールがトップレベル コントロールかどうかを判断します。</summary>
        <returns>コントロールがトップレベル コントロールである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ操作中に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップ操作が開始されたときにイベントが発生します。 <xref:System.Windows.Forms.Control.GiveFeedback>イベント、ドラッグ イベントのソースことができます、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更しています。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ先であるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップの効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするイベントが発生し、データをドロップして、ドラッグを継続するかどうかを決定します。 または、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>します。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果でイベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>これにより、ユーザーがマウスの位置で最新のフィードバックを指定してマウスをドロップ先の間で移動、されたイベントはペアになっています。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`ソース アプリケーションでは、ソース データに対して適切な操作を実行できるように、データの切り取り、移動、操作だった場合、ドロップ効果の値がソースに返されます。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 例では、<xref:System.Windows.Forms.Control.DoDragDrop%2A>ドラッグ操作の開始メソッド。 ドラッグ操作の開始、マウスが移動した場合は、複数の<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、カスタム カーソルをドラッグ アンド ドロップ操作を使用しても示しています。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタム ドラッグ用のアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタム カーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がチェックされます。 カスタム カーソルが設定されて、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価される、<xref:System.Windows.Forms.Control.DragOver>右側のイベント ハンドラー`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL + ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されますが、ドロップが発生、`DragOver`イベント。 削除するデータがない場合、 `String`、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>します。 ドロップダウンの状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>します。  
  
 右側のドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`します。 ドラッグ操作が、フォームの境界の外側に移動しでドラッグ アンド ドロップ操作を取り消したかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.GiveFeedback>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッド。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event EventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : EventHandler " Usage="member this.GotFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを受け取ると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 フォーカスを変更すると、マウスを使用して、または呼び出すことによって、<xref:System.Windows.Forms.Control.Focus%2A>メソッドでは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 **注**、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、低レベルのフォーカス イベント WM_KILLFOCUS と WM_SETFOCUS Windows メッセージに関連付けられています。 通常、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、更新するときにのみ使用<xref:System.Windows.Forms.UICues>またはカスタム コントロールを作成します。 代わりに、<xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>を除くすべてのコントロールのイベントを使用する必要があります、<xref:System.Windows.Forms.Form>クラスを使用する、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 詳細については、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントを参照してください、 [WM_SETFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646283\(v=vs.85\).aspx)と[WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピック。  
  
> [!CAUTION]
>  内からフォーカスを設定しないで、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションまたはオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピック。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.GotFocus>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.GotFocus>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#47](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#47)]
 [!code-vb[System.Windows.Forms.EventExamples#47](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#47)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Windows.Forms.Control.Handle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Forms.IWin32Window.Handle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-515)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのバインド先のウィンドウ ハンドルを取得します。</summary>
        <value>コントロールのウィンドウ ハンドル (<see cref="T:System.IntPtr" />) を格納する <see langword="HWND" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値、<xref:System.Windows.Forms.Control.Handle%2A>プロパティは、Windows`HWND`します。 ハンドルが作成されていない場合このプロパティを参照しているがハンドルを強制的に作成します。  
  
   
  
## Examples  
 次のコード例に示しますを使用して、<xref:System.Windows.Forms.ControlPaint.DrawFocusRectangle%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.Control.Handle%2A>プロパティ。 例を実行するには、次のコードをフォームに貼り付けます。 という名前の 2 つのボタンを追加`Button1`と`Button2`をフォームにすべてのイベントは、それぞれのイベント ハンドラーに接続していることを確認します。  
  
 [!code-cpp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlPaint1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlPaint1/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleCreated">
      <MemberSignature Language="C#" Value="public event EventHandler HandleCreated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleCreated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleCreated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleCreated;" />
      <MemberSignature Language="F#" Value="member this.HandleCreated : EventHandler " Usage="member this.HandleCreated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに対してハンドルが作成されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ハンドルが作成されるときに、<xref:System.Windows.Forms.Control>が最初に表示されます。 たとえば場合、<xref:System.Windows.Forms.Control>が作成されますが<xref:System.Windows.Forms.Control.Visible%2A>に設定`false`、<xref:System.Windows.Forms.Control.HandleCreated>までイベントは発生しません<xref:System.Windows.Forms.Control.Visible%2A>に設定されている`true`します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.HandleCreated>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.HandleCreated>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#37](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#37)]
 [!code-vb[System.Windows.Forms.EventExamples#37](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HandleDestroyed">
      <MemberSignature Language="C#" Value="public event EventHandler HandleDestroyed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HandleDestroyed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HandleDestroyed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HandleDestroyed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HandleDestroyed;" />
      <MemberSignature Language="F#" Value="member this.HandleDestroyed : EventHandler " Usage="member this.HandleDestroyed : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのハンドルが破棄されているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 中に、<xref:System.Windows.Forms.Control.HandleDestroyed>イベント、コントロールが有効な Windows のコントロールでは引き続き、<xref:System.Windows.Forms.Control.Handle%2A>呼び出すことで再作成することができます、<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッド。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.HandleDestroyed>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.HandleDestroyed>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#38](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#38)]
 [!code-vb[System.Windows.Forms.EventExamples#38](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#38)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="HasChildren">
      <MemberSignature Language="C#" Value="public bool HasChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.HasChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChildren : bool" Usage="System.Windows.Forms.Control.HasChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに 1 つ以上の子コントロールが格納されているかどうかを示す値を取得します。</summary>
        <value>コントロールに 1 つ以上の子コントロールが格納されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.Controls%2A>コレクションには、<xref:System.Windows.Forms.Layout.ArrangedElementCollection.Count%2A>ゼロより大きい、<xref:System.Windows.Forms.Control.HasChildren%2A>プロパティが返す`true`。 アクセス、<xref:System.Windows.Forms.Control.HasChildren%2A>プロパティの作成を強制しません、<xref:System.Windows.Forms.Control.ControlCollection>子コントロールがない場合は、このプロパティを参照するため、パフォーマンスが向上ときに指定できますのコントロールのツリーをウォークします。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Windows.Forms.Control.BackColor%2A>と<xref:System.Windows.Forms.Control.ForeColor%2A>の既定のシステム カラーをコントロールします。 コードを再帰的には、コントロールに子コントロールがある場合は自分自身を呼び出します。 このコード例が必要です、<xref:System.Windows.Forms.Form>を少なくとも 1 つの子コントロールでただし、子コンテナーを制御するような<xref:System.Windows.Forms.Panel>または<xref:System.Windows.Forms.GroupBox>、わかりやすく示すためコントロールが、再帰、独自の子にします。  
  
 [!code-cpp[Windows.Forms.Control Properties#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#1)]
 [!code-vb[Windows.Forms.Control Properties#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Layout.ArrangedElementCollection.Count" />
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public int Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Height { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Height : int with get, set" Usage="System.Windows.Forms.Control.Height" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの高さを取得または設定します。</summary>
        <value>コントロールの高さ (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加えられた変更、<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Top%2A>プロパティ値が原因、<xref:System.Windows.Forms.Control.Bottom%2A>を変更するコントロールのプロパティの値。  
  
> [!NOTE]
>  派生コントロールの高さの最小値<xref:System.Windows.Forms.Splitter>1 ピクセルです。 既定の高さ、<xref:System.Windows.Forms.Splitter>コントロールが 3 ピクセルです。 高さの設定、<xref:System.Windows.Forms.Splitter>が既定の高さにプロパティの値をリセット 1 より小さい値を制御します。  
  
   
  
## Examples  
 次のコード例では、3 つを作成<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用して、そのサイズと位置を設定します。 この例が必要です、<xref:System.Windows.Forms.Form>少なくとも 300 ピクセルの高さ、幅を持ちます。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Drawing.Size.Height" />
      </Docs>
    </Member>
    <Member MemberName="HelpRequested">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HelpEventHandler HelpRequested;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HelpEventHandler HelpRequested" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.HelpRequested" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpRequested As HelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HelpEventHandler ^ HelpRequested;" />
      <MemberSignature Language="F#" Value="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " Usage="member this.HelpRequested : System.Windows.Forms.HelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがコントロールのヘルプを要求すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.HelpRequested> F1 キーを押したときにイベントが発生一般的キーまたは関連付けられている状況依存のヘルプ ボタンをクリックします。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、処理を示しています、 <xref:System.Windows.Forms.Control.HelpRequested> 4 つのアドレス フィールドを表示するフォームにカスタム ヘルプ コンテンツを表示するイベントです。 <xref:System.Windows.Forms.Control.HelpRequested>アドレス フィールドにフォーカスを持つ F1 キーを押すか、状況依存のヘルプ ボタンを使用してヘルプ カーソルを [アドレス] フィールドをクリックすると、イベントが発生します。 <xref:System.Windows.Forms.HelpEventArgs.Handled%2A>プロパティがあることを示す true に設定、`HelpRequested`イベントを処理します。 例も示していますのヘルプ テキストを格納する、<xref:System.Windows.Forms.Control.Tag%2A?displayProperty=nameWithType>プロパティ。  
  
 [!code-cpp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CPP/helpevent.cpp#1)]
 [!code-csharp[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/CS/helpevent.cs#1)]
 [!code-vb[System.Windows.Forms.HelpEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HelpEventHandler/VB/helpevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
        <altmember cref="T:System.Windows.Forms.HelpProvider" />
        <altmember cref="T:System.Windows.Forms.Help" />
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberSignature Language="F#" Value="member this.Hide : unit -&gt; unit" Usage="control.Hide " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールをユーザーに対して非表示にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 等しい設定は、コントロールを非表示、<xref:System.Windows.Forms.Control.Visible%2A>プロパティを`false`します。 後に、<xref:System.Windows.Forms.Control.Hide%2A>メソッドを呼び出すと、<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値を返します`false`まで、<xref:System.Windows.Forms.Control.Show%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次のコード例では、ボタンがクリックされたときに、CTRL キーが押された場合、ボタンが表示されません。 この例が必要です、<xref:System.Windows.Forms.Button>という名前の`button1`上、<xref:System.Windows.Forms.Form>します。  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
      </Docs>
    </Member>
    <Member MemberName="ImeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImeMode ImeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::ImeMode ImeMode { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeMode : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの IME (Input Method Editor) モードを取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.ImeMode" /> 値のいずれか。 既定値は、<see cref="F:System.Windows.Forms.ImeMode.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 IME は、標準キーボードを使用して複雑な文字と日本語の漢字などの記号を入力するようにするプログラムです。 <xref:System.Windows.Forms.Control.ImeMode%2A>プロパティに設定されて通常<xref:System.Windows.Forms.ImeMode.Off?displayProperty=nameWithType>の<xref:System.Windows.Forms.TextBox>数値のみ入力するためのものがコントロール。 <xref:System.Windows.Forms.Control.ImeMode%2A>プロパティの値に設定されて<xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType>の<xref:System.Windows.Forms.Form>クラス。  
  
 ほとんどのクラスを直接サポートして入力方式エディター、または、IME から直接入力を許可するのには、このプロパティの値が設定されます<xref:System.Windows.Forms.ImeMode.NoControl>します。  
  
> [!IMPORTANT]
>  ユーザーが変更できる対話形式で、<xref:System.Windows.Forms.Control.ImeMode%2A>にプログラムで設定されている場合を除き、<xref:System.Windows.Forms.ImeMode.Disable?displayProperty=nameWithType>します。 この場合、ユーザーは、IME を使用できません。  
>   
>  <xref:System.Windows.Forms.Control.ImeMode%2A>グローバル入力モードが有効な場合、Windows 8 のプロパティは無視されます。 詳細については、次を参照してください。[スイッチ テキスト入力からスレッドごとに変更 Per-user](https://go.microsoft.com/fwlink/?LinkID=256509)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">代入された値が、<see cref="T:System.Windows.Forms.ImeMode" /> 列挙値ではありません。</exception>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
        <altmember cref="P:System.Windows.Forms.Control.DefaultImeMode" />
      </Docs>
    </Member>
    <Member MemberName="ImeModeBase">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Forms.ImeMode ImeModeBase { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode ImeModeBase" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ImeModeBase" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Property ImeModeBase As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode ImeModeBase { System::Windows::Forms::ImeMode get(); void set(System::Windows::Forms::ImeMode value); };" />
      <MemberSignature Language="F#" Value="member this.ImeModeBase : System.Windows.Forms.ImeMode with get, set" Usage="System.Windows.Forms.Control.ImeModeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの IME モードを取得または設定します。</summary>
        <value>コントロールの IME モード。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeModeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ImeModeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeModeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ImeModeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeModeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeModeChanged;" />
      <MemberSignature Language="F#" Value="member this.ImeModeChanged : EventHandler " Usage="member this.ImeModeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ImeMode" /> プロパティが変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.ImeMode%2A>プロパティを変更すると、プログラムの変更によって、または相互作用使用します。  
  
 入力メソッドのマネージャーをサポートしないコントロールでは、このイベントが発生しません。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ*PropertyName* `Changed`にある場合に発生します、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="InitLayout">
      <MemberSignature Language="C#" Value="protected virtual void InitLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InitLayout" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InitLayout ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InitLayout();" />
      <MemberSignature Language="F#" Value="abstract member InitLayout : unit -&gt; unit&#xA;override this.InitLayout : unit -&gt; unit" Usage="control.InitLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールが別のコンテナーに追加された後、呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.InitLayout%2A>メソッドは、コンテナーにコントロールを追加した直後に呼び出されます。 <xref:System.Windows.Forms.Control.InitLayout%2A>メソッドは、そのコンテナーに基づくレイアウト状態を初期化するコントロールを使用できます。 たとえば、通常適用固定とドッキングのコントロールに、<xref:System.Windows.Forms.Control.InitLayout%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.InitLayout" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.InitLayout" />メソッド コントロールが正しく表示されるようにします。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Anchor" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invalidate">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールの特定の領域を無効にし、そのコントロールに描画メッセージを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate();" />
      <MemberSignature Language="F#" Value="member this.Invalidate : unit -&gt; unit" Usage="control.Invalidate " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの表面全体を無効化して、コントロールを再描画します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは同期の描画を強制しません。 同期の描画を強制的に、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出して、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッド。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体の更新領域に追加されます。  
  
   
  
## Examples  
 次のコード例で、イメージまたはイメージ ファイルをフォームにドラッグして、上の点で、表示するユーザーが削除されます。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームが描画されるたびに、イメージを再描画する。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドをフォームにドラッグされるデータの種類を決定および適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合イベント処理メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値は、画面座標、例では、<xref:System.Windows.Forms.Control.PointToClient%2A>クライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : bool -&gt; unit" Usage="control.Invalidate invalidateChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidateChildren">コントロールの子コントロールを無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールの特定の領域を無効にし、そのコントロールに描画メッセージを送信します。 オプションとして、そのコントロールに割り当てられている子コントロールも無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは同期の描画を強制しません。 同期の描画を強制的に、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出して、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッド。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体の更新領域に追加されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.Invalidate rc" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="rc">無効化する領域を表す <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは同期の描画を強制しません。 同期の描画を強制的に、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出して、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッド。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体の更新領域に追加されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region -&gt; unit" Usage="control.Invalidate region" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
      </Parameters>
      <Docs>
        <param name="region">無効化する <see cref="T:System.Drawing.Region" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは同期の描画を強制しません。 同期の描画を強制的に、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出して、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッド。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体の更新領域に追加されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(valuetype System.Drawing.Rectangle rc, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Rectangle,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Invalidate (rc As Rectangle, invalidateChildren As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Rectangle rc, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Rectangle * bool -&gt; unit" Usage="control.Invalidate (rc, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rc" Type="System.Drawing.Rectangle" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rc">無効化する領域を表す <see cref="T:System.Drawing.Rectangle" />。</param>
        <param name="invalidateChildren">コントロールの子コントロールを無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。 オプションとして、そのコントロールに割り当てられている子コントロールも無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは同期の描画を強制しません。 同期の描画を強制的に、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出して、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッド。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体の更新領域に追加されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidate">
      <MemberSignature Language="C#" Value="public void Invalidate (System.Drawing.Region region, bool invalidateChildren);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Invalidate(class System.Drawing.Region region, bool invalidateChildren) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Invalidate(System::Drawing::Region ^ region, bool invalidateChildren);" />
      <MemberSignature Language="F#" Value="member this.Invalidate : System.Drawing.Region * bool -&gt; unit" Usage="control.Invalidate (region, invalidateChildren)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="region" Type="System.Drawing.Region" />
        <Parameter Name="invalidateChildren" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="region">無効化する <see cref="T:System.Drawing.Region" />。</param>
        <param name="invalidateChildren">コントロールの子コントロールを無効にする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールの指定した領域を無効にし (そのコントロールの次の描画操作で再描画される領域を示す更新領域に追加し)、描画メッセージがそのコントロールに送信されるようにします。 オプションとして、そのコントロールに割り当てられている子コントロールも無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは同期の描画を強制しません。 同期の描画を強制的に、<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出して、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッド。 このメソッドはパラメーターなしで呼び出されると、クライアント領域全体の更新領域に追加されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Refresh" />
        <altmember cref="M:System.Windows.Forms.Control.Update" />
      </Docs>
    </Member>
    <Member MemberName="Invalidated">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InvalidateEventHandler Invalidated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InvalidateEventHandler Invalidated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Invalidated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Invalidated As InvalidateEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InvalidateEventHandler ^ Invalidated;" />
      <MemberSignature Language="F#" Value="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " Usage="member this.Invalidated : System.Windows.Forms.InvalidateEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InvalidateEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの表示に再描画が必要なときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.Invalidated>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.Invalidated>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#40](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#40)]
 [!code-vb[System.Windows.Forms.EventExamples#40](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#40)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールの基になるウィンドウ ハンドルを所有するスレッド上で、デリゲートを実行します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Invoke(class System.Delegate method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Invoke(Delegate ^ method);" />
      <MemberSignature Language="F#" Value="member this.Invoke : Delegate -&gt; obj" Usage="control.Invoke method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="method">コントロールのスレッド コンテキストで呼び出されるメソッドを格納しているデリゲート。</param>
        <summary>コントロールの基になるウィンドウ ハンドルを所有するスレッド上で、指定したデリゲートを実行します。</summary>
        <returns>呼び出されるデリゲートからの戻り値。デリゲートに戻り値がない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートは、C または C++ 言語の関数ポインターに似ています。 デリゲートは、デリゲート オブジェクト内のメソッドへの参照をカプセル化します。 デリゲート オブジェクト参照先のメソッドを呼び出すコードに渡すことができ、メソッドを呼び出すことができない既知コンパイル時にします。 C または C++ では、関数のポインターとは異なりデリゲートは、オブジェクト指向、タイプ セーフとセキュリティを強化します。  
  
 <xref:System.Windows.Forms.Control.Invoke%2A>チェーン コントロールの親コントロールまたはウィンドウのあるフォームが見つかるまでメソッドの検索が現在のコントロールの基になるウィンドウ ハンドルがまだ存在しない場合に処理します。 適切なハンドルが見つからない場合、<xref:System.Windows.Forms.Control.Invoke%2A>メソッドは例外をスローします。 呼び出し中に発生した例外は、呼び出し元に反映されます。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティはスレッド セーフであるコントロールの 4 つの方法があります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しにはコントロールのスレッドへの呼び出しをマーシャ リングするのに invoke メソッドのいずれかを使用する必要があります。  
  
 デリゲートのインスタンスであることができます<xref:System.EventHandler>、後者 sender パラメーターは、このコントロールを含むおよびイベント パラメーターが含まれます<xref:System.EventArgs.Empty?displayProperty=nameWithType>します。 デリゲートのインスタンスであることができますも<xref:System.Windows.Forms.MethodInvoker>、または void パラメーター リストを受け取るその他のデリゲート。 呼び出し、<xref:System.EventHandler>または<xref:System.Windows.Forms.MethodInvoker>デリゲートが別の種類のデリゲートの呼び出しよりも高速になります。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされます。  
  
   
  
## Examples  
 次のコード例では、デリゲートを格納しているコントロールを示します。 デリゲートが、リスト ボックスに項目を追加するメソッドをカプセル化し、このメソッドは、フォームの基になるハンドルを所有するスレッドで実行されます。 ボタンをクリックすると`Invoke`デリゲートを実行します。  
  
 [!code-cpp[Control_Invoke2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke2/CPP/control_invoke2.cpp#1)]
 [!code-csharp[Control_Invoke2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke2/CS/control_invoke2.cs#1)]
 [!code-vb[Control_Invoke2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke2/VB/control_invoke2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (Delegate method, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(class System.Delegate method, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Invoke(System.Delegate,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (method As Delegate, ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(Delegate ^ method, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member Invoke : Delegate * obj[] -&gt; obj&#xA;override this.Invoke : Delegate * obj[] -&gt; obj" Usage="control.Invoke (method, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ComponentModel.ISynchronizeInvoke.Invoke(System.Delegate,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.Delegate" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="method"><paramref name="args" /> パラメーターに指定されている数および型と同じ数および型のパラメーターをとるメソッドへのデリゲート。</param>
        <param name="args">指定したメソッドに引数として渡すオブジェクトの配列。 メソッドが引数をとらない場合、このパラメーターは <see langword="null" /> にすることができます。</param>
        <summary>コントロールの基になるウィンドウ ハンドルを所有するスレッド上で、指定した引数リストを使用して、指定したデリゲートを実行します。</summary>
        <returns>呼び出されるデリゲートからの戻り値を格納する <see cref="T:System.Object" />。デリゲートに戻り値がない場合は <see langword="null" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 デリゲートは、C または C++ 言語の関数ポインターに似ています。 デリゲートは、デリゲート オブジェクト内のメソッドへの参照をカプセル化します。 デリゲート オブジェクト参照先のメソッドを呼び出すコードに渡すことができ、メソッドを呼び出すことができない既知コンパイル時にします。 C または C++ では、関数のポインターとは異なりデリゲートは、オブジェクト指向、タイプ セーフとセキュリティを強化します。  
  
 コントロールのハンドルがまだ存在しない場合、このメソッドは、コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、コントロールの親チェーンを検索します。 適切なハンドルが見つからない場合、このメソッドは例外をスローします。 呼び出し中に発生した例外は、呼び出し元に反映されます。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティはスレッド セーフであるコントロールの 4 つの方法があります: <xref:System.Windows.Forms.Control.Invoke%2A>、 <xref:System.Windows.Forms.Control.BeginInvoke%2A>、 <xref:System.Windows.Forms.Control.EndInvoke%2A>、および<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しにはコントロールのスレッドへの呼び出しをマーシャ リングするのに invoke メソッドのいずれかを使用する必要があります。  
  
 デリゲートのインスタンスであることができます<xref:System.EventHandler>、後者 sender パラメーターは、このコントロールを含むおよびイベント パラメーターが含まれます<xref:System.EventArgs.Empty?displayProperty=nameWithType>します。 デリゲートのインスタンスであることができますも<xref:System.Windows.Forms.MethodInvoker>、または void パラメーター リストを受け取るその他のデリゲート。 呼び出し、<xref:System.EventHandler>または<xref:System.Windows.Forms.MethodInvoker>デリゲートが別の種類のデリゲートの呼び出しよりも高速になります。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされます。  
  
   
  
## Examples  
 次のコード例では、デリゲートを格納しているコントロールを示します。 デリゲートが、リスト ボックスに項目を追加するメソッドをカプセル化し、このメソッドは、指定した引数を使用して、フォームの基になるハンドルを所有するスレッドで実行されます。 ボタンをクリックすると`Invoke`デリゲートを実行します。  
  
 [!code-cpp[Control_Invoke1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Invoke1/CPP/control_invoke1.cpp#1)]
 [!code-csharp[Control_Invoke1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Invoke1/CS/control_invoke1.cs#1)]
 [!code-vb[Control_Invoke1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Invoke1/VB/control_invoke1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MethodInvoker" />
        <altmember cref="P:System.Windows.Forms.Control.InvokeRequired" />
      </Docs>
    </Member>
    <Member MemberName="InvokeGotFocus">
      <MemberSignature Language="C#" Value="protected void InvokeGotFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeGotFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeGotFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeGotFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeGotFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeGotFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">イベントの割り当て先の <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.GotFocus" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeLostFocus">
      <MemberSignature Language="C#" Value="protected void InvokeLostFocus (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeLostFocus(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeLostFocus (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeLostFocus(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeLostFocus : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeLostFocus (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke">イベントの割り当て先の <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.LostFocus" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeOnClick">
      <MemberSignature Language="C#" Value="protected void InvokeOnClick (System.Windows.Forms.Control toInvoke, EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokeOnClick(class System.Windows.Forms.Control toInvoke, class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokeOnClick (toInvoke As Control, e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokeOnClick(System::Windows::Forms::Control ^ toInvoke, EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokeOnClick : System.Windows.Forms.Control * EventArgs -&gt; unit" Usage="control.InvokeOnClick (toInvoke, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toInvoke" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="toInvoke"><see cref="T:System.Windows.Forms.Control" /> イベントの割り当て先の <see cref="E:System.Windows.Forms.Control.Click" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.Click" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokePaint">
      <MemberSignature Language="C#" Value="protected void InvokePaint (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaint(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaint (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaint(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaint : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaint (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Windows.Forms.Control" /> イベントの割り当て先の <see cref="E:System.Windows.Forms.Control.Paint" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>指定したコントロールの <see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="InvokePaintBackground">
      <MemberSignature Language="C#" Value="protected void InvokePaintBackground (System.Windows.Forms.Control c, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InvokePaintBackground(class System.Windows.Forms.Control c, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InvokePaintBackground (c As Control, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InvokePaintBackground(System::Windows::Forms::Control ^ c, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.InvokePaintBackground : System.Windows.Forms.Control * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.InvokePaintBackground (c, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Windows.Forms.Control" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="c"><see cref="T:System.Windows.Forms.Control" /> イベントの割り当て先の <see cref="E:System.Windows.Forms.Control.Paint" />。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>指定したコントロールの <see langword="PaintBackground" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InvokeRequired">
      <MemberSignature Language="C#" Value="public bool InvokeRequired { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool InvokeRequired" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.InvokeRequired" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InvokeRequired As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool InvokeRequired { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.InvokeRequired : bool" Usage="System.Windows.Forms.Control.InvokeRequired" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.ISynchronizeInvoke.InvokeRequired</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>呼び出し元がコントロールの作成されたスレッドと異なるスレッド上にあるため、コントロールに対してメソッドの呼び出しを実行するときに、呼び出し元で invoke メソッドを呼び出す必要があるかどうかを示す値を取得します。</summary>
        <value>コントロールの <see langword="true" /> が、呼び出し元スレッドと異なるスレッド上で作成された (invoke メソッドを通じてコントロールを呼び出す必要があることを示す) 場合は <see cref="P:System.Windows.Forms.Control.Handle" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォームのコントロールは、特定のスレッドにバインドされ、スレッド セーフではありません。 そのため、別のスレッドからコントロールのメソッドを呼び出す場合をする必要がありますを使用して、いずれかのコントロールの適切なスレッドの呼び出しをマーシャ リングするメソッドの呼び出し。 このプロパティは、かどうかは、どのようなスレッドは、コントロールを所有して把握していない場合に便利です、invoke メソッドを呼び出す必要がありますを使用できます。  
  
> [!NOTE]
>  加え、<xref:System.Windows.Forms.Control.InvokeRequired%2A>プロパティ、コントロールのスレッドの呼び出しは安全である 4 つのメソッドがある: <xref:System.Windows.Forms.Control.Invoke%2A>、<xref:System.Windows.Forms.Control.BeginInvoke%2A>、<xref:System.Windows.Forms.Control.EndInvoke%2A>と<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルが既に作成されている場合。 呼び出す<xref:System.Windows.Forms.Control.CreateGraphics%2A>コントロールのハンドルがバック グラウンド スレッドで作成される前に発生する可能性がクロス スレッドの呼び出しが無効です。 他のすべてのメソッド呼び出しのため、これらのいずれかを使用する必要があります別のスレッドからを呼び出すときにメソッドを呼び出します。  
  
 コントロールのハンドルがまだ存在しない場合<xref:System.Windows.Forms.Control.InvokeRequired%2A>コントロールまたはウィンドウ ハンドルを持つフォームが見つかるまで、検索は、コントロールの親チェーンをセットアップします。 適切なハンドルが見つからない場合、<xref:System.Windows.Forms.Control.InvokeRequired%2A>メソッドを返します。`false`します。  
  
 つまり、<xref:System.Windows.Forms.Control.InvokeRequired%2A>返すことができます`false`場合<xref:System.Windows.Forms.Control.Invoke%2A>は必要ありません (呼び出しは、同じスレッドで発生します)、またはコントロールが別のスレッドで作成されましたが、コントロールのハンドルが作成されていない場合。  
  
 コントロールのハンドルがまだ作成されていない場合は、呼び出す必要はありません単にプロパティ、メソッド、またはイベント コントロール。 メッセージ ポンプなしのスレッドでコントロールを分離し、により、アプリケーションを不安定、バック グラウンド スレッド上に作成されるコントロールのハンドルがある可能性があります。  
  
 またの値をチェックしてこのケースに照らしてを保護する<xref:System.Windows.Forms.Control.IsHandleCreated%2A>とき<xref:System.Windows.Forms.Control.InvokeRequired%2A>返します`false`バック グラウンド スレッドでします。 コントロール ハンドルが作成されていない場合に、呼び出す前に作成されるまでを待つ必要があります<xref:System.Windows.Forms.Control.Invoke%2A>または<xref:System.Windows.Forms.Control.BeginInvoke%2A>します。 これは、バック グラウンド スレッドが、アプリケーションのプライマリのフォームのコンス トラクターで作成された場合にのみ通常、(うに`Application.Run(new MainForm())`フォームが表示される前に、または`Application.Run`が呼び出されました。  
  
 1 つのソリューションでは、バック グラウンド スレッドを開始する前に、フォームのハンドルが作成されるまでを待ちます。 いずれかの強制的に呼び出すことによってハンドルを作成、<xref:System.Windows.Forms.Control.Handle%2A>プロパティ、またはまでの待機、<xref:System.Windows.Forms.Form.Load>イベントがバック グラウンド プロセスを開始します。  
  
 優れたソリューションでは、使用する、`SynchronizationContext`によって返される<xref:System.Threading.SynchronizationContext>スレッド間マーシャ リングするためのコントロールではなく。  
  
> [!NOTE]
>  メッセージを処理するスレッドがアクティブでなくなった場合、例外がスローされます。  
  
 マルチ スレッドの Windows フォーム コントロールの詳細については、次を参照してください。[方法。ファイルを検索するバック グラウンド スレッドを使用して](~/docs/framework/winforms/controls/how-to-use-a-background-thread-to-search-for-files.md)と[方法。Windows フォーム コントロールのスレッド セーフな呼び出しを行う](~/docs/framework/winforms/controls/how-to-make-thread-safe-calls-to-windows-forms-controls.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Invoke(System.Delegate)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeGotFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeLostFocus(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokeOnClick(System.Windows.Forms.Control,System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaint(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsAccessible">
      <MemberSignature Language="C#" Value="public bool IsAccessible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAccessible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsAccessible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsAccessible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAccessible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsAccessible : bool with get, set" Usage="System.Windows.Forms.Control.IsAccessible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがユーザー補助アプリケーションに表示されるかどうかを示す値を取得または設定します。</summary>
        <value>コントロールがユーザー補助アプリケーションに表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.Forms.AccessibleObject" />
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Windows.Forms.Control.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが破棄されているかどうかを示す値を取得します。</summary>
        <value>コントロールが破棄されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返す場合`true`コントロールが破棄され、有効な Windows のコントロールとしては参照されなくなったことができます。 コントロールのインスタンスが破棄されると、場合でもガベージ コレクションをメモリから削除されるまでメモリにまだ保持がされます。 呼び出すことはできません、コントロールが破棄されると、その<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Dispose(System.Boolean)" />
        <altmember cref="T:System.GC" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
      </Docs>
    </Member>
    <Member MemberName="IsHandleCreated">
      <MemberSignature Language="C#" Value="public bool IsHandleCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHandleCreated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsHandleCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHandleCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHandleCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHandleCreated : bool" Usage="System.Windows.Forms.Control.IsHandleCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにハンドルが関連付けられているかどうかを示す値を取得します。</summary>
        <value>コントロールにハンドルが関連付けられている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.IsHandleCreated%2A>プロパティを決定するかどうか<xref:System.Windows.Forms.Control.CreateHandle%2A>が呼び出されました。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="IsInputChar">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member IsInputChar : char -&gt; bool&#xA;override this.IsInputChar : char -&gt; bool" Usage="control.IsInputChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">テスト対象の文字。</param>
        <summary>文字が、コントロールによって認識される入力文字かどうかを判断します。</summary>
        <returns>文字をコントロールに直接送信する必要があり、プリプロセスしない場合は <see langword="true" />。それ以外の場合は、<see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.IsInputChar%2A>によって指定された文字にするかどうかを判断するメソッド、`charCode`パラメーターは、コントロールが表示される入力文字。 このメソッドは、指定した入力文字を前処理またはコントロールに直接送信されるかどうかを判断するウィンドウ メッセージのプリプロセス時に呼び出されます。 場合<xref:System.Windows.Forms.Control.IsInputChar%2A>返します`true`、指定した文字がコントロールに直接送信されます。 場合<xref:System.Windows.Forms.Control.IsInputChar%2A>返します`false`、指定した文字が前処理され、前処理中に消費していない場合のみ、コントロールに送信します。 文字の前処理では、文字は、別のコントロールのニーモニックかどうかをチェックが含まれています。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected virtual bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsInputKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsInputKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member IsInputKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.IsInputKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.IsInputKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData"><see cref="T:System.Windows.Forms.Keys" /> 値のいずれか。</param>
        <summary>指定されているキーが、通常の入力キーであるか、またはプリプロセスを必要とする特殊なキーであるかを確認します。</summary>
        <returns>指定されているキーが通常の入力キーである場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.IsInputKey%2A>によってキーが指定されているかどうかを判断するメソッド、`keyData`パラメーターは、コントロールが入力のキー。 このメソッドは、指定した入力キーの前処理またはコントロールに直接送信する必要があるかどうかを判断するウィンドウ メッセージのプリプロセス時に呼び出されます。 場合<xref:System.Windows.Forms.Control.IsInputKey%2A>返します`true`、指定したキーがコントロールに直接送信されます。 場合<xref:System.Windows.Forms.Control.IsInputKey%2A>返します`false`、指定したキーが前処理され、前処理中に消費していない場合のみ、コントロールに送信します。 前処理されたキーには、タブ、返された場合、esc キー、および上矢印、下矢印、左方向キー、および右矢印キーが含まれます。  
  
   
  
## Examples  
 次のコード例は、オーバーライドする方法を示します、<xref:System.Windows.Forms.Control.IsInputKey%2A>のメソッドを<xref:System.Windows.Forms.TextBox>コントロール。 この例で、`TabTextBox`クラスは、TAB キーを処理します。 ときに、`TabTextBox`にフォーカスがある、ユーザーは、選択したテキストを置き換えながらという 4 つの空白を追加して、テキスト挿入ポイントで TAB キーを押した。 既定で、<xref:System.Windows.Forms.TextBox>コントロールは、次のコントロールに入力フォーカスを移動することによって、TAB キーを処理します。 ここで、keypress に到達しません、<xref:System.Windows.Forms.Control.OnKeyDown%2A>メソッドのオーバーライド。 この既定の動作を防ぐために、<xref:System.Windows.Forms.Control.IsInputKey%2A>メソッドのオーバーライド`true`ユーザーが TAB キーを押すとします。 その他のすべてのキープレス、<xref:System.Windows.Forms.Control.IsInputKey%2A>メソッドのオーバーライドは基本クラスのバージョンのメソッドの呼び出しの結果を返します。  
  
 [!code-csharp[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/cs/form1.cs#0)]
 [!code-vb[System.Windows.Forms.Control.IsInputKey#0](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.IsInputKey/vb/form1.vb#0)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="T:System.Windows.Forms.Keys" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="P:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyLocked">
      <MemberSignature Language="C#" Value="public static bool IsKeyLocked (System.Windows.Forms.Keys keyVal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsKeyLocked(valuetype System.Windows.Forms.Keys keyVal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsKeyLocked(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsKeyLocked (keyVal As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsKeyLocked(System::Windows::Forms::Keys keyVal);" />
      <MemberSignature Language="F#" Value="static member IsKeyLocked : System.Windows.Forms.Keys -&gt; bool" Usage="System.Windows.Forms.Control.IsKeyLocked keyVal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyVal" Type="System.Windows.Forms.Keys" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="keyVal"><see cref="T:System.Windows.Forms.Keys" /> 列挙体の CAPS LOCK、NUM LOCK、または SCROLL LOCK の各メンバー。</param>
        <summary>CapsLock、NumLock、または ScrollLock の各キーが有効かどうかを判断します。</summary>
        <returns>指定されたキーが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.Forms.Control.IsKeyLocked%2A>プロパティを個別にかどうか、または組み合わせで CAPS LOCK、NUM LOCK、または SCROLL LOCK キーがオンになっているかどうかを判断します。  
  
   
  
## Examples  
 次のコード例では、指定したキー (この場合の Caps Lock キー) が有効かどうかを示すメッセージ ボックスが表示されます。  
  
 [!code-cpp[ControlIsKeyLocked#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ControlIsKeyLocked/CPP/controliskeylocked.cpp#1)]
 [!code-csharp[ControlIsKeyLocked#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ControlIsKeyLocked/CS/controliskeylocked.cs#1)]
 [!code-vb[ControlIsKeyLocked#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ControlIsKeyLocked/VB/controliskeylocked.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="keyVal" /> パラメーターは、CapsLock、NumLock、または ScrollLock の各キー以外のキーを参照します。</exception>
      </Docs>
    </Member>
    <Member MemberName="IsMirrored">
      <MemberSignature Language="C#" Value="public bool IsMirrored { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMirrored" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.IsMirrored" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMirrored As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMirrored { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMirrored : bool" Usage="System.Windows.Forms.Control.IsMirrored" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがミラー化されるかどうかを示す値を取得します。</summary>
        <value>コントロールがミラー化される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ミラー化されたコントロールは、レイアウトと右から左へのテキストの両方が表示されます。 詳細については、「[方法 :作成するミラー化された Windows フォームおよびコントロール](https://msdn.microsoft.com/library/7c5c4ecc-9bfb-4508-8383-753e306719b1)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMnemonic">
      <MemberSignature Language="C#" Value="public static bool IsMnemonic (char charCode, string text);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsMnemonic(char charCode, string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsMnemonic (charCode As Char, text As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsMnemonic(char charCode, System::String ^ text);" />
      <MemberSignature Language="F#" Value="static member IsMnemonic : char * string -&gt; bool" Usage="System.Windows.Forms.Control.IsMnemonic (charCode, text)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="charCode">テスト対象の文字。</param>
        <param name="text">検索対象の文字列。</param>
        <summary>指定した文字が、指定した文字列内のコントロールに割り当てられたニーモニック文字かどうかを確認します。</summary>
        <returns><paramref name="charCode" /> 文字が、コントロールに割り当てられたニーモニック文字である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ニーモニック文字が最初のインスタンスでの"&"の直後の文字を<xref:System.String>します。  
  
   
  
## Examples  
 次のコード例は、オーバーライドするボタン クラスの拡張機能を示します、<xref:System.Windows.Forms.Control.ProcessMnemonic%2A>メソッドがカスタム動作。 例では、使用も示しています、<xref:System.Windows.Forms.Control.CanSelect%2A>と<xref:System.Windows.Forms.Control.IsMnemonic%2A>プロパティ。 実行には、この例は、同じファイル内のフォーム クラスを使用して、次のコードを貼り付けます。 型のボタンを追加する`MnemonicButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがあるときにキーが押されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重要なイベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 フォーム レベルでのみ、キーボード イベントを処理し、キーボード イベントを受信するには、他のコントロール、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント処理メソッドを`true`します。 タブ、返された場合、esc キー、および矢印キーなどの特定のキーがコントロールによって自動的に処理されます。 これらのキーを生成する、<xref:System.Windows.Forms.Control.KeyDown>イベントをオーバーライドする必要がある、<xref:System.Windows.Forms.Control.IsInputKey%2A>フォーム上の各コントロールのメソッド。 オーバーライドのコード、<xref:System.Windows.Forms.Control.IsInputKey%2A>が押されたかどうか、特殊なキーのいずれかを決定し、値を返す必要があります`true`します。 オーバーライドする代わりに、<xref:System.Windows.Forms.Control.IsInputKey%2A>処理するメソッド、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベントとセット、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティを`true`します。 コード例では、次を参照してください。、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベント。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyDown>イベントをコントロールに入力した文字の種類を判断します。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
 次のコード例は、発生の順序を示します、 <xref:System.Windows.Forms.Control.KeyDown>、 <xref:System.Windows.Forms.Control.KeyUp>、<xref:System.Windows.Forms.Control.KeyPress>イベント、およびそれらのイベント ハンドラーを登録する方法。  
 
 [!code-csharp[Control.KeyDown#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyDown#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.KeyEventArgs" />
        <altmember cref="T:System.Windows.Forms.KeyEventHandler" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyPressEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyPressEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As KeyPressEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyPressEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " Usage="member this.KeyPress : System.Windows.Forms.KeyPressEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyPressEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがあるときに、文字、 スペース、または Backspace キーが押された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重要なイベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 <xref:System.Windows.Forms.Control.KeyPress>領域とバック スペース以外の非文字キー イベントは発生しません。 ただし、非文字キーを生成しないでください、<xref:System.Windows.Forms.Control.KeyDown>と<xref:System.Windows.Forms.Control.KeyUp>イベント。  
  
 使用して、<xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A>サンプル キーストロークを実行時にし、使用または一般的なキーボード操作のサブセットを変更するプロパティ。  
  
 フォーム レベルでのみ、キーボード イベントを処理し、キーボード イベントを受信するには、他のコントロール、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント処理メソッドを`true`します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyPress>文字がコントロールに入力するを防ぐためにイベント。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
 
 
  次のコード例は、増大の順序を示します、 <xref:System.Windows.Forms.Control.KeyDown>、<xref:System.Windows.Forms.Control.KeyUp>と<xref:System.Windows.Forms.Control.KeyPress>イベント、それらのイベント ハンドラーを登録する方法もします。  
 
 [!code-csharp[Control.KeyPress#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyPress#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.KeyPressEventArgs.KeyChar" />
        <altmember cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Forms.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 重要なイベントは、次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.KeyDown>  
  
2.  <xref:System.Windows.Forms.Control.KeyPress>  
  
3.  <xref:System.Windows.Forms.Control.KeyUp>  
  
 フォーム レベルでのみ、キーボード イベントを処理し、キーボード イベントを受信するには、他のコントロール、設定、<xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType>フォームのプロパティ<xref:System.Windows.Forms.Control.KeyPress>イベント処理メソッドを`true`します。 タブ、返された場合、esc キー、および矢印キーなどの特定のキーがコントロールによって自動的に処理されます。 これらのキーを生成する、<xref:System.Windows.Forms.Control.KeyUp>イベントをオーバーライドする必要がある、<xref:System.Windows.Forms.Control.IsInputKey%2A>フォーム上の各コントロールのメソッド。 コードのオーバーライドを<xref:System.Windows.Forms.Control.IsInputKey%2A>が押されたかどうか、特殊なキーのいずれかを決定し、値を返す必要があります`true`します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyUp>イベントを<xref:System.Windows.Forms.Help>をユーザーにポップアップ スタイルのヘルプを表示するクラス。  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
 
 
  次のコード例は、増大の順序を示します、 <xref:System.Windows.Forms.Control.KeyDown>、<xref:System.Windows.Forms.Control.KeyUp>と<xref:System.Windows.Forms.Control.KeyPress>イベント、それらのイベント ハンドラーを登録する方法もします。  
 
 [!code-csharp[Control.KeyUp#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form2.cs#1)]
 [!code-vb[Control.KeyUp#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/Form2.vb#1)]
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="Layout">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LayoutEventHandler Layout;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LayoutEventHandler Layout" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Layout" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Layout As LayoutEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LayoutEventHandler ^ Layout;" />
      <MemberSignature Language="F#" Value="member this.Layout : System.Windows.Forms.LayoutEventHandler " Usage="member this.Layout : System.Windows.Forms.LayoutEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LayoutEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの子コントロールの位置を変更する必要があるときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Layout>イベントは、子コントロールが追加または削除、コントロールの変更、およびその他の変更が発生すると、境界は、コントロールのレイアウトに影響を受けた場合に発生します。 使用して、レイアウト イベントを抑制することができます、<xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド。 レイアウトを中断するには、それぞれの変更、レイアウトを実行することがなくコントロールで複数のアクションを実行することができます。 たとえば、サイズを変更して、コントロールを移動する場合は、各操作が発生する<xref:System.Windows.Forms.Control.Layout>イベント。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例のセンター、<xref:System.Windows.Forms.Form>の画面で、<xref:System.Windows.Forms.Control.Layout>イベント。 これにより、ユーザーがサイズを変更中央フォームが保持されます。 この例では、作成済みである必要があります、<xref:System.Windows.Forms.Form>コントロール。  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
      </Docs>
    </Member>
    <Member MemberName="LayoutEngine">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.Layout.LayoutEngine LayoutEngine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Layout.LayoutEngine LayoutEngine" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.LayoutEngine" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property LayoutEngine As LayoutEngine" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::Layout::LayoutEngine ^ LayoutEngine { System::Windows::Forms::Layout::LayoutEngine ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LayoutEngine : System.Windows.Forms.Layout.LayoutEngine" Usage="System.Windows.Forms.Control.LayoutEngine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Layout.LayoutEngine</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのレイアウト エンジンのキャッシュ インスタンスを取得します。</summary>
        <value>コントロールの内容の <see cref="T:System.Windows.Forms.Layout.LayoutEngine" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.LayoutEngine%2A>プロパティ、コントロール自体ではなく、コントロールの子のレイアウト エンジンを取得します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Layout.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public event EventHandler Leave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Leave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Leave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Leave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Leave;" />
      <MemberSignature Language="F#" Value="member this.Leave : EventHandler " Usage="member this.Leave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力フォーカスがコントロールを離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 フォーカスを変更すると、マウスを使用して、または呼び出すことによって、<xref:System.Windows.Forms.Control.Focus%2A>メソッドでは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>によってイベントが抑制されます、<xref:System.Windows.Forms.Form>クラス。 同等のイベント、<xref:System.Windows.Forms.Form>クラスは、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 <xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>イベントを階層し、適切なコントロールに到達するまで、親のチェーンを上下に伝播します。 たとえば、ある場合、<xref:System.Windows.Forms.Form>の 2 つ<xref:System.Windows.Forms.GroupBox>コントロール、および各<xref:System.Windows.Forms.GroupBox>コントロールが 1 つ<xref:System.Windows.Forms.TextBox>コントロール。 1、カレットを移動するとき<xref:System.Windows.Forms.TextBox>、他の<xref:System.Windows.Forms.Control.Leave>のイベントは、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.Control.Enter>イベントは、他の<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.TextBox>。  
  
> [!CAUTION]
>  内からフォーカスを設定しないで、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションまたはオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピック。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Leave>コントロールを元の状態にリセットするイベントです。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public int Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Left { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Left : int with get, set" Usage="System.Windows.Forms.Control.Left" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの左端とコンテナーのクライアント領域の左端の間の距離をピクセルで取得または設定します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの左端とコンテナーのクライアント領域の左端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Left%2A>プロパティの値が等しく、<xref:System.Drawing.Point.X%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Windows.Forms.Control.Location%2A>コントロールのプロパティの値。  
  
 加えられた変更、<xref:System.Windows.Forms.Control.Width%2A>と<xref:System.Windows.Forms.Control.Left%2A>プロパティ値が原因、<xref:System.Windows.Forms.Control.Right%2A>を変更するコントロールのプロパティの値。  
  
   
  
## Examples  
 次のコード例では、3 つを作成<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用して、そのサイズと位置を設定します。 この例が必要です、<xref:System.Windows.Forms.Form>少なくとも 300 ピクセルの高さ、幅を持ちます。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.X" />
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberSignature Language="F#" Value="member this.Location : System.Drawing.Point with get, set" Usage="System.Windows.Forms.Control.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテナーの左上隅に対する相対座標として、コントロールの左上隅の座標を取得または設定します。</summary>
        <value>コントロールの左上隅をコンテナーの左上隅に対して相対的に表す <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point>クラスは、値型 (`Structure` Visual Basic で`struct`Visual C# で)、値、つまり、コントロールの左上隅の点のコピーを返すプロパティにアクセスすることが返されます。 そのため、調整、<xref:System.Drawing.Point.X%2A>または<xref:System.Drawing.Point.Y%2A>のプロパティ、<xref:System.Drawing.Point>これから返されるプロパティには影響は、 <xref:System.Windows.Forms.Control.Left%2A>、 <xref:System.Windows.Forms.Control.Right%2A>、 <xref:System.Windows.Forms.Control.Top%2A>、または<xref:System.Windows.Forms.Control.Bottom%2A>コントロールのプロパティの値。 これらのプロパティを個別に、各プロパティ値を設定したり、設定を調整する、<xref:System.Windows.Forms.Control.Location%2A>プロパティを新しい<xref:System.Drawing.Point>します。  
  
 場合、<xref:System.Windows.Forms.Control>は、 <xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Control.Location%2A>プロパティの値の左上隅を表す、<xref:System.Windows.Forms.Form>画面座標。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>および一部の一般的なプロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>フォームの上部に、グループ ボックス ドッキングし、グループ ボックスのプロパティ。 グループ ボックスを無効に設定して、最後に、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックス内に含まれるすべてのコントロール。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberSignature Language="F#" Value="member this.LocationChanged : EventHandler " Usage="member this.LocationChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Location" /> プロパティ値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Location%2A>プロパティを変更すると、プログラムの変更によって、または相互作用使用します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例が発生、<xref:System.Windows.Forms.Control.LocationChanged>上のイベントを<xref:System.Windows.Forms.StatusStrip>フォームのサイズを変更するとします。  
  
 [!code-csharp[System.Windows.Forms.LocationChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.LocationChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.LocationChanged/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public System.Drawing.Size LogicalToDeviceUnits (System.Drawing.Size value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Size LogicalToDeviceUnits(valuetype System.Drawing.Size value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Size LogicalToDeviceUnits(System::Drawing::Size value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">拡大縮小するサイズ。</param>
        <summary>現在の DPI に合わせて拡大縮小し、幅と高さを最も近い整数値に丸めることで論理単位からデバイス単位にサイズを変換します。</summary>
        <returns>拡大縮小されたサイズ。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalToDeviceUnits">
      <MemberSignature Language="C#" Value="public int LogicalToDeviceUnits (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LogicalToDeviceUnits(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.LogicalToDeviceUnits(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LogicalToDeviceUnits (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LogicalToDeviceUnits(int value);" />
      <MemberSignature Language="F#" Value="member this.LogicalToDeviceUnits : int -&gt; int" Usage="control.LogicalToDeviceUnits value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="value">変換する論理値。</param>
        <summary>論理 DPI 値をその同等 DeviceUnit DPI 値に変換します。</summary>
        <returns>結果の DeviceUnit 値。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event EventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : EventHandler " Usage="member this.LostFocus : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 フォーカスを変更すると、マウスを使用して、または呼び出すことによって、<xref:System.Windows.Forms.Control.Focus%2A>メソッドでは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 場合、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>に設定されている`true`で、<xref:System.Windows.Forms.Control.Validating>イベント デリゲート、後に通常発生するすべてのイベント、<xref:System.Windows.Forms.Control.Validating>イベントが抑制されます。  
  
> [!NOTE]
>  <xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、低レベルのフォーカス イベント WM_KILLFOCUS と WM_SETFOCUS Windows メッセージに関連付けられています。 通常、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントは、更新するときにのみ使用<xref:System.Windows.Forms.UICues>またはカスタム コントロールを作成します。 代わりに、<xref:System.Windows.Forms.Control.Enter>と<xref:System.Windows.Forms.Control.Leave>を除くすべてのコントロールのイベントを使用する必要があります、<xref:System.Windows.Forms.Form>クラスを使用する、<xref:System.Windows.Forms.Form.Activated>と<xref:System.Windows.Forms.Form.Deactivate>イベント。 詳細については、<xref:System.Windows.Forms.Control.GotFocus>と<xref:System.Windows.Forms.Control.LostFocus>イベントを参照してください、 [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)と[WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピック。  
  
> [!CAUTION]
>  内からフォーカスを設定しないで、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションまたはオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms646282\(v=vs.85\).aspx)トピック。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、TextBox1 のテキストを検証を示します。 処理も示しています、<xref:System.Windows.Forms.Control.LostFocus>イベントを設定して、 <xref:System.Windows.Forms.FileDialog.InitialDirectory%2A?displayProperty=nameWithType> TextBox1 でテキストのプロパティ。 使用しているコード例、<xref:System.Windows.Forms.ErrorProvider.GetError%2A?displayProperty=nameWithType>ファイル ダイアログ ボックスを開く前に、エラーをチェックするメソッド。 この例を実行するには、含まれているフォームに次のコードを貼り付けます、<xref:System.Windows.Forms.TextBox>という名前`TextBox1`、<xref:System.Windows.Forms.OpenFileDialog>という名前`OpenFileDialog1`、<xref:System.Windows.Forms.Button>という名前`Button1`、および<xref:System.Windows.Forms.ErrorProvider>という`ErrorProvider1`。 すべてのイベントがイベント ハンドラーに関連付けられていることを確認します。  
  
 [!code-cpp[System.Windows.Forms.FileDialog#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CPP/filedialogform.cpp#2)]
 [!code-csharp[System.Windows.Forms.FileDialog#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/CS/filedialogform.cs#2)]
 [!code-vb[System.Windows.Forms.FileDialog#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FileDialog/VB/filedialogform.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Margin : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Margin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール間の空白を取得または設定します。</summary>
        <value>コントロール間の空白を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールの既定値が表示される<xref:System.Windows.Forms.Control.Margin%2A>Windows ユーザー インターフェイス ガイドラインの近くにある程度であります。 いくつかの調整は、特定のアプリケーションに必要なある可能性があります。  
  
> [!NOTE]
>  設定、<xref:System.Windows.Forms.Control.Margin%2A>ドッキングされたコントロールのプロパティは、そのコンテナーの端からの距離に影響を与えません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberSignature Language="F#" Value="member this.MarginChanged : EventHandler " Usage="member this.MarginChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのマージンが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.MarginChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.MarginChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#21](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#21)]
 [!code-vb[System.Windows.Forms.EventExamples#21](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#21)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MaximumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MaximumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.AmbientValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> が指定できる上限のサイズを取得または設定します。</summary>
        <value>四角形の幅と高さを表す、順序を付与した <see cref="T:System.Drawing.Size" /> 型のペア。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.MinimumSize : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.MinimumSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.GetPreferredSize(System.Drawing.Size)" /> が指定できる下限のサイズを取得または設定します。</summary>
        <value>四角形の幅と高さを表す、順序を付与した <see cref="T:System.Drawing.Size" /> 型のペア。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModifierKeys">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Keys ModifierKeys { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.Keys ModifierKeys" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ModifierKeys" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ModifierKeys As Keys" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Keys ModifierKeys { System::Windows::Forms::Keys get(); };" />
      <MemberSignature Language="F#" Value="member this.ModifierKeys : System.Windows.Forms.Keys" Usage="System.Windows.Forms.Control.ModifierKeys" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Keys</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>どの修飾子キー (Shift キー、Ctrl キーおよび Alt キー) が押された状態であるかを示す値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.Keys" /> 値のビットごとの組み合わせ。 既定値は、<see cref="F:System.Windows.Forms.Keys.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例では、ボタンがクリックされたときに、CTRL キーが押されたときにボタンを非表示にします。 この例が必要です、<xref:System.Windows.Forms.Button>という名前の`button1`上、<xref:System.Windows.Forms.Form>します。  
  
 [!code-cpp[Windows.Forms.Control Members4#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members4#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#2)]
 [!code-vb[Windows.Forms.Control Members4#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Keys" />
      </Docs>
    </Member>
    <Member MemberName="MouseButtons">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.MouseButtons MouseButtons { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.MouseButtons MouseButtons" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MouseButtons" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MouseButtons As MouseButtons" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::MouseButtons MouseButtons { System::Windows::Forms::MouseButtons get(); };" />
      <MemberSignature Language="F#" Value="member this.MouseButtons : System.Windows.Forms.MouseButtons" Usage="System.Windows.Forms.Control.MouseButtons" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseButtons</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>どのマウス ボタンが押されている状態であるかを示す値を取得します。</summary>
        <value><see cref="T:System.Windows.Forms.MouseButtons" /> 列挙値のビットごとの組み合わせ。 既定値は、<see cref="F:System.Windows.Forms.MouseButtons.None" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、使用する方法を示します、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.RectangleToScreen%2A>、 <xref:System.Windows.Forms.Control.PointToScreen%2A>、 <xref:System.Windows.Forms.Control.MouseButtons%2A>、 <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>、および<xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>メンバー。 例を実行するには、Form1 という形式で次のコードを貼り付けいくつかのコントロールを格納しています。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseMove>、および<xref:System.Windows.Forms.Control.MouseUp>イベントは、この例で定義されているイベント ハンドラーに接続しています。  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MouseButtons" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseCaptureChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MouseCaptureChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseCaptureChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseCaptureChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseCaptureChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseCaptureChanged;" />
      <MemberSignature Language="F#" Value="member this.MouseCaptureChanged : EventHandler " Usage="member this.MouseCaptureChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがマウスのキャプチャを失うと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 まれなシナリオでは、予期しない入力を検出する必要があります。 たとえば、次のシナリオを検討してください。  
  
-   マウス操作中には、ユーザーは、Windows キーまたは ctrl キーを押しながら esc キーを押して、[スタート] メニューを開きます。  
  
-   ユーザーは、マウス操作中に、ALT + TAB キーを押して別のプログラムに切り替わります。  
  
-   マウス操作中に、別のプログラムは、ウィンドウまたは現在のアプリケーションからフォーカスを受け取るメッセージ ボックスが表示されます。  
  
 クリックし、フォームまたはコントロールを上にマウス ポインターを保持しているマウス操作を含めることができますか、操作をドラッグ、マウスを実行します。 フォームを検出する、またはコントロールは、これらのマウス キャプチャを失った場合、関連の予期しないシナリオを使用できます、<xref:System.Windows.Forms.Control.MouseCaptureChanged>イベント。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Windows.Forms.Control.MouseCaptureChanged>イベントを<xref:System.Windows.Forms.Button>コントロール。  
  
 [!code-csharp[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.MouseCaptureChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.mousecapturechanged/vb/form1.vb#1)]  
  
 この例をテストするには、f5 キーを押して、デバッガーで実行します。 開く、**出力**Visual Studio のウィンドウにイベントが発生した場合に表示できるようにします。 をクリックして、<xref:System.Windows.Forms.Button>し、次の出力に注意してください。  
  
 `button1_MouseDown`  
  
 `button1_MouseUp`  
  
 `button1_MouseCaptureChanged`  
  
 ここで、 をクリックしマウスの左ボタンを押したまま、<xref:System.Windows.Forms.Button>コントロール。 まだマウスをクリックして、別のプログラムに切り替えるには、ALT + TAB キーを押します。 注意、<xref:System.Windows.Forms.Control.MouseCaptureChanged>可能性のあるこのシナリオを処理できるようにイベントが発生します。 自分の操作によって、<xref:System.Windows.Forms.Control.MouseUp>イベントが発生しなくなります。 このテストは、Windows キーまたは ctrl キーを押しながら esc キーを試すこともできます。  
  
 `button1_MouseDown`  
  
 `button1_MouseCaptureChanged`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseClick;" />
      <MemberSignature Language="F#" Value="member this.MouseClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウスでコントロールをクリックしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール上では、通常、カーソルとマウス ボタンを押すと、次の一連のコントロールからのイベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> イベント。  
  
2.  <xref:System.Windows.Forms.Control.Click> イベント。  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> イベント。  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> イベント。  
  
 これを行うには、コントロールのクラスでさまざまなイベントを無効にすることはできません。  
  
 2 つの単一のユーザーのオペレーティング システムでは、マウスの設定によって決定される短い時間、間隔でが生成されますが発生したクリック、 <xref:System.Windows.Forms.Control.MouseDoubleClick> 、2 つ目ではなくイベント<xref:System.Windows.Forms.Control.MouseClick>イベント。  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.Click> イベントは、コントロールの論理的に上位レベルのイベントです。 このイベントは、コントロールにフォーカスがある場合は、ENTER キーを押すなどその他のアクションによって発生する多くの場合は。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.MouseClick>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.MouseClick>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#54](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#54)]
 [!code-vb[System.Windows.Forms.EventExamples#54](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDoubleClick As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDoubleClick;" />
      <MemberSignature Language="F#" Value="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDoubleClick : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウスでコントロールをダブルクリックしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MouseDoubleClick>コントロールの上にカーソルがあるときに、ユーザーが立て続けに 2 回のマウスのボタン イベントは発生します。 ダブルクリックを 2 回のクリックを 1 つを区別する時間間隔については、ユーザーのオペレーティング システムのマウス設定によって決まります。  
  
 このようなユーザー操作が発生すると、コントロールによって次の一連のイベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseDown> イベント。  
  
2.  <xref:System.Windows.Forms.Control.Click> イベント。  
  
3.  <xref:System.Windows.Forms.Control.MouseClick> イベント。  
  
4.  <xref:System.Windows.Forms.Control.MouseUp> イベント。  
  
5.  <xref:System.Windows.Forms.Control.MouseDown> イベント。  
  
6.  <xref:System.Windows.Forms.Control.DoubleClick> イベント。  
  
7.  <xref:System.Windows.Forms.Control.MouseDoubleClick> イベント。  
  
8.  <xref:System.Windows.Forms.Control.MouseUp> イベント。  
  
 これを行うには、コントロールのクラスでさまざまなイベントを無効にすることはできません。  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Control.DoubleClick> イベントは、コントロールの論理的に上位レベルのイベントです。 これらは、ショートカット キーの組み合わせなどの他のユーザー操作によって発生可能性があります。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.MouseDoubleClick>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.MouseDoubleClick>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#55](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#55)]
 [!code-vb[System.Windows.Forms.EventExamples#55](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#55)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.MouseDoubleClick" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseDown : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロール上にあり、マウス ボタンがクリックされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseClick" />
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event EventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : EventHandler " Usage="member this.MouseEnter : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターによってコントロールが入力されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseHover">
      <MemberSignature Language="C#" Value="public event EventHandler MouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseHover" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseHover As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseHover;" />
      <MemberSignature Language="F#" Value="member this.MouseHover : EventHandler " Usage="member this.MouseHover : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターをコントロールの上に重ねると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 一般的な使用<xref:System.Windows.Forms.Control.MouseHover>コントロール (「静止領域」) の周囲の指定した領域内のコントロールでマウスを置いたときに、ツール ヒントを表示することです。 このイベントが発生するのに必要な一時停止がでミリ秒単位で指定された、<xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>プロパティ。  
  
 <xref:System.Windows.Forms.Control.MouseHover>イベントが定義されているし、で検出された、<xref:System.Windows.Forms.SystemInformation.MouseHoverSize%2A>と<xref:System.Windows.Forms.SystemInformation.MouseHoverTime%2A>プロパティ。  
  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MouseHoverTime" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event EventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : EventHandler " Usage="member this.MouseLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロールを離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロール上を移動すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 典型的な使用<xref:System.Windows.Forms.Control.MouseMove>はコントロールの色を変更する、または発生したコントロールを囲む四角形を描画します。  
  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MousePosition">
      <MemberSignature Language="C#" Value="public static System.Drawing.Point MousePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Drawing.Point MousePosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.MousePosition" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MousePosition As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Drawing::Point MousePosition { System::Drawing::Point get(); };" />
      <MemberSignature Language="F#" Value="member this.MousePosition : System.Drawing.Point" Usage="System.Windows.Forms.Control.MousePosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス カーソルの位置を画面座標で取得します。</summary>
        <value>画面の左上隅に対する相対座標として、マウス カーソルの座標を格納している <see cref="T:System.Drawing.Point" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.MousePosition%2A>プロパティが返す、<xref:System.Drawing.Point>プロパティの参照時にマウス カーソルの位置を表します。 座標は画面で、コントロール、相対的ではない位置を示すし、コントロール上でカーソルが配置されているかどうかに関係なく返されます。 画面の左上隅の座標は、0, 0 です。  
  
 <xref:System.Windows.Forms.Control.MousePosition%2A>プロパティのと同じですが、<xref:System.Windows.Forms.Cursor.Position%2A?displayProperty=nameWithType>プロパティ。  
  
   
  
## Examples  
 次のコード例、<xref:System.Windows.Forms.TreeNode>ラベル ツリー ノード上にマウス カーソルがあるときに、ユーザーが ALT + E を押したときに編集可能な状態にします。 ユーザーが完了したら、ラベルを編集するには、ラベルは編集できませんもう一度再 ALT + E キーの組み合わせが押されるまでです。 この例が必要です、<xref:System.Windows.Forms.TreeView>上、<xref:System.Windows.Forms.Form>します。 ツリー ビューでは少なくとも 1 つが必要も<xref:System.Windows.Forms.TreeNode>でその<xref:System.Windows.Forms.TreeView.Nodes%2A>コレクション。  
  
 [!code-cpp[Windows.Forms.Control Members4#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CPP/controlmembers4.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members4#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members4/CS/controlmembers4.cs#3)]
 [!code-vb[Windows.Forms.Control Members4#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members4/VB/controlmembers4.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseUp : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがコントロール上にある状態でマウス ボタンが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
> [!NOTE]
>  に対して、次のイベントは発生しません、<xref:System.Windows.Forms.TabControl>クラスの 1 つ以上ある場合を除き、<xref:System.Windows.Forms.TabPage>で、<xref:System.Windows.Forms.TabControl.TabPages%2A?displayProperty=nameWithType>コレクション: <xref:System.Windows.Forms.Control.Click>、 <xref:System.Windows.Forms.Control.DoubleClick>、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseUp>、 <xref:System.Windows.Forms.Control.MouseHover>、 <xref:System.Windows.Forms.Control.MouseEnter>、<xref:System.Windows.Forms.Control.MouseLeave>と<xref:System.Windows.Forms.Control.MouseMove>します。 少なくとも 1 つを使用する必要がある場合<xref:System.Windows.Forms.TabPage>、コレクション内でユーザーがタブ コントロールのヘッダーを操作し、(場所、<xref:System.Windows.Forms.TabPage>名前が表示されます)、<xref:System.Windows.Forms.TabControl>適切なイベントを発生させます。 ただし、タブ ページのクライアント領域内のユーザーとの対話がの場合、<xref:System.Windows.Forms.TabPage>適切なイベントを発生させます。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MouseEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MouseEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MouseEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " Usage="member this.MouseWheel : System.Windows.Forms.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールにフォーカスがある間に、マウスのホイールを移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 処理するときに、<xref:System.Windows.Forms.Control.MouseWheel>イベントは、マウス ホイールに関連付けられているユーザー インターフェイス (UI) の標準に準拠することが重要です。 <xref:System.Windows.Forms.MouseEventArgs.Delta%2A?displayProperty=nameWithType>プロパティの値は、マウス ホイールの回転の量が移動されたことを示します。 UI には、蓄積された差分がプラスまたはマイナス 120 をスクロールする必要があります。 UI がによって返される論理行の数をスクロールする必要があります、<xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType>デルタ値ごとにプロパティに達しました。 スクロールできますより円滑に小さいその 120 ユニットずつ増加比率が一定に保たつまりただし<xref:System.Windows.Forms.SystemInformation.MouseWheelScrollLines%2A?displayProperty=nameWithType>行のスクロール ホイールの動きの 120 のデルタ単位ごと。  
  
 マウス ホイールのメッセージの処理の詳細については、次を参照してください。、 [WM_MOUSEWHEEL](https://msdn.microsoft.com/library/windows/desktop/ms645617\(v=vs.85\).aspx)トピック。  
  
 マウス イベントは次の順序で発生します。  
  
1.  <xref:System.Windows.Forms.Control.MouseEnter>  
  
2.  <xref:System.Windows.Forms.Control.MouseMove>  
  
3.  <xref:System.Windows.Forms.Control.MouseHover> / <xref:System.Windows.Forms.Control.MouseDown> / <xref:System.Windows.Forms.Control.MouseWheel>  
  
4.  <xref:System.Windows.Forms.Control.MouseUp>  
  
5.  <xref:System.Windows.Forms.Control.MouseLeave>  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示しますマウスのパスを描画するためにさまざまなマウス イベントを使用して、<xref:System.Windows.Forms.Panel>します。 線分を追加、<xref:System.Drawing.Drawing2D.GraphicsPath>各<xref:System.Windows.Forms.Control.MouseMove>と<xref:System.Windows.Forms.Control.MouseDown>発生するイベントです。 グラフィックスを更新する、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドが呼び出されます、<xref:System.Windows.Forms.Panel>各`MouseDown`と`MouseUp`イベント。 さらに、グラフィック パスがときに上下にスクロールされる基準、<xref:System.Windows.Forms.Control.MouseWheel>イベントが発生します。 などの他のマウス イベント、 <xref:System.Windows.Forms.Control.MouseHover>、画面も識別されます。 マウスの詳細については、画面に表示することも、<xref:System.Windows.Forms.SystemInformation>クラス。  
  
 [!code-cpp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CPP/mouseeventexample.cpp#1)]
 [!code-csharp[System.Windows.Forms.MouseEvent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/CS/mouseeventexample.cs#1)]
 [!code-vb[System.Windows.Forms.MouseEvent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MouseEvent/VB/mouseeventexample.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public event EventHandler Move;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Move" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Move" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Move As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Move;" />
      <MemberSignature Language="F#" Value="member this.Move : EventHandler " Usage="member this.Move : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが移動されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Move>フォームの位置を画面座標、フォームのキャプション バーに表示するイベントです。  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.Control.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの名前を取得または設定します。</summary>
        <value>コントロールの名前。 既定値は、空の文字列 ("") です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Name%2A>プロパティできます実行時に、オブジェクトを評価する名前ではなく型とプログラム名でします。 <xref:System.Windows.Forms.Control.Name%2A>プロパティが返す、<xref:System.String>型はケース スタイル ロジック ステートメントで評価されます (`Select` Visual Basic でのステートメント`switch`ビジュアルでステートメントC#と[!INCLUDE[vcprvc](~/includes/vcprvc-md.md)])。  
  
   
  
## Examples  
 次のコード例が表示されます、<xref:System.Windows.Forms.Control.Name%2A>コントロールの<xref:System.Windows.Forms.MessageBox>コントロールが追加またはフォームから削除します。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ComponentModel.ISite.Name" />
      </Docs>
    </Member>
    <Member MemberName="NotifyInvalidate">
      <MemberSignature Language="C#" Value="protected virtual void NotifyInvalidate (System.Drawing.Rectangle invalidatedArea);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void NotifyInvalidate(valuetype System.Drawing.Rectangle invalidatedArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.NotifyInvalidate(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub NotifyInvalidate (invalidatedArea As Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void NotifyInvalidate(System::Drawing::Rectangle invalidatedArea);" />
      <MemberSignature Language="F#" Value="abstract member NotifyInvalidate : System.Drawing.Rectangle -&gt; unit&#xA;override this.NotifyInvalidate : System.Drawing.Rectangle -&gt; unit" Usage="control.NotifyInvalidate invalidatedArea" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="invalidatedArea" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="invalidatedArea">無効化する領域を表す <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>無効化するコントロールの領域を指定して、<see cref="E:System.Windows.Forms.Control.Invalidated" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAutoSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAutoSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAutoSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAutoSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAutoSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAutoSizeChanged : EventArgs -&gt; unit&#xA;override this.OnAutoSizeChanged : EventArgs -&gt; unit" Usage="control.OnAutoSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.AutoSizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnAutoSizeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnAutoSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="control.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackColorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnBackColorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBackColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnBackgroundImageChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBackgroundImageChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImage" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBackgroundImageLayoutChanged : EventArgs -&gt; unit&#xA;override this.OnBackgroundImageLayoutChanged : EventArgs -&gt; unit" Usage="control.OnBackgroundImageLayoutChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBackgroundImageLayoutChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnBindingContextChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnBindingContextChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
        <altmember cref="P:System.Windows.Forms.Control.BindingContext" />
      </Docs>
    </Member>
    <Member MemberName="OnCausesValidationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCausesValidationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCausesValidationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCausesValidationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCausesValidationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCausesValidationChanged : EventArgs -&gt; unit&#xA;override this.OnCausesValidationChanged : EventArgs -&gt; unit" Usage="control.OnCausesValidationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.CausesValidationChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnCausesValidationChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnCausesValidationChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CausesValidationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
      </Docs>
    </Member>
    <Member MemberName="OnChangeUICues">
      <MemberSignature Language="C#" Value="protected virtual void OnChangeUICues (System.Windows.Forms.UICuesEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChangeUICues(class System.Windows.Forms.UICuesEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChangeUICues (e As UICuesEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChangeUICues(System::Windows::Forms::UICuesEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit&#xA;override this.OnChangeUICues : System.Windows.Forms.UICuesEventArgs -&gt; unit" Usage="control.OnChangeUICues e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.UICuesEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.UICuesEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ChangeUICues" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnChangeUICues%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnChangeUICues(System.Windows.Forms.UICuesEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="T:System.Windows.Forms.UICues" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClick : EventArgs -&gt; unit&#xA;override this.OnClick : EventArgs -&gt; unit" Usage="control.OnClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Click" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 オーバーライドする次のコード例に示します、<xref:System.Windows.Forms.Control.OnClick%2A>派生クラスのメソッド。 例を実行するには、後、同じファイル内のフォーム クラスに次のコードを貼り付けます。 型のテキスト ボックスを追加`SingleClickTextBox`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ControlOnClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlOnClick/VB/form1.vb#1)]  
  
 次のコード例を示していますの多くの用途の 1 つ、<xref:System.Windows.Forms.Control.Click>イベントとイベント ハンドラー。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnClick(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Click" />
      </Docs>
    </Member>
    <Member MemberName="OnClientSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnClientSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClientSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClientSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClientSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnClientSizeChanged : EventArgs -&gt; unit&#xA;override this.OnClientSizeChanged : EventArgs -&gt; unit" Usage="control.OnClientSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ClientSizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnClientSizeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnClientSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnContextMenuChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnContextMenuChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ContextMenuChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuStripChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuStripChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuStripChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuStripChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuStripChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContextMenuStripChanged : EventArgs -&gt; unit&#xA;override this.OnContextMenuStripChanged : EventArgs -&gt; unit" Usage="control.OnContextMenuStripChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ContextMenuStripChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnContextMenuStripChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnContextMenuStripChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnControlAdded">
      <MemberSignature Language="C#" Value="protected virtual void OnControlAdded (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlAdded(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlAdded (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlAdded(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlAdded : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlAdded e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.ControlEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ControlAdded" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールに子コントロールが追加されたときに呼び出されます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnControlAdded%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlAdded>をフォームにコントロールを追加するで追加したコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>します。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnControlAdded(System.Windows.Forms.ControlEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlAdded" />
      </Docs>
    </Member>
    <Member MemberName="OnControlRemoved">
      <MemberSignature Language="C#" Value="protected virtual void OnControlRemoved (System.Windows.Forms.ControlEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnControlRemoved(class System.Windows.Forms.ControlEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnControlRemoved (e As ControlEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnControlRemoved(System::Windows::Forms::ControlEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit&#xA;override this.OnControlRemoved : System.Windows.Forms.ControlEventArgs -&gt; unit" Usage="control.OnControlRemoved e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ControlEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.ControlEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ControlRemoved" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子コントロールがコントロールから削除されたときに呼び出されます。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnControlRemoved%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では<xref:System.Windows.Forms.Control.ControlRemoved>フォームからコントロールを削除するで削除されたコントロールの名前を表示し、<xref:System.Windows.Forms.MessageBox>します。  
  
 [!code-cpp[Control.ControlRemoved#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.ControlRemoved/CPP/form1.cpp#1)]
 [!code-csharp[Control.ControlRemoved#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.ControlRemoved/CS/form1.cs#1)]
 [!code-vb[Control.ControlRemoved#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.ControlRemoved/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnControlRemoved(System.Windows.Forms.ControlEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ControlRemoved" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected virtual void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCreateControl();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateControl : unit -&gt; unit&#xA;override this.OnCreateControl : unit -&gt; unit" Usage="control.OnCreateControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="M:System.Windows.Forms.Control.CreateControl" /> メソッドを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A>コントロールが最初に作成したときにメソッドが呼び出されます。  
  
 <xref:System.Windows.Forms.Control.OnCreateControl%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnCreateControl" /> メソッドを呼び出してください。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
      </Docs>
    </Member>
    <Member MemberName="OnCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCursorChanged : EventArgs -&gt; unit&#xA;override this.OnCursorChanged : EventArgs -&gt; unit" Usage="control.OnCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.CursorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnCursorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnCursorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.CursorChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="OnDockChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDockChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDockChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDockChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDockChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDockChanged : EventArgs -&gt; unit&#xA;override this.OnDockChanged : EventArgs -&gt; unit" Usage="control.OnDockChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DockChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnDockChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDockChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DockChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Dock" />
      </Docs>
    </Member>
    <Member MemberName="OnDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnDoubleClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDoubleClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDoubleClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDoubleClick(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDoubleClick : EventArgs -&gt; unit&#xA;override this.OnDoubleClick : EventArgs -&gt; unit" Usage="control.OnDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DoubleClick" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnDoubleClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.DoubleClick>のイベントを<xref:System.Windows.Forms.ListBox>が記載されたテキスト ファイルを読み込む、<xref:System.Windows.Forms.ListBox>に、<xref:System.Windows.Forms.TextBox>コントロール。  
  
 [!code-cpp[Control.DoubleClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.DoubleClick/CPP/form1.cpp#1)]
 [!code-csharp[Control.DoubleClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.DoubleClick/CS/form1.cs#1)]
 [!code-vb[Control.DoubleClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.DoubleClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDoubleClick(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DoubleClick" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedAfterParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedAfterParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedAfterParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedAfterParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedAfterParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedAfterParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedAfterParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedAfterParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedAfterParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DpiChangedAfterParent" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChangedBeforeParent">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChangedBeforeParent (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChangedBeforeParent(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDpiChangedBeforeParent(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChangedBeforeParent (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChangedBeforeParent(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDpiChangedBeforeParent : EventArgs -&gt; unit&#xA;override this.OnDpiChangedBeforeParent : EventArgs -&gt; unit" Usage="control.OnDpiChangedBeforeParent e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DpiChangedBeforeParent" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDragDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDragDrop (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragDrop(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragDrop (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragDrop : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragDrop drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragDrop" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnDragDrop%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragDrop(System.Windows.Forms.DragEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragEnter drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragEnter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnDragEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragEnter(System.Windows.Forms.DragEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : EventArgs -&gt; unit&#xA;override this.OnDragLeave : EventArgs -&gt; unit" Usage="control.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragLeave" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnDragLeave%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragLeave(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.Forms.DragEventArgs drgevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.Forms.DragEventArgs drgevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (drgevent As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::Forms::DragEventArgs ^ drgevent);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.OnDragOver drgevent" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgevent" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="drgevent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragOver" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnDragOver%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnDragOver(System.Windows.Forms.DragEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnEnabledChanged : EventArgs -&gt; unit" Usage="control.OnEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.EnabledChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnEnabledChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnEnter : EventArgs -&gt; unit&#xA;override this.OnEnter : EventArgs -&gt; unit" Usage="control.OnEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Enter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Enter>の前景色と背景色を変更するイベントを<xref:System.Windows.Forms.TextBox>特定の条件下でします。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnEnter(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Enter" />
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnFontChanged : EventArgs -&gt; unit&#xA;override this.OnFontChanged : EventArgs -&gt; unit" Usage="control.OnFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.FontChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnFontChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnFontChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnForeColorChanged : EventArgs -&gt; unit" Usage="control.OnForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnForeColorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnForeColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.Forms.GiveFeedbackEventArgs gfbevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.Forms.GiveFeedbackEventArgs gfbevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (gfbevent As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::Forms::GiveFeedbackEventArgs ^ gfbevent);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.Forms.GiveFeedbackEventArgs -&gt; unit" Usage="control.OnGiveFeedback gfbevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="gfbevent" Type="System.Windows.Forms.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="gfbevent">イベント データを格納している <see cref="T:System.Windows.Forms.GiveFeedbackEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.GiveFeedback" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnGiveFeedback%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : EventArgs -&gt; unit&#xA;override this.OnGotFocus : EventArgs -&gt; unit" Usage="control.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.GotFocus" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnGotFocus%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnGotFocus(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleCreated : EventArgs -&gt; unit&#xA;override this.OnHandleCreated : EventArgs -&gt; unit" Usage="control.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleCreated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnHandleCreated%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected virtual void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHandleDestroyed : EventArgs -&gt; unit&#xA;override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="control.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HandleDestroyed" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnHandleDestroyed%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HandleDestroyed" />
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpRequested">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpRequested (System.Windows.Forms.HelpEventArgs hevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpRequested(class System.Windows.Forms.HelpEventArgs hevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpRequested (hevent As HelpEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpRequested(System::Windows::Forms::HelpEventArgs ^ hevent);" />
      <MemberSignature Language="F#" Value="abstract member OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit&#xA;override this.OnHelpRequested : System.Windows.Forms.HelpEventArgs -&gt; unit" Usage="control.OnHelpRequested hevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hevent" Type="System.Windows.Forms.HelpEventArgs" />
      </Parameters>
      <Docs>
        <param name="hevent">イベント データを格納している <see cref="T:System.Windows.Forms.HelpEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.HelpRequested" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnHelpRequested%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="OnImeModeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnImeModeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeModeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeModeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeModeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeModeChanged : EventArgs -&gt; unit&#xA;override this.OnImeModeChanged : EventArgs -&gt; unit" Usage="control.OnImeModeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ImeModeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnImeModeChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnImeModeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ImeModeChanged" />
        <altmember cref="P:System.Windows.Forms.Control.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="OnInvalidated">
      <MemberSignature Language="C#" Value="protected virtual void OnInvalidated (System.Windows.Forms.InvalidateEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInvalidated(class System.Windows.Forms.InvalidateEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInvalidated (e As InvalidateEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInvalidated(System::Windows::Forms::InvalidateEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit&#xA;override this.OnInvalidated : System.Windows.Forms.InvalidateEventArgs -&gt; unit" Usage="control.OnInvalidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InvalidateEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.InvalidateEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Invalidated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnInvalidated%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnInvalidated(System.Windows.Forms.InvalidateEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Invalidated" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyDown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnKeyDown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyDown>イベントをコントロールに入力した文字の種類を判断します。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyPress (e As KeyPressEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyPress(System::Windows::Forms::KeyPressEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit&#xA;override this.OnKeyPress : System.Windows.Forms.KeyPressEventArgs -&gt; unit" Usage="control.OnKeyPress e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyPressEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyPress" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnKeyPress%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyPress>文字がコントロールに入力するを防ぐためにイベント。  
  
 [!code-cpp[Control.KeyDown#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyDown/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyDown/CS/form1.cs#1)]
 [!code-vb[Control.KeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyDown/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.KeyUp" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnKeyUp%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.KeyUp>イベントを<xref:System.Windows.Forms.Help>をユーザーにポップアップ スタイルのヘルプを表示するクラス。  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected virtual void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberSignature Language="F#" Value="abstract member OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit&#xA;override this.OnLayout : System.Windows.Forms.LayoutEventArgs -&gt; unit" Usage="control.OnLayout levent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">イベント データを格納している <see cref="T:System.Windows.Forms.LayoutEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Layout" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnLayout%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.OnLayout(System.Windows.Forms.LayoutEventArgs)" />メソッドの一般的なドッキングと固定の関数を使用し、登録されているデリゲートがイベントを受け取るようにします。 派生クラスでは、任意のカスタム レイアウト ロジックを実行するには、このメソッドをオーバーライドする必要があります。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="OnLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLeave : EventArgs -&gt; unit&#xA;override this.OnLeave : EventArgs -&gt; unit" Usage="control.OnLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Leave" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnLeave%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Leave>コントロールを元の状態にリセットするイベントです。  
  
 [!code-cpp[Control.Enter#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Enter/CPP/form1.cpp#1)]
 [!code-csharp[Control.Enter#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Enter/CS/form1.cs#1)]
 [!code-vb[Control.Enter#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Enter/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnLeave(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Leave" />
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLocationChanged : EventArgs -&gt; unit&#xA;override this.OnLocationChanged : EventArgs -&gt; unit" Usage="control.OnLocationChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.LocationChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnLocationChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnLocationChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LocationChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : EventArgs -&gt; unit&#xA;override this.OnLostFocus : EventArgs -&gt; unit" Usage="control.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.LostFocus" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnLostFocus%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnLostFocus(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnMarginChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMarginChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMarginChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMarginChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMarginChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMarginChanged : EventArgs -&gt; unit&#xA;override this.OnMarginChanged : EventArgs -&gt; unit" Usage="control.OnMarginChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MarginChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMarginChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMarginChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseCaptureChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseCaptureChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseCaptureChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseCaptureChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseCaptureChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseCaptureChanged : EventArgs -&gt; unit&#xA;override this.OnMouseCaptureChanged : EventArgs -&gt; unit" Usage="control.OnMouseCaptureChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseCaptureChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseCaptureChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseCaptureChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseClick" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseClick(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDoubleClick (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDoubleClick(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDoubleClick (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDoubleClick(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDoubleClick : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDoubleClick e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDoubleClick" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseDoubleClick%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseDown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseDown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseDown" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : EventArgs -&gt; unit&#xA;override this.OnMouseEnter : EventArgs -&gt; unit" Usage="control.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseEnter" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseEnter%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseEnter(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseEnter" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseHover (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseHover(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseHover : EventArgs -&gt; unit&#xA;override this.OnMouseHover : EventArgs -&gt; unit" Usage="control.OnMouseHover e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseHover" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseHover%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、オーバーライドする方法を示します、<xref:System.Windows.Forms.Control.OnMouseHover%2A>と<xref:System.Windows.Forms.Control.OnMouseMove%2A>派生クラスのメソッド。 例を実行するには、新しいフォームで次のコードを貼り付けしてこのクラスは、フォームの後、同じファイルを形成を貼り付けます。 型のボタンを追加する`FunButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseHover(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseHover" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : EventArgs -&gt; unit&#xA;override this.OnMouseLeave : EventArgs -&gt; unit" Usage="control.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseLeave" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseLeave%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseLeave(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseLeave" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseMove" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseMove%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、オーバーライドする方法を示します、<xref:System.Windows.Forms.Control.OnMouseHover%2A>と<xref:System.Windows.Forms.Control.OnMouseMove%2A>派生クラスのメソッド。 例を実行するには、新しいフォームで次のコードを貼り付けしてこのクラスは、フォームの後、同じファイルを形成を貼り付けます。 型のボタンを追加する`FunButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ControlDefaultProperties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ControlDefaultProperties/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseMove" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseUp" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseUp%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseUp" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.MouseWheel" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMouseWheel%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.MouseWheel" />
        <altmember cref="T:System.Windows.Forms.MouseEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMove (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMove(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMove (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMove(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMove : EventArgs -&gt; unit&#xA;override this.OnMove : EventArgs -&gt; unit" Usage="control.OnMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Move" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnMove%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Move>フォームの位置を画面座標、フォームのキャプション バーに表示するイベントです。  
  
 [!code-cpp[Control.Move#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Move/CPP/form1.cpp#1)]
 [!code-csharp[Control.Move#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Move/CS/form1.cs#1)]
 [!code-vb[Control.Move#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Move/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Move" />
      </Docs>
    </Member>
    <Member MemberName="OnNotifyMessage">
      <MemberSignature Language="C#" Value="protected virtual void OnNotifyMessage (System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNotifyMessage(valuetype System.Windows.Forms.Message m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnNotifyMessage (m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnNotifyMessage(System::Windows::Forms::Message m);" />
      <MemberSignature Language="F#" Value="abstract member OnNotifyMessage : System.Windows.Forms.Message -&gt; unit&#xA;override this.OnNotifyMessage : System.Windows.Forms.Message -&gt; unit" Usage="control.OnNotifyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" />
      </Parameters>
      <Docs>
        <param name="m">Windows メッセージを表す <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>コントロールに Windows メッセージを通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnNotifyMessage%2A>場合、メソッドが呼び出されたコントロールの`EnableNotifyMessage`でスタイル ビットが設定されて<xref:System.Windows.Forms.ControlStyles>します。 `EnableNotifyMessage`でスタイル<xref:System.Windows.Forms.ControlStyles>時に通知が制御できるように、<xref:System.Windows.Forms.Control.WndProc%2A>メソッドは、Windows メッセージを受信します。 この方法では、部分的に信頼されたコントロールにメッセージを変更すること Windows メッセージをリッスンできます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />、派生クラスで呼び出す基本クラスの<see cref="M:System.Windows.Forms.Control.OnNotifyMessage(System.Windows.Forms.Message)" />メソッドの最初の実装がないため必要はありません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaddingChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPaddingChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaddingChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaddingChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaddingChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaddingChanged : EventArgs -&gt; unit&#xA;override this.OnPaddingChanged : EventArgs -&gt; unit" Usage="control.OnPaddingChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.PaddingChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnPaddingChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnPaddingChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected virtual void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例では、イメージまたはイメージ ファイルをフォームにドラッグしが削除された時点で表示させるユーザーができるようにします。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームが描画されるたびに、イメージを再描画する。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドをフォームにドラッグされるデータの種類を決定および適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合イベント処理メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値は、画面座標、例では、<xref:System.Windows.Forms.Control.PointToClient%2A>クライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="OnPaintBackground">
      <MemberSignature Language="C#" Value="protected virtual void OnPaintBackground (System.Windows.Forms.PaintEventArgs pevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPaintBackground(class System.Windows.Forms.PaintEventArgs pevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPaintBackground (pevent As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPaintBackground(System::Windows::Forms::PaintEventArgs ^ pevent);" />
      <MemberSignature Language="F#" Value="abstract member OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPaintBackground : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPaintBackground pevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pevent" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="pevent">描画するコントロールに関する情報を格納する <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>コントロールの背景を描画します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.OnPaintBackground%2A> Windows のバック グラウンドの処理を有効に派生クラスのメソッドが要求を消去します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>クラスを継承すると、windows から背景の消去要求を処理するには、このメソッドをオーバーライドする必要があります。 オーバーライドするときに<see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />派生クラスでは、基本クラスを呼び出す必要<see cref="M:System.Windows.Forms.Control.OnPaintBackground(System.Windows.Forms.PaintEventArgs)" />します。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.InvokePaintBackground(System.Windows.Forms.Control,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackColorChanged : EventArgs -&gt; unit" Usage="control.OnParentBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.BackColorChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.BackColor" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentBackColorChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentBackColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBackgroundImageChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBackgroundImageChanged : EventArgs -&gt; unit&#xA;override this.OnParentBackgroundImageChanged : EventArgs -&gt; unit" Usage="control.OnParentBackgroundImageChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.BackgroundImage" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentBackgroundImageChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentBackgroundImageChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentBindingContextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentBindingContextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentBindingContextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentBindingContextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentBindingContextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentBindingContextChanged : EventArgs -&gt; unit&#xA;override this.OnParentBindingContextChanged : EventArgs -&gt; unit" Usage="control.OnParentBindingContextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.BindingContextChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.BindingContext" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentBindingContextChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentBindingContextChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.BindingContextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentChanged : EventArgs -&gt; unit&#xA;override this.OnParentChanged : EventArgs -&gt; unit" Usage="control.OnParentChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.ParentChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ParentChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentCursorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentCursorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentCursorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentCursorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentCursorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentCursorChanged : EventArgs -&gt; unit&#xA;override this.OnParentCursorChanged : EventArgs -&gt; unit" Usage="control.OnParentCursorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.CursorChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentCursorChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentCursorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnParentEnabledChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentEnabledChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentEnabledChanged : EventArgs -&gt; unit&#xA;override this.OnParentEnabledChanged : EventArgs -&gt; unit" Usage="control.OnParentEnabledChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.EnabledChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.Enabled" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentEnabledChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentEnabledChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.EnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentFontChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentFontChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentFontChanged : EventArgs -&gt; unit&#xA;override this.OnParentFontChanged : EventArgs -&gt; unit" Usage="control.OnParentFontChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.FontChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.Font" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentFontChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentFontChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.FontChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentForeColorChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentForeColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentForeColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentForeColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentForeColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentForeColorChanged : EventArgs -&gt; unit&#xA;override this.OnParentForeColorChanged : EventArgs -&gt; unit" Usage="control.OnParentForeColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.ForeColorChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.ForeColor" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentForeColorChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentForeColorChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.ForeColorChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnParentRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnParentRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.RightToLeft" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentRightToLeftChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentRightToLeftChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnParentVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnParentVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnParentVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnParentVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnParentVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnParentVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnParentVisibleChanged : EventArgs -&gt; unit" Usage="control.OnParentVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary>コントロールのコンテナーの <see cref="E:System.Windows.Forms.Control.VisibleChanged" /> プロパティ値が変更された場合に、<see cref="P:System.Windows.Forms.Control.Visible" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnParentVisibleChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnParentVisibleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Forms.PreviewKeyDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Forms.PreviewKeyDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As PreviewKeyDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Forms::PreviewKeyDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventArgs -&gt; unit" Usage="control.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PreviewKeyDownEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PreviewKeyDownEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.PreviewKeyDown" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnPreviewKeyDown%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnPreviewKeyDown(System.Windows.Forms.PreviewKeyDownEventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnPrint">
      <MemberSignature Language="C#" Value="protected virtual void OnPrint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPrint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnPrint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPrint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPrint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit&#xA;override this.OnPrint : System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.OnPrint e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Paint" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、`UserPaint`のビット、<xref:System.Windows.Forms.ControlStyles>が設定を上書きできます<xref:System.Windows.Forms.Control.OnPrint%2A>レイヤーの描画を行う。 詳細については、「<xref:System.Windows.Forms.Control.SetStyle%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターが <see langword="null" /> です。</exception>
        <altmember cref="M:System.Windows.Forms.Control.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.Forms.QueryContinueDragEventArgs qcdevent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.Forms.QueryContinueDragEventArgs qcdevent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (qcdevent As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::Forms::QueryContinueDragEventArgs ^ qcdevent);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.Forms.QueryContinueDragEventArgs -&gt; unit" Usage="control.OnQueryContinueDrag qcdevent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qcdevent" Type="System.Windows.Forms.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="qcdevent">イベント データを格納している <see cref="T:System.Windows.Forms.QueryContinueDragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.QueryContinueDrag" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドが繰り返しによって呼び出されますドラッグが開始された後、[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]ドラッグ操作が取り消されたか完了するまでです。  
  
> [!NOTE]
>  ドラッグ操作が取り消された、ドロップが行われる点を変更する場合は、このメソッドをオーバーライドします。  
  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnQueryContinueDrag%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnRegionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRegionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRegionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRegionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRegionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRegionChanged : EventArgs -&gt; unit&#xA;override this.OnRegionChanged : EventArgs -&gt; unit" Usage="control.OnRegionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.RegionChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnRegionChanged%2A> メソッドを使用すると、デリゲートを結び付けずに、派生クラスでイベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnRegionChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected virtual void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResize(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnResize : EventArgs -&gt; unit&#xA;override this.OnResize : EventArgs -&gt; unit" Usage="control.OnResize e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Resize" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnResize%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" /> メソッドを呼び出してください。 <see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />構築時に、メソッドを呼び出すことができますをオーバーライドする場合、<see cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />コントロールのコンス トラクターが呼び出される前に呼び出すことができます。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnRightToLeftChanged : EventArgs -&gt; unit&#xA;override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="control.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.RightToLeftChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnRightToLeftChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.RightToLeftChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSizeChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSizeChanged : EventArgs -&gt; unit&#xA;override this.OnSizeChanged : EventArgs -&gt; unit" Usage="control.OnSizeChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.SizeChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnSizeChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStyleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStyleChanged : EventArgs -&gt; unit&#xA;override this.OnStyleChanged : EventArgs -&gt; unit" Usage="control.OnStyleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.StyleChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnStyleChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.StyleChanged" />
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="OnSystemColorsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSystemColorsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSystemColorsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSystemColorsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSystemColorsChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSystemColorsChanged : EventArgs -&gt; unit&#xA;override this.OnSystemColorsChanged : EventArgs -&gt; unit" Usage="control.OnSystemColorsChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.SystemColorsChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnSystemColorsChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.SystemColorsChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabIndexChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabIndexChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabIndexChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabIndexChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabIndexChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabIndexChanged : EventArgs -&gt; unit&#xA;override this.OnTabIndexChanged : EventArgs -&gt; unit" Usage="control.OnTabIndexChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TabIndexChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnTabIndexChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabIndexChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTabStopChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTabStopChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTabStopChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTabStopChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTabStopChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTabStopChanged : EventArgs -&gt; unit&#xA;override this.OnTabStopChanged : EventArgs -&gt; unit" Usage="control.OnTabStopChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TabStopChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnTabStopChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TabStopChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextChanged : EventArgs -&gt; unit&#xA;override this.OnTextChanged : EventArgs -&gt; unit" Usage="control.OnTextChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.TextChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnTextChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.TextChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnValidated">
      <MemberSignature Language="C#" Value="protected virtual void OnValidated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidated : EventArgs -&gt; unit&#xA;override this.OnValidated : EventArgs -&gt; unit" Usage="control.OnValidated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Validated" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnValidated%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="OnValidating">
      <MemberSignature Language="C#" Value="protected virtual void OnValidating (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnValidating(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnValidating (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnValidating(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit&#xA;override this.OnValidating : System.ComponentModel.CancelEventArgs -&gt; unit" Usage="control.OnValidating e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.ComponentModel.CancelEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.Validating" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnValidating%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVisibleChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVisibleChanged : EventArgs -&gt; unit&#xA;override this.OnVisibleChanged : EventArgs -&gt; unit" Usage="control.OnVisibleChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.VisibleChanged" /> イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを発生させると、イベント ハンドラーがデリゲートから呼び出されます。 詳細については、次を参照してください。[処理とイベントの発生](~/docs/standard/events/index.md)します。  
  
 <xref:System.Windows.Forms.Control.OnVisibleChanged%2A>メソッドでは、派生クラス、デリゲートをアタッチせず、イベントを処理することもできます。 派生クラスでイベントを処理する場合は、この手法をお勧めします。  
  
   
  
## Examples  
 次のコード例は、イベント発生メソッドは、実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ`On` *PropertyName* `Changed` 、対応するを発生させる*PropertyName* `Changed`イベント時に、*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示するクラスを派生します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例から派生したクラスである必要があります、<xref:System.Windows.Forms.TextBox>クラス。  
  
 [!code-cpp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CPP/onpropertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/CS/onpropertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_OnPropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_OnPropertyChangedEvents/VB/onpropertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生クラスで <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> をオーバーライドする場合は、登録されているデリゲートがイベントを受け取ることができるように、基本クラスの <see cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" /> メソッドを呼び出してください。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Show" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Padding" />
      <MemberSignature Language="VB.NET" Value="Public Property Padding As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Padding { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberSignature Language="F#" Value="member this.Padding : System.Windows.Forms.Padding with get, set" Usage="System.Windows.Forms.Control.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの埋め込みを取得または設定します。</summary>
        <value>コントロールの内部の間隔特性を表す <see cref="T:System.Windows.Forms.Padding" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 などのコンテナーの<xref:System.Windows.Forms.GroupBox>と<xref:System.Windows.Forms.TabControl>、<xref:System.Windows.Forms.Control.Padding%2A>プロパティを取得または設定、それぞれ<xref:System.Windows.Forms.Control.DisplayRectangle%2A>プロパティ。 <xref:System.Windows.Forms.ScrollableControl.DockPadding%2A?displayProperty=nameWithType>プロパティがその<xref:System.Windows.Forms.Control.Padding%2A?displayProperty=nameWithType>プロパティ。  
  
 コントロールの既定値が表示される<xref:System.Windows.Forms.Control.Padding%2A>Windows ユーザー インターフェイス ガイドラインの近くにある程度であります。 いくつかの調整は、特定のアプリケーションに必要なある可能性があります。  
  
 実装するすべてのコントロール<xref:System.Windows.Forms.Control.GetPreferredSize%2A>の量だけ拡大は<xref:System.Windows.Forms.Control.Padding%2A>とき<xref:System.Windows.Forms.Control.AutoSize%2A>は`true`します。  
  
 次のコントロールは使用しないでください<xref:System.Windows.Forms.Control.Padding%2A>:  
  
-   コントロールを実装しない<xref:System.Windows.Forms.Control.AutoSize%2A>経由 <xref:System.Windows.Forms.Control.GetPreferredSize%2A>  
  
-   カスタム コントロールを直接継承するクラス <xref:System.Windows.Forms.Control>  
  
-   <xref:System.Windows.Forms.AxHost>  
  
-   <xref:System.Windows.Forms.ComboBox>  
  
-   <xref:System.Windows.Forms.DataGridView>  
  
-   <xref:System.Windows.Forms.DateTimePicker>  
  
-   <xref:System.Windows.Forms.HScrollBar>  
  
-   <xref:System.Windows.Forms.ListView>  
  
-   <xref:System.Windows.Forms.MaskedTextBox>  
  
-   <xref:System.Windows.Forms.MonthCalendar>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.PropertyGrid>  
  
-   <xref:System.Windows.Forms.RichTextBox>  
  
-   <xref:System.Windows.Forms.SplitContainer>  
  
-   <xref:System.Windows.Forms.TextBox>  
  
-   <xref:System.Windows.Forms.TextBoxBase>  
  
-   <xref:System.Windows.Forms.TreeView>  
  
-   <xref:System.Windows.Forms.VScrollBar>  
  
-   <xref:System.Windows.Forms.WebBrowser>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PaddingChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PaddingChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ PaddingChanged;" />
      <MemberSignature Language="F#" Value="member this.PaddingChanged : EventHandler " Usage="member this.PaddingChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの埋め込みが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.PaddingChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.PaddingChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#41](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#41)]
 [!code-vb[System.Windows.Forms.EventExamples#41](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#41)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Paint" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Paint As PaintEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PaintEventHandler ^ Paint;" />
      <MemberSignature Language="F#" Value="member this.Paint : System.Windows.Forms.PaintEventHandler " Usage="member this.Paint : System.Windows.Forms.PaintEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが再描画されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Paint>コントロールが再描画されるときにイベントが発生します。 インスタンスを渡す<xref:System.Windows.Forms.PaintEventArgs>を処理するメソッドに、<xref:System.Windows.Forms.Control.Paint>イベント。  
  
 外観が異なると、新しいカスタム コントロールまたは継承されたコントロールを作成するときに、オーバーライドすることで、コントロールをレンダリングするコードを提供する必要があります、<xref:System.Windows.Forms.Control.OnPaint%2A>メソッド。 詳細については、次を参照してください。 [OnPaint メソッドのオーバーライド](~/docs/framework/winforms/controls/overriding-the-onpaint-method.md)と[コントロールのカスタム描画およびレンダリング](~/docs/framework/winforms/controls/custom-control-painting-and-rendering.md)します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.PictureBox>使用してフォーム上のコントロール、<xref:System.Windows.Forms.Control.Paint>を描画するイベントです。  
  
 [!code-cpp[Control.Paint#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Paint/CPP/form1.cpp#1)]
 [!code-csharp[Control.Paint#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Paint/CS/form1.cs#1)]
 [!code-vb[Control.Paint#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Paint/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control Parent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Parent" />
      <MemberSignature Language="VB.NET" Value="Public Property Parent As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ Parent { System::Windows::Forms::Control ^ get(); void set(System::Windows::Forms::Control ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.Control with get, set" Usage="System.Windows.Forms.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの親コンテナーを取得または設定します。</summary>
        <value>コントロールの親コントロールまたはコンテナー コントロールを表す <see cref="T:System.Windows.Forms.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、<xref:System.Windows.Forms.Control.Parent%2A>プロパティの値を`null`からコントロールを削除、<xref:System.Windows.Forms.Control.ControlCollection>現在親コントロールの。  
  
   
  
## Examples  
 次のコード例では、<xref:System.Windows.Forms.Control.Parent%2A>プロパティと<xref:System.Windows.Forms.Control.FindForm%2A>ボタンと、フォームの親コントロールでプロパティを設定します。  
  
 [!code-cpp[Control.FindForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.FindForm/CPP/form1.cpp#1)]
 [!code-csharp[Control.FindForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.FindForm/CS/form1.cs#1)]
 [!code-vb[Control.FindForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.FindForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を取得するすべてのウィンドウ。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="ParentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler ParentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ParentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.ParentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ParentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ParentChanged;" />
      <MemberSignature Language="F#" Value="member this.ParentChanged : EventHandler " Usage="member this.ParentChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Parent" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Parent%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnParentChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Parent" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PerformLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールがレイアウト ロジックを子コントロールに適用するように強制します。</summary>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout();" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : unit -&gt; unit" Usage="control.PerformLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールがレイアウト ロジックをすべての子コントロールに適用するように強制します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.SuspendLayout%2A>呼び出す前にメソッドが呼び出された、<xref:System.Windows.Forms.Control.PerformLayout%2A>メソッド、<xref:System.Windows.Forms.Control.Layout>イベントが抑制されます。  
  
 <xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A>と<xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A>のプロパティ、<xref:System.Windows.Forms.LayoutEventArgs>に設定されて作成`null`場合、値が指定されていない場合に、<xref:System.Windows.Forms.Control.PerformLayout%2A>メソッドが呼び出されました。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Windows.Forms.Control.PerformLayout%2A> メソッドの使用方法を示します。 ための方法も示しています、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。 この例で、`Click`のイベント ハンドラー`Button1`明示的に呼び出す<xref:System.Windows.Forms.Control.PerformLayout%2A>します。 `Click`のイベント ハンドラー`Button2`暗黙的に呼び出します<xref:System.Windows.Forms.Control.PerformLayout%2A>します。 <xref:System.Windows.Forms.Control.PerformLayout%2A> フォームが読み込まれるときに呼び出されます。 `Button3` 読み込まれたときの状態にコントロールを返します。 各ケースで、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。  
  
 これは、完全な例です。 例を実行するには、空白のフォームで次のコードを貼り付けます。  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PerformLayout">
      <MemberSignature Language="C#" Value="public void PerformLayout (System.Windows.Forms.Control affectedControl, string affectedProperty);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformLayout(class System.Windows.Forms.Control affectedControl, string affectedProperty) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PerformLayout(System.Windows.Forms.Control,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformLayout (affectedControl As Control, affectedProperty As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformLayout(System::Windows::Forms::Control ^ affectedControl, System::String ^ affectedProperty);" />
      <MemberSignature Language="F#" Value="member this.PerformLayout : System.Windows.Forms.Control * string -&gt; unit" Usage="control.PerformLayout (affectedControl, affectedProperty)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="affectedControl" Type="System.Windows.Forms.Control" />
        <Parameter Name="affectedProperty" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="affectedControl">最近変更されたコントロールを表す <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="affectedProperty">コントロールで最近変更されたプロパティの名前。</param>
        <summary>コントロールがレイアウト ロジックをすべての子コントロールに適用するように強制します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.SuspendLayout%2A>呼び出す前にメソッドが呼び出された、<xref:System.Windows.Forms.Control.PerformLayout%2A>メソッド、<xref:System.Windows.Forms.Control.Layout>イベントが抑制されます。  
  
 `affectedControl`と`affectedProperty`両方に設定できるパラメーター`null`します。 そのため、<xref:System.Windows.Forms.LayoutEventArgs.AffectedControl%2A>と<xref:System.Windows.Forms.LayoutEventArgs.AffectedProperty%2A>のプロパティ、<xref:System.Windows.Forms.LayoutEventArgs>に設定するために作成`null`です。  
  
   
  
## Examples  
 次のコード例は、<xref:System.Windows.Forms.Control.PerformLayout%2A> メソッドの使用方法を示します。 ための方法も示しています、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。 この例で、`Click`のイベント ハンドラー`Button1`明示的に呼び出す<xref:System.Windows.Forms.Control.PerformLayout%2A>します。 `Click`のイベント ハンドラー`Button2`暗黙的に呼び出します<xref:System.Windows.Forms.Control.PerformLayout%2A>します。 <xref:System.Windows.Forms.Control.PerformLayout%2A> フォームが読み込まれるときに呼び出されます。 `Button3` 読み込まれたときの状態にコントロールを返します。 各ケースで、<xref:System.Windows.Forms.Control.Layout>イベントが発生します。  
  
 これは、完全な例です。 例を実行するには、空白のフォームで次のコードを貼り付けます。  
  
 [!code-cpp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PerformLayout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.PerformLayout/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
        <altmember cref="P:System.Windows.Forms.Control.BackgroundImageLayout" />
      </Docs>
    </Member>
    <Member MemberName="PointToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToClient (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToClient(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToClient (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToClient(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToClient : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToClient p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">画面座標で示された変換対象の <see cref="T:System.Drawing.Point" />。</param>
        <summary>指定した画面上のポイントを計算してクライアント座標を算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Point" />、<see cref="T:System.Drawing.Point" /> をクライアント座標で表す <paramref name="p" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例で、イメージまたはイメージ ファイルをフォームにドラッグして、上の点で、表示するユーザーが削除されます。 <xref:System.Windows.Forms.Control.OnPaint%2A>メソッドをオーバーライドして、フォームが描画されるたびに、イメージを再描画する。 それ以外の場合、イメージは、次回の再描画されるまで保持はのみです。 <xref:System.Windows.Forms.Control.DragEnter>イベント処理メソッドをフォームにドラッグされるデータの種類を決定および適切なフィードバックを提供します。 <xref:System.Windows.Forms.Control.DragDrop>場合イベント処理メソッドに、フォームのイメージが表示されます、<xref:System.Drawing.Image>データから作成できます。 <xref:System.Windows.Forms.DragEventArgs.X%2A?displayProperty=nameWithType>と<xref:System.Windows.Forms.DragEventArgs.Y%2A?displayProperty=nameWithType>値は、画面座標、例では、<xref:System.Windows.Forms.Control.PointToClient%2A>クライアント座標に変換するメソッド。  
  
 [!code-cpp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CPP/imagedrag.cpp#1)]
 [!code-csharp[Windows.Forms.Control.DragOperations#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/CS/imagedrag.cs#1)]
 [!code-vb[Windows.Forms.Control.DragOperations#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control.DragOperations/VB/imagedrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PointToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Point PointToScreen (System.Drawing.Point p);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Point PointToScreen(valuetype System.Drawing.Point p) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PointToScreen(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Function PointToScreen (p As Point) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Point PointToScreen(System::Drawing::Point p);" />
      <MemberSignature Language="F#" Value="member this.PointToScreen : System.Drawing.Point -&gt; System.Drawing.Point" Usage="control.PointToScreen p" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="p" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="p">クライアント座標で示された変換対象の <see cref="T:System.Drawing.Point" />。</param>
        <summary>指定したクライアント ポイントを計算して画面座標を算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Point" />、<see cref="T:System.Drawing.Point" /> を画面座標で表す <paramref name="p" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、使用する方法を示します、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.RectangleToScreen%2A>、 <xref:System.Windows.Forms.Control.PointToScreen%2A>、 <xref:System.Windows.Forms.Control.MouseButtons%2A>、 <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>、および<xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>メンバー。 例を実行するには、Form1 という形式で次のコードを貼り付けいくつかのコントロールを格納しています。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseMove>、および<xref:System.Windows.Forms.Control.MouseUp>イベントは、この例で定義されているイベント ハンドラーに接続しています。  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Point" />
        <altmember cref="M:System.Windows.Forms.Control.PointToClient(System.Drawing.Point)" />
      </Docs>
    </Member>
    <Member MemberName="PreferredSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size PreferredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size PreferredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PreferredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PreferredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size PreferredSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.PreferredSize : System.Drawing.Size" Usage="System.Windows.Forms.Control.PreferredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが適合する四角形領域のサイズを取得します。</summary>
        <value>高さおよび幅をピクセル単位で格納した <see cref="T:System.Drawing.Size" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessControlMessage">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.PreProcessControlState PreProcessControlMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.PreProcessControlState PreProcessControlMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessControlMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Function PreProcessControlMessage (ByRef msg As Message) As PreProcessControlState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::PreProcessControlState PreProcessControlMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="member this.PreProcessControlMessage :  -&gt; System.Windows.Forms.PreProcessControlState" Usage="control.PreProcessControlMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreProcessControlState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="msg">処理するメッセージを表す <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージまたは入力メッセージがディスパッチされる前に、メッセージ ループ内の入力メッセージを前処理します。</summary>
        <returns><see cref="T:System.Windows.Forms.PreProcessControlState" /> のいずれかの値。<see cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" /> が <see langword="true" /> と <see langword="false" /> のどちらであるか、さらに、<see cref="M:System.Windows.Forms.Control.IsInputKey(System.Windows.Forms.Keys)" /> または <see cref="M:System.Windows.Forms.Control.IsInputChar(System.Char)" /> が <see langword="true" /> と <see langword="false" /> のどちらであるかによって異なります。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreProcessMessage">
      <MemberSignature Language="C#" Value="public virtual bool PreProcessMessage (ref System.Windows.Forms.Message msg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PreProcessMessage(valuetype System.Windows.Forms.Message&amp; msg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PreProcessMessage (ByRef msg As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PreProcessMessage(System::Windows::Forms::Message % msg);" />
      <MemberSignature Language="F#" Value="abstract member PreProcessMessage :  -&gt; bool&#xA;override this.PreProcessMessage :  -&gt; bool" Usage="control.PreProcessMessage msg" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="msg">処理するメッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。 有効な値は、WM_KEYDOWN、WM_SYSKEYDOWN、WM_CHAR、および WM_SYSCHAR です。</param>
        <summary>キーボード メッセージまたは入力メッセージがディスパッチされる前に、メッセージ ループ内の入力メッセージを前処理します。</summary>
        <returns>メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.PreProcessMessage%2A> ディスパッチされる前に、入力メッセージを前処理する、アプリケーションのメッセージ ループによって呼び出されます。 指定できる値、`msg`パラメーターは、WM_KEYDOWN、WM_SYSKEYDOWN、WM_CHAR、WM_SYSCHAR、します。  
  
 オーバーライドするときに<xref:System.Windows.Forms.Control.PreProcessMessage%2A>、コントロールを返す必要があります`true`をメッセージを処理したことを示します。 結果、コントロールによって処理されないメッセージ`base.PreProcessMessage`返される必要があります。 コントロールは通常メソッドのオーバーライドより専門的ななど<xref:System.Windows.Forms.Control.IsInputChar%2A>、 <xref:System.Windows.Forms.Control.IsInputKey%2A>、 <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>、 <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>、または<xref:System.Windows.Forms.Control.ProcessDialogKey%2A>オーバーライドする代わりに<xref:System.Windows.Forms.Control.PreProcessMessage%2A>します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出す直前の呼び出し元のすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PreviewKeyDownEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As PreviewKeyDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::PreviewKeyDownEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Forms.PreviewKeyDownEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PreviewKeyDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールにフォーカスがあるときにキーが押された場合、<see cref="E:System.Windows.Forms.Control.KeyDown" /> イベントの前に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タブ、返された場合、esc キー、および方向キーなどのいくつかのキー入力は、入力のキーの押下がないと見なされるために通常いくつかのコントロールによって無視されます。 たとえば、既定を<xref:System.Windows.Controls.Button>コントロールは、方向キーを無視します。 前または次のコントロールに移動するフォーカスは、通常、方向キーを押すとします。 ナビゲーション キーと通常これらのキーを発生させませんキーを押して、方向キーと見なされます、<xref:System.Windows.Forms.Control.KeyDown>イベントを<xref:System.Windows.Controls.Button>します。 ただし、用のキー、矢印キーを押して、<xref:System.Windows.Controls.Button>は発生、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベント。 処理することによって、<xref:System.Windows.Forms.Control.PreviewKeyDown>イベントを<xref:System.Windows.Controls.Button>と設定、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティを`true`、増やすことができます、<xref:System.Windows.Forms.Control.KeyDown>方向キーが押されたときにイベント。 ただし、方向キーを処理する場合、フォーカスは前または次のコントロールには移動不要になった。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Windows.Forms.Button>を含む、<xref:System.Windows.Forms.ContextMenuStrip>します。 ときに、<xref:System.Windows.Forms.Button>にフォーカスがあるし、上向き矢印または下向き矢印キーを押して、<xref:System.Windows.Forms.ContextMenuStrip>が表示されます。 <xref:System.Windows.Forms.Control.PreviewKeyDown>イベント ハンドラーが ↑ または ↓ キーが押されたときを検出し、設定、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティを`true`します。 これが発生、<xref:System.Windows.Forms.Control.KeyDown>イベント表示できるように、<xref:System.Windows.Forms.ContextMenuStrip>します。 任意のロジック配置しないで、<xref:System.Windows.Forms.Control.PreviewKeyDown>設定よりもその他のイベント ハンドラー、<xref:System.Windows.Forms.PreviewKeyDownEventArgs.IsInputKey%2A>プロパティ。 代わりに、ロジックを配置する必要があります、<xref:System.Windows.Forms.Control.KeyDown>イベント ハンドラー。  
  
 [!code-csharp[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.PreviewKeyDown#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.previewkeydown/vb/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessCmdKey (msg, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <param name="keyData">処理するキーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>コマンド キーを処理します。</summary>
        <returns>文字がコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メッセージのプリプロセス コマンド キーを処理中に呼び出されます。 コマンド キーは、通常の入力キーに常に優先されるキーです。 コマンド キーの例には、アクセラレータやメニューのショートカットが含まれます。 メソッドが返す必要があります`true`コマンド キーを処理したことを示すまたは`false`をキーは、コマンド キーではないことを示します。 このメソッドは、コントロールは、Windows フォーム アプリケーションまたは ActiveX コントロールとしてホストされている場合にのみ呼び出されます。  
  
 <xref:System.Windows.Forms.Control.ProcessCmdKey%2A>メソッドはまず、コントロールがあるかどうかを判断、 <xref:System.Windows.Forms.ContextMenu>、でき、そうである場合、<xref:System.Windows.Forms.ContextMenu>コマンド キーを処理します。 親のキーが渡されるコマンド キーが メニューのショートカット、コントロールに親がある場合は、<xref:System.Windows.Forms.Control.ProcessCmdKey%2A>メソッド。 実質的な効果は、そのコマンドのキーは「バブル」コントロールの階層構造です。 だけでなく、ユーザーが押されたキー、キーのデータもかを示しますでの修飾キーが押された場合に、キーと同時にします。 修飾子キーには、shift キーを押し、CTRL、ALT キーが含まれます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">直前の呼び出し元と継承したクラスをこのメソッドを呼び出します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogChar(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogChar : char -&gt; bool&#xA;override this.ProcessDialogChar : char -&gt; bool" Usage="control.ProcessDialogChar charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">処理対象の文字。</param>
        <summary>ダイアログ文字を処理します。</summary>
        <returns>文字がコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メッセージのコントロールのニーモニックなど、ダイアログの文字を処理するために前処理中に呼び出されます。 場合にのみ、このメソッドが呼び出されます、<xref:System.Windows.Forms.Control.IsInputChar%2A>メソッドは、コントロールでは、文字は処理されていないことを示します。 <xref:System.Windows.Forms.Control.ProcessDialogChar%2A>メソッドは、親に文字を送信するだけ<xref:System.Windows.Forms.Control.ProcessDialogChar%2A>メソッド、または返します`false`コントロールに親がありません。 <xref:System.Windows.Forms.Form>クラス ダイアログ文字の実際の処理を実行するには、このメソッドをオーバーライドします。 このメソッドは、コントロールは、Windows フォーム アプリケーションまたは ActiveX コントロールとしてホストされている場合にのみ呼び出されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />派生クラスでメソッドをコントロールを返します<see langword="true" />を文字を処理したことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されない文字<see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="abstract member ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool&#xA;override this.ProcessDialogKey : System.Windows.Forms.Keys -&gt; bool" Usage="control.ProcessDialogKey keyData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">処理するキーを表す <see cref="T:System.Windows.Forms.Keys" /> 値の 1 つ。</param>
        <summary>ダイアログ キーを処理します。</summary>
        <returns>キーがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、タブ、返された場合、esc キー、および矢印キーなどのダイアログの文字を処理するメッセージのプリプロセス時に呼び出されます。 場合にのみ、このメソッドが呼び出されます、<xref:System.Windows.Forms.Control.IsInputKey%2A>メソッドでは、コントロールがキーを処理していないことを示します。 <xref:System.Windows.Forms.Control.ProcessDialogKey%2A>に親の文字を単純に送信します<xref:System.Windows.Forms.Control.ProcessDialogKey%2A>メソッド、または返します`false`コントロールに親がありません。 <xref:System.Windows.Forms.Form>クラス ダイアログ キーの実際の処理を実行するには、このメソッドをオーバーライドします。 このメソッドは、コントロールは、Windows フォーム アプリケーションまたは ActiveX コントロールとしてホストされている場合にのみ呼び出されます。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessDialogKey(System.Windows.Forms.Keys)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyEventArgs">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyEventArgs (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyEventArgs(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyEventArgs (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyEventArgs(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyEventArgs :  -&gt; bool&#xA;override this.ProcessKeyEventArgs :  -&gt; bool" Usage="control.ProcessKeyEventArgs m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キー メッセージを処理し、適切なコントロール イベントを生成します。</summary>
        <returns>メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールがキーボード メッセージを受信すると、このメソッドが呼び出されます。 このメソッドは呼び出すことによって、メッセージの適切なキー イベントを生成するため、 <xref:System.Windows.Forms.Control.OnKeyPress%2A>、 <xref:System.Windows.Forms.Control.OnKeyDown%2A>、または<xref:System.Windows.Forms.Control.OnKeyUp%2A>メソッド。 `m`パラメーターにはウィンドウ メッセージ処理する必要がありますにはが含まれています。 指定できる値、<xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>プロパティは、WM_CHAR、WM_KEYDOWN、WM_SYSKEYDOWN、WM_KEYUP、WM_SYSKEYUP、および WM_IME_CHAR います。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />メソッドが返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para></block>
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyMessage">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessKeyMessage (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessKeyMessage(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessKeyMessage (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessKeyMessage(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyMessage :  -&gt; bool&#xA;override this.ProcessKeyMessage :  -&gt; bool" Usage="control.ProcessKeyMessage m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージを処理します。</summary>
        <returns>メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールがキーボード メッセージを受信すると、このメソッドが呼び出されます。 メソッドが最初に、コントロールが親を持つかどうかを決定しますそのため、親を呼び出す場合<xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッド。 場合、親の<xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッドは、メッセージを処理していない、<xref:System.Windows.Forms.Control.ProcessKeyEventArgs%2A>メソッドが呼び出され、適切なキーボード イベントを生成します。 `m`パラメーターにはウィンドウ メッセージ処理する必要がありますにはが含まれています。 指定できる値、<xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>プロパティは、WM_CHAR、WM_KEYDOWN、WM_SYSKEYDOWN、WM_KEYUP、および WM_SYSKEYUP います。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessKeyMessage(System.Windows.Forms.Message@)" />コントロールが返されます、<see langword="true" />をキーが処理されたことを示します。 コントロールの基本クラスの結果によって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessKeyEventArgs(System.Windows.Forms.Message@)" />返される必要があります。 コントロールがこのメソッドをオーバーライドする必要はほとんどありません。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected virtual bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member ProcessKeyPreview :  -&gt; bool&#xA;override this.ProcessKeyPreview :  -&gt; bool" Usage="control.ProcessKeyPreview m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理するウィンドウ メッセージを表す、参照渡しされた <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>キーボード メッセージをプレビューします。</summary>
        <returns>メッセージがコントロールによって処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子コントロールがキーボード メッセージを受信すると、子コントロールがこのメソッドが呼び出されます。 子コントロールは、メッセージのキーボード イベントを生成する前に、このメソッドを呼び出します。 このメソッドが戻る場合`true`、子コントロールが処理されたと見なされ、キーボード イベントを生成しません。 `m`パラメーターには、プレビュー ウィンドウのメッセージが含まれています。 指定できる値、<xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>プロパティは、WM_CHAR、WM_KEYDOWN、WM_SYSKEYDOWN、WM_KEYUP、および WM_SYSKEYUP います。 <xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッドは、親に文字を送信するだけ<xref:System.Windows.Forms.Control.ProcessKeyPreview%2A>メソッド、または返します`false`コントロールに親がありません。 <xref:System.Windows.Forms.Form>クラス ダイアログ キーの実際の処理を実行するには、このメソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides"><para>オーバーライドする場合、<see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />派生クラスでメソッドをコントロールを返します<see langword="true" />をキーが処理されたことを示します。 基本クラスの呼び出しの結果、コントロールによって処理されないキー<see cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />メソッドが返される必要があります。</para></block>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal virtual bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ProcessMnemonic(char charCode);" />
      <MemberSignature Language="F#" Value="abstract member ProcessMnemonic : char -&gt; bool&#xA;override this.ProcessMnemonic : char -&gt; bool" Usage="control.ProcessMnemonic charCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">処理対象の文字。</param>
        <summary>ニーモニック文字を処理します。</summary>
        <returns>文字がコントロールによってニーモニックとして処理された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コントロールのニーモニック文字を処理する機会を与えるために呼び出されます。 メソッドは、およびコントロールが状態ニーモニックを処理するかどうか、特定の文字がニーモニックを表すかどうかを判断する必要があります。 かどうか、メソッドの動作を実行、ニーモニックと戻り値に関連付けられている`true`します。 場合は、メソッドが返す、`false`します。 このメソッドの実装を使用して、多くの場合、<xref:System.Windows.Forms.Control.IsMnemonic%2A>する特定の文字がコントロールのテキストでニーモニックと一致するかどうかを判断するメソッド。  
  
 次に例を示します。  
  
```csharp  
if (CanSelect && IsMnemonic(charCode, MyControl.Text) {  
      // Perform action associated with mnemonic.  
       }  
```  
  
 この既定の実装の<xref:System.Windows.Forms.Control.ProcessMnemonic%2A>メソッドは単に返します`false`コントロールにアクセラレータ キーがないことを表します。  
  
   
  
## Examples  
 次のコード例は、オーバーライドするボタン クラスの拡張機能を示します、<xref:System.Windows.Forms.Control.ProcessMnemonic%2A>メソッドがカスタム動作。 例では、使用も示しています、<xref:System.Windows.Forms.Control.CanSelect%2A>と<xref:System.Windows.Forms.Control.IsMnemonic%2A>プロパティ。 実行には、この例は、同じファイル内のフォーム クラスを使用して、次のコードを貼り付けます。 型のボタンを追加する`MnemonicButton`をフォームにします。  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すクラスを継承するすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="M:System.Windows.Forms.Control.IsMnemonic(System.Char,System.String)" />
        <altmember cref="M:System.Windows.Forms.Control.ProcessDialogChar(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProductName">
      <MemberSignature Language="C#" Value="public string ProductName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductName : string" Usage="System.Windows.Forms.Control.ProductName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを格納しているアセンブリの製品名を取得します。</summary>
        <value>コントロールを格納しているアセンブリの製品名。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductName%2A>プロパティは読み取り専用プロパティです。 このプロパティの値を変更するには、設定、<xref:System.Reflection.AssemblyProductAttribute.Product%2A>プロパティの値、<xref:System.Reflection.AssemblyProductAttribute>します。 次の C# コードのセットの行、<xref:System.Windows.Forms.Control.ProductName%2A>プロパティ。  
  
```  
[assembly: AssemblyProduct("MyApplication")]  
```  
  
> [!NOTE]
>  会社名、製品名、および製品バージョンを指定することを強くお勧めします。 など、Windows フォームの機能の使用により、この情報を提供する<xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType>を容易にできるように、"Certified for Windows"のプログラムに準拠するアプリケーションを作成します。 Windows の認定プログラムに関する詳細については、次を参照してください。http://msdn.microsoft.com/certificationします。  
  
   
  
## Examples  
 次のコード例で、アプリケーションに関する情報を表示する、<xref:System.Windows.Forms.Label>に含まれる、<xref:System.Windows.Forms.Form>します。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.CompanyName%2A>、<xref:System.Windows.Forms.Control.ProductName%2A>と<xref:System.Windows.Forms.Control.ProductVersion%2A>が設定されています。  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyProductAttribute.Product" />
      </Docs>
    </Member>
    <Member MemberName="ProductVersion">
      <MemberSignature Language="C#" Value="public string ProductVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProductVersion" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ProductVersion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProductVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProductVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProductVersion : string" Usage="System.Windows.Forms.Control.ProductVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールを格納しているアセンブリのバージョンを取得します。</summary>
        <value>コントロールを格納しているアセンブリのファイル バージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ProductVersion%2A>プロパティは読み取り専用プロパティです。 このプロパティの値を変更するには、設定、<xref:System.Reflection.AssemblyVersionAttribute.Version%2A>プロパティの値、<xref:System.Reflection.AssemblyVersionAttribute>します。 次の C# コードのセットの行、<xref:System.Windows.Forms.Control.ProductVersion%2A>プロパティ。  
  
```  
[assembly: AssemblyVersion("1.0.1")]  
```  
  
> [!NOTE]
>  会社名、製品名、および製品バージョンを指定することを強くお勧めします。 など、Windows フォームの機能の使用により、この情報を提供する<xref:System.Windows.Forms.Application.UserAppDataPath%2A?displayProperty=nameWithType>を容易にできるように、"Certified for Windows"のプログラムに準拠するアプリケーションを作成します。 Windows の認定プログラムに関する詳細については、次を参照してください。http://msdn.microsoft.com/certificationします。  
  
   
  
## Examples  
 次のコード例で、アプリケーションに関する情報を表示する、<xref:System.Windows.Forms.Label>に含まれる、<xref:System.Windows.Forms.Form>します。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.CompanyName%2A>、<xref:System.Windows.Forms.Control.ProductName%2A>と<xref:System.Windows.Forms.Control.ProductVersion%2A>が設定されています。  
  
 [!code-cpp[Windows.Forms.Control Properties3#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CPP/aboutdialog.cpp#1)]
 [!code-csharp[Windows.Forms.Control Properties3#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties3/CS/aboutdialog.cs#1)]
 [!code-vb[Windows.Forms.Control Properties3#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties3/VB/aboutdialog.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.AssemblyVersionAttribute.Version" />
      </Docs>
    </Member>
    <Member MemberName="PropagatingImeMode">
      <MemberSignature Language="C#" Value="protected static System.Windows.Forms.ImeMode PropagatingImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Windows.Forms.ImeMode PropagatingImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Shared ReadOnly Property PropagatingImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static property System::Windows::Forms::ImeMode PropagatingImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberSignature Language="F#" Value="member this.PropagatingImeMode : System.Windows.Forms.ImeMode" Usage="System.Windows.Forms.Control.PropagatingImeMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>反映する IME モードを表すオブジェクトを取得します。</summary>
        <value>反映する IME モードを表すオブジェクト。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryAccessibilityHelp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryAccessibilityHelpEventHandler QueryAccessibilityHelp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryAccessibilityHelp As QueryAccessibilityHelpEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryAccessibilityHelpEventHandler ^ QueryAccessibilityHelp;" />
      <MemberSignature Language="F#" Value="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " Usage="member this.QueryAccessibilityHelp : System.Windows.Forms.QueryAccessibilityHelpEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryAccessibilityHelpEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.Forms.AccessibleObject" /> がユーザー補助アプリケーションにヘルプを提供したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用する必要があります、<xref:System.Windows.Forms.HelpProvider>クラスにユーザーが F1 キーを押しても、ユーザー補助オブジェクトのヘルプを起動します。 使用して、<xref:System.Windows.Forms.HelpProvider>で完全な情報を提供、<xref:System.Windows.Forms.QueryAccessibilityHelpEventArgs>します。 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 ユーザー補助対応のグラフの作成を次のコード例に示しますを使用して、制御、<xref:System.Windows.Forms.AccessibleObject>と<xref:System.Windows.Forms.Control.ControlAccessibleObject>アクセス可能な情報を公開するクラス。 コントロールは、凡例と共に 2 つの曲線をプロットします。 `ChartControlAccessibleObject`から派生したクラス`ControlAccessibleObject`で使用されて、<xref:System.Windows.Forms.Control.CreateAccessibilityInstance%2A>グラフ コントロールのカスタムのアクセス可能な情報を提供するメソッド。 グラフの凡例は、実際はないため<xref:System.Windows.Forms.Control>-ベースの制御が描画される代わりに、グラフ コントロールではなく組み込みアクセス可能な情報。 このため、`ChartControlAccessibleObject`オーバーライド、<xref:System.Windows.Forms.AccessibleObject.GetChild%2A>を返すメソッドを`CurveLegendAccessibleObject`凡例の各部分にアクセスできる情報を表します。 ユーザー補助対応アプリケーションでは、このコントロールを使用すると、コントロールは、アクセスに必要な情報を提供できます。  
  
 このコードの抜粋は、処理を示しています、<xref:System.Windows.Forms.Control.QueryAccessibilityHelp>イベント。 参照してください、<xref:System.Windows.Forms.AccessibleObject>完全なコード例では、クラスの概要。  
  
 [!code-cpp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CPP/chartcontrol.cpp#3)]
 [!code-csharp[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/CS/chartcontrol.cs#3)]
 [!code-vb[System.Windows.Forms.AccessibleObject#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.AccessibleObject/VB/chartcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.AccessibleObject.GetHelpTopic(System.String@)" />
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作中に発生し、ドラッグ ソースがドラッグ アンド ドロップ操作をキャンセルする必要があるかどうかを決定できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.QueryContinueDrag>ドラッグ アンド ドロップ操作中にキーボードまたはマウス ボタンの状態の変更がある場合に、イベントが発生します。 <xref:System.Windows.Forms.Control.QueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断します。  
  
 ドラッグ アンド ドロップ操作関連のイベントがどのように、いつ発生するかについて次に示します。  
  
 <xref:System.Windows.Forms.Control.DoDragDrop%2A>メソッドは、現在のカーソル位置の下にあるコントロールを決定します。 コントロールが有効なドロップ先であるかどうかを確認します。  
  
 コントロールが有効なドロップ ターゲットである場合、<xref:System.Windows.Forms.Control.GiveFeedback>ドラッグ アンド ドロップの効果が指定されたイベントが発生します。 ドラッグ アンド ドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
 マウス カーソルの位置、キーボードの状態、およびマウス ボタンの状態の変更が監視されます。  
  
-   ユーザーがウィンドウの外に移動した場合、<xref:System.Windows.Forms.Control.DragLeave> イベントが生成されます。  
  
-   マウスが別のコントロールに移動した場合は、そのコントロールの <xref:System.Windows.Forms.Control.DragEnter> が生成されます。  
  
-   マウスが移動しても同じコントロール内の場合は、<xref:System.Windows.Forms.Control.DragOver> イベントが生成されます。  
  
 キーボードまたはマウス ボタンの状態に変更がある場合、<xref:System.Windows.Forms.Control.QueryContinueDrag>の値に基づいて、操作をキャンセルするイベントが発生し、データをドロップして、ドラッグを継続するかどうかを決定します。 または、<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>イベントのプロパティ<xref:System.Windows.Forms.QueryContinueDragEventArgs>します。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Continue`、<xref:System.Windows.Forms.Control.DragOver>イベントは、操作を続行して、<xref:System.Windows.Forms.Control.GiveFeedback>適切な視覚的なフィードバックを設定できるように新しい効果でイベントが発生します。 有効なドロップ効果の一覧については、<xref:System.Windows.Forms.DragDropEffects> 列挙体を参照してください。  
  
    > [!NOTE]
    >  <xref:System.Windows.Forms.Control.DragOver>と<xref:System.Windows.Forms.Control.GiveFeedback>これにより、ユーザーがマウスの位置で最新のフィードバックを指定してマウスをドロップ先の間で移動、されたイベントはペアになっています。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Drop`ソース アプリケーションでは、ソース データに対して適切な操作を実行できるように、データの切り取り、移動、操作だった場合、ドロップ効果の値がソースに返されます。  
  
-   場合の値<xref:System.Windows.Forms.DragAction>は`Cancel`、<xref:System.Windows.Forms.Control.DragLeave>イベントが発生します。  
  
 既定では、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント セット<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>に`Cancel`で<xref:System.Windows.Forms.DragAction>ESC キーが押された設定する場合<xref:System.Windows.Forms.QueryContinueDragEventArgs.Action%2A>に`Drop`で<xref:System.Windows.Forms.DragAction>左、中央、または右マウス ボタンが押された場合。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、2 つの間でドラッグ アンド ドロップ操作を示します<xref:System.Windows.Forms.ListBox>コントロール。 例では、<xref:System.Windows.Forms.Control.DoDragDrop%2A>ドラッグ操作の開始メソッド。 ドラッグ操作の開始、マウスが移動した場合は、複数の<xref:System.Windows.Forms.SystemInformation.DragSize%2A?displayProperty=nameWithType>中にマウスの位置から、<xref:System.Windows.Forms.Control.MouseDown>イベント。 <xref:System.Windows.Forms.ListBox.IndexFromPoint%2A>メソッドを使用中にドラッグする項目のインデックスを確認して、`MouseDown`イベント。  
  
 例では、カスタム カーソルをドラッグ アンド ドロップ操作を使用しても示しています。 例では、その 2 つが必要です、カーソル ファイル`3dwarro.cur`と`3dwno.cur`、カスタム ドラッグ用のアプリケーション ディレクトリ内に存在および非ドロップ カーソルの場合、それぞれします。 場合に使用されるカスタム カーソル、 `UseCustomCursorsCheck` <xref:System.Windows.Forms.CheckBox>がチェックされます。 カスタム カーソルが設定されて、<xref:System.Windows.Forms.Control.GiveFeedback>イベント ハンドラー。  
  
 キーボードの状態が評価される、<xref:System.Windows.Forms.Control.DragOver>右側のイベント ハンドラー`ListBox`ドラッグ操作を決定するには、shift キーを押し、CTRL、alt キーを押し、または CTRL + ALT キーの状態に基づいて。 内の場所、`ListBox`中にも決定されますが、ドロップが発生、`DragOver`イベント。 削除するデータがない場合、 `String`、<xref:System.Windows.Forms.DragEventArgs.Effect%2A?displayProperty=nameWithType>に設定されている`None`で<xref:System.Windows.Forms.DragDropEffects>します。 ドロップダウンの状態を表示する最後に、 `DropLocationLabel`<xref:System.Windows.Forms.Label>します。  
  
 右側のドロップするデータ`ListBox`で決定されます、<xref:System.Windows.Forms.Control.DragDrop>イベント ハンドラーと`String`の適切な場所にある値を追加、`ListBox`します。 ドラッグ操作が、フォームの境界の外側に移動しでドラッグ アンド ドロップ操作を取り消したかどうか、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント ハンドラー。  
  
 このコードの抜粋では、使用方法を示します、<xref:System.Windows.Forms.Control.QueryContinueDrag>イベント。 参照してください、<xref:System.Windows.Forms.Control.DoDragDrop%2A>完全なコード例のメソッド。  
  
 [!code-cpp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CPP/form1.cpp#6)]
 [!code-csharp[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/CS/form1.cs#6)]
 [!code-vb[System.Windows.Forms.Control.DoDragDrop#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.DoDragDrop/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseDragEvent">
      <MemberSignature Language="C#" Value="protected void RaiseDragEvent (object key, System.Windows.Forms.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseDragEvent(object key, class System.Windows.Forms.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseDragEvent (key As Object, e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseDragEvent(System::Object ^ key, System::Windows::Forms::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseDragEvent : obj * System.Windows.Forms.DragEventArgs -&gt; unit" Usage="control.RaiseDragEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary>適切なドラッグ イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseKeyEvent">
      <MemberSignature Language="C#" Value="protected void RaiseKeyEvent (object key, System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseKeyEvent(object key, class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseKeyEvent (key As Object, e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseKeyEvent(System::Object ^ key, System::Windows::Forms::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseKeyEvent : obj * System.Windows.Forms.KeyEventArgs -&gt; unit" Usage="control.RaiseKeyEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.KeyEventArgs" />。</param>
        <summary>適切なキー イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaiseMouseEvent">
      <MemberSignature Language="C#" Value="protected void RaiseMouseEvent (object key, System.Windows.Forms.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseMouseEvent(object key, class System.Windows.Forms.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaiseMouseEvent (key As Object, e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaiseMouseEvent(System::Object ^ key, System::Windows::Forms::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaiseMouseEvent : obj * System.Windows.Forms.MouseEventArgs -&gt; unit" Usage="control.RaiseMouseEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.MouseEventArgs" />。</param>
        <summary>適切なマウス イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RaisePaintEvent">
      <MemberSignature Language="C#" Value="protected void RaisePaintEvent (object key, System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaisePaintEvent(object key, class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RaisePaintEvent(System.Object,System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RaisePaintEvent (key As Object, e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RaisePaintEvent(System::Object ^ key, System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.RaisePaintEvent : obj * System.Windows.Forms.PaintEventArgs -&gt; unit" Usage="control.RaisePaintEvent (key, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Object" />
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="key">発生させるイベント。</param>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Forms.PaintEventArgs" />。</param>
        <summary>適切な描画イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.RaiseDragEvent(System.Object,System.Windows.Forms.DragEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseKeyEvent(System.Object,System.Windows.Forms.KeyEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RaiseMouseEvent(System.Object,System.Windows.Forms.MouseEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RecreateHandle">
      <MemberSignature Language="C#" Value="protected void RecreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RecreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RecreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RecreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RecreateHandle();" />
      <MemberSignature Language="F#" Value="member this.RecreateHandle : unit -&gt; unit" Usage="control.RecreateHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的にコントロールのハンドルを再作成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RecreateHandle%2A>パラメーターに新しいコントロールでは、必要なときに、メソッドが呼び出されますからの呼び出しを使用して<xref:System.Windows.Forms.Control.UpdateStyles%2A>に<xref:System.Windows.Forms.Control.CreateParams%2A>は不十分です。 このメソッドも呼び出します<xref:System.Windows.Forms.Control.DestroyHandle%2A>と<xref:System.Windows.Forms.Control.CreateHandle%2A>設定と<xref:System.Windows.Forms.Control.RecreatingHandle%2A>に`true`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RecreatingHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RecreatingHandle">
      <MemberSignature Language="C#" Value="public bool RecreatingHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RecreatingHandle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RecreatingHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RecreatingHandle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RecreatingHandle { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RecreatingHandle : bool" Usage="System.Windows.Forms.Control.RecreatingHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが現在そのコントロールのハンドルを再作成中かどうかを示す値を取得します。</summary>
        <value>コントロールが現在そのコントロールのハンドルを再作成中である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RecreatingHandle%2A>プロパティが返す`true`場合、<xref:System.Windows.Forms.Control.RecreateHandle%2A>メソッドが、コントロールで実行されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControl" />
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
        <altmember cref="P:System.Windows.Forms.Control.CreateParams" />
        <altmember cref="M:System.Windows.Forms.Control.DestroyHandle" />
        <altmember cref="P:System.Windows.Forms.Control.Handle" />
        <altmember cref="P:System.Windows.Forms.Control.IsHandleCreated" />
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateStyles" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToClient">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToClient (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToClient(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToClient (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToClient(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToClient : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToClient r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">画面座標で示された変換対象の <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>指定した画面上の四角形のサイズと位置をクライアント座標で算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Rectangle" />、<see cref="T:System.Drawing.Rectangle" /> をクライアント座標で表す <paramref name="r" />。</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="RectangleToScreen">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RectangleToScreen (System.Drawing.Rectangle r);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Drawing.Rectangle RectangleToScreen(valuetype System.Drawing.Rectangle r) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RectangleToScreen(System.Drawing.Rectangle)" />
      <MemberSignature Language="VB.NET" Value="Public Function RectangleToScreen (r As Rectangle) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Drawing::Rectangle RectangleToScreen(System::Drawing::Rectangle r);" />
      <MemberSignature Language="F#" Value="member this.RectangleToScreen : System.Drawing.Rectangle -&gt; System.Drawing.Rectangle" Usage="control.RectangleToScreen r" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="r" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="r">クライアント座標で示された変換対象の <see cref="T:System.Drawing.Rectangle" />。</param>
        <summary>指定したクライアント領域の四角形のサイズと位置を画面座標で算出します。</summary>
        <returns>変換された <see cref="T:System.Drawing.Rectangle" />、<see cref="T:System.Drawing.Rectangle" /> を画面座標で表す <paramref name="p" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例は、使用する方法を示します、 <xref:System.Windows.Forms.Control.BackColor%2A>、 <xref:System.Windows.Forms.Control.RectangleToScreen%2A>、 <xref:System.Windows.Forms.Control.PointToScreen%2A>、 <xref:System.Windows.Forms.Control.MouseButtons%2A>、 <xref:System.Windows.Forms.ControlPaint.DrawReversibleFrame%2A?displayProperty=nameWithType>、および<xref:System.Drawing.Rectangle.IntersectsWith%2A?displayProperty=nameWithType>メンバー。 例を実行すると呼ばれる形式で次のコードを貼り付け**Form1**いくつかのコントロールを格納しています。 この例では、する必要があります、 <xref:System.Windows.Forms.Control.MouseDown>、 <xref:System.Windows.Forms.Control.MouseMove>、および<xref:System.Windows.Forms.Control.MouseUp>イベントは、この例で定義されているイベント ハンドラーに接続しています。  
  
 [!code-cpp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.RectangleToScreen#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RectangleToScreen/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Rectangle" />
        <altmember cref="M:System.Windows.Forms.Control.RectangleToClient(System.Drawing.Rectangle)" />
      </Docs>
    </Member>
    <Member MemberName="ReflectMessage">
      <MemberSignature Language="C#" Value="protected static bool ReflectMessage (IntPtr hWnd, ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool ReflectMessage(native int hWnd, valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ReflectMessage(System.IntPtr,System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function ReflectMessage (hWnd As IntPtr, ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool ReflectMessage(IntPtr hWnd, System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="static member ReflectMessage : nativeint *  -&gt; bool" Usage="System.Windows.Forms.Control.ReflectMessage (hWnd, m)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hWnd" Type="System.IntPtr" />
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="hWnd">メッセージをリフレクションするコントロールのハンドルを表す <see cref="T:System.IntPtr" />。</param>
        <param name="m">リフレクションする Windows メッセージを表す <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>指定したメッセージを指定したハンドルにバインドされたコントロールにリフレクションします。</summary>
        <returns>メッセージがリフレクションされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ReflectMessage%2A>メソッドはインフラストラクチャ メソッドであるし、通常、コードからは呼び出されません。  
  
 場合、`hWnd`パラメーターは、有効なコントロールを表していない、<xref:System.Windows.Forms.Control.ReflectMessage%2A>メソッドを返します。`false`します。  
  
 Windows メッセージは最上位レベルのウィンドウに返されるため、<xref:System.Windows.Forms.Control.ReflectMessage%2A>メソッドを使用してメッセージを送信したコントロールに応答メッセージを伝達します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このメソッドを呼び出すすべてのウィンドウ。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberSignature Language="F#" Value="abstract member Refresh : unit -&gt; unit&#xA;override this.Refresh : unit -&gt; unit" Usage="control.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>強制的に、コントロールがクライアント領域を無効化し、直後にそのコントロール自体とその子コントロールを再描画するようにします。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.Refresh" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.Refresh" />メソッド コントロールとその子コントロールを無効にして再描画されるようにします。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.Update" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <Member MemberName="Region">
      <MemberSignature Language="C#" Value="public System.Drawing.Region Region { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Region Region" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Region" />
      <MemberSignature Language="VB.NET" Value="Public Property Region As Region" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Region ^ Region { System::Drawing::Region ^ get(); void set(System::Drawing::Region ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Region : System.Drawing.Region with get, set" Usage="System.Windows.Forms.Control.Region" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Region</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに関連付けられたウィンドウ領域を取得または設定します。</summary>
        <value>コントロールに関連付けられたウィンドウ <see cref="T:System.Drawing.Region" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ウィンドウ領域では、オペレーティング システムで描画が許可されているウィンドウ内のピクセルのコレクションです。 オペレーティング システムでは、ウィンドウの領域の外部にあるウィンドウの任意の部分は表示されません。 コントロールの領域の座標では、コントロールのクライアント領域ではなく、コントロールの左上隅に対して相対的です。  
  
> [!NOTE]
>  ピクセルを領域に含まれるコレクションは非連続にできます。  
  
   
  
## Examples  
 次のコード例は、使用する方法を示します、<xref:System.Windows.Forms.Control.Region%2A>丸いボタンを作成するプロパティ。 例を実行するには、というボタンを含むフォームで次のコードを貼り付け`roundButton`します。 この例では、する必要があります、<xref:System.Windows.Forms.Control.Paint>の例で定義されたイベント ハンドラーにイベントが接続されています。  
  
 [!code-cpp[System.Windows.Forms.Control.Region#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.Region#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.Region#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.Region/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を設定するすべてのウィンドウ。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="RegionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RegionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RegionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RegionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RegionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RegionChanged;" />
      <MemberSignature Language="F#" Value="member this.RegionChanged : EventHandler " Usage="member this.RegionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Region" /> プロパティの値が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.RegionChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.RegionChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#22](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#22)]
 [!code-vb[System.Windows.Forms.EventExamples#22](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderRightToLeft">
      <MemberSignature Language="C#" Value="protected internal bool RenderRightToLeft { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RenderRightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Protected Friend ReadOnly Property RenderRightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property bool RenderRightToLeft { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.RenderRightToLeft : bool" Usage="System.Windows.Forms.Control.RenderRightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated. Please use RightToLeft instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このプロパティは使用されなくなりました。</summary>
        <value>コントロールが左から右から左へ表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RescaleConstantsForDpi">
      <MemberSignature Language="C#" Value="protected virtual void RescaleConstantsForDpi (int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RescaleConstantsForDpi(int32 deviceDpiOld, int32 deviceDpiNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RescaleConstantsForDpi(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RescaleConstantsForDpi (deviceDpiOld As Integer, deviceDpiNew As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RescaleConstantsForDpi(int deviceDpiOld, int deviceDpiNew);" />
      <MemberSignature Language="F#" Value="abstract member RescaleConstantsForDpi : int * int -&gt; unit&#xA;override this.RescaleConstantsForDpi : int * int -&gt; unit" Usage="control.RescaleConstantsForDpi (deviceDpiOld, deviceDpiNew)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">変更前の DPI 値。</param>
        <param name="deviceDpiNew">変更後の DPI 値。</param>
        <summary>DPI の変更が発生したときに、コントロールの再スケーリングの定数を提供します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBackColor">
      <MemberSignature Language="C#" Value="public virtual void ResetBackColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetBackColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetBackColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetBackColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetBackColor : unit -&gt; unit&#xA;override this.ResetBackColor : unit -&gt; unit" Usage="control.ResetBackColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.BackColor" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetBindings">
      <MemberSignature Language="C#" Value="public void ResetBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetBindings" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetBindings ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetBindings();" />
      <MemberSignature Language="F#" Value="member this.ResetBindings : unit -&gt; unit" Usage="control.ResetBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.Forms.BindingSource" /> にバインドされたコントロールに対し、リスト内のすべての項目を再度読み込んで表示値を更新するよう通知します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.DataBindings" />
      </Docs>
    </Member>
    <Member MemberName="ResetCursor">
      <MemberSignature Language="C#" Value="public virtual void ResetCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetCursor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetCursor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetCursor();" />
      <MemberSignature Language="F#" Value="abstract member ResetCursor : unit -&gt; unit&#xA;override this.ResetCursor : unit -&gt; unit" Usage="control.ResetCursor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Cursor" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetFont">
      <MemberSignature Language="C#" Value="public virtual void ResetFont ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetFont() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetFont" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetFont ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetFont();" />
      <MemberSignature Language="F#" Value="abstract member ResetFont : unit -&gt; unit&#xA;override this.ResetFont : unit -&gt; unit" Usage="control.ResetFont " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Font" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetForeColor">
      <MemberSignature Language="C#" Value="public virtual void ResetForeColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetForeColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetForeColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetForeColor();" />
      <MemberSignature Language="F#" Value="abstract member ResetForeColor : unit -&gt; unit&#xA;override this.ResetForeColor : unit -&gt; unit" Usage="control.ResetForeColor " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ForeColor" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetImeMode">
      <MemberSignature Language="C#" Value="public void ResetImeMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetImeMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetImeMode" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetImeMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetImeMode();" />
      <MemberSignature Language="F#" Value="member this.ResetImeMode : unit -&gt; unit" Usage="control.ResetImeMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.ImeMode" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetMouseEventArgs">
      <MemberSignature Language="C#" Value="protected void ResetMouseEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ResetMouseEventArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetMouseEventArgs" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ResetMouseEventArgs ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ResetMouseEventArgs();" />
      <MemberSignature Language="F#" Value="member this.ResetMouseEventArgs : unit -&gt; unit" Usage="control.ResetMouseEventArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="E:System.Windows.Forms.Control.MouseLeave" /> イベントを処理するためのコントロールをリセットします。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetRightToLeft">
      <MemberSignature Language="C#" Value="public virtual void ResetRightToLeft ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetRightToLeft() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetRightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetRightToLeft ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetRightToLeft();" />
      <MemberSignature Language="F#" Value="abstract member ResetRightToLeft : unit -&gt; unit&#xA;override this.ResetRightToLeft : unit -&gt; unit" Usage="control.ResetRightToLeft " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.RightToLeft" /> プロパティを既定値にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetText">
      <MemberSignature Language="C#" Value="public virtual void ResetText ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetText() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResetText" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ResetText ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ResetText();" />
      <MemberSignature Language="F#" Value="abstract member ResetText : unit -&gt; unit&#xA;override this.ResetText : unit -&gt; unit" Usage="control.ResetText " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Text" /> プロパティを既定値 (<see cref="F:System.String.Empty" />) にリセットします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 いずれかのデザイナーを作成する場合は通常このメソッドを使用する、<xref:System.Windows.Forms.Control>またはコントロールを組み込む独自に作成、<xref:System.Windows.Forms.Control>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Resize">
      <MemberSignature Language="C#" Value="public event EventHandler Resize;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Resize" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Resize" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resize As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Resize;" />
      <MemberSignature Language="F#" Value="member this.Resize : EventHandler " Usage="member this.Resize : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのサイズが変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 決定する、<xref:System.Windows.Forms.Control.Size%2A>サイズを変更したコントロールのキャストすることができます、 `sender` 、登録済みのパラメーター<xref:System.Windows.Forms.ControlEventHandler>メソッドを<xref:System.Windows.Forms.Control>取得とその<xref:System.Windows.Forms.Control.Size%2A>プロパティ (または<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Width%2A>プロパティ個別に)。  
  
 カスタム レイアウトを処理するために使用して、<xref:System.Windows.Forms.Control.Layout>サイズ変更イベントではなくイベント。 <xref:System.Windows.Forms.Control.Layout>への応答でイベントが発生します、<xref:System.Windows.Forms.Control.Resize>イベントも、コントロールのレイアウトに影響するその他の変更に応答します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例のハンドル、<xref:System.Windows.Forms.Control.Resize>のイベントを<xref:System.Windows.Forms.Form>します。 イベント ハンドラーでは、フォームが正方形のままになることによって、フォームがサイズ変更されると (その<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Width%2A>変化がない)。 この例を実行することを確認し、このイベント処理メソッドを関連付けるフォームの<xref:System.Windows.Forms.Control.Resize>イベント。  
  
 [!code-cpp[WinForms.Control.Resize#1](~/samples/snippets/cpp/VS_Snippets_Winforms/WinForms.Control.Resize/CPP/form1.cpp#1)]
 [!code-csharp[WinForms.Control.Resize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/WinForms.Control.Resize/CS/form1.cs#1)]
 [!code-vb[WinForms.Control.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/WinForms.Control.Resize/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="ResizeRedraw">
      <MemberSignature Language="C#" Value="protected bool ResizeRedraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ResizeRedraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ResizeRedraw" />
      <MemberSignature Language="VB.NET" Value="Protected Property ResizeRedraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool ResizeRedraw { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ResizeRedraw : bool with get, set" Usage="System.Windows.Forms.Control.ResizeRedraw" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>サイズが変更されたときに、コントロールがコントロール自体を再描画するかどうかを示す値を取得または設定します。</summary>
        <value>サイズが変更されるとコントロールがコントロール自体を再描画する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.ResizeRedraw%2A>プロパティの値がの戻り値に相当する、<xref:System.Windows.Forms.Control.GetStyle%2A>メソッドに渡すと、<xref:System.Windows.Forms.ControlStyles.ResizeRedraw?displayProperty=nameWithType>値をパラメーターとして。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="F:System.Windows.Forms.ControlStyles.ResizeRedraw" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ResumeLayout">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>通常のレイアウト ロジックを再開します。</summary>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout();" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : unit -&gt; unit" Usage="control.ResumeLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>通常のレイアウト ロジックを再開します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド強制的に即時のレイアウト、保留中のレイアウトの要求を使用する必要がある場合。  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを使用して並行して複数の抑制<xref:System.Windows.Forms.Control.Layout>イベント中に、コントロールの複数の属性を調整します。 呼び出します通常など、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを設定し、 <xref:System.Windows.Forms.Control.Size%2A>、 <xref:System.Windows.Forms.Control.Location%2A>、 <xref:System.Windows.Forms.Control.Anchor%2A>、または<xref:System.Windows.Forms.Control.Dock%2A>制御、および次のプロパティ、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを有効にする変更を有効にします。  
  
 保留中の呼び出しが必要ない<xref:System.Windows.Forms.Control.SuspendLayout%2A>の<xref:System.Windows.Forms.Control.ResumeLayout%2A>正常に呼び出されます。  
  
   
  
## Examples  
 次のコード例では、フォームに 2 つのボタンを追加します。 トランザクションの例を使用して、ボタンの追加、<xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド。  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="ResumeLayout">
      <MemberSignature Language="C#" Value="public void ResumeLayout (bool performLayout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResumeLayout(bool performLayout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ResumeLayout(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResumeLayout (performLayout As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResumeLayout(bool performLayout);" />
      <MemberSignature Language="F#" Value="member this.ResumeLayout : bool -&gt; unit" Usage="control.ResumeLayout performLayout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="performLayout" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="performLayout">保留中のレイアウトの要求を実行する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>通常のレイアウト ロジックを再開します。オプションで、保留中のレイアウト要求のレイアウトを強制的に即時実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド強制的に即時のレイアウト、保留中のレイアウトの要求を使用する必要がある場合。 ときに、`performLayout`にパラメーターが設定されている`true`、即時のレイアウトは、保留中のレイアウトの要求を使用する必要がある場合に発生します。  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを使用して並行して複数の抑制<xref:System.Windows.Forms.Control.Layout>イベント中に、コントロールの複数の属性を調整します。 呼び出します通常など、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを設定し、 <xref:System.Windows.Forms.Control.Size%2A>、 <xref:System.Windows.Forms.Control.Location%2A>、 <xref:System.Windows.Forms.Control.Anchor%2A>、または<xref:System.Windows.Forms.Control.Dock%2A>制御、および次のプロパティ、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを有効にする変更を有効にします。  
  
 保留中の呼び出しが必要ない<xref:System.Windows.Forms.Control.SuspendLayout%2A>の<xref:System.Windows.Forms.Control.ResumeLayout%2A>正常に呼び出されます。  
  
> [!NOTE]
>  いくつかのコントロールを親コントロールを追加する場合は、呼び出すことをお勧めしますが、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを追加するコントロールを初期化する前にします。 親コントロールにコントロールを追加した後、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド。 これにより、多くのコントロールを持つアプリケーションのパフォーマンスが向上します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="Right">
      <MemberSignature Language="C#" Value="public int Right { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Right" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Right" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Right As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Right { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Right : int" Usage="System.Windows.Forms.Control.Right" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの右端とコンテナーのクライアント領域の左端の間の距離をピクセルで取得します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの右端とコンテナーのクライアント領域の左端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値、<xref:System.Windows.Forms.Control.Right%2A>プロパティは、の合計に等しい、<xref:System.Windows.Forms.Control.Left%2A>プロパティの値と<xref:System.Windows.Forms.Control.Width%2A>プロパティの値。  
  
 <xref:System.Windows.Forms.Control.Right%2A> プロパティは読み取り専用です。 変更しないこのプロパティの値直接の値を変更することで、<xref:System.Windows.Forms.Control.Left%2A>または<xref:System.Windows.Forms.Control.Width%2A>プロパティまたは呼び出す、 <xref:System.Windows.Forms.Control.SetBounds%2A>、 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>、 <xref:System.Windows.Forms.Control.UpdateBounds%2A>、または<xref:System.Windows.Forms.Control.SetClientSizeCore%2A>メソッド。  
  
   
  
## Examples  
 次のコード例では、3 つを作成<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用して、そのサイズと位置を設定します。 この例が必要です、<xref:System.Windows.Forms.Form>少なくとも 300 ピクセルの高さ、幅を持ちます。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 [!code-cpp[Control.KeyUp#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.KeyUp/CPP/form1.cpp#1)]
 [!code-csharp[Control.KeyUp#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.KeyUp/CS/form1.cs#1)]
 [!code-vb[Control.KeyUp#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.KeyUp/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Right" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.RightToLeft RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RightToLeft RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeft As RightToLeft" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::RightToLeft RightToLeft { System::Windows::Forms::RightToLeft get(); void set(System::Windows::Forms::RightToLeft value); };" />
      <MemberSignature Language="F#" Value="member this.RightToLeft : System.Windows.Forms.RightToLeft with get, set" Usage="System.Windows.Forms.Control.RightToLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RightToLeft</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの要素が、右から左へ表示されるフォントを使用するロケールをサポートするように配置されているかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Forms.RightToLeft" /> 値のいずれか。 既定値は、<see cref="F:System.Windows.Forms.RightToLeft.Inherit" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティは、アンビエント プロパティです。 アンビエントのプロパティはコントロールのプロパティ セットは、親コントロールから取得されます。 たとえば、<xref:System.Windows.Forms.Button>が、同じ<xref:System.Windows.Forms.Control.BackColor%2A>親として<xref:System.Windows.Forms.Form>既定では。 アンビエント プロパティの詳細については、次を参照してください。、<xref:System.Windows.Forms.AmbientProperties>クラスまたは<xref:System.Windows.Forms.Control>クラスの概要。  
  
 <xref:System.Windows.Forms.Control.RightToLeft%2A>右から左、ヘブライ語やアラビア語などの言語の書き込み先の国際対応アプリケーション プロパティで使用します。 このプロパティに設定しているときに<xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>、右から左へテキストを含むコントロールの要素が表示されます。  
  
> [!NOTE]
>  場合の値、<xref:System.Windows.Forms.Control.RightToLeft%2A>実行時にプロパティが変更された、書式を未加工のテキストのみが保持されます。  
  
 コントロール要素の影響について、いくつかの例を次に、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ値の<xref:System.Windows.Forms.RightToLeft.Yes?displayProperty=nameWithType>:  
  
-   スクロール可能なコントロールの右側にあるのではなく、左側に垂直スクロール バーが表示されます (たとえば、 <xref:System.Windows.Forms.Form>、<xref:System.Windows.Forms.Panel>複数行、 <xref:System.Windows.Forms.TextBox>、および<xref:System.Windows.Forms.RichTextBox>)。  
  
-   水平スクロール バーは右揃えのスクロール ボックス (つまみ) を起動します。  
  
-   によって制御されるチェック ボックス要素の配置、`CheckAlign`プロパティには逆に<xref:System.Windows.Forms.CheckBox>と<xref:System.Windows.Forms.RadioButton>コントロール。  
  
-   リスト ボックス、コンボ ボックス、およびアップダウン コントロール内の項目が右寄せになります。  
  
-   上向きボタンおよび下向きは左揃えで<xref:System.Windows.Forms.NumericUpDown>と<xref:System.Windows.Forms.DomainUpDown>コントロール。  
  
-   メニュー (<xref:System.Windows.Forms.MainMenu>、 <xref:System.Windows.Forms.MenuItem>、および<xref:System.Windows.Forms.ContextMenu>) 右揃えに表示されます。  
  
-   ツールバーのボタンの配置を<xref:System.Windows.Forms.ToolBar>コントロールまたはの上のテキストの配置を<xref:System.Windows.Forms.ToolBarButton>は影響されません、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティ。  
  
-   <xref:System.Windows.Forms.AxHost> 右から左への配置をサポートしていますただし、ActiveX コントロールへの影響は、コントロールの作成者が右から左に表示するためのサポートを実装するエクステントによって異なります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">代入された値が、<see cref="T:System.Windows.Forms.RightToLeft" /> 値ではありません。</exception>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.RightToLeft" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.RightToLeft" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.RightToLeft" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="T:System.Windows.Forms.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.RightToLeftChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftChanged;" />
      <MemberSignature Language="F#" Value="member this.RightToLeftChanged : EventHandler " Usage="member this.RightToLeftChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.RightToLeft" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.RightToLeft%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、イベント ハンドラーを実行すると実行、<xref:System.Windows.Forms.Control.Text%2A>プロパティ値が変更されます。 <xref:System.Windows.Forms.Control>クラスがいくつかのメソッド名のパターンを持つ*PropertyName* `Changed`にある場合に発生します、対応する*PropertyName*値の変更 (*PropertyName*対応するプロパティの名前を表します)。  
  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RtlTranslateAlignment">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>現在の配置を適切な配置に変換し、テキストを右から左に表示できるようにします。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Drawing.ContentAlignment RtlTranslateAlignment (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateAlignment(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Drawing::ContentAlignment RtlTranslateAlignment(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Drawing.ContentAlignment" /> を適切な <see cref="T:System.Drawing.ContentAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティの<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値が等しく、`align`でパラメーターが渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateAlignment(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.HorizontalAlignment" /> を適切な <see cref="T:System.Windows.Forms.HorizontalAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティの<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値が等しく、`align`でパラメーターが渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateAlignment">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateAlignment(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateAlignment (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateAlignment(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateAlignment : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateAlignment align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.LeftRightAlignment" /> を適切な <see cref="T:System.Windows.Forms.LeftRightAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティの<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値が等しく、`align`でパラメーターが渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateContent">
      <MemberSignature Language="C#" Value="protected internal System.Drawing.ContentAlignment RtlTranslateContent (System.Drawing.ContentAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance valuetype System.Drawing.ContentAlignment RtlTranslateContent(valuetype System.Drawing.ContentAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function RtlTranslateContent (align As ContentAlignment) As ContentAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Drawing::ContentAlignment RtlTranslateContent(System::Drawing::ContentAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateContent : System.Drawing.ContentAlignment -&gt; System.Drawing.ContentAlignment" Usage="control.RtlTranslateContent align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.ContentAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Drawing.ContentAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Drawing.ContentAlignment" /> を適切な <see cref="T:System.Drawing.ContentAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Drawing.ContentAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティの<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値が等しく、`align`でパラメーターが渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Drawing.ContentAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateHorizontal">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal (System.Windows.Forms.HorizontalAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.HorizontalAlignment RtlTranslateHorizontal(valuetype System.Windows.Forms.HorizontalAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateHorizontal (align As HorizontalAlignment) As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::HorizontalAlignment RtlTranslateHorizontal(System::Windows::Forms::HorizontalAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateHorizontal : System.Windows.Forms.HorizontalAlignment -&gt; System.Windows.Forms.HorizontalAlignment" Usage="control.RtlTranslateHorizontal align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.HorizontalAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.HorizontalAlignment" /> を適切な <see cref="T:System.Windows.Forms.HorizontalAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.HorizontalAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティの<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値が等しく、`align`でパラメーターが渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      </Docs>
    </Member>
    <Member MemberName="RtlTranslateLeftRight">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight (System.Windows.Forms.LeftRightAlignment align);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance valuetype System.Windows.Forms.LeftRightAlignment RtlTranslateLeftRight(valuetype System.Windows.Forms.LeftRightAlignment align) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.RtlTranslateLeftRight(System.Windows.Forms.LeftRightAlignment)" />
      <MemberSignature Language="VB.NET" Value="Protected Function RtlTranslateLeftRight (align As LeftRightAlignment) As LeftRightAlignment" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Forms::LeftRightAlignment RtlTranslateLeftRight(System::Windows::Forms::LeftRightAlignment align);" />
      <MemberSignature Language="F#" Value="member this.RtlTranslateLeftRight : System.Windows.Forms.LeftRightAlignment -&gt; System.Windows.Forms.LeftRightAlignment" Usage="control.RtlTranslateLeftRight align" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LeftRightAlignment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="align" Type="System.Windows.Forms.LeftRightAlignment" />
      </Parameters>
      <Docs>
        <param name="align"><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.LeftRightAlignment" /> を適切な <see cref="T:System.Windows.Forms.LeftRightAlignment" /> に変換し、テキストを右から左に表示できるようにします。</summary>
        <returns><see cref="T:System.Windows.Forms.LeftRightAlignment" /> 値のいずれか。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.RightToLeft%2A>プロパティの<xref:System.Windows.Forms.RightToLeft>に設定されている`No`、戻り値が等しく、`align`でパラメーターが渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="T:System.Windows.Forms.LeftRightAlignment" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateContent(System.Drawing.ContentAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateHorizontal(System.Windows.Forms.HorizontalAlignment)" />
        <altmember cref="M:System.Windows.Forms.Control.RtlTranslateAlignment(System.Windows.Forms.HorizontalAlignment)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Scale">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールおよび子コントロールのスケールを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (System.Drawing.SizeF factor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(valuetype System.Drawing.SizeF factor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Drawing.SizeF)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (factor As SizeF)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(System::Drawing::SizeF factor);" />
      <MemberSignature Language="F#" Value="member this.Scale : System.Drawing.SizeF -&gt; unit" Usage="control.Scale factor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">水平および垂直方向の倍率を格納した <see cref="T:System.Drawing.SizeF" />。</param>
        <summary>指定されたスケール ファクターによってコントロールおよびすべての子コントロールのスケールを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Scale%2A>メソッドは、指定したスケーリングによって、コントロールをスケーリング`factor`します。 これも再帰的にはすべての子コントロールをスケーリングの場合、<xref:System.Windows.Forms.Control.ScaleChildren%2A>プロパティは`true`します。 内部的には、このメソッドを呼び出す<xref:System.Windows.Forms.Control.ScaleControl%2A>各コントロールをスケーリングします。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ScaleChildren" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float ratio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 ratio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (ratio As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float ratio);" />
      <MemberSignature Language="F#" Value="member this.Scale : single -&gt; unit" Usage="control.Scale ratio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ratio" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="ratio">スケーリングに使用する比率。</param>
        <summary>コントロールおよび子コントロールのスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Scale">
      <MemberSignature Language="C#" Value="public void Scale (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Scale(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Scale(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Scale (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Scale(float dx, float dy);" />
      <MemberSignature Language="F#" Value="member this.Scale : single * single -&gt; unit" Usage="control.Scale (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Use the Scale(SizeF ratio) method instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">水平方向のスケール ファクター。</param>
        <param name="dy">垂直方向のスケール ファクター。</param>
        <summary>コントロール全体および子コントロールのスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleBitmapLogicalToDevice">
      <MemberSignature Language="C#" Value="public void ScaleBitmapLogicalToDevice (ref System.Drawing.Bitmap logicalBitmap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScaleBitmapLogicalToDevice(class System.Drawing.Bitmap&amp; logicalBitmap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleBitmapLogicalToDevice(System.Drawing.Bitmap@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScaleBitmapLogicalToDevice (ByRef logicalBitmap As Bitmap)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScaleBitmapLogicalToDevice(System::Drawing::Bitmap ^ % logicalBitmap);" />
      <MemberSignature Language="F#" Value="member this.ScaleBitmapLogicalToDevice :  -&gt; unit" Usage="control.ScaleBitmapLogicalToDevice logicalBitmap" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="logicalBitmap" Type="System.Drawing.Bitmap" RefType="ref" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="logicalBitmap">スケールを設定するビットマップ。</param>
        <summary>DPI の変更が発生したときに、同等のデバイス単位値に論理ビットマップ値のスケールを設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleChildren">
      <MemberSignature Language="C#" Value="protected virtual bool ScaleChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ScaleChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ScaleChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ScaleChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ScaleChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ScaleChildren : bool" Usage="System.Windows.Forms.Control.ScaleChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>子コントロールの表示スケールを決定する値を取得します。</summary>
        <value>このコントロールで <see langword="true" /> メソッドが呼び出されたときに子コントロールのスケールが設定される場合は <see cref="M:System.Windows.Forms.Control.Scale(System.Single)" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、<xref:System.Windows.Forms.Control.ScaleChildren%2A>プロパティは`true`、<xref:System.Windows.Forms.Control.Scale%2A>メソッドが再帰的に呼び出す、<xref:System.Windows.Forms.Control.ScaleControl%2A>その子コントロールのそれぞれのメソッド。  
  
 既定の実装<xref:System.Windows.Forms.Control.ScaleChildren%2A>は常に返します`true`します。 派生クラスでオーバーライドできます<xref:System.Windows.Forms.Control.ScaleChildren%2A>を返す`false`をスケーリングする必要がありますいないで実行されることの子を示します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Scale(System.Single)" />
        <altmember cref="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected virtual void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.ScaleControl : System.Drawing.SizeF * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.ScaleControl (factor, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" Index="1" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="factor">コントロールの高さと幅のスケールを設定する際のファクター。</param>
        <param name="specified">コントロールのサイズと位置を定義するときに使用するコントロールの境界を指定する <see cref="T:System.Windows.Forms.BoundsSpecified" /> 値。</param>
        <summary>コントロールの位置、サイズ、埋め込み、およびマージンのスケールを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールが最上位レベルの場合は、このコントロールの位置は対応できません。 これは、子、または自動的にサイズ変更されたコントロールのサイズには拡張できません。 値を変更することで、任意の方向にスケーリングを省略することができます、`specified`パラメーター。  
  
   
  
## Examples  
 <xref:System.Windows.Forms.BoundsSpecified>  
  
 <xref:System.Windows.Forms.Control.Scale%2A>  
  
 <xref:System.Windows.Forms.Control.GetScaledBounds%2A>  
  
 <xref:System.Windows.Forms.Control.SetBoundsCore%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected virtual void ScaleCore (float dx, float dy);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ScaleCore(float32 dx, float32 dy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ScaleCore (dx As Single, dy As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ScaleCore(float dx, float dy);" />
      <MemberSignature Language="F#" Value="abstract member ScaleCore : single * single -&gt; unit&#xA;override this.ScaleCore : single * single -&gt; unit" Usage="control.ScaleCore (dx, dy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dx" Type="System.Single" />
        <Parameter Name="dy" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="dx">水平方向のスケール ファクター。</param>
        <param name="dy">垂直方向のスケール ファクター。</param>
        <summary>このクラスでは、このメソッドは無効です。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このメソッドは無効です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Select">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<xref:System.Windows.Forms.Control.Select%2A>場合、メソッドは、コントロールをアクティブにコントロールの<xref:System.Windows.Forms.ControlStyles.Selectable?displayProperty=nameWithType>にスタイル ビットが設定されている`true`、別のコントロールに含まれていると、すべての親コントロールが両方表示して有効にします。

次の一覧に Windows フォーム コントロールは、選択可能ではありません。 リストのコントロールから派生したコントロールも選択できません。
  
- <xref:System.Windows.Forms.Label>  
- <xref:System.Windows.Forms.Panel>  
- <xref:System.Windows.Forms.GroupBox>
- <xref:System.Windows.Forms.PictureBox>  
- <xref:System.Windows.Forms.ProgressBar>
- <xref:System.Windows.Forms.Splitter>
- <xref:System.Windows.Forms.LinkLabel> (この場合、コントロール内にリンクすることはありません)
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="control.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールをアクティブにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
  
## Examples  

次のコード例を指定した選択<xref:System.Windows.Forms.Control>が選択可能な場合。
  
[!code-cpp[Windows.Forms.ControlMembers6#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#2)]
[!code-csharp[Windows.Forms.ControlMembers6#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#2)]
[!code-vb[Windows.Forms.ControlMembers6#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected virtual void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Select(bool directed, bool forward);" />
      <MemberSignature Language="F#" Value="abstract member Select : bool * bool -&gt; unit&#xA;override this.Select : bool * bool -&gt; unit" Usage="control.Select (directed, forward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">選択するコントロールの方向を指定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="forward">タブ オーダー内を前方に移動する場合は <see langword="true" />。後方に移動する場合は <see langword="false" />。</param>
        <summary>子コントロールをアクティブにします。 オプションとして、タブ オーダーでコントロールを選択するときの方向を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `directed`と`forward`コンテナー スタイルのコントロールでパラメーターを使用します。 ときに、`directed`にパラメーターが設定されている`true`、`forward`を選択するコントロールを決定するパラメーターが評価されます。 ときに`forward`に設定されている`true`、タブ オーダーの次のコントロールが選択されているときに`false`、タブ オーダー内で前のコントロールが選択されています。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="M:System.Windows.Forms.Control.Select" />
      </Docs>
    </Member>
    <Member MemberName="SelectNextControl">
      <MemberSignature Language="C#" Value="public bool SelectNextControl (System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SelectNextControl(class System.Windows.Forms.Control ctl, bool forward, bool tabStopOnly, bool nested, bool wrap) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SelectNextControl(System.Windows.Forms.Control,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function SelectNextControl (ctl As Control, forward As Boolean, tabStopOnly As Boolean, nested As Boolean, wrap As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SelectNextControl(System::Windows::Forms::Control ^ ctl, bool forward, bool tabStopOnly, bool nested, bool wrap);" />
      <MemberSignature Language="F#" Value="member this.SelectNextControl : System.Windows.Forms.Control * bool * bool * bool * bool -&gt; bool" Usage="control.SelectNextControl (ctl, forward, tabStopOnly, nested, wrap)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ctl" Type="System.Windows.Forms.Control" />
        <Parameter Name="forward" Type="System.Boolean" />
        <Parameter Name="tabStopOnly" Type="System.Boolean" />
        <Parameter Name="nested" Type="System.Boolean" />
        <Parameter Name="wrap" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="ctl">検索の開始位置とする <see cref="T:System.Windows.Forms.Control" />。</param>
        <param name="forward">タブ オーダー内を前方に移動する場合は <see langword="true" />。後方に移動する場合は <see langword="false" />。</param>
        <param name="tabStopOnly"><see cref="P:System.Windows.Forms.Control.TabStop" /> プロパティが <see langword="true" /> に設定されているコントロールを無視する場合は <see langword="false" />。それ以外の場合は <see langword="false" />。</param>
        <param name="nested">入れ子になった (子コントロールの子) 子コントロールを含める場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="wrap">タブ オーダーの最後のコントロールに到達した後、タブ オーダーの最初のコントロールから検索を続行する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>次のコントロールをアクティブにします。</summary>
        <returns>コントロールがアクティブにされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド場合、タブ オーダーの次のコントロールをアクティブにするコントロールの`Selectable`にスタイル ビットが設定されている`true`で<xref:System.Windows.Forms.ControlStyles>、別のコントロールに含まれていると、すべての親コントロールが両方表示して有効にします。  
  
 次の一覧に Windows フォーム コントロールは、選択可能ではありません。 リストのコントロールから派生したコントロールも選択できません。  
  
-   <xref:System.Windows.Forms.Label>  
  
-   <xref:System.Windows.Forms.Panel>  
  
-   <xref:System.Windows.Forms.GroupBox>  
  
-   <xref:System.Windows.Forms.PictureBox>  
  
-   <xref:System.Windows.Forms.ProgressBar>  
  
-   <xref:System.Windows.Forms.Splitter>  
  
-   <xref:System.Windows.Forms.LinkLabel> (この場合、コントロール内にリンクすることはありません)  
  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
   
  
## Examples  
 次のコード exampleshows、<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッドをいくつかのコントロールを持つフォームで使用されています。 フォームをクリックするたびに、次のコントロールがアクティブです。 <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A>プロパティは、コンテナー コントロールで現在アクティブなコントロールを取得します。  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#1)]  
  
 次のコード例は、<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッドを持つフォームで使用されている、<xref:System.Windows.Forms.Button>およびその他のいくつかのコントロール。 クリックすると、<xref:System.Windows.Forms.Button>後の次のコントロール、<xref:System.Windows.Forms.Button>がアクティブ化されます。 親を取得するがあることに注意してください、<xref:System.Windows.Forms.Button>コントロール。 <xref:System.Windows.Forms.Button> 、コンテナーではない呼び出し<xref:System.Windows.Forms.Control.SelectNextControl%2A>上で直接、<xref:System.Windows.Forms.Button>アクティブ化は変化しません。  
  
 [!code-csharp[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/csharp/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/cs/form1.cs#2)]
 [!code-vb[System.Windows.Forms.Control.SelectNextControl#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/system.windows.forms.control.selectnextcontrol/vb/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.Select" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
      </Docs>
    </Member>
    <Member MemberName="SendToBack">
      <MemberSignature Language="C#" Value="public void SendToBack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendToBack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SendToBack" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendToBack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendToBack();" />
      <MemberSignature Language="F#" Value="member this.SendToBack : unit -&gt; unit" Usage="control.SendToBack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを z オーダーの背面に移動します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールは、z オーダーの背面に移動されます。 コントロールが別のコントロールの子である場合は、子コントロールは、z オーダーの背面に移動されます。 コントロールがトップレベル コントロールである場合は、このメソッドは正しく動きませんコントロールがアクティブでない限りです。 最上位のコントロールは、コントロールなどを<xref:System.Windows.Forms.Form>、いない子である別のコントロール。 アクティブなコントロールは、表示コントロールに入力フォーカスです。 使用する、<xref:System.Windows.Forms.Control.SendToBack%2A>メソッドを非アクティブ、最上位のコントロールを呼び出す最初、<xref:System.Windows.Forms.Control.BringToFront%2A>コントロールのメソッド。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.BringToFront" />
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
      </Docs>
    </Member>
    <Member MemberName="SetAutoSizeMode">
      <MemberSignature Language="C#" Value="protected void SetAutoSizeMode (System.Windows.Forms.AutoSizeMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetAutoSizeMode(valuetype System.Windows.Forms.AutoSizeMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetAutoSizeMode(System.Windows.Forms.AutoSizeMode)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetAutoSizeMode (mode As AutoSizeMode)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetAutoSizeMode(System::Windows::Forms::AutoSizeMode mode);" />
      <MemberSignature Language="F#" Value="member this.SetAutoSizeMode : System.Windows.Forms.AutoSizeMode -&gt; unit" Usage="control.SetAutoSizeMode mode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mode" Type="System.Windows.Forms.AutoSizeMode" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="mode"><see cref="T:System.Windows.Forms.AutoSizeMode" /> 値のいずれか。</param>
        <summary><see cref="P:System.Windows.Forms.Control.AutoSize" /> プロパティが有効なときのコントロールの動作を示す値を設定します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールの範囲を設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int -&gt; unit" Usage="control.SetBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <summary>コントロールの範囲を指定した位置とサイズに設定します。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBounds">
      <MemberSignature Language="C#" Value="public void SetBounds (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBounds(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBounds (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBounds(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="member this.SetBounds : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBounds (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 値のビットごとの組み合わせ。 指定されていないパラメーターについては、現在の値が使用されます。</param>
        <summary>コントロールの指定した範囲を指定した位置とサイズに設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次のコード例のセンター、<xref:System.Windows.Forms.Form>の画面で、<xref:System.Windows.Forms.Control.Layout>イベント。 これにより、ユーザーがサイズを変更中央フォームが保持されます。 この例では、作成済みである必要があります、<xref:System.Windows.Forms.Form>コントロール。  
  
 [!code-cpp[Control.Layout#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Layout/CPP/layout.cpp#1)]
 [!code-csharp[Control.Layout#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Layout/CS/layout.cs#1)]
 [!code-vb[Control.Layout#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Layout/VB/layout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected virtual void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberSignature Language="F#" Value="abstract member SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit&#xA;override this.SetBoundsCore : int * int * int * int * System.Windows.Forms.BoundsSpecified -&gt; unit" Usage="control.SetBoundsCore (x, y, width, height, specified)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Left" /> プロパティ値。</param>
        <param name="y">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Top" /> プロパティ値。</param>
        <param name="width">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Width" /> プロパティ値。</param>
        <param name="height">コントロールの新しい <see cref="P:System.Windows.Forms.Control.Height" /> プロパティ値。</param>
        <param name="specified"><see cref="T:System.Windows.Forms.BoundsSpecified" /> 値のビットごとの組み合わせ。</param>
        <summary>このコントロールの指定した境界を設定する作業を実行します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 含まれていない境界に対応するパラメーター、通常、`specified`パラメーターは、その現在の値で渡されます。 たとえば、 <xref:System.Windows.Forms.Control.Height%2A>、 <xref:System.Windows.Forms.Control.Width%2A>、または<xref:System.Drawing.Point.X%2A>または<xref:System.Drawing.Point.Y%2A>のプロパティ、<xref:System.Windows.Forms.Control.Location%2A>プロパティは、コントロールの現在のインスタンスへの参照で渡すことができます。 ただしで渡されるすべての値が受け入れられ、コントロールに適用します。  
  
 `boundsSpecified`パラメーターは、コントロールの要素を表す<xref:System.Windows.Forms.Control.Bounds%2A>アプリケーションによって変更します。 変更する場合など、 <xref:System.Windows.Forms.Control.Size%2A> 、コントロールの`boundsSpecified`パラメーター値が、`Size`の値<xref:System.Windows.Forms.BoundsSpecified>します。 ただし場合、<xref:System.Windows.Forms.Control.Size%2A>への応答が調整、<xref:System.Windows.Forms.Control.Dock%2A>プロパティが設定されている、`boundsSpecified`パラメーター値が、`None`の値<xref:System.Windows.Forms.BoundsSpecified>します。  
  
> [!NOTE]
>  Windows Server 2003 システムでのサイズ、<xref:System.Windows.Forms.Form>最大ピクセル幅と、モニターの高さによって制限されます。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.SetBoundsCore%2A>メソッドをコントロールが固定サイズが変更されることを確認します。 この例から、直接または間接的に派生したクラスである必要があります、<xref:System.Windows.Forms.Control>クラス。  
  
 [!code-cpp[Windows.Forms.Control_Methods#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#1)]
 [!code-csharp[Windows.Forms.Control_Methods#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#1)]
 [!code-vb[Windows.Forms.Control_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />を変更するコントロールの境界を強制する方法。 派生クラスがサイズ制限を追加、<see cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />メソッド。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected virtual void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetClientSizeCore(int x, int y);" />
      <MemberSignature Language="F#" Value="abstract member SetClientSizeCore : int * int -&gt; unit&#xA;override this.SetClientSizeCore : int * int -&gt; unit" Usage="control.SetClientSizeCore (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">クライアント領域の幅 (ピクセル単位)。</param>
        <param name="y">クライアント領域の高さ (ピクセル単位)。</param>
        <summary>コントロールのクライアント領域のサイズを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 クライアント領域から始まり、(0, 0) の場所に拡張し、(`x`、 `y`) 場所。  
  
 通常、設定しないでください、<xref:System.Windows.Forms.Control.ClientSize%2A>のコントロール。  
  
   
  
## Examples  
 次のコード例の上書き、<xref:System.Windows.Forms.Control.SetClientSizeCore%2A>コントロールの四角形を確保する方法。 この例から、直接または間接的に派生したクラスである必要があります、<xref:System.Windows.Forms.Control>クラス。  
  
 [!code-cpp[Windows.Forms.Control_Methods#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CPP/controlmethods.cpp#2)]
 [!code-csharp[Windows.Forms.Control_Methods#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_Methods/CS/controlmethods.cs#2)]
 [!code-vb[Windows.Forms.Control_Methods#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_Methods/VB/controlmethods.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.SetClientSizeCore(System.Int32,System.Int32)" />メソッドように、<see cref="P:System.Windows.Forms.Control.ClientSize" />プロパティを調整します。  
  
コントロールの描画に関する詳細については、次を参照してください。 [Windows フォーム コントロールのレンダリング](~/docs/framework/winforms/controls/rendering-a-windows-forms-control.md)します。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetStyle">
      <MemberSignature Language="C#" Value="protected void SetStyle (System.Windows.Forms.ControlStyles flag, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetStyle(valuetype System.Windows.Forms.ControlStyles flag, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetStyle (flag As ControlStyles, value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetStyle(System::Windows::Forms::ControlStyles flag, bool value);" />
      <MemberSignature Language="F#" Value="member this.SetStyle : System.Windows.Forms.ControlStyles * bool -&gt; unit" Usage="control.SetStyle (flag, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Windows.Forms.ControlStyles" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flag">設定する <see cref="T:System.Windows.Forms.ControlStyles" /> ビット。</param>
        <param name="value">指定したスタイルをコントロールに適用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>指定した <see cref="T:System.Windows.Forms.ControlStyles" /> フラグを <see langword="true" /> または <see langword="false" /> に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロール スタイル ビット フラグは、サポートされている動作の分類に使用されます。 コントロールは、スタイルを有効に呼び出すことによって、<xref:System.Windows.Forms.Control.SetStyle%2A>メソッドを渡すことで、適切な<xref:System.Windows.Forms.ControlStyles>ビット (またはビット) と、ビットに設定するブール値。 指定したに割り当てられている値を決定する<xref:System.Windows.Forms.ControlStyles>ビットを使用して、<xref:System.Windows.Forms.Control.GetStyle%2A>メソッドを渡します、<xref:System.Windows.Forms.ControlStyles>を評価するメンバー。  
  
> [!CAUTION]
>  コントロール スタイル ビットを設定、コントロールの動作を変更できます。 レビュー、<xref:System.Windows.Forms.ControlStyles>列挙体のドキュメントを呼び出す前に、コントロール スタイル ビットの変更の影響を理解しておく、<xref:System.Windows.Forms.Control.SetStyle%2A>メソッド。  
  
   
  
## Examples  
 次のコード例は、のダブル バッファリングを有効、<xref:System.Windows.Forms.Form>し、変更を反映するようにスタイルを更新します。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetStyle(System.Windows.Forms.ControlStyles)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SetTopLevel">
      <MemberSignature Language="C#" Value="protected void SetTopLevel (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetTopLevel(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetTopLevel(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetTopLevel (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetTopLevel(bool value);" />
      <MemberSignature Language="F#" Value="member this.SetTopLevel : bool -&gt; unit" Usage="control.SetTopLevel value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">コントロールをトップレベル コントロールとして設定する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールをトップレベル コントロールとして設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す場合、<xref:System.Windows.Forms.Control.SetTopLevel%2A>のメソッド、<xref:System.Windows.Forms.Form>の値を渡すと`false`を呼び出すまで、フォームは表示されません<xref:System.Windows.Forms.Control.SetTopLevel%2A>の値を渡して、もう一度`true`します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> パラメーターが <see langword="true" /> に設定されていて、コントロールが ActiveX コントロールです。</exception>
        <exception cref="T:System.Exception"><see cref="M:System.Windows.Forms.Control.GetTopLevel" /> の戻り値が、<paramref name="value" /> パラメーターと等しい値ではなく、<see cref="P:System.Windows.Forms.Control.Parent" /> プロパティが <see langword="null" /> ではありません。</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">以外の任意の型がある場合は、コントロールがトップレベル コントロールとしてコントロールを設定する<see cref="T:System.Windows.Forms.Form" />します。 場合にだけ、このアクセス許可が要求、<paramref name="value" />パラメーターが<see langword="true" />とコントロールが ActiveX コントロールではありません。 列挙型に関連付けられている: <see langword="AllWindows" /> <see cref="T:System.Security.Permissions.UIPermissionWindow" />します。</permission>
        <altmember cref="M:System.Windows.Forms.Control.GetTopLevel" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected virtual void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void SetVisibleCore(bool value);" />
      <MemberSignature Language="F#" Value="abstract member SetVisibleCore : bool -&gt; unit&#xA;override this.SetVisibleCore : bool -&gt; unit" Usage="control.SetVisibleCore value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">コントロールを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>コントロールを指定した表示状態に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、コントロールの可視性の動作を変更するには、このメソッドをオーバーライドします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドするときに<see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />、派生クラスでは、基本クラスを呼び出す、<see cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />を変更するコントロールの可視性を強制する方法。</para></block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberSignature Language="F#" Value="member this.Show : unit -&gt; unit" Usage="control.Show " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールをユーザーに対して表示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 等しい設定は、コントロールを表示、<xref:System.Windows.Forms.Control.Visible%2A>プロパティを`true`します。 後に、<xref:System.Windows.Forms.Control.Show%2A>メソッドを呼び出すと、<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値を返します`true`まで、<xref:System.Windows.Forms.Control.Hide%2A>メソッドが呼び出されます。  
  
   
  
## Examples  
 次のコード例が表示されます、ダイアログ ボックスの詳細について一時的にそのサーフェイスに青い四角形を描画します。 この例から派生したクラスが定義されている必要があります<xref:System.Windows.Forms.Form>という`AboutDialog`します。  
  
 [!code-cpp[Windows.Forms.Control Members2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#1)]
 [!code-csharp[Windows.Forms.Control Members2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#1)]
 [!code-vb[Windows.Forms.Control Members2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
      </Docs>
    </Member>
    <Member MemberName="ShowFocusCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowFocusCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowFocusCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowFocusCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowFocusCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowFocusCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowFocusCues : bool" Usage="System.Windows.Forms.Control.ShowFocusCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールがフォーカスを示す四角形を表示する必要があるかどうかを示す値を取得します。</summary>
        <value>コントロールがフォーカスを示す四角形を表示する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この機能の詳細については、次を参照してください。、 [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx)、 [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)、および[WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)トピック。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.ShowFocusCues" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.ShowFocusCues" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。</para></block>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      </Docs>
    </Member>
    <Member MemberName="ShowKeyboardCues">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShowKeyboardCues { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowKeyboardCues" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property ShowKeyboardCues As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool ShowKeyboardCues { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShowKeyboardCues : bool" Usage="System.Windows.Forms.Control.ShowKeyboardCues" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザー インターフェイスがキーボード アクセラレータを表示または非表示にする適切な状態かどうかを示す値を取得します。</summary>
        <value>キーボード アクセラレータを表示する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Windows フォーム デザイナーで作成されたコントロールでは、キーボード アクセラレータは、既定で表示されます。  
  
 この機能の詳細については、次を参照してください。、 [WM_CHANGEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646342\(v=vs.85\).aspx)、 [WM_QUERYUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646355\(v=vs.85\).aspx)、および[WM_UPDATEUISTATE](https://msdn.microsoft.com/library/windows/desktop/ms646361\(v=vs.85\).aspx)トピック。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.UICues" />
        <altmember cref="P:System.Windows.Forms.Control.ShowFocusCues" />
        <altmember cref="E:System.Windows.Forms.Control.ChangeUICues" />
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public override System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Site" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Site As ISite" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::ISite ^ Site { System::ComponentModel::ISite ^ get(); void set(System::ComponentModel::ISite ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Site : System.ComponentModel.ISite with get, set" Usage="System.Windows.Forms.Control.Site" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.ComponentModel.IComponent.Site</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールのサイトを取得または設定します。</summary>
        <value><see cref="T:System.ComponentModel.ISite" /> に関連付けられている <see cref="T:System.Windows.Forms.Control" /> (存在する場合)。</value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.ComponentModel.ISite" />
        <altmember cref="P:System.ComponentModel.IComponent.Site" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberSignature Language="F#" Value="member this.Size : System.Drawing.Size with get, set" Usage="System.Windows.Forms.Control.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの高さと幅を取得または設定します。</summary>
        <value>コントロールの高さと幅をピクセル単位で表す <see cref="T:System.Drawing.Size" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Size>クラスは、値型 (`Structure` Visual Basic で`struct`Visual C# で)、つまりコントロールのサイズのコピーを返すプロパティにアクセスする、値によって返されます。 そのため、調整、<xref:System.Drawing.Size.Width%2A>または<xref:System.Drawing.Size.Height%2A>のプロパティ、<xref:System.Drawing.Size>これから返されるプロパティには影響は、<xref:System.Windows.Forms.Control.Width%2A>または<xref:System.Windows.Forms.Control.Height%2A>コントロールの。 調整する、<xref:System.Windows.Forms.Control.Width%2A>または<xref:System.Windows.Forms.Control.Height%2A>、コントロールのコントロールを設定する必要があります<xref:System.Windows.Forms.Control.Width%2A>または<xref:System.Windows.Forms.Control.Height%2A>プロパティ、またはセット、<xref:System.Windows.Forms.Control.Size%2A>プロパティを新しい<xref:System.Drawing.Size>します。  
  
> [!NOTE]
>  優れたパフォーマンスを維持する設定しないで、<xref:System.Drawing.Size>コントロールのコンス トラクター。 推奨される方法は、オーバーライドする、<xref:System.Windows.Forms.Control.DefaultSize%2A>プロパティ。  
  
> [!NOTE]
>  Windows Server 2003 システムでのサイズ、<xref:System.Windows.Forms.Form>最大ピクセル幅と、モニターの高さによって制限されます。  
  
   
  
## Examples  
 次のコード例を追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の一般的なプロパティを設定します。 例は、フォームのサイズと、その相対位置が維持されるように、フォームの右下隅にあるボタンを固定します。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズにボタンのサイズを変更し、<xref:System.Drawing.Image>します。 設定し、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティ。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベント。 この例が必要です、<xref:System.Windows.Forms.ImageList>という`imageList1`します。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SizeChanged;" />
      <MemberSignature Language="F#" Value="member this.SizeChanged : EventHandler " Usage="member this.SizeChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Size" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用することをお勧め、<xref:System.Windows.Forms.Control.Layout>カスタム レイアウトを処理するイベントです。 <xref:System.Windows.Forms.Control.Layout>への応答でイベントが発生します<xref:System.Windows.Forms.Control.Resize>レイアウトを適用する必要がある際の他の状況でものイベント。  
  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Size%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例に示します、<xref:System.Windows.Forms.Control.SizeChanged>イベント。 インスタンスを<xref:System.Windows.Forms.Button>コントロールは水平および垂直にスケールできますを提供しました。 A<xref:System.Windows.Forms.NumericUpDown>インスタンスが水平および垂直方向のスケール値を提供します。 <xref:System.Windows.Forms.Button>という名前のインスタンス**OK**のスケール値の設定に使用される、<xref:System.Windows.Forms.Button>コントロール インスタンス。 たびに、コントロールのサイズが変更に関連付けられているイベント ハンドラー、<xref:System.Windows.Forms.Control.SizeChanged>コントロールのイベントが呼び出されます。 このイベント ハンドラーでは、コントロールのサイズが変更されたことを示すメッセージ ボックスが表示されます。  
  
 [!code-cpp[Control_Scale1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_Scale1/CPP/control_scale1.cpp#2)]
 [!code-csharp[Control_Scale1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_Scale1/CS/control_scale1.cs#2)]
 [!code-vb[Control_Scale1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_Scale1/VB/control_scale1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
      </Docs>
    </Member>
    <Member MemberName="SizeFromClientSize">
      <MemberSignature Language="C#" Value="protected virtual System.Drawing.Size SizeFromClientSize (System.Drawing.Size clientSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Drawing.Size SizeFromClientSize(valuetype System.Drawing.Size clientSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SizeFromClientSize(System.Drawing.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function SizeFromClientSize (clientSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Drawing::Size SizeFromClientSize(System::Drawing::Size clientSize);" />
      <MemberSignature Language="F#" Value="abstract member SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size&#xA;override this.SizeFromClientSize : System.Drawing.Size -&gt; System.Drawing.Size" Usage="control.SizeFromClientSize clientSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientSize" Type="System.Drawing.Size" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="clientSize">コントロールのクライアント領域の高さおよび幅を表す <see cref="T:System.Drawing.Size" /> 値。</param>
        <summary>クライアント領域の高さおよび幅からコントロール全体のサイズを決定します。</summary>
        <returns>コントロール全体の高さおよび幅を表す <see cref="T:System.Drawing.Size" /> 値。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StyleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StyleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.StyleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StyleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StyleChanged;" />
      <MemberSignature Language="F#" Value="member this.StyleChanged : EventHandler " Usage="member this.StyleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロール スタイルが変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.StyleChanged>イベントが発生したときに<xref:System.Windows.Forms.ControlStyles>フラグが追加または変更されています。  
  
 コントロールのスタイルは、プログラムの変更またはユーザーの操作によって変更された場合は、このイベントが発生します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.StyleChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.StyleChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#68](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#68)]
 [!code-vb[System.Windows.Forms.EventExamples#68](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#68)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.SetStyle(System.Windows.Forms.ControlStyles,System.Boolean)" />
        <altmember cref="T:System.Windows.Forms.ControlStyles" />
      </Docs>
    </Member>
    <Member MemberName="SuspendLayout">
      <MemberSignature Language="C#" Value="public void SuspendLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SuspendLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.SuspendLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub SuspendLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SuspendLayout();" />
      <MemberSignature Language="F#" Value="member this.SuspendLayout : unit -&gt; unit" Usage="control.SuspendLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールのレイアウト ロジックを一時的に中断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 コントロールのレイアウト ロジックが中断、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドが呼び出されます。  
  
 <xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを使用して並行して複数の抑制<xref:System.Windows.Forms.Control.Layout>イベント中に、コントロールの複数の属性を調整します。 呼び出します通常など、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを設定し、 <xref:System.Windows.Forms.Control.Size%2A>、 <xref:System.Windows.Forms.Control.Location%2A>、 <xref:System.Windows.Forms.Control.Anchor%2A>、または<xref:System.Windows.Forms.Control.Dock%2A>制御、および次のプロパティ、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッドを有効にする変更を有効にします。  
  
 保留中の呼び出しが必要ない<xref:System.Windows.Forms.Control.SuspendLayout%2A>の<xref:System.Windows.Forms.Control.ResumeLayout%2A>正常に呼び出されます。  
  
> [!NOTE]
>  いくつかのコントロールを親コントロールを追加する場合は、呼び出すことをお勧めしますが、<xref:System.Windows.Forms.Control.SuspendLayout%2A>メソッドを追加するコントロールを初期化する前にします。 親コントロールにコントロールを追加した後、<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド。 これにより、多くのコントロールを持つアプリケーションのパフォーマンスが向上します。  
  
   
  
## Examples  
 次のコード例では、フォームに 2 つのボタンを追加します。 トランザクションの例を使用して、ボタンの追加、<xref:System.Windows.Forms.Control.SuspendLayout%2A>と<xref:System.Windows.Forms.Control.ResumeLayout%2A>メソッド。  
  
 [!code-cpp[Windows.Forms.Control Members2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#2)]
 [!code-csharp[Windows.Forms.Control Members2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#2)]
 [!code-vb[Windows.Forms.Control Members2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.ResumeLayout" />
        <altmember cref="P:System.Windows.Forms.Control.LayoutEngine" />
        <altmember cref="E:System.Windows.Forms.Control.Layout" />
        <altmember cref="M:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="M:System.Windows.Forms.Control.SuspendLayout" />
        <altmember cref="M:System.Windows.Forms.Control.InitLayout" />
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragDrop">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragDrop (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragDrop(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragDrop(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragDrop (drgEvent As DragEventArgs) Implements IDropTarget.OnDragDrop" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragDrop(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragDrop;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragDrop(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragDrop" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragEnter">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragEnter (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragEnter(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragEnter(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragEnter (drgEvent As DragEventArgs) Implements IDropTarget.OnDragEnter" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragEnter(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragEnter;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragEnter(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragEnter" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragLeave">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragLeave(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragLeave (e As EventArgs) Implements IDropTarget.OnDragLeave" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragLeave(EventArgs ^ e) = System::Windows::Forms::IDropTarget::OnDragLeave;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragLeave(System.EventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.EventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragLeave" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Forms.IDropTarget.OnDragOver">
      <MemberSignature Language="C#" Value="void IDropTarget.OnDragOver (System.Windows.Forms.DragEventArgs drgEvent);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Forms.IDropTarget.OnDragOver(class System.Windows.Forms.DragEventArgs drgEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.System#Windows#Forms#IDropTarget#OnDragOver(System.Windows.Forms.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Sub OnDragOver (drgEvent As DragEventArgs) Implements IDropTarget.OnDragOver" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Forms.IDropTarget.OnDragOver(System::Windows::Forms::DragEventArgs ^ drgEvent) = System::Windows::Forms::IDropTarget::OnDragOver;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Forms.IDropTarget.OnDragOver(System.Windows.Forms.DragEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drgEvent" Type="System.Windows.Forms.DragEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="drgEvent">イベント データを格納している <see cref="T:System.Windows.Forms.DragEventArgs" />。</param>
        <summary><see cref="E:System.Windows.Forms.Control.DragOver" /> イベントを発生させます。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SystemColorsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SystemColorsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SystemColorsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.SystemColorsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SystemColorsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SystemColorsChanged;" />
      <MemberSignature Language="F#" Value="member this.SystemColorsChanged : EventHandler " Usage="member this.SystemColorsChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>システム カラーが変更されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Drawing.SystemColors>プログラムの変更、またはユーザーの操作によってです。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.SystemColorsChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.SystemColorsChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#69](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#69)]
 [!code-vb[System.Windows.Forms.EventExamples#69](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#69)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnSystemColorsChanged(System.EventArgs)" />
        <altmember cref="T:System.Drawing.SystemColors" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int with get, set" Usage="System.Windows.Forms.Control.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コンテナー内のコントロールのタブ オーダーを取得または設定します。</summary>
        <value>コンテナー内のコントロールのセット内にあるコントロールのインデックス値。 コンテナー内のコントロールは、タブ オーダーに含まれます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タブ インデックスは、小さい番号のタブ オーダー内で以前にされている、0 個以上の有効な整数で構成できます。 同じ親コントロールでは、複数のコントロールに同じタブ インデックスがある場合は、コントロールの z オーダーはコントロールを循環する順序を決定します。  
  
 タブ オーダーに含まれるコントロールの<xref:System.Windows.Forms.Control.TabStop%2A>にプロパティを設定する必要があります`true`します。  
  
   
  
## Examples  
 次のコード例を追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の一般的なプロパティを設定します。 例は、フォームのサイズと、その相対位置が維持されるように、フォームの右下隅にあるボタンを固定します。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズにボタンのサイズを変更し、<xref:System.Drawing.Image>します。 設定し、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティ。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベント。 この例が必要です、<xref:System.Windows.Forms.ImageList>という`imageList1`します。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.UpdateZOrder" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberSignature Language="F#" Value="member this.TabIndexChanged : EventHandler " Usage="member this.TabIndexChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.TabIndex" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.TabIndex%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.TabIndexChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.TabIndexChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#25](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#25)]
 [!code-vb[System.Windows.Forms.EventExamples#25](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#25)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabIndexChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.TabStop : bool with get, set" Usage="System.Windows.Forms.Control.TabStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーが Tab キーを使用することによってこのコントロールにフォーカスを移すことができるかどうかを示す値を取得または設定します。</summary>
        <value>ユーザーが Tab キーを使用してコントロールにフォーカスを移すことができる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。  
  
 <block subset="none" type="note"><para>  
 <see langword="true" /> クラスのインスタンスの場合、このプロパティは必ず <see cref="T:System.Windows.Forms.Form" /> を返します。  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ユーザーは、TAB キーを押すと、入力フォーカスがタブ オーダー内で次のコントロールに設定されます。 コントロール、<xref:System.Windows.Forms.Control.TabStop%2A>プロパティ値の`false`タブ オーダーでコントロールのコレクションには含まれません。 コントロールの設定がタブ オーダーを操作できる<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティの値。  
  
   
  
## Examples  
 次のコード例を追加、<xref:System.Windows.Forms.Button>をフォームにし、一部の一般的なプロパティを設定します。 例は、フォームのサイズと、その相対位置が維持されるように、フォームの右下隅にあるボタンを固定します。 次に、設定、<xref:System.Windows.Forms.Control.BackgroundImage%2A>と同じサイズにボタンのサイズを変更し、<xref:System.Drawing.Image>します。 設定し、<xref:System.Windows.Forms.Control.TabStop%2A>に`true`設定と、<xref:System.Windows.Forms.Control.TabIndex%2A>プロパティ。 最後に、処理するイベント ハンドラーを追加、<xref:System.Windows.Forms.Control.Click>ボタンのイベント。 この例が必要です、<xref:System.Windows.Forms.ImageList>という`imageList1`します。  
  
 [!code-cpp[Windows.Forms.Control Properties#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#3)]
 [!code-csharp[Windows.Forms.Control Properties#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#3)]
 [!code-vb[Windows.Forms.Control Properties#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.TabIndex" />
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberSignature Language="F#" Value="member this.TabStopChanged : EventHandler " Usage="member this.TabStopChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.TabStop" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.TabStop%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例では、このメンバーの使用を示します。 例では、イベント ハンドラーが発生するときに報告、<xref:System.Windows.Forms.Control.TabStopChanged>イベント。 このレポートでは、イベントが発生してデバッグに役立つについて説明します。 複数のイベントまたは頻繁に発生するイベントを報告する、交換を検討<xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType>で<xref:System.Console.WriteLine%2A?displayProperty=nameWithType>またはメッセージを複数行に追加<xref:System.Windows.Forms.TextBox>します。  
  
 コード例を実行するから継承する型のインスタンスを含むプロジェクトに貼り付けること<xref:System.Windows.Forms.Control>などを<xref:System.Windows.Forms.Button>または<xref:System.Windows.Forms.ComboBox>します。 インスタンスの名前を`Control1`イベント ハンドラーに関連付けられていることを確認してください、<xref:System.Windows.Forms.Control.TabStopChanged>イベント。  
  
 [!code-csharp[System.Windows.Forms.EventExamples#26](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#26)]
 [!code-vb[System.Windows.Forms.EventExamples#26](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTabStopChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.TabStop" />
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Tag : obj with get, set" Usage="System.Windows.Forms.Control.Tag" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.StringConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールに関するデータを格納するオブジェクトを取得または設定します。</summary>
        <value>コントロールに関するデータを格納している <see cref="T:System.Object" />。 既定値は、<see langword="null" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生する型、<xref:System.Object>クラスは、このプロパティに割り当てることができます。 場合、<xref:System.Windows.Forms.Control.Tag%2A>プロパティが、Windows フォーム デザイナーで、テキストのみを割り当てることができます。  
  
 一般的な用途、<xref:System.Windows.Forms.Control.Tag%2A>プロパティは、コントロールに密接に関連付けられているデータを格納します。 たとえば、顧客に関する情報を表示するコントロールがあれば、保存する、<xref:System.Data.DataSet>そのコントロールの顧客の注文履歴を格納している<xref:System.Windows.Forms.Control.Tag%2A>プロパティ データを簡単にアクセスできるようにします。  
  
   
  
## Examples  
 次のコード例は、フォームを表示し、格納、`Customer`でその<xref:System.Windows.Forms.Control.Tag%2A>プロパティ。 この例から派生したクラスが定義されている必要があります<xref:System.Windows.Forms.Form>という`CustomerForm`と定義されている、`Customer`します。  
  
 [!code-cpp[Windows.Forms.Control Members2#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CPP/controlmembers2.cpp#3)]
 [!code-csharp[Windows.Forms.Control Members2#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Members2/CS/controlmembers2.cs#3)]
 [!code-vb[Windows.Forms.Control Members2#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Members2/VB/controlmembers2.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public virtual string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.Control.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-517)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このコントロールに関連付けられているテキストを取得または設定します。</summary>
        <value>このコントロールに関連付けられたテキスト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Text%2A>各派生クラスによって異なる方法でコントロールのプロパティを使用します。 たとえば、<xref:System.Windows.Forms.Control.Text%2A>のプロパティを<xref:System.Windows.Forms.Form>フォームの上部にあるタイトル バーに表示される、非常に小さく、文字数では、および通常は、アプリケーションまたはドキュメント名が表示されます。 ただし、<xref:System.Windows.Forms.Control.Text%2A>のプロパティを<xref:System.Windows.Forms.RichTextBox>が大きくなるし、テキストの書式設定するために使用、さまざまなビジュアル文字を含めることができます。 表示されるテキストなど、<xref:System.Windows.Forms.RichTextBox>を調整してフォーマットすることができます、<xref:System.Drawing.Font>プロパティ、またはスペースまたはタブ文字、テキストを配置するを追加。  
  
   
  
## Examples  
 次のコード例を作成、<xref:System.Windows.Forms.GroupBox>および一部の一般的なプロパティを設定します。 例は、作成、<xref:System.Windows.Forms.TextBox>設定とその<xref:System.Windows.Forms.Control.Location%2A>グループ ボックス内で。 次に、設定、<xref:System.Windows.Forms.Control.Text%2A>フォームの上部に、グループ ボックス ドッキングし、グループ ボックスのプロパティ。 グループ ボックスを無効に設定して、最後に、<xref:System.Windows.Forms.Control.Enabled%2A>プロパティを`false`、それが原因で無効にするグループ ボックス内に含まれるすべてのコントロール。  
  
 [!code-cpp[Windows.Forms.Control Properties#2](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CPP/controlproperties.cpp#2)]
 [!code-csharp[Windows.Forms.Control Properties#2](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control Properties/CS/controlproperties.cs#2)]
 [!code-vb[Windows.Forms.Control Properties#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control Properties/VB/controlproperties.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>オーバーライドする場合、 <see cref="P:System.Windows.Forms.Control.Text" /> 、派生クラスでプロパティを使用して、基本クラスの<see cref="P:System.Windows.Forms.Control.Text" />基本実装を拡張するプロパティ。 それ以外の場合、すべての実装を提供する必要があります。 両方をオーバーライドする必要はありません、<see langword="get" />と<see langword="set" />のアクセサー、<see cref="P:System.Windows.Forms.Control.Text" />プロパティです。 必要な場合は 1 つだけをオーバーライドできます。</para></block>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.TextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TextChanged;" />
      <MemberSignature Language="F#" Value="member this.TextChanged : EventHandler " Usage="member this.TextChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Text" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Text%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例の変更、<xref:System.Windows.Forms.Control.ForeColor%2A>の<xref:System.Windows.Forms.TextBox>通貨データを表示します。 例では、文字列に変換する 10 進数と変更、<xref:System.Windows.Forms.Control.ForeColor%2A>に<xref:System.Drawing.Color.Red%2A?displayProperty=nameWithType>数が負の値とする<xref:System.Drawing.Color.Black%2A?displayProperty=nameWithType>数が正の場合。 この例が必要です、<xref:System.Windows.Forms.Form>を格納している、<xref:System.Windows.Forms.TextBox>します。  
  
 [!code-cpp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CPP/propertychangedevents.cpp#1)]
 [!code-csharp[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/CS/propertychangedevents.cs#1)]
 [!code-vb[Windows.Forms.Control_PropertyChangedEvents#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control_PropertyChangedEvents/VB/propertychangedevents.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public int Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Top { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Top : int with get, set" Usage="System.Windows.Forms.Control.Top" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの上端とコンテナーのクライアント領域の上端の間の距離をピクセル単位で取得または設定します。</summary>
        <value><see cref="T:System.Int32" /> は、コントロールの下端とコンテナーのクライアント領域の上端の間の距離 (ピクセル単位) を示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.Top%2A>プロパティの値が等しく、<xref:System.Drawing.Point.Y%2A?displayProperty=nameWithType>のプロパティ、<xref:System.Windows.Forms.Control.Location%2A>コントロールのプロパティの値。  
  
 加えられた変更、<xref:System.Windows.Forms.Control.Height%2A>と<xref:System.Windows.Forms.Control.Top%2A>プロパティ値が原因、<xref:System.Windows.Forms.Control.Bottom%2A>を変更するコントロールのプロパティの値。  
  
   
  
## Examples  
 次のコード例では、3 つを作成<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用して、そのサイズと位置を設定します。 この例が必要です、<xref:System.Windows.Forms.Form>少なくとも 300 ピクセルの高さ、幅を持ちます。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Drawing.Point.Y" />
        <altmember cref="P:System.Windows.Forms.Control.Bottom" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="TopLevelControl">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Control TopLevelControl { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Control TopLevelControl" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.TopLevelControl" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TopLevelControl As Control" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Control ^ TopLevelControl { System::Windows::Forms::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TopLevelControl : System.Windows.Forms.Control" Usage="System.Windows.Forms.Control.TopLevelControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>別の Windows フォーム コントロールを親として持たない親コントロールを取得します。 一般的に、これは、コントロールを格納している最も外側の <see cref="T:System.Windows.Forms.Form" /> です。</summary>
        <value>現在のコントロールを格納しているトップレベル コントロールを表す <see cref="T:System.Windows.Forms.Control" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 最上位のコントロールは、別の Windows フォーム コントロールを親として持たない親コントロールとして定義されます。 一般的に、これは、コントロールを格納している最も外側の <xref:System.Windows.Forms.Form> です。 コントロールが MDI 子に含まれている場合など、 <xref:System.Windows.Forms.Form>、最上位のコントロールは、マルチ ドキュメント インターフェイス (MDI) 親<xref:System.Windows.Forms.Form>します。 コントロールに親がない場合、 <xref:System.Windows.Forms.Form>、このプロパティは`null`します。  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">このプロパティの値を取得するすべてのウィンドウ。 関連付けられた列挙体。 <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="T:System.Windows.Forms.Form" />
      </Docs>
    </Member>
    <Member MemberName="Update">
      <MemberSignature Language="C#" Value="public void Update ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Update() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.Update" />
      <MemberSignature Language="VB.NET" Value="Public Sub Update ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Update();" />
      <MemberSignature Language="F#" Value="member this.Update : unit -&gt; unit" Usage="control.Update " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールによって、クライアント領域内の無効化された領域が再描画されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 保留中の描画要求を実行します。  
  
 フォームとその内容を再描画する 2 つの方法はあります。  
  
-   オーバー ロードのいずれかを使用することができます、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドを<xref:System.Windows.Forms.Control.Update%2A>メソッド。  
  
-   呼び出すことができます、<xref:System.Windows.Forms.Control.Refresh%2A>メソッドで、それ自体とそのすべての子の再描画するように強制します。 設定するのと同じ、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドを`true`でを使用して<xref:System.Windows.Forms.Control.Update%2A>します。  
  
 <xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは描画内容を取得または再描画を制御します。 <xref:System.Windows.Forms.Control.Update%2A>メソッドは、描画または再描画が発生したときを制御します。 使用する場合、<xref:System.Windows.Forms.Control.Invalidate%2A>と<xref:System.Windows.Forms.Control.Update%2A>メソッドを呼び出すのではなくまとめて<xref:System.Windows.Forms.Control.Refresh%2A>、のどのオーバー ロードに依存再描画内容を取得<xref:System.Windows.Forms.Control.Invalidate%2A>を使用します。 <xref:System.Windows.Forms.Control.Update%2A>メソッドだけ強制的にすぐに描画するコントロールが、<xref:System.Windows.Forms.Control.Invalidate%2A>メソッドは制御を呼び出すときに描画内容を取得、<xref:System.Windows.Forms.Control.Update%2A>メソッド。  
  
 詳細については、次を参照してください。、 [WM_PAINT](https://msdn.microsoft.com/library/dd145213\(v=vs.85\).aspx)トピック。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
        <altmember cref="P:System.Windows.Forms.Control.ClientSize" />
        <altmember cref="M:System.Windows.Forms.Control.Invalidate(System.Drawing.Region)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateBounds">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>コントロールの範囲を更新します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected internal void UpdateBounds ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void UpdateBounds() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub UpdateBounds ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void UpdateBounds();" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : unit -&gt; unit" Usage="control.UpdateBounds " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールの範囲を現在のサイズと位置で更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、新しい<xref:System.Windows.Forms.Control.Size%2A>のコントロールは、前のさまざまな<xref:System.Drawing.Size>、<xref:System.Windows.Forms.Control.SizeChanged>イベントが発生します。 同様に場合、<xref:System.Windows.Forms.Control.Location%2A>のコントロールの変更、<xref:System.Windows.Forms.Control.LocationChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの <see cref="P:System.Drawing.Point.X" /> 座標。</param>
        <param name="y">コントロールの <see cref="P:System.Drawing.Point.Y" /> 座標。</param>
        <param name="width">コントロールの <see cref="P:System.Drawing.Size.Width" />。</param>
        <param name="height">コントロールの <see cref="P:System.Drawing.Size.Height" />。</param>
        <summary>コントロールの範囲を指定したサイズと位置で更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、新しい<xref:System.Windows.Forms.Control.Size%2A>前と異なる場合、コントロールの<xref:System.Drawing.Size>、<xref:System.Windows.Forms.Control.SizeChanged>イベントが発生します。 同様に、<xref:System.Windows.Forms.Control.Location%2A>コントロールの変更の<xref:System.Windows.Forms.Control.LocationChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="UpdateBounds">
      <MemberSignature Language="C#" Value="protected void UpdateBounds (int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateBounds(int32 x, int32 y, int32 width, int32 height, int32 clientWidth, int32 clientHeight) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateBounds(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateBounds (x As Integer, y As Integer, width As Integer, height As Integer, clientWidth As Integer, clientHeight As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateBounds(int x, int y, int width, int height, int clientWidth, int clientHeight);" />
      <MemberSignature Language="F#" Value="member this.UpdateBounds : int * int * int * int * int * int -&gt; unit" Usage="control.UpdateBounds (x, y, width, height, clientWidth, clientHeight)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="clientWidth" Type="System.Int32" />
        <Parameter Name="clientHeight" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">コントロールの <see cref="P:System.Drawing.Point.X" /> 座標。</param>
        <param name="y">コントロールの <see cref="P:System.Drawing.Point.Y" /> 座標。</param>
        <param name="width">コントロールの <see cref="P:System.Drawing.Size.Width" />。</param>
        <param name="height">コントロールの <see cref="P:System.Drawing.Size.Height" />。</param>
        <param name="clientWidth">コントロールのクライアント <see cref="P:System.Drawing.Size.Width" />。</param>
        <param name="clientHeight">コントロールのクライアント <see cref="P:System.Drawing.Size.Height" />。</param>
        <summary>コントロールの範囲を指定したサイズ、位置、およびクライアント サイズで更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、新しい<xref:System.Windows.Forms.Control.Size%2A>のコントロールは、前のさまざまな<xref:System.Drawing.Size>、<xref:System.Windows.Forms.Control.SizeChanged>イベントが発生します。 同様に場合、<xref:System.Windows.Forms.Control.Location%2A>のコントロールの変更、<xref:System.Windows.Forms.Control.LocationChanged>イベントが発生します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Control.ClientRectangle" />
      </Docs>
    </Member>
    <Member MemberName="UpdateStyles">
      <MemberSignature Language="C#" Value="protected void UpdateStyles ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateStyles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateStyles" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateStyles ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateStyles();" />
      <MemberSignature Language="F#" Value="member this.UpdateStyles : unit -&gt; unit" Usage="control.UpdateStyles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>割り当て済みのスタイルを強制的にコントロールに再適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、<xref:System.Windows.Forms.Control.CreateParams%2A>を適用するスタイルを取得します。 割り当てられているスタイル、<xref:System.Windows.Forms.CreateParams.Style%2A>と<xref:System.Windows.Forms.CreateParams.ExStyle%2A>のプロパティ、<xref:System.Windows.Forms.CreateParams>をコントロールの割り当てられている<xref:System.Windows.Forms.Control.CreateParams%2A>プロパティが再適用されます。 コントロールが必要な場合は、スタイルの変更を反映するように再描画します。  
  
 <xref:System.Windows.Forms.Control.UpdateStyles%2A>メソッドには効果がない場合、<xref:System.Windows.Forms.Control.IsHandleCreated%2A>プロパティの値が`false`します。  
  
   
  
## Examples  
 次のコード例は、のダブル バッファリングを有効、<xref:System.Windows.Forms.Form>し、変更を反映するようにスタイルを更新します。  
  
 [!code-cpp[Windows.Forms.ControlMembers6#3](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CPP/controlmembers6.cpp#3)]
 [!code-csharp[Windows.Forms.ControlMembers6#3](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/CS/controlmembers6.cs#3)]
 [!code-vb[Windows.Forms.ControlMembers6#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.ControlMembers6/VB/controlmembers6.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="UpdateZOrder">
      <MemberSignature Language="C#" Value="protected void UpdateZOrder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void UpdateZOrder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.UpdateZOrder" />
      <MemberSignature Language="VB.NET" Value="Protected Sub UpdateZOrder ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void UpdateZOrder();" />
      <MemberSignature Language="F#" Value="member this.UpdateZOrder : unit -&gt; unit" Usage="control.UpdateZOrder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>コントロールを親の z オーダーで更新します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.UpdateZOrder%2A>メソッドはその親コントロールの z オーダーでコントロールの位置を更新します。 このコントロールは、新しく作成されたコントロール場合、に追加されたなど、 <xref:System.Windows.Forms.Control.ControlCollection>、z オーダーは、新しいコントロールの後ろに追加で更新されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Control.ControlCollection" />
      </Docs>
    </Member>
    <Member MemberName="UseWaitCursor">
      <MemberSignature Language="C#" Value="public bool UseWaitCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseWaitCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.UseWaitCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property UseWaitCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseWaitCursor { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseWaitCursor : bool with get, set" Usage="System.Windows.Forms.Control.UseWaitCursor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のコントロールおよびすべての子コントロールに待機カーソルを使用するかどうかを示す値を取得または設定します。</summary>
        <value>現在の子コントロールおよびすべての子コントロールに待機カーソルを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 かなりの時間を取得する操作を実行するたびに待機カーソルを使用します。 ただし、UI スレッドをブロックする操作は、カーソルの変更にもブロックされます。 そのため、このプロパティは、別のスレッドで時間のかかる操作を実行する場合にのみ使用する必要があります。 グローバルとすぐには、カーソルを変更するを参照してください。、<xref:System.Windows.Forms.Cursor.Current%2A>プロパティ。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validated">
      <MemberSignature Language="C#" Value="public event EventHandler Validated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Validated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Validated;" />
      <MemberSignature Language="F#" Value="member this.Validated : EventHandler " Usage="member this.Validated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの検証が終了すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 フォーカスを変更すると、マウスを使用して、または呼び出すことによって、<xref:System.Windows.Forms.Control.Focus%2A>メソッドでは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 場合、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>に設定されている`true`で、<xref:System.Windows.Forms.Control.Validating>イベント デリゲート、後に通常発生するすべてのイベント、<xref:System.Windows.Forms.Control.Validating>イベントが抑制されます。  
  
> [!CAUTION]
>  内からフォーカスを設定しないで、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションまたはオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 [WM_KILLFOCUS](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)トピック、およびの"メッセージ デッドロック"セクション、[についてメッセージとメッセージ キュー](https://msdn.microsoft.com/library/windows/desktop/ms644927\(v=vs.85\).aspx)トピック。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.TextBox>しユーザーが入力した電子メール アドレスを検証します。 標準形式の電子メール アドレスがない場合 (を含む"@" and ".")、検証に失敗、<xref:System.Windows.Forms.ErrorProvider>アイコンが表示され、イベントが取り消されました。 この例では、する必要があります、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.ErrorProvider>フォームで作成されたコントロール。  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidated(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validating" />
      </Docs>
    </Member>
    <Member MemberName="Validating">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Validating;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Validating" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.Validating" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Validating As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Validating;" />
      <MemberSignature Language="F#" Value="member this.Validating : System.ComponentModel.CancelEventHandler " Usage="member this.Validating : System.ComponentModel.CancelEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールが検証しているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによってキーボード (タブ、shift キーを押しながら TAB となど) を使用して、フォーカスを変更すると、<xref:System.Windows.Forms.Control.Select%2A>または<xref:System.Windows.Forms.Control.SelectNextControl%2A>メソッド、または設定して、<xref:System.Windows.Forms.ContainerControl.ActiveControl%2A?displayProperty=nameWithType>プロパティを現在のフォームは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.Leave>  
  
4.  <xref:System.Windows.Forms.Control.Validating>  
  
5.  <xref:System.Windows.Forms.Control.Validated>  
  
6.  <xref:System.Windows.Forms.Control.LostFocus>  
  
 フォーカスを変更すると、マウスを使用して、または呼び出すことによって、<xref:System.Windows.Forms.Control.Focus%2A>メソッドでは、次の順序でフォーカス イベントが発生します。  
  
1.  <xref:System.Windows.Forms.Control.Enter>  
  
2.  <xref:System.Windows.Forms.Control.GotFocus>  
  
3.  <xref:System.Windows.Forms.Control.LostFocus>  
  
4.  <xref:System.Windows.Forms.Control.Leave>  
  
5.  <xref:System.Windows.Forms.Control.Validating>  
  
6.  <xref:System.Windows.Forms.Control.Validated>  
  
 場合、<xref:System.Windows.Forms.Control.CausesValidation%2A>プロパティに設定されて`false`、<xref:System.Windows.Forms.Control.Validating>と<xref:System.Windows.Forms.Control.Validated>イベントが抑制されます。  
  
 場合、<xref:System.ComponentModel.CancelEventArgs.Cancel%2A>のプロパティ、<xref:System.ComponentModel.CancelEventArgs>に設定されている`true`で、<xref:System.Windows.Forms.Control.Validating>イベント デリゲート、後に通常発生するすべてのイベント、<xref:System.Windows.Forms.Control.Validating>イベントが抑制されます。  
  
> [!CAUTION]
>  内からフォーカスを設定しないで、 <xref:System.Windows.Forms.Control.Enter>、 <xref:System.Windows.Forms.Control.GotFocus>、 <xref:System.Windows.Forms.Control.Leave>、 <xref:System.Windows.Forms.Control.LostFocus>、 <xref:System.Windows.Forms.Control.Validating>、または<xref:System.Windows.Forms.Control.Validated>イベント ハンドラー。 これには、アプリケーションまたはオペレーティング システムが応答を停止する可能性があります。 詳細については、次を参照してください。、 `WM_KILLFOCUS` "キーボード入力リファレンス"セクションと、MSDN ライブラリで"のメッセージ キューとメッセージ キュー"トピックの"メッセージ デッドロック"セクションのトピックhttp://msdn.microsoft.com/libraryします。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.TextBox>しユーザーが入力した電子メール アドレスを検証します。 標準形式の電子メール アドレスがない場合 (を含む"@" and ".")、検証に失敗、<xref:System.Windows.Forms.ErrorProvider>アイコンが表示され、イベントが取り消されました。 この例では、する必要があります、<xref:System.Windows.Forms.TextBox>と<xref:System.Windows.Forms.ErrorProvider>フォームで作成されたコントロール。  
  
 [!code-cpp[Control.Validating#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control.Validating/CPP/validating.cpp#1)]
 [!code-csharp[Control.Validating#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control.Validating/CS/validating.cs#1)]
 [!code-vb[Control.Validating#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control.Validating/VB/validating.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnValidating(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.CausesValidation" />
        <altmember cref="E:System.Windows.Forms.Control.Validated" />
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Visible : bool with get, set" Usage="System.Windows.Forms.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールとそのすべての子コントロールが表示されているかどうかを示す値を取得または設定します。</summary>
        <value>コントロールとそのすべての子コントロールが表示されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 その場合であっても注意してください`Visible`に設定されている`true`コントロールは他のコントロールの背後に隠されている場合、ユーザーに表示されません。  
  
   
  
## Examples  
 次のコード例は、派生クラスを使用して<xref:System.Windows.Forms.VScrollBar>と<xref:System.Windows.Forms.HScrollBar>設定とその<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値のサイズに基づいて、<xref:System.Drawing.Image>に表示されている、<xref:System.Windows.Forms.PictureBox>コントロール。 この例では、する必要があります、<xref:System.Windows.Forms.PictureBox>がフォーム上に作成された<xref:System.Windows.Forms.HScrollBar>と<xref:System.Windows.Forms.VScrollBar>で作成されたコントロール、<xref:System.Windows.Forms.PictureBox>します。 このコードを呼び出す、イメージが読み込まれるときに画像ボックスとで、<xref:System.Windows.Forms.Control.Resize>フォームのイベント。  
  
 [!code-cpp[Classic Control.Visible Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Control.Visible Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Control.Visible Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Control.Visible Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Visible Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Control.Visible Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Enabled" />
        <altmember cref="P:System.Windows.Forms.Control.CanFocus" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="VisibleChanged">
      <MemberSignature Language="C#" Value="public event EventHandler VisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Control.VisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VisibleChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.VisibleChanged : EventHandler " Usage="member this.VisibleChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.Forms.Control.Visible" /> プロパティの値が変化すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このイベントが発生した、<xref:System.Windows.Forms.Control.Visible%2A>プログラムの変更またはユーザーの操作のいずれかによってプロパティを変更します。  
  
 イベントの処理の詳細については、「[処理とイベントの発生](~/docs/standard/events/index.md)」を参照してください。  
  
   
  
## Examples  
 次のコード例が発生、<xref:System.Windows.Forms.Control.VisibleChanged>イベント時に、<xref:System.Windows.Forms.Control.Visible%2A>プロパティの値、<xref:System.Windows.Forms.Label>コントロールが変更されました。  
  
 [!code-cpp[Control_VisibleChanged#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Control_VisibleChanged/CPP/control_visiblechanged.cpp#1)]
 [!code-csharp[Control_VisibleChanged#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Control_VisibleChanged/CS/control_visiblechanged.cs#1)]
 [!code-vb[Control_VisibleChanged#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Control_VisibleChanged/VB/control_visiblechanged.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnVisibleChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public int Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Width { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.Width : int with get, set" Usage="System.Windows.Forms.Control.Width" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>コントロールの幅を取得または設定します。</summary>
        <value>コントロールの幅 (ピクセル単位)。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 加えられた変更、<xref:System.Windows.Forms.Control.Width%2A>と<xref:System.Windows.Forms.Control.Left%2A>プロパティ値が原因、<xref:System.Windows.Forms.Control.Right%2A>を変更するコントロールのプロパティの値。  
  
   
  
## Examples  
 次のコード例では、3 つを作成<xref:System.Windows.Forms.Button>フォームのコントロールし、さまざまなサイズに関連して、場所に関連するプロパティを使用して、そのサイズと位置を設定します。 この例が必要です、<xref:System.Windows.Forms.Form>少なくとも 300 ピクセルの高さ、幅を持ちます。  
  
 [!code-cpp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CPP/controlsizelocation.cpp#1)]
 [!code-csharp[Windows.Forms.Control SizeLocation#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/CS/controlsizelocation.cs#1)]
 [!code-vb[Windows.Forms.Control SizeLocation#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Windows.Forms.Control SizeLocation/VB/controlsizelocation.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Drawing.Size.Width" />
        <altmember cref="M:System.Windows.Forms.Control.SetBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="WindowTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IWindowTarget WindowTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IWindowTarget WindowTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Control.WindowTarget" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowTarget As IWindowTarget" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IWindowTarget ^ WindowTarget { System::Windows::Forms::IWindowTarget ^ get(); void set(System::Windows::Forms::IWindowTarget ^ value); };" />
      <MemberSignature Language="F#" Value="member this.WindowTarget : System.Windows.Forms.IWindowTarget with get, set" Usage="System.Windows.Forms.Control.WindowTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IWindowTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このクラスでは、このプロパティは使用されません。</summary>
        <value>コントロールに含まれる NativeWindow。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでは、このプロパティは使用されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected virtual void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="abstract member WndProc :  -&gt; unit&#xA;override this.WndProc :  -&gt; unit" Usage="control.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">処理対象の Windows <see cref="T:System.Windows.Forms.Message" />。</param>
        <summary>Windows メッセージを処理します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 すべてのメッセージ、<xref:System.Windows.Forms.Control.WndProc%2A>メソッドでフィルター処理の取得後、<xref:System.Windows.Forms.Control.PreProcessMessage%2A>メソッド。  
  
 
  <xref:System.Windows.Forms.Control.WndProc%2A> メソッドは、Windows `WindowProc` 関数に正確に対応しています。 Windows メッセージの処理に関する詳細については、次を参照してください。、 [WindowProc 関数](https://go.microsoft.com/fwlink/?LinkId=181565)します。  
  
   
  
## Examples  
 オーバーライドする次のコード例に示します、<xref:System.Windows.Forms.Control.WndProc%2A>で識別されるオペレーティング システムのメッセージを処理するメソッド、<xref:System.Windows.Forms.Message>構造体。 [WM_ACTIVATEAPP](https://msdn.microsoft.com/library/windows/desktop/ms632614\(v=vs.85\).aspx)別のアプリケーションがアクティブになることとを把握するには、この例ではオペレーティング システムのメッセージを処理します。 使用可能なを理解するのには、次のトピックを参照してください。 <xref:System.Windows.Forms.Message.Msg%2A?displayProperty=nameWithType>、 <xref:System.Windows.Forms.Message.LParam%2A?displayProperty=nameWithType>、および<xref:System.Windows.Forms.Message.WParam%2A?displayProperty=nameWithType>値。 実際の定数値は、Windows.h のヘッダー ファイルで確認できます。  
  
 [!code-cpp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.Control.WndProc#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.Control.WndProc/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを呼び出す直前の呼び出し元。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
        <block subset="none" type="overrides"><para>継承コントロールで、基本クラスを呼び出す必要があります<see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />処理しないすべてのメッセージを処理するメソッド。</para></block>
        <altmember cref="M:System.Windows.Forms.Control.PreProcessMessage(System.Windows.Forms.Message@)" />
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>