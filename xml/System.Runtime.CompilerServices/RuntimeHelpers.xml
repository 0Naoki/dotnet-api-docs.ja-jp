<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RuntimeHelpers.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5c39d8180904c9260ec3b7f679f09d3791b94ac31.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c39d8180904c9260ec3b7f679f09d3791b94ac31</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Provides a set of static methods and properties that provide support for compilers.</source>
          <target state="translated">さまざまなコンパイラのためのサポートを提供する静的メソッドと静的プロパティのセットを提供します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>This class cannot be inherited.</source>
          <target state="translated">このクラスは継承できません。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">次の例を使用してハンドルを確実に設定する方法を示しています、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">指定した既存のハンドルをハンドルを確実に設定するをことを確認、ネイティブのハンドルの割り当てとそのハンドル内の後続の記録、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>オブジェクトがアトミックです。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">これらの操作 (スレッドの中止またはメモリ不足の例外) などの間で、エラーをすべて漏洩のネイティブ ハンドルが発生します。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph>メソッドが、ハンドルのリークがないかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</source>
          <target state="translated">残りのスタック領域が通常の .NET Framework 関数を実行できる大きさであることを確認します。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> 実行される復旧アクションと、例外を発生させるための十分な領域を保持する人工的な制限付きのスタックに関する情報を提供します。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</source>
          <target state="translated">共通言語ランタイムは人為的なスタックの制限を選択して、安全な例外をスローするために十分な領域が残ってことを確認してください。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</source>
          <target state="translated">このメソッドは、スタック オーバーフローが無限再帰の結果として発生する状況の状況で役に立ちます。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</source>
          <target state="translated">目的が、コンパイラ サービス シナリオで使用することも使用できますが安全に他の開発シナ リオでします。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</source>
          <target state="translated">スタック領域が十分では、例外はスローされませんし、ほとんどの .NET Framework の型およびメンバーも呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">このメソッドは、制約された実行領域 (CER) サポートの一部ではないと混同しないで、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack">
          <source>The available stack space is insufficient to execute the average .NET Framework function.</source>
          <target state="translated">使用できるスタック領域が通常の .NET Framework 関数を実行できる大きさではありません。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The first object to compare.</source>
          <target state="translated">比較する最初のオブジェクト。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The second object to compare.</source>
          <target state="translated">比較する 2 番目のオブジェクト。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> instances are considered equal.</source>
          <target state="translated">指定された <ph id="ph1">&lt;see cref="T:System.Object" /&gt;</ph> インスタンスが等しいかどうかを判断します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;paramref name="o1" /&gt;</ph> parameter is the same instance as the <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> parameter, or if both are <ph id="ph4">&lt;see langword="null" /&gt;</ph>, or if <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>; otherwise, <ph id="ph6">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="o1" /&gt;</ph> パラメーターが <ph id="ph3">&lt;paramref name="o2" /&gt;</ph> パラメーターと同じインスタンスである場合、両方のインスタンスが <ph id="ph4">&lt;see langword="null" /&gt;</ph> である場合、または <bpt id="p1">&lt;c&gt;</bpt>o1.Equals(o2)<ept id="p1">&lt;/c&gt;</ept> が <ph id="ph5">&lt;see langword="true" /&gt;</ph> 場合を返す場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph6">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)">
          <source>The following example demonstrates how to compare two objects by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph> method.</source>
          <target state="translated">次の例を使用して 2 つのオブジェクトを比較する方法を示します、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to try.</source>
          <target state="translated">試行するコードに対するデリゲート。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>A delegate to the code to run if an exception occurs.</source>
          <target state="translated">例外が発生した場合に実行するコードに対するデリゲート。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>The data to pass to <bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> and <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>code<ept id="p1">&lt;/c&gt;</ept> と <bpt id="p2">&lt;c&gt;</bpt>backoutCode<ept id="p2">&lt;/c&gt;</ept> に渡すデータ。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>Executes code using a <ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> while using another <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> to execute additional code in case of an exception.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Delegate" /&gt;</ph> を使用してコードを実行します。例外の場合は、別の <ph id="ph2">&lt;see cref="T:System.Delegate" /&gt;</ph> を使用して追加のコードを実行します。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>An object to retrieve the hash code for.</source>
          <target state="translated">ハッシュ コードを取得するオブジェクト。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</source>
          <target state="translated">特定のオブジェクトのハッシュ関数として機能し、ハッシュ アルゴリズムやハッシュ テーブルのようなハッシュ コードを使うデータ構造での使用に適しています。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A hash code for the object identified by the <ph id="ph1">&lt;paramref name="o" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> パラメーターで識別されるオブジェクトのハッシュ コード。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method always calls the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドは常に呼び出し、<ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッド非仮想的オブジェクトの型がオーバーライドされた場合でも、<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, using <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> might differ from calling <ph id="ph2">`GetHashCode`</ph> directly on the object with the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">したがってを使用して<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>通話と異なる場合があります<ph id="ph2">`GetHashCode`</ph>を持つオブジェクトで直接、<ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドは、同一のオブジェクト参照の同一のハッシュ コードを返します、する必要がありますいないこのメソッドを使用するオブジェクトの id をテストするため、このハッシュ コードがオブジェクト参照を一意に識別できません。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">テスト オブジェクトを識別するには (つまり、その 2 つのテスト オブジェクトにメモリ内の同じオブジェクトを参照)、呼び出す、<ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Nor should you use <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.</source>
          <target state="translated">使用する必要がありますも<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph>文字列がインターン プールに存在するために、2 つの文字列と等しいオブジェクト参照を表すかどうかをテストします。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>To test for string interning, call the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">文字列インターンの使用をテストするには、呼び出し、<ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods differ as follows:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドが次のように異なります。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that is based on the object's definition of equality.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 等しいかどうかのオブジェクトの定義に基づくハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>For example, two strings with identical contents will return the same value for <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">たとえば、同じ内容の 2 つの文字列は、同じ値を返しますの<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> returns a hash code that indicates object identity.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> オブジェクト id を示すハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id="p1">[</bpt>String Interning<ept id="p1">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.</source>
          <target state="translated">つまり、2 つの文字列変数の内容は同じと隔離されている場合、文字列を表す (を参照してください、<bpt id="p1">[</bpt>文字列インターン<ept id="p1">](#interning)</ept>セクション) またはメモリ内の 1 つの文字列を返すと同じを表すハッシュ コード。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Note that <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.</source>
          <target state="translated">なお<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph>常に同じオブジェクト参照のと同じハッシュ コードを返します。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the reverse is not true: equal hash codes do not indicate equal object references.</source>
          <target state="translated">ただし、この逆はできません: と等しいオブジェクト参照と同じハッシュ コードが示されていません。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</source>
          <target state="translated">特定のハッシュ コード値が特定のオブジェクト参照であるに一意ではありません。別のオブジェクト参照は、同一のハッシュ コードを生成できます。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>String Interning</source>
          <target state="translated">文字列インターンの使用</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</source>
          <target state="translated">共通言語ランタイム (CLR) は、文字列の内部プールを保持し、リテラルをプールに格納します。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If two strings (for example, <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> to point to the same location on the managed heap to conserve memory.</source>
          <target state="translated">場合は 2 つの文字列 (たとえば、<ph id="ph1">`str1`</ph>と<ph id="ph2">`str2`</ph>) と同じ文字列リテラルでは、CLR の設定から形成される<ph id="ph3">`str1`</ph>と<ph id="ph4">`str2`</ph>メモリを節約するために、マネージ ヒープ上の同じ場所を指すです。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</source>
          <target state="translated">呼び出す<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>これら 2 つの文字列でオブジェクトが、前のセクションで、2 番目の行頭文字付きアイテムとは対照的によって同じハッシュ コードを生成します。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The CLR adds only literals to the pool.</source>
          <target state="translated">CLR は、リテラルのみをプールに追加します。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</source>
          <target state="translated">コンパイラによって、単一の文字列リテラルと文字列の連結が解決しない限り、連結などの文字列操作の結果は、プールに追加されません。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Therefore, if <ph id="ph1">`str2`</ph> was created as the result of a concatenation operation, and <ph id="ph2">`str2`</ph> is identical to <ph id="ph3">`str1`</ph>, using <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> on these two string objects will not produce the same hash code.</source>
          <target state="translated">そのため場合、 <ph id="ph1">`str2`</ph> 、連結演算の結果として作成されたと<ph id="ph2">`str2`</ph>と同じ<ph id="ph3">`str1`</ph>を使用して、<ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>オブジェクトが同じハッシュ コードをもたらさないこれら 2 つの文字列にします。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>If you want to add a concatenated string to the pool explicitly, use the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">プールには、連結文字列を明示的に追加する場合を使用して、<ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>You can also use the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph> method to check whether a string has an interned reference.</source>
          <target state="translated">使用することも、<ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=nameWithType&gt;</ph>文字列がインターン処理後の参照を持つかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The following example demonstrates the difference between the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> methods.</source>
          <target state="translated">次の例での違い、<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The output from the example illustrates the following:</source>
          <target state="translated">出力例を次に示します。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Both sets of hash codes for the first set of strings passed to the <ph id="ph1">`ShowHashCodes`</ph> method are different, because the strings are completely different.</source>
          <target state="translated">渡される文字列の最初のセットのハッシュ コードの両方のセット、<ph id="ph1">`ShowHashCodes`</ph>文字列が完全に異なるために、メソッドが異なる場合、します。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> generates the same hash code for the second set of strings passed to the <ph id="ph2">`ShowHashCodes`</ph> method, because the strings are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> 渡される文字列の 2 番目のセットの同じハッシュ コードを生成、<ph id="ph2">`ShowHashCodes`</ph>メソッド、文字列が等しいためです。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>However, the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> method does not.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>メソッドはありません。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>The first string is defined by using a string literal and so is interned.</source>
          <target state="translated">最初の文字列は、リテラル文字列を使用して定義され、ので隔離されている場合。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>Although the value of the second string is the same, it is not interned, because it is returned by a call to the <ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">2 番目の文字列の値が同じですが、いない隔離されている場合への呼び出しによって返されるため、<ph id="ph1">&lt;xref:System.String.Format%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>In the case of the third string, the hash codes produced by <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> for both strings are identical, as are the hash codes produced by <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">3 番目の文字列の場合は、によって生成されたハッシュ コード<ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>によって生成されたハッシュ コードとして、両方の文字列が同一の<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)">
          <source>This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</source>
          <target state="translated">これは、同一のインターン処理後の文字列に文字列変数が参照して、コンパイラが 1 つの文字列リテラル、両方の文字列に割り当てられた値を扱われるためです。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The value type to be boxed.</source>
          <target state="translated">ボックスに格納する値型。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxes a value type.</source>
          <target state="translated">値型をボックスに格納します。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>A boxed copy of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> if it is a value class; otherwise, <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> itself.</source>
          <target state="translated">値クラスの場合は <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> のボックス化されたコピー。それ以外の場合は <ph id="ph2">&lt;paramref name="obj" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</source>
          <target state="translated">値の型をボックス化オブジェクトを作成し、新しいオブジェクトに指定された値型のフィールドのシャロー コピーを実行します。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</source>
          <target state="translated">このメソッドでは、値クラスがそこには、値クラスのエイリアス動作中にオブジェクトとして操作できるようにします。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The return value depends on whether the value class is mutable or immutable:</source>
          <target state="translated">戻り値は、値クラスは、変更可能または変更できないかどうかによって異なります。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</source>
          <target state="translated">割り当てられている値が変更可能な値クラスの場合は、値クラスは、コピーのセマンティクスを持つため、メソッド、クラスの簡易コピーを返します。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</source>
          <target state="translated">割り当てられている値が変更できない値クラスの場合は、メソッドは、オブジェクト自体、クラスのコピーではなくを返します。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</source>
          <target state="translated">動的に型指定された言語のコンパイラでは、このメソッドを使用して、ボックス化された値の型がボックス化解除された値の型と同じ機能を確認してください。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>That is, boxed value types get cloned when you pass them around, and they are always passed by value.</source>
          <target state="translated">つまり、ボックス化された値の型は取得、それらに渡すし、常に値によって渡されるときに複製されます。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The compiler can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.</source>
          <target state="translated">コンパイラが呼び出すことができます<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph>値の型をオブジェクトに割り当てるか、値の型を object 型のパラメーターとして渡す。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)">
          <source>The following example demonstrates how to box a value class by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> method.</source>
          <target state="translated">次の例では、値クラスを使用して、ボックス、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>The array to be initialized.</source>
          <target state="translated">初期化する配列。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>A field handle that specifies the location of the data used to initialize the array.</source>
          <target state="translated">配列の初期化に使用するデータの位置を指定するフィールド ハンドル。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>Provides a fast way to initialize an array from data that is stored in a module.</source>
          <target state="translated">モジュールに格納されているデータから配列を高速に初期化する方法を提供します。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Gets the offset, in bytes, to the data in the given string.</source>
          <target state="translated">特定の文字列のデータへのオフセットをバイト単位で取得します。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>The byte offset, from the start of the <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> object to the first character in the string.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> オブジェクトの先頭から、文字列の最初の文字までのバイト オフセット。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</source>
          <target state="translated">コンパイラでは、このプロパティを使用して、安全ではありませんが、効率的なポインターでの操作、管理対象の文字列内の文字です。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Compilers should pin the string against movement by the garbage collector before use.</source>
          <target state="translated">コンパイラは、使用する前に、ガベージ コレクターによって移動されない文字列をピン留めする必要があります。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData">
          <source>Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</source>
          <target state="translated">共通言語ランタイムの文字列の不変の状態がないことに注意してください。つまり、その内容を読み取るが変更されません。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Designates a body of code as a constrained execution region (CER).</source>
          <target state="translated">コード本体を制約された実行領域 (CER) として指定します。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Compilers use this method to mark <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, and <ph id="ph3">`fault`</ph> blocks as constrained execution regions (CERs).</source>
          <target state="translated">コンパイラでは、このメソッドを使用して、マーク<ph id="ph1">`catch`</ph>、 <ph id="ph2">`finally`</ph>、および<ph id="ph3">`fault`</ph>制約された実行領域 (Cer) としてブロックされます。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Code that is marked as a constrained region must only call other code with strong reliability contracts.</source>
          <target state="translated">制約された領域は、信頼性のコントラクトには、他のコードを呼び出す必要がありますのみとマークされているコード。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</source>
          <target state="translated">エラーを処理する準備ができた場合を除き、仮想メソッドの呼び出しを準備解除または信頼性の低いをくださいまたは割り当てにしないでください。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Note that no intermediate language opcodes, except <ph id="ph1">`NOP`</ph>, are allowed between a call to the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">いいえ言語オペコードを除く中級レベルの注<ph id="ph1">`NOP`</ph>への呼び出しが許可されている、<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph>メソッドおよび<ph id="ph3">`try`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information about CERs, see the classes in the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</source>
          <target state="translated">Cer の詳細については、クラスを参照してください、<ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph>名前空間。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>CERs that are marked using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id="ph3">`try`</ph> block.</source>
          <target state="translated">使用してマークされている Cer、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph>メソッドが完全に機能しない場合、<ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph>から生成された、<ph id="ph3">`try`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.</source>
          <target state="translated">詳細については、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> メソッドを参照してください。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> メソッドは <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>The following example shows how to reliably set handles by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method.</source>
          <target state="translated">次の例を使用してハンドルを確実に設定する方法を示しています、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is atomic.</source>
          <target state="translated">指定した既存のハンドルをハンドルを確実に設定するをことを確認、ネイティブのハンドルの割り当てとそのハンドル内の後続の記録、<ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph>オブジェクトがアトミックです。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</source>
          <target state="translated">これらの操作 (スレッドの中止またはメモリ不足の例外) などの間で、エラーをすべて漏洩のネイティブ ハンドルが発生します。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>You can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method to make sure that the handle is not leaked.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph>メソッドが、ハンドルのリークがないかどうかを確認します。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Designates a body of code as a constrained execution region (CER) without performing any probing.</source>
          <target state="translated">プローブを実行しないで、コード本体を制約された実行領域 (CER) として指定します。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Compilers should not call this method directly.</source>
          <target state="translated">コンパイラでは、このメソッドを直接呼び出さないでください。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>Instead, define a CER by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">代わりに、呼び出すことによって、CER を定義、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>The event delegate to prepare.</source>
          <target state="translated">準備するイベント デリゲート。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Provides a way for applications to dynamically prepare <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> event delegates.</source>
          <target state="translated">アプリケーションが <ph id="ph1">&lt;see cref="T:System.AppDomain" /&gt;</ph> イベント デリゲートを動的に準備する手段を提供します。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> イベントのデリゲートなど<ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>、 <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>、および<ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph>自動的に準備ができていない起動時。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>You can use the following methods to prepare them:</source>
          <target state="translated">準備のために、次のメソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.</source>
          <target state="translated">メソッドを使用して、属性、<ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.</source>
          <target state="translated">メソッドを使用して、属性、<ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph>属性。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph>デリゲートを動的に準備します。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>For more information, see the article <bpt id="p1">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.</source>
          <target state="translated">詳細については、記事を参照してください。<bpt id="p1">[</bpt>保持、コードを実行していると、.NET Framework の信頼性機能と<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept>MSDN マガジンのです。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>The delegate type to prepare.</source>
          <target state="translated">準備するデリゲート型。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</source>
          <target state="translated">指定されたデリゲートを制約された実行領域 (CER: Constrained Execution Region) に含めるように準備する必要があることを示します。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</source>
          <target state="translated">コンパイラを使用してこのメソッドをデリゲートの呼び出しメソッドを準備し、その呼び出し (および、デリゲートの呼び出しが静的に確定グラフ) のターゲットを準備するのに制約された実行領域 (CER) として。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Runtime.CompilerServices.RuntimeHelpers">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">制約された実行領域 (CER) に含めるためのメソッドを準備します。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>A handle to the method to prepare.</source>
          <target state="translated">準備するメソッドのハンドル。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
          <target state="translated">制約された実行領域 (CER) に含めるためのメソッドを準備します。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Compilers use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).</source>
          <target state="translated">コンパイラが使う、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph>制約された実行領域 (CER) 内で行われます仮想呼び出しを処理するメソッド。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</source>
          <target state="translated">JIT コンパイル時に、共通言語ランタイムは通常ありません仮想呼び出しのターゲットに関する十分な情報。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>Therefore, the runtime does not initially prepare that segment of the call graph.</source>
          <target state="translated">そのため、ランタイムは、呼び出し先のセグメントを最初に準備できません。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</source>
          <target state="translated">CER までの時間の任意の時点でターゲットを確認するのには、実際に入力された CER を使用しているコードに十分な知識がある場合は、呼び出すことができます<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph>を行う CER が引数として指定されたメソッドをルートとの通常、同じランタイム準備を実行します。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>A handle to the method to prepare.</source>
          <target state="translated">準備するメソッドのハンドル。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The instantiation to pass to the method.</source>
          <target state="translated">メソッドに渡すインスタンス化。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</source>
          <target state="translated">指定のインスタンス化を使用して、制約された実行領域 (CER) に含めるためのメソッドを準備します。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can provide generics support for compilers by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.</source>
          <target state="translated">使用してコンパイラのジェネリックのサポートを提供する、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</source>
          <target state="translated">共通言語ランタイムが制約された実行領域 (Cer) をジェネリック型パラメーター (型パラメーター、メソッドまたはメソッド自体に 1 つを含むクラス) を持つメソッドにルートを準備することはできませんと参照型でこれらの型パラメーターがインスタンス化されるときです。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</source>
          <target state="translated">このオーバー ロードを使用して (型の配列) などの特定のインスタンス化を渡すことができます (存在する場合)、最初にクラスの型パラメーターを指定する、メソッド型パラメーター (ある場合) その後にします。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>The runtime prepares that instantiation of the method.</source>
          <target state="translated">ランタイムは、メソッドのインスタンス化を準備します。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id="ph1">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> or other value types.</source>
          <target state="translated">(これはインスタンス化使用するにはには、少なくとも 1 つの参照型パラメーターが含まれている場合にのみ必要です。)したがって、CER 形式を使用することができます<ph id="ph1">`try`</ph>ジェネリック メソッド (または、ジェネリック クラスの非ジェネリック メソッド) 内の句のインスタンス化で確実に動作して<ph id="ph2">&lt;xref:System.Int32&gt;</ph>またはその他の値の型。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>To instantiate reference types such as <ph id="ph1">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.</source>
          <target state="translated">などの参照をインスタンス化する型<ph id="ph1">&lt;xref:System.String&gt;</ph>、する必要がありますを使用して、明示的な<ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph>CER でメソッドがメソッドを最初にルートします。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</source>
          <target state="translated">一定量のスタック領域をプローブして、後続のコード ブロック内でスタック オーバーフローが発生しないことを確認します (コードは有限かつ適度な量のスタック領域だけを使用することを前提に)。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>We recommend that you use a constrained execution region (CER) instead of this method.</source>
          <target state="translated">このメソッドではなく、制約された実行領域 (CER) を使用することをお勧めします。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</source>
          <target state="translated">スタック オーバーフローなど、Microsoft SQL Server と Microsoft Exchange Server に回復力のあるホストで実行する場合は、このメソッドを制約された実行領域 (CER) インフラストラクチャによって使用されます。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</source>
          <target state="translated">このメソッドは、x86 の場合は、48 KB のスタック領域を現在プローブ プラットフォームしますが、費やす時間の経過と共に変更することがあり、他のプラットフォームで異なる場合があります。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This method is also used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラによっても使用されます。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.</source>
          <target state="translated">使用する代わりに、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph>メソッド、標準的な CER を使用する必要があります。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>That is, if you are planning to use a moderate amount of stack space, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph> method immediately before your <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> or <ph id="ph5">`try`</ph><ph id="ph6">/</ph><ph id="ph7">`catch`</ph> block.</source>
          <target state="translated">スタック領域量が中程度の使用を計画している場合は、呼び出し、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType&gt;</ph>メソッドの直前に、 <ph id="ph2">`try`</ph> <ph id="ph3">/</ph> <ph id="ph4">`finally`</ph>または<ph id="ph5">`try`</ph> <ph id="ph6">/</ph> <ph id="ph7">`catch`</ph>ブロックします。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">使用する必要があります再帰メソッドまたはスタック領域を大量に使用する計画を呼び出している場合、<ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>requires full trust for the immediate caller.</source>
          <target state="translated">直前の呼び出し元に対する完全な信頼が必要です。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">このメンバーは、部分的に信頼されているまたは透過的なコードで使用することはできません。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>A type handle that specifies the class constructor method to run.</source>
          <target state="translated">実行するクラス コンストラクター メソッドを指定する型ハンドル。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>Runs a specified class constructor method.</source>
          <target state="translated">指定したクラスのコンストラクター メソッドを実行します。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)">
          <source>The class initializer throws an exception.</source>
          <target state="translated">クラス初期化子は例外をスローします。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>A handle that specifies the module constructor method to run.</source>
          <target state="translated">実行するモジュール コンストラクター メソッドを指定するハンドル。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>Runs a specified module constructor method.</source>
          <target state="translated">指定したモジュールのコンストラクター メソッドを実行します。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>This method is used by compilers.</source>
          <target state="translated">このメソッドは、コンパイラで使用します。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)">
          <source>The module constructor throws an exception.</source>
          <target state="translated">モジュール コンストラクターが例外をスローします。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>