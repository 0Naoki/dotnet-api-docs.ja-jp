<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Socket.xml" source-language="en-US" target-language="ja-JP">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9575d09f-9d72-4690-889e-b83c405ca456c93cc8bd7b21bbe208244f30ebd0e865cd18a7a5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">c93cc8bd7b21bbe208244f30ebd0e865cd18a7a5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">254e16ae65e82f4aa59360cd8572b36b6b5b2f80</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/05/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Implements the Berkeley sockets interface.</source>
          <target state="translated">Berkeley ソケット インターフェイスを実装します。</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスは、ネットワーク通信について豊富な一連のメソッドとプロパティを提供します。</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスはどちらも実行を同期できに示されている通信プロトコルのいずれかを使用して非同期のデータ転送、<ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスが非同期メソッド用の .NET Framework 名前付けパターンに従います。</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>For example, the synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.</source>
          <target state="translated">たとえば、同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは非同期に対応<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>と<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</source>
          <target state="translated">アプリケーションには、実行中に 1 つのスレッドのみ必要とする場合は、次のメソッドは、同期動作モード用に設計されてを使用します。</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">使用した接続に、サーバーがリッスンできる TCP などの接続指向プロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッド プロセスすべての着信接続を要求しを返します、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>ことは、データをリモート ホストに通信するために使用することができます。</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">この返さ<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を呼び出して、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドを呼び出す前に、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>メソッドのローカル IP アドレスとポート番号を指定する場合。</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use a port number of zero if you want the underlying service provider to assign a free port for you.</source>
          <target state="translated">基になるサービス プロバイダーのポートを割り当てる空きをする場合は、ゼロのポート番号を使用します。</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you want to connect to a listening host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">リッスンしているホストに接続する場合は、呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To communicate data, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">データを通信するために呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合は、すべての接続をリッスンする必要はありません。</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドを受信データグラムを受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>データグラムをリモート ホストに送信するメソッド。</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</source>
          <target state="translated">実行中に個別のスレッドを使用して通信を処理するには、次のメソッドは、非同期の操作モード用に設計されてを使用します。</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.</source>
          <target state="translated">TCP などの接続指向プロトコルを使用している場合を使用して、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>リッスン中のホストに接続する方法です。</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>と<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>データを非同期的に通信するメソッド。</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Incoming connection requests can be processed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</source>
          <target state="translated">使用して接続要求を処理できる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を使用できます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>、データグラムを送信して<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>と<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>データグラムを受信します。</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</source>
          <target state="translated">ソケットに対して複数の非同期操作を実行する場合、必ずしもで完了しなかった開始される順序。</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>When you are finished sending and receiving data, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">完成した送信とデータを受信したらを使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>無効にする方法、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>に関連付けられているすべてのリソースを解放するメソッド、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスでは、構成することができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Retrieve these settings using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">使用してこれらの設定を取得、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are writing a relatively simple application and do not require maximum performance, consider using <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</source>
          <target state="translated">比較的単純なアプリケーションを作成して、最大のパフォーマンスは必要ない場合、は、使用を検討して<ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>These classes provide a simpler and more user-friendly interface to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</source>
          <target state="translated">これらのクラスに簡素化され、ユーザーにわかりやすいインターフェイスを提供する<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>通信します。</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can be used to send data to an HTTP server and receive the response.</source>
          <target state="translated">次のコード例に示す方法、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスは、HTTP サーバーにデータを送信し、応答を受信するために使用できます。</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>This example blocks until the entire page is received.</source>
          <target state="translated">この例は、ページ全体を受信するまでブロックします。</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To establish an outgoing connection or accept an incoming request.</source>
          <target state="translated">発信接続を確立するか、受信要求を受け入れます。</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Instances of this class are thread safe.</source>
          <target state="translated">このクラスのインスタンスでは、スレッド セーフです。</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>The socket information returned by <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph> によって返されるソケット情報。</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified value returned from <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph> から返された値を指定して、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.</source>
          <target state="translated">呼び出す場合は、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成する、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>同一の基になるソケットで秒です。</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">この方法はお勧めします。</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified socket type and protocol.</source>
          <target state="translated">指定したソケットの種類とプロトコルを使用して、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`socketType`</ph> parameter specifies the type of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id="ph3">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`socketType`</ph>パラメーターの型を指定、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスおよび<ph id="ph3">`protocolType`</ph>パラメーターで使用されるプロトコルを指定<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The two parameters are not independent.</source>
          <target state="translated">2 つのパラメーターが独立してではありません。</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">多くの場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>型は、プロトコルで暗黙の型。</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合の組み合わせ<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>種類とプロトコル型の結果、無効な<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、このコンス トラクターをスロー、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">このコンス トラクターをスローした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of  <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> and <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> と <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> を組み合わせると、無効なソケットになります。</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified address family, socket type and protocol.</source>
          <target state="translated">指定したアドレス ファミリ、ソケットの種類、およびプロトコルを使用して、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスの新しいインスタンスを初期化します。</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`addressFamily`</ph> parameter specifies the addressing scheme that the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id="ph3">`socketType`</ph> parameter specifies the type of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id="ph5">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`addressFamily`</ph>パラメーターを指定するアドレス指定スキーム、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスの使用方法、<ph id="ph3">`socketType`</ph>パラメーターの型を指定、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラス、および<ph id="ph5">`protocolType`</ph>パラメーターで使用されるプロトコルを指定<ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The three parameters are not independent.</source>
          <target state="translated">次の 3 つのパラメーターが独立してではありません。</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Some address families restrict which protocols can be used with them, and often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">一部のアドレス ファミリを制限、および多くの場合、どのプロトコルを使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>型は、プロトコルで暗黙の型。</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of address family, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合、アドレス ファミリの組み合わせ<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>型、およびプロトコルの種類は、無効な<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、このコンス トラクターをスロー、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">このコンス トラクターをスローした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The following code example demonstrates how to create an instance of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">次のコード例は、のインスタンスを作成する方法を示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>、<ph id="ph2">&lt;paramref name="socketType" /&gt;</ph>、および <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> を組み合わせると、無効なソケットになります。</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">新しく作成された接続に対して新しい <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> を作成します。</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">新しく作成された接続に対する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> 同期的に待機中のソケットの接続要求のキューから最初の保留中の接続要求を抽出を作成し、新しい<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">返されるこれを使用することはできません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接続キューからその他の接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>However, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">ただし、呼び出すことができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>メソッドの返された<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>をリモート ホストのネットワーク アドレスとポート番号を識別します。</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>In blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.</source>
          <target state="translated">ブロッキング モード<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>受信接続の試行がキューに登録するまでブロックします。</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Once a connection is accepted, the original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.</source>
          <target state="translated">接続を受け入れる元<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>キューの着信接続を要求するまで閉じることが続行されます。</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you call this method using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">非ブロッキングを使用してこのメソッドを呼び出すかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、および接続要求がキューに入れ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>をスロー、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">呼び出しの前に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッド、最初に呼び出す必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>をリッスンし、接続要求をキューにメソッドです。</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The following code example accepts a simple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection.</source>
          <target state="translated">次のコード例は、単純なを受け入れる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接続します。</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">受け入れ元のソケットが、接続をリッスンしていません。</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph> の前に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> および <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">受信接続の試行を受け入れる非同期操作を開始します。</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">接続指向プロトコルを使用できる、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>着信接続を非同期的に処理するメソッドと試みます。</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">呼び出しの前に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>メソッドを呼び出す必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>をリッスンし、接続要求をキューにメソッドです。</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; を委任し、それを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが必要。</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller can optionally specify an existing <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">呼び出し元は、既存のオプションで指定できます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を指定して、着信接続に使用する、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>で使用する、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property is null, a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph>プロパティが null、新しい<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が同じで構築されて<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>、および<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph>現在<ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>として設定し、<ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">必要に応じて、後にソケット上のデータの最初のブロックを受信するためのバッファーを指定する場合があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドが成功します。</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.</source>
          <target state="translated">ここで、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>プロパティを受信するデータを格納しているバッファーに設定する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>プロパティをバッファーに受信するデータのバイトの最大数に設定する必要があります。</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>These properties can be set using the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">使用してこれらのプロパティを設定することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</source>
          <target state="translated">渡されたバッファーの一部で使用される内部的に使用する基になる Winsock AcceptEx 呼び出しです。</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This means that the amount of data returned will always be less than the value of the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instance provided.</source>
          <target state="translated">つまり、返されるデータの量が常の値より小さい、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>指定されたインスタンスです。</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The amount of the buffer used internally varies based on the address family of the socket.</source>
          <target state="translated">内部的に使用されるバッファーの容量は、ソケット アドレス ファミリに変わります。</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The minimum buffer size required is 288 bytes.</source>
          <target state="translated">必要な最小バッファー サイズは、288 バイトです。</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a larger buffer size is specified, then the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</source>
          <target state="translated">大きなバッファー サイズが指定されている場合、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Winsock AcceptEx 呼び出しで受け取ったアドレス データ以外のいくつかの余分なデータを必要として、この余分なデータが受信されるまで待機します。</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a timeout occurs, the connection is reset.</source>
          <target state="translated">タイムアウトが発生した場合、接続がリセットされます。</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</source>
          <target state="translated">それで余分なデータが特定の容量の予測される場合、最小バッファー サイズとこの金額に、バッファーのサイズを設定する必要があります。</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The completion callback method should examine the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.</source>
          <target state="translated">完了コールバック メソッドを調べる必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>プロパティかどうかを<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>操作は成功しました。</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to be set to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベントの接続が許可されていない場合に発生して発生することができます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>設定するプロパティを<ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).</source>
          <target state="translated">これは、ポートを半開 SYN 型スキャンを使用してスキャンの結果として発生することができます (SYN SYN ACK]-&gt; [RST シーケンス -&gt;)。</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Applications using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.</source>
          <target state="translated">アプリケーションを使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>この条件を処理するメソッドを準備する必要があります。</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">引数が有効ではありません。</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the buffer provided is not large enough.</source>
          <target state="translated">この例外は、提供されたバッファーのサイズが不足している場合に発生します。</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</source>
          <target state="translated">バッファーは、2 * (sizeof(SOCKADDR_STORAGE + 16) バイト以上であることが必要です。</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">この例外は、複数のバッファーが指定されているときに、<ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> プロパティが null 値ではない場合にも発生します。</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is out of range.</source>
          <target state="translated">引数が範囲外です。</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The exception occurs if the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> is less than 0.</source>
          <target state="translated">この例外は、<ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> が 0 未満の場合に発生します。</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An invalid operation was requested.</source>
          <target state="translated">無効な操作が要求されました。</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the accepting <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not listening for connections or the accepted socket is bound.</source>
          <target state="translated">この例外は、受け入れ側の <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が接続をリッスンしていない場合、または受け入れられたソケットがバインドされている場合に発生します。</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> method before calling the <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> メソッドを呼び出す前に、<ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> メソッドと <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> メソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">この例外は、ソケットが既に接続されている、またはソケット操作が指定された <ph id="ph1">&lt;paramref name="e" /&gt;</ph> パラメーターを使用して既に進行中の場合にも発生します。</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>Gets the address family of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> のアドレス ファミリを取得します。</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>をアドレス指定スキームを指定のインスタンス、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスを使用できます。</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>This property is read-only and is set when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated">このプロパティは読み取り専用と設定されているときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を作成します。</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">次のコード例では表示、 <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>コンソールにします。</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>Gets the amount of data that has been received from the network and is available to be read.</source>
          <target state="translated">ネットワークから受信した、読み取り可能なデータ量を取得します。</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The number of bytes of data received from the network and available to be read.</source>
          <target state="translated">ネットワークから受信した、読み取り可能なデータのバイト数。</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you are using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">非ブロッキングを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>を呼び出す前に、読み取り用のデータがキューに置かれたかどうかを決定することをお勧めは<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The available data is the total amount of data queued in the network buffer for reading.</source>
          <target state="translated">使用可能なデータは、読み取り用のネットワーク バッファーにキューに置かれたデータの合計サイズです。</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If no data is queued in the network buffer, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.</source>
          <target state="translated">ネットワーク バッファーにデータがキューにない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 を返します。</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If the remote host shuts down or closes the connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">リモート ホストがシャット ダウン、または、接続を閉じる場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>スローすることができます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The following code example compares the results of calling IOControl with FIONREAD and the Available property.</source>
          <target state="translated">次のコード例では、呼び出し元の IOControl FIONREAD と使用可能なプロパティを使用した結果を比較します。</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">受信接続の試行を受け入れる非同期操作を開始します。</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">受信接続の試行を受け入れる非同期操作を開始します。</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated">非同期の <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> 作成を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">接続指向プロトコルを使用できる、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>着信接続を非同期的に処理するメソッドと試みます。</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">呼び出しの前に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを呼び出す必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>をリッスンし、接続要求をキューにメソッドです。</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成する必要があります、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">そのためには、少なくとも、リッスンを渡す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オブジェクトを<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>を通じて、<ph id="ph3">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>保留中の接続が取得されるまでです。</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 新しい戻ります<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オブジェクトをリモート ホストとのデータの送受信に使用できます。</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">返されるこれを使用することはできません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接続キューからその他の接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを使用して<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Set メソッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>元のスレッドに実行を継続する場合は、コールバック メソッドにします。</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">ここで、<ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph>プロパティで返された<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>ことを示すために設定されます、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドは同期的に完了しました。</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">使用することができます、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> 、返されたプロパティ<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>をリモート ホストのネットワーク アドレスとポート番号を識別します。</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケット バージョン 2 API エラー コードのドキュメントに MSDN でエラーの詳細な説明を参照してください。</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The following code example attempts to receive an incoming connection asynchronously.</source>
          <target state="translated">次のコード例は、非同期的に受信接続を受信しようとします。</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">受け入れ元のソケットが、接続をリッスンしていません。</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> の前に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> および <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">受け入れられたソケットがバインドされています。</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes to accept from the sender.</source>
          <target state="translated">送信元から受け入れるバイト数。</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</source>
          <target state="translated">受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated">非同期の <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> 作成を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">接続指向プロトコルを使用できる、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>着信接続を非同期的に処理するメソッドと試みます。</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</source>
          <target state="translated">非同期接続の受け入れを使用すると、個別の実行スレッド内でデータを送受信できます。</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">このオーバー ロードでは、初期の転送に同意するバイト数を指定することができます、<ph id="ph1">`receiveSize`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">呼び出しの前に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを呼び出す必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>をリッスンし、接続要求をキューにメソッドです。</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成する必要があります、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">そのためには、少なくとも、リッスンを渡す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オブジェクトを<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>を通じて、<ph id="ph3">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>保留中の接続が取得されるまでです。</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 新しいを返します<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>リモート ホストとのデータの送受信を行えます。</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">返されるこれを使用することはできません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接続キューからその他の接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを使用して<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Set メソッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>元のスレッドに実行を継続する場合は、コールバック メソッドにします。</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">ここで、<ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph>プロパティで返された<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>ことを示すために設定されます、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドは同期的に完了しました。</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You can call use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">使用してを呼び出すことができます、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> 、返されたプロパティ<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>をリモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">次のコード例は、ソケットを開き、非同期接続を受け入れます。</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data.</source>
          <target state="translated">この例では、ソケットは、最初の 10 バイトのデータを受け取っています。</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">受信したバイト数と、データは、コールバック デリゲートをコンソールに表示されます。</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>残りのデータを受信する方法の詳細についてはします。</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">受け入れ元のソケットが、接続をリッスンしていません。</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> の前に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> および <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">受け入れられたソケットがバインドされています。</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">受け入れた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This value may be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">この値は <ph id="ph1">&lt;see langword="null" /&gt;</ph> の場合もあります。</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to receive.</source>
          <target state="translated">受信する最大バイト数。</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</source>
          <target state="translated">指定したソケットから受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object creation.</source>
          <target state="translated">非同期の <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトの作成を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">接続指向プロトコルを使用できる、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>着信接続を非同期的に処理するメソッドと試みます。</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the accepted socket in the <ph id="ph1">`acceptSocket`</ph> parameter.</source>
          <target state="translated">このオーバー ロードで受け入れられたソケットを指定することができます、<ph id="ph1">`acceptSocket`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this parameter is <ph id="ph1">`null`</ph>, the accepted socket is created by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">このパラメーターは場合<ph id="ph1">`null`</ph>、受け入れられたソケットがによって作成された、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">初期転送に同意するバイト数を指定することができます、<ph id="ph1">`receiveSize`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">呼び出しの前に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを呼び出す必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>をリッスンし、接続要求をキューにメソッドです。</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成する必要があります、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">そのためには、少なくとも、リッスンを渡す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オブジェクトを<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>を通じて、<ph id="ph3">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>保留中の接続が取得されるまでです。</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 新しいを返します<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オブジェクトをリモート ホストとのデータの送受信に使用できます。</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">返されるこれを使用することはできません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>接続キューからその他の接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを使用して<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Set メソッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>元のスレッドに実行を継続する場合は、コールバック メソッドにします。</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">ここで、<ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph>プロパティで返された<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>ことを示すために設定されます、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドは同期的に完了しました。</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの作成方法の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">使用することができます、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> 、返されたプロパティ<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>をリモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">次のコード例は、ソケットを開き、非同期接続を受け入れます。</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data and the <ph id="ph1">`acceptSocket`</ph> parameter is <ph id="ph2">`null`</ph>, which forces the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to create the accepted socket.</source>
          <target state="translated">この例では、ソケットは最初の 10 バイトのデータを受け入れます。 と<ph id="ph1">`acceptSocket`</ph>パラメーターは<ph id="ph2">`null`</ph>、強制的に実行する、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>受け入れられたソケットを作成する方法です。</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">受信したバイト数と、データは、コールバック デリゲートをコンソールに表示されます。</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">参照してください<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>残りのデータを受信する方法の詳細についてはします。</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">受け入れ元のソケットが、接続をリッスンしていません。</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> の前に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> および <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">受け入れられたソケットがバインドされています。</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">リモート ホスト接続への非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">リモート ホスト接続への非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">非同期接続を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドへの接続への非同期要求の開始、<ph id="ph2">`remoteEP`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを確立します。</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">接続するか、既定のリモート ホストの設定を非同期的に個別の実行スレッド内でデータを送受信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>At the very minimum, you must pass the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">少なくとも、渡す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を通じて、<ph id="ph3">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が正常に接続するか、例外をスローします。</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドを使用して<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Set メソッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>元のスレッドに実行を継続する場合は、コールバック メソッドにします。</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>のリモート ホストと通信します。</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you wish to set your default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>にブロードキャストを設定および<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you cannot, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">できない場合は、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているし、呼び出さないかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号を呼び出すまで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>目的のエンドポイントを使用してメソッドです。</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">このソケットが解除されていたし場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作が完了するまで終了しないスレッドで呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">次のコード例では、非同期接続の試行を開始します。</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> of the remote host.</source>
          <target state="translated">リモート ホストの <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">リモート ホストのポート番号。</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">接続操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">リモート ホスト接続への非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and a port number.</source>
          <target state="translated">ホストは <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> とポート番号で指定されます。</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">非同期接続を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`requestCallback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドのオーバー ロードまたは<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す。<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">このソケットが解除されていたし場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作が完了するまで終了しないスレッドで呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">また、<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>は別にする必要がありますを使用します。</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">次のコード例では、非同期接続の試行を開始します。</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not in the socket family.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> はソケット ファミリに含まれません。</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">ポート番号が無効です。</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>At least one <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, designating the remote host.</source>
          <target state="translated">リモート ホストを指定する、少なくとも 1 つの <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">リモート ホストのポート番号。</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">接続操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">リモート ホスト接続への非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> array and a port number.</source>
          <target state="translated">ホストは、<ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> 配列とポート番号で指定されます。</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connections.</source>
          <target state="translated">非同期接続を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`requestCallback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください。<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">このソケットが解除されていたし場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作が完了するまで終了しないスレッドで呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">また、<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>は別にする必要がありますを使用します。</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">次のコード例では、非同期接続の試行を開始します。</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets that use <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</source>
          <target state="translated">このメソッドは <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> を使用するソケットで有効です。</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">ポート番号が無効です。</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The name of the remote host.</source>
          <target state="translated">リモート ホストの名前。</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">リモート ホストのポート番号。</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">接続操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">リモート ホスト接続への非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">ホストはホスト名とポート番号で指定されます。</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">非同期接続を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`requestCallback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the  <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">保留中の呼び出しをキャンセルする、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッド、閉じる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドが呼び出されます。</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">後続の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph>操作が取り消されましたことを示すためにします。</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す。<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">このソケットが解除されていたし場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>操作が完了するまで終了しないスレッドで呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">また、<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>は別にする必要がありますを使用します。</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">次のコード例では、非同期接続の試行を開始します。</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ファミリのソケットで有効です。</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">ポート番号が無効です。</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">接続の終了後、このソケットが再利用できる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">リモート エンドポイントからの切断の非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous operation.</source>
          <target state="translated">非同期操作を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.</source>
          <target state="translated">接続指向のプロトコルを使用している場合は、呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>リモート エンドポイントからの切断要求を送信します。</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">場合<ph id="ph1">`reuseSocket`</ph>は<ph id="ph2">`true`</ph>ソケットを再利用することができます。</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>メソッドは、指定されたコールバック メソッドを呼び出す別のスレッドを使用します。</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph>メソッドは、保留中の切断までブロックが完了しました。</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの作成方法の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">データが送信されると、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>送信を停止し、受信アクティビティのために呼び出されます。</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>切断要求を開始すると呼びます。</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">要求が完了したら、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からの非同期のデータ受信を開始します。</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">操作の完了時に呼び出すメソッドを参照する <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">受信操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からの非同期のデータ受信を開始します。</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">非同期の読み取りを参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`callback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください。<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">操作の完了時に呼び出すメソッドを参照する <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">受信操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からの非同期のデータ受信を開始します。</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">非同期の読み取りを参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`callback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください。<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the received data.</source>
          <target state="translated">受信データを格納する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の、インデックス番号が 0 から始まる位置。</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">操作の完了時に呼び出すメソッドを参照する <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">受信操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からの非同期のデータ受信を開始します。</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">非同期の読み取りを参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`callback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください。<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、接続からデータを非同期的に受信を開始<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">受信データを格納する <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> 内の場所。</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">操作の完了時に呼び出すメソッドを参照する <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">受信操作に関する情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">このオブジェクトは、操作の完了時に <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> デリゲートに渡されます。</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からの非同期のデータ受信を開始します。</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">非同期の読み取りを参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">非同期の<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>操作を呼び出すことによって完了する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`callback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">操作が完了するまでブロックするには、いずれかを使用、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドのオーバー ロードします。</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください。<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">データを格納する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の、インデックス番号が 0 から始まる位置。</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">指定したネットワーク デバイスから、データの非同期の受信を開始します。</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">非同期の読み取りを参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドが、リモート ホストからコネクションレス データグラムを非同期的に読み取りを開始します。</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを受信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターが、接続されているを含む必要がありますまたは既定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されています。</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>、システムが、指定されたコールバック メソッドを実行する別のスレッドを使用、およびを<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>データを読み取るか例外をスローします。</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドを使用して<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの作成方法の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>、明示的にバインドする必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、ローカル エンドポイントを<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド、または<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>がスローされます、<ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.</source>
          <target state="translated">このメソッドにデータを読み込みます、<ph id="ph1">`buffer`</ph>パラメーター、およびデータの送信元となるエンドポイントをホストするリモート キャプチャします。</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">このエンドポイントを取得する方法についてを参照してください<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">このような場合は、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドは入力<ph id="ph3">`buffer`</ph>メッセージは、可能であれば、throw の多くで、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">信頼性の低いプロトコルを使用している場合、余分なデータが失われます。</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>のに十分な大きさのバッファーを持つメソッドです。</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id="ph4">`optionLevel`</ph> parameter set to <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id="ph7">`optionName`</ph> parameter set to <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id="ph9">`optionValue`</ph> parameter to enable this option before calling the <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">リモート ホストのエンドポイントが常に返される、アプリケーションでは明示的にバインドする必要がありますのことを保証するために、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>ローカル エンドポイントを使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドと、呼び出し、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドを<ph id="ph4">`optionLevel`</ph>パラメーターに設定<ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>または<ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph>、必要に応じて、<ph id="ph7">`optionName`</ph>パラメーターに設定<ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>、および<ph id="ph9">`optionValue`</ph>を呼び出す前にこのオプションを有効にするパラメーター、<ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッド。</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">それ以外の場合、可能であれば、受信側が呼び出される前に、送信者のデータグラムの数が送信する場合は、返されていないリモート ホストのエンドポイントの<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドを呼び出して、受信接続要求を受け入れるか、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">呼び出す場合は、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>確立するか、接続を受け入れる前にメソッドが表示されます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドは無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">接続指向のソケットと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>がで指定したバイトの数まで使用できる多くのデータを読み取り、<ph id="ph2">`size`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously receives connectionless datagrams from a remote host.</source>
          <target state="translated">次のコード例は、リモート ホストから非同期的にコネクションレス データグラムを受信します。</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">データを格納する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の、インデックス番号が 0 から始まる位置。</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the source of the data.</source>
          <target state="translated">データのソースを表す <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information..</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、指定したバイト数のデータの非同期受信を開始して、データ バッファー内の指定した位置に格納します。さらに、エンドポイントとパケット情報を格納します。</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">非同期の読み取りを参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The asynchronous receive operation must be completed by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">非同期の受信操作呼び出しで完了する必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`asyncCallback`</ph> delegate.</source>
          <target state="translated">通常、このメソッドはによって、<ph id="ph1">`asyncCallback`</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation completes.</source>
          <target state="translated">このメソッドは、操作が完了するまでにはブロックされません。</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To block until the operation completes, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">操作が完了するまでをブロックするを使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">詳細については、非同期プログラミング モデルを使用して、次を参照してください<bpt id="p1">[</bpt>同期のメソッドを非同期に呼び出す。<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</source>
          <target state="translated">このメソッドにデータを読み込みます、<ph id="ph1">`buffer`</ph>パラメーター、およびデータの送信元となるエンドポイントをホストするリモート キャプチャだけでなく、受信したパケットに関する情報。</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">このエンドポイントを取得する方法についてを参照してください<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">送信するデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">非同期の送信を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 最初に呼び出す必要はない場合、例外がスローされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターが、接続されているを含む必要がありますまたは既定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されています。</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を要求したバイト数を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドを使用して、<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>最初を呼び出すことのコネクションレスのプロトコルでも、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">送信するデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">非同期の送信を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 最初に呼び出す必要はない場合、例外がスローされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターが、接続されているを含む必要がありますまたは既定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されています。</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を要求したバイト数を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドを使用して、<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Set メソッドを呼び出す、<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>元のスレッドに実行を継続する場合は、コールバック メソッドにします。</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>最初を呼び出すことのコネクションレスのプロトコルでも、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">送信するデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">データの送信を開始する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の、インデックス番号が 0 から始まる位置。</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">非同期の送信を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 最初に呼び出す必要はない場合、例外がスローされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターが、接続されているを含む必要がありますまたは既定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されています。</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を要求したバイト数を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドを使用して、<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>最初を呼び出すことのコネクションレスのプロトコルでも、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さより小さい値です。</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">送信するデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">データの送信を開始する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の、インデックス番号が 0 から始まる位置。</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">非同期の送信を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> 最初に呼び出す必要はない場合、例外がスローされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターが、接続されているを含む必要がありますまたは既定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されています。</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を要求したバイト数を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドを使用して、<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>最初を呼び出すことのコネクションレスのプロトコルでも、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ユーザー定義のクラスのインスタンス化します。</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins asynchronously sending data to a remote host.</source>
          <target state="translated">次のコード例では、リモート ホストへのデータを非同期的に送信を開始します。</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さより小さい値です。</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトに、ファイルを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to send.</source>
          <target state="translated">送信するファイルのパスと名前を格納する文字列。</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> flag.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> フラグを使用して、接続されている <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトにファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> を送信します。</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous send.</source>
          <target state="translated">非同期送信を表す <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">このオーバー ロードは、そのファイルを送信<ph id="ph1">`fileName`</ph>接続されたソケットにします。</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">場合<ph id="ph1">`fileName`</ph>されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">ワイルドカード ("..<ph id="ph1">\\</ph>\myfile.txt") と UNC 共有名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared ディレクトリ<ph id="ph5">\\</ph>\myfile.txt") はサポートされています。</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">ファイルが見つからない場合、例外<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">このメソッドを使用して、 <ph id="ph1">`TransmitFile`</ph> Windows Sockets 2 API である関数。</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">詳細については、<ph id="ph1">`TransmitFile`</ph>関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> 最初に呼び出す必要はありませんは例外をスロー <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドでは、個別の実行スレッド内のファイルを送信することができます。</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>パラメーターを委任します。</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターを含める必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されているオブジェクトします。</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このカスタム オブジェクトのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>ファイル全体を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>最初を呼び出すことのコネクションレスのプロトコルでも、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用してファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication.</source>
          <target state="translated">次のコード例では、作成し、非同期通信のソケットを接続します。</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>First, the file "text.txt" is sent asynchronously to the remote host.</source>
          <target state="translated">最初に、ファイル"text.txt"は、リモート ホストに非同期的に送信されます。</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">コールバック デリゲート呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>転送を完了します。</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">ソケットがリモート ホストに接続されていません。</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">ファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> が見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to be sent.</source>
          <target state="translated">送信されるファイルのパスと名前を格納する文字列。</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">ファイルが送信される前に送信されるデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 配列。</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">ファイルが送信された後で送信されるデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 配列。</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate to be invoked when this operation completes.</source>
          <target state="translated">このオプションの完了時に呼び出される <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するユーザー定義のオブジェクト。</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Sends a file and buffers of data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトに、ファイルとデータのバッファーを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous operation.</source>
          <target state="translated">非同期操作を表す <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>値。</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated"><ph id="ph1">`preBuffer`</ph>パラメーターには、ファイルの前にすべてのデータが含まれています。</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> ファイルを使用するデータが含まれています。</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">場合<ph id="ph1">`fileName`</ph>されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">ワイルドカード ("..<ph id="ph1">\\</ph>\myfile.txt") と UNC 共有名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared ディレクトリ<ph id="ph5">\\</ph>\myfile.txt") はサポートされています。</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">ファイルが見つからない場合、例外<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated"><ph id="ph1">`flags`</ph>パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">このパラメーターを使用する方法の詳細については、次を参照してください。<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">このメソッドを使用して、 <ph id="ph1">`TransmitFile`</ph> Windows Sockets 2 API である関数。</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">詳細については、<ph id="ph1">`TransmitFile`</ph>関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> 最初に呼び出す必要はありませんは例外をスロー <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドは、個別の実行スレッド内のファイルを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>パラメーターを委任します。</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターを含める必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されているオブジェクトします。</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このカスタム オブジェクトのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>ファイル全体を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述の詳細については、次を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>最初を呼び出すことのコネクションレスのプロトコルでも、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>In this example, a <ph id="ph1">`preBuffer`</ph> and a <ph id="ph2">`postBuffer`</ph> of data is created to send with the file and the default <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> value is used.</source>
          <target state="translated">この例では、<ph id="ph1">`preBuffer`</ph>と<ph id="ph2">`postBuffer`</ph>データのファイルとその既定値を送信するために作成が<ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>値を使用します。</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">コールバック デリゲート呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>転送を完了します。</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">オペレーティング システムは Windows NT 以降ではありません。</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> または</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">ソケットがリモート ホストに接続されていません。</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">ファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> が見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">送信するデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The zero-based position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin sending data.</source>
          <target state="translated">データ送信を開始する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> 内の、インデックス番号が 0 から始まる位置。</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> デリゲート。</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">この要求の状態情報を格納するオブジェクト。</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">特定のリモート ホストにデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">非同期の送信を参照する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドで指定されたリモート ホストへの非同期送信操作を開始、<ph id="ph2">`remoteEP`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">コネクションレス プロトコルは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>コネクションレス型との接続指向プロトコルの両方で動作します。</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.</source>
          <target state="translated">実装するコールバック メソッドを作成することができます、<ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph>を委任し、その名前を渡す、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">これを行う、非常に最小値で、<ph id="ph1">`state`</ph>パラメーターが、接続されているを含む必要がありますまたは既定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の通信に使用されています。</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、およびその他の必要な情報です。</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">このクラスのインスタンスを渡す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドによって、<ph id="ph2">`state`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッドを呼び出す必要がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">アプリケーションを呼び出すと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>まで、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を要求したバイト数を送信または例外をスローします。</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">場合は、元のスレッドをブロックを呼び出した後、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドを使用して、<ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information about writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">コールバック メソッドの記述に関する追加情報を参照してください。<bpt id="p1">[</bpt>コールバック メソッドとしてのデリゲートをマーシャ リング<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">最初に呼び出す必要がある接続指向のプロトコルを使用している場合、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッド、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>がスローされます、<ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> 無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターと送信のデータを<ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph>で確立されている、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、または<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">この呼び出しをする場合にだけ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph4">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">呼び出す場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph4">`remoteEP`</ph>パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">必要はありませんを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>In this case, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">この場合、基になるサービス プロバイダーは、最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">基になるサービス プロバイダーは、空いているポートを選択する場合は、ゼロのポート番号を使用します。</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>後プロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>メソッドが正常に完了するとします。</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">のバッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認必要もあります。</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">特定のコンテキストの初回使用後に (特定の非同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>メソッドは、特定の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously sends data to the specified remote host.</source>
          <target state="translated">次のコード例は、指定したリモート ホストにデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The local <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> to associate with the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に関連付けるローカル <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associates a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> with a local endpoint.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> をローカル エンドポイントと関連付けます。</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドを特定のローカル エンドポイントを使用する必要がある場合。</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>を呼び出す前に、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.</source>
          <target state="translated">呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>使用する前に、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド、ローカルの特定のエンドポイントを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>コネクションレス型との接続指向プロトコルの両方のメソッドです。</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.</source>
          <target state="translated">呼び出す前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>、ローカルを作成する必要がありますまず<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>データをやり取りするからです。</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local address is assigned, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.</source>
          <target state="translated">ローカル アドレスの割り当てを限定しない場合は、作成、<ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph>を使用して<ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph>アドレス パラメーターと、基になるサービス プロバイダーは、最も適切なネットワーク アドレスを割り当てます。</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This might help simplify your application if you have multiple network interfaces.</source>
          <target state="translated">これにより、複数のネットワーク インターフェイスがある場合に、アプリケーションを簡略化のに役立ちます。</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local port is used, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.</source>
          <target state="translated">使用されているローカル ポートを限定しない場合は、作成、<ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph>ポート番号として 0 を使用します。</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>In this case, the service provider will assign an available port number between 1024 and 5000.</source>
          <target state="translated">この場合、サービス プロバイダーは 1024 ~ 5000 で、使用可能なポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</source>
          <target state="translated">上記の方法を使用する場合は、呼び出すことによってどのようなローカル ネットワーク アドレスとポート番号が割り当てられてを検出することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>への呼び出しを行った後まで、ローカルで割り当てられているネットワーク アドレスは返されません、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合はありませんこの情報にアクセスする送信を完了したかが表示されるまでです。</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If a UDP socket wants to receive interface information on received packets,  the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">UDP ソケットがインターフェイスについては、受信したパケットを受信する場合は、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>と共にソケット オプションに設定して、メソッドを明示的に呼び出されなければなりません<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>呼び出し直後後、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you intend to receive multicast datagrams, you must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.</source>
          <target state="translated">マルチキャスト データグラムを受信する場合は、呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>マルチキャストのポート番号を持つメソッドです。</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド コネクションレス データグラムを使用して受信する場合、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を呼び出すときに、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドを使用して、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The following code example binds a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the specified local endpoint.</source>
          <target state="translated">次のコード例のバインド、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>指定したローカル エンドポイントを使用します。</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>for accepting connections from the host defined by <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</source>
          <target state="translated">によって定義されたホストからの接続を受け入れるため<ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>Gets or sets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is in blocking mode.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がブロッキング モードかどうかを示す値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will block; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がブロックする場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティを示すかどうか、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>ブロッキング モードでは、します。</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</source>
          <target state="translated">ブロッキング モードでは、すると、メソッドがすぐに完了しない場合、アプリケーションは、要求された操作が完了するまで実行をブロックします。</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you want execution to continue even though the requested operation is not complete, change the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">要求された操作の完了がいない場合でも続行、変更を実行する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティを<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティが非同期メソッドに対して影響を与えません。</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are sending and receiving data asynchronously and want to block execution, use the <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.</source>
          <target state="translated">使用している場合を送信し、データの非同期受信の実行をブロックする、<ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> methods.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> メソッドの 1 つを呼び出してリモート ホストへの接続を要求するために使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">リモート ホスト接続への非同期要求を取り消します。</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph>メソッドは、リモート ホスト接続への非同期要求をキャンセルします。</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="e" /&gt;</ph> パラメーターおよび <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> を null 値にすることはできません。</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> 接続を閉じ、関連付けられたすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> 接続を閉じ、関連付けられたすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージおよびアンマネージ リソースに関連付けられている、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">決算時に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティに設定されている<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">接続指向プロトコルは勧めを呼び出すこと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>呼び出す前に、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">呼び出す必要がある場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>最初呼び出さず<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>、データ キューを設定して送信される出力方向の送信にあることを確認することができます、 <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプションを<ph id="ph5">`false`</ph>と 0 以外のタイムアウト間隔を指定します。</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">設定した場合<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>に<ph id="ph2">`false`</ph>0 のタイムアウト間隔を指定して<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.</source>
          <target state="translated">設定する、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>ソケット オプションに<ph id="ph2">`false`</ph>、作成、 <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>、enabled プロパティを設定<ph id="ph4">`true`</ph>、設定と、<ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>プロパティ、目的のタイムアウト期間をします。</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">これを使用して<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と共に、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>ソケット オプションを呼び出して、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The following code example closes a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例が閉じ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Wait up to <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> seconds to send any remaining data, then close the socket.</source>
          <target state="translated">最大 <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージおよびアンマネージ リソースに関連付けられている、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">決算時に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティに設定されている<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</source>
          <target state="translated">接続指向プロトコルは勧めを呼び出すこと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id="ph4">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">呼び出す必要がある場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>最初呼び出さず<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>、データ キューを設定して送信される出力方向の送信にあることを確認することができます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>オプションを<ph id="ph4">`false`</ph>と 0 以外のタイムアウト間隔を指定します。</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">設定した場合<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>に<ph id="ph2">`false`</ph>0 のタイムアウト間隔を指定して<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.</source>
          <target state="translated">設定する、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>ソケット オプションに<ph id="ph2">`false`</ph>、作成、<ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>に有効なプロパティを設定<ph id="ph4">`true`</ph>、設定と、<ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>プロパティを目的のタイムアウト期間。</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">これを使用して<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と共に、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>ソケット オプションを呼び出して、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The following code example demonstrates how to close a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例を終了する方法を示しています、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">リモート ホストへの接続を確立します。</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the remote device.</source>
          <target state="translated">リモート デバイスを表す <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">リモート ホストへの接続を確立します。</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">TCP などの接続指向プロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドは同期的に間のネットワーク接続を確立<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>と指定したリモート エンドポイント。</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>既定のリモート ホストを確立します。</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>のリモート デバイスにデータを送信することができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッド、またはリモート デバイスからデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>リモート ホストを同期的に通信するためにします。</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド ブロックを明示的に設定する場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティを<ph id="ph3">`false`</ph>呼び出しの前に<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>時接続を確立する必要があるためです。</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>特定のエラー コードを取得します。</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、まだ完了していませんが正常にします。</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>タイミングを決定するメソッド、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が終了した接続です。</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出す<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>目的のエンドポイントを指定しています。</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">非同期のいずれかを使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を再接続する方法です。</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">次のコード例では、リモート エンドポイントに接続し、接続を検証します。</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっています。</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>for connecting to the remote host.</source>
          <target state="translated">リモート ホストに接続します。</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></source>
          <target state="translated">関連する列挙。 <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The IP address of the remote host.</source>
          <target state="translated">リモート ホストの IP アドレス。</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">リモート ホストのポート番号。</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">リモート ホストへの接続を確立します。</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The host is specified by an IP address and a port number.</source>
          <target state="translated">ホストは、IP アドレスとポート番号で指定されます。</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">TCP などの接続指向プロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドは同期的に間のネットワーク接続を確立<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>と指定したリモート エンドポイント。</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>既定のリモート ホストを確立します。</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>のリモート デバイスにデータを送信することができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッド、またはリモート デバイスからデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>リモート ホストを同期的に通信するためにします。</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> 具体的に設定していない場合、メソッドはブロック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティを<ph id="ph3">`false`</ph>呼び出しの前に<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>時接続を確立する必要があるためです。</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>特定のエラー コードを取得します。</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、まだ完了していませんが正常にします。</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>タイミングを決定するメソッド、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が終了した接続です。</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出す<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>目的のエンドポイントを指定しています。</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">非同期のいずれかを使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を再接続する方法です。</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">次のコード例では、リモート エンドポイントに接続し、接続を検証します。</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">ポート番号が無効です。</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ファミリのソケットで有効です。</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっています。</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The IP addresses of the remote host.</source>
          <target state="translated">リモート ホストの IP アドレス。</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">リモート ホストのポート番号。</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">リモート ホストへの接続を確立します。</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The host is specified by an array of IP addresses and a port number.</source>
          <target state="translated">ホストは、IP アドレスの配列とポート番号で指定されます。</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is typically used immediately after a call to <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.</source>
          <target state="translated">このメソッドはすぐに呼び出しの後に通常使用<ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>、1 つのホストの複数の IP アドレスを返すことができます。</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">TCP などの接続指向プロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドは同期的に間のネットワーク接続を確立<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>と指定したリモート エンドポイント。</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>既定のリモート ホストを確立します。</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>のリモート デバイスにデータを送信することができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッド、またはリモート デバイスからデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>リモート ホストを同期的に通信するためにします。</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> 具体的に設定していない場合、メソッドはブロック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティを<ph id="ph3">`false`</ph>呼び出しの前に<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>時接続を確立する必要があるためです。</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>特定のエラー コードを取得します。</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、まだ完了していませんが正常にします。</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>タイミングを決定するメソッド、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が終了した接続です。</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出す<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>目的のエンドポイントを指定しています。</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">非同期のいずれかを使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を再接続する方法です。</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">次のコード例では、リモート エンドポイントに接続し、接続を検証します。</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">ポート番号が無効です。</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ファミリのソケットで有効です。</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> の長さが 0 です。</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっています。</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The name of the remote host.</source>
          <target state="translated">リモート ホストの名前。</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">リモート ホストのポート番号。</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">リモート ホストへの接続を確立します。</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">ホストはホスト名とポート番号で指定されます。</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.</source>
          <target state="translated">TCP などの接続指向プロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドは同期的に間のネットワーク接続を確立<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>と指定したリモート ホストします。</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>既定のリモート ホストを確立します。</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>のリモート デバイスにデータを送信することができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッド、またはリモート デバイスからデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>リモート ホストを同期的に通信するためにします。</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> 具体的に設定していない場合、メソッドはブロック、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph>プロパティを<ph id="ph3">`false`</ph>呼び出しの前に<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>時接続を確立する必要があるためです。</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>特定のエラー コードを取得します。</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、まだ完了していませんが正常にします。</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>タイミングを決定するメソッド、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が終了した接続です。</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If IPv6 is enabled and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</source>
          <target state="translated">IPv6 が有効になっている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph>メソッドは両方とも IPv6 に解決されるホストに接続して IPv4 アドレス、IPv4 アドレスの前に最初に、IPv6 アドレスに接続試行します。</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</source>
          <target state="translated">これには、ホストが、IPv6 アドレスでリッスンしていない場合、接続の確立に時間が遅延の影響があります。</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出す<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>目的のエンドポイントを指定しています。</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">非同期のいずれかを使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を再接続する方法です。</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">これは、基になるプロバイダーの制限です。</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">次のコード例では、リモート エンドポイントに接続し、接続を検証します。</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">ポート番号が無効です。</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">このメソッドは、<ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> または <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ファミリのソケットで有効です。</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> は <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> を呼び出すことでリッスン状態になっています。</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">リモート ホストに接続する非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">リモート ホストに接続する非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドは、リモート ホストに接続するための非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>既定のリモート ホストを確立します。</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; を委任し、アタッチするためのコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">呼び出し元を設定する必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>リモート ホストに接続するのです。</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>のリモート ホストと通信します。</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>目的のエンドポイントを使用してメソッドです。</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>にブロードキャストを設定および<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">これが行われていない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが必要。</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドが成功します。</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">ここで、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>プロパティが送信するデータを格納しているバッファーに設定する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>プロパティをバッファーから送信するデータのバイト数に設定する必要があります。</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">接続が確立されると、このバッファーのデータが送信されます。</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているし、呼び出さないかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドでのスロー<ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>場合のアドレス ファミリ、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>と<ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>同じアドレス ファミリではありません。</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>このメソッドを呼び出したときに使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">引数が有効ではありません。</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">この例外は、複数のバッファーが指定されているときに、<ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> プロパティが null 値ではない場合に発生します。</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="e" /&gt;</ph> パラメーターおよび <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> を null 値にすることはできません。</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がリッスンしているか、<ph id="ph3">&lt;paramref name="e" /&gt;</ph> パラメーターで指定されている <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">この例外は、ローカル エンドポイントと <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> が同じアドレス ファミリではない場合にも発生します。</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">リモート ホストに接続する非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) メソッドは、リモート ホストに接続するための非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id="ph2">`socketType`</ph> and <ph id="ph3">`protocolType`</ph> parameters.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>で指定された既定のリモート ホストを確立、<ph id="ph2">`socketType`</ph>と<ph id="ph3">`protocolType`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; を委任し、アタッチするためのコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">呼び出し元を設定する必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>リモート ホストに接続するのです。</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>データを送受信する前にします。</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>のリモート ホストと通信します。</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">既定のリモート ホストを変更する場合は、呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>目的のエンドポイントを使用してメソッドです。</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>にブロードキャストを設定および<ph id="ph2">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">これが行われていない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが必要。</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドが成功します。</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">ここで、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>プロパティが送信するデータを格納しているバッファーに設定する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>プロパティをバッファーから送信するデータのバイト数に設定する必要があります。</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">接続が確立されると、このバッファーのデータが送信されます。</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">接続指向のプロトコルを使用しているし、呼び出さないかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドでのスロー<ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph>場合のアドレス ファミリ、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>と<ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>同じアドレス ファミリではありません。</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>このメソッドを呼び出したときに使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">引数が有効ではありません。</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">この例外は、複数のバッファーが指定されているときに、<ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> プロパティが null 値ではない場合に発生します。</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="e" /&gt;</ph> パラメーターおよび <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> を null 値にすることはできません。</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がリッスンしているか、<ph id="ph3">&lt;paramref name="e" /&gt;</ph> パラメーターで指定されている <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">この例外は、ローカル エンドポイントと <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> が同じアドレス ファミリではない場合にも発生します。</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Connected">
          <source>Gets a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is connected to a remote host as of the last <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> or <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> operation.</source>
          <target state="translated">最後に実行された <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> 操作または <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> 操作の時点で、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がリモート ホストに接続されていたかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">最後に実行された操作の時点で、<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がリモート リソースに接続されていた場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The <ph id="ph1">`Connected`</ph> property gets the connection state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.</source>
          <target state="translated"><ph id="ph1">`Connected`</ph>プロパティ、接続の状態を取得、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>最後の I/O 操作の時点でします。</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>When it returns <ph id="ph1">`false`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.</source>
          <target state="translated">返す場合<ph id="ph1">`false`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>されたか、接続されていない、または接続されていません。</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The value of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.</source>
          <target state="translated">値、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティには、最新の操作の時点で接続の状態が反映されます。</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</source>
          <target state="translated">接続の現在の状態を確認する必要がある場合は、非ブロッキングを持つ 0 バイトの Send 呼び出しをください。</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</source>
          <target state="translated">呼び出しの成功または WAEWOULDBLOCK エラー コード (10035) がスローされる場合、は、ソケットがまだ接続しているです。それ以外の場合、ソケットが接続していません。</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id="ph3">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.</source>
          <target state="translated">呼び出す場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>ユーザー データグラム プロトコル (UDP) ソケット上、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティは常に返します<ph id="ph3">`true`</ph>。 ただし、この操作では、UDP のコネクションレス型固有であるは変更されません。</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The following code example connects to a remote endpoint, checks the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property, and checks the current state of the connection.</source>
          <target state="translated">次のコード例は、チェックをリモート エンドポイントに接続する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティ、接続の現在の状態を確認します。</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在の接続の終了後、このソケットが再利用できる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>Closes the socket connection and allows reuse of the socket.</source>
          <target state="translated">ソケット接続を閉じ、ソケットを再利用できるようにします。</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you are using a connection-oriented protocol, you can use this method to close the socket.</source>
          <target state="translated">接続指向のプロトコルを使用している場合は、ソケットを閉じるにこのメソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method ends the connection and sets the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">このメソッドが設定されている接続およびセットには、終了、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティを<ph id="ph2">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>However, if <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">ただし場合、<ph id="ph1">`reuseSocket`</ph>は<ph id="ph2">`true`</ph>ソケットを再利用することができます。</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>To ensure that all data is sent and received before the socket is closed, you should call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.</source>
          <target state="translated">すべてのデータで送信および受信ソケットが閉じられる前にするを呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>呼び出す前に、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</source>
          <target state="translated">呼び出す必要がある場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>最初呼び出さず<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>、設定することができます、 <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプションを<ph id="ph5">`false`</ph>データ キューは送信方向の送信にあることを確認する 0 以外のタイムアウト間隔を指定します。</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> データが送信されるまで、または指定したタイムアウトが経過するまでブロックします。</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">設定した場合<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph>に<ph id="ph2">`false`</ph>0 のタイムアウト間隔を指定して<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The following code example creates a socket for synchronous communication and sends some data to a remote host.</source>
          <target state="translated">次のコード例では、同期通信のソケットを作成し、リモート ホストにいくつかのデータを送信します。</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>It then calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, to stop the send and receive activity, and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>, to close the socket connection.</source>
          <target state="translated">呼び出して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>を送信を停止し、受信アクティビティ、および<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>、ソケット接続を閉じます。</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method requires Windows 2000 or earlier, or the exception will be thrown.</source>
          <target state="translated">このメソッドは、Windows 2000 以前でのみサポートされます。それ以外の場合は、例外がスローされます。</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">リモート エンドポイントからの切断の非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.</source>
          <target state="translated">接続指向のプロトコルを使用する場合の呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph>メソッドがリモート エンドポイントからの接続が切断を要求します。</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`e`</ph> parameter, the socket can be reused.</source>
          <target state="translated">設定した場合<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph>に<ph id="ph2">`true`</ph>で、<ph id="ph3">`e`</ph>パラメーター、ソケットを再利用できます。</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="e" /&gt;</ph> パラメーターを null 値にすることはできません。</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターに指定された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> を使い終わったら <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> を呼び出します。</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> メソッドによって、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> は使用不可の状態になります。</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.</source>
          <target state="translated">呼び出した後<ph id="ph1">`Dispose`</ph>へのすべての参照を解放する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>ガベージ コレクターがメモリを再利用できるようにする、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>占有されていた。</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>アンマネージ リソースのクリーンアップ<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>と<bpt id="p2">[</bpt>Dispose メソッドの実装<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose`</ph> への最後の参照を解放する前に、必ず <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> を呼び出してください。</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">そうしないと、ガベージ コレクターが <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オブジェクトの <ph id="ph2">`Finalize`</ph> メソッドを呼び出すまで、使用されているリソースは解放されません。</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to releases only unmanaged resources.</source>
          <target state="translated">マネージ リソースとアンマネージ リソースの両方を解放する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。アンマネージ リソースだけを解放する場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, and optionally disposes of the managed resources.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が使用しているアンマネージ リソースを解放します。オプションでマネージ リソースも破棄します。</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">このメソッドは、パブリック<ph id="ph1">`Dispose()`</ph>メソッドおよび<ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> プロテクト呼び出します<ph id="ph2">`Dispose(Boolean)`</ph>メソッドを<ph id="ph3">`disposing`</ph>パラメーターに設定<ph id="ph4">`true`</ph>です。</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> 呼び出す<ph id="ph2">`Dispose`</ph>で<ph id="ph3">`disposing`</ph>'éý'<ph id="ph4">`false`</ph>です。</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.</source>
          <target state="translated"><ph id="ph1">`disposing`</ph> パラメーターが <ph id="ph2">`true`</ph> の場合、このメソッドは、この <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> が参照しているすべてのマネージ オブジェクトによって保持されているリソースをすべて解放します。</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">このメソッドは、参照される各オブジェクトの <ph id="ph1">`Dispose()`</ph> メソッドを呼び出します。</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> は、他のオブジェクトから複数回呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph> をオーバーライドする場合は、以前に <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">実装する方法の詳細についての<ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>を参照してください<bpt id="p1">[</bpt>Dispose メソッドの実装<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Overriding the Finalize Method<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">詳細については<ph id="ph1">&lt;see langword="Dispose" /&gt;</ph>と<ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>を参照してください<bpt id="p1">[</bpt>アンマネージ リソースのクリーンアップ<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept>と<bpt id="p2">[</bpt>Finalize メソッドをオーバーライドする<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>です。</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> でインターネット プロトコル (IP) データグラムの断片化を許可するかどうかを指定する <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> 値を、取得または設定します。</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows datagram fragmentation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> でデータグラムの断片化を許可する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</source>
          <target state="translated">データグラムでは、そのサイズが、最大転送単位 (MTU) の伝送媒体を超えたときに断片化が必要です。</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</source>
          <target state="translated">データグラムは、送信ホスト (すべてのインターネット プロトコル バージョン) または中間ルーター (インターネット プロトコル バージョン 4 のみ) で断片化している可能性があります。</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>If a datagram must be fragmented, and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</source>
          <target state="translated">場合は、データグラムを断片化している必要があります、および<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph>オプションが設定されている、データグラム破棄され、インターネット制御メッセージ プロトコル (ICMP) エラー メッセージが、データグラムの送信者に返されます。</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">このプロパティは、<ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ファミリまたは <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ファミリのソケットに対してだけ設定できます。</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> 値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a  dual-mode socket; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がデュアルモードのソケットの場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The ID of the target process where a duplicate of the socket reference is created.</source>
          <target state="translated">ソケット参照の複製が作成されるターゲット プロセスの ID。</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplicates the socket reference for the target process, and closes the socket for this process.</source>
          <target state="translated">ターゲット プロセスのソケット参照を複製してこのプロセスのソケットを閉じます。</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The socket reference to be passed to the target process.</source>
          <target state="translated">ターゲット プロセスに渡されるソケット参照。</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The target process should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.</source>
          <target state="translated">ターゲット プロセスを使用する必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>重複するソケットのインスタンスを作成します。</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.</source>
          <target state="translated">呼び出す場合は、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成する、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>と基になるソケットの同じインスタンスです。</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">この方法はお勧めします。</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If the process creating the socket uses asynchronous methods (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.</source>
          <target state="translated">ソケットを作成するプロセスは、非同期メソッドを使用している場合 (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>)、プロセスを設定する必要があります最初、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph>プロパティをソケットを引き起こす可能性があります、作成したプロセスの完了ポートへバインド true をそれ以外の場合、<ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph>ターゲット プロセスでスローされます。</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> is not a valid process id.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> が有効なプロセス ID ではありません。</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplication of the socket reference failed.</source>
          <target state="translated">ソケット参照の複製に失敗しました。</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> can send or receive broadcast packets.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> でブロードキャスト パケットの送受信を許可するかどうかを指定する <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> 値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows broadcast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> でブロードキャスト パケットを許可する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</source>
          <target state="translated">ブロードキャストが、特定のサブネットに制限されており、ユーザー データグラム プロトコル (UDP) を使用する必要があります。255.255.255.255 以外にパケットを送信することによってインターネット プロトコル バージョン 4 では、ローカル サブネットにブロードキャストことができます。または、ホストの部分を設定するすべてのビットをインターネット プロトコル (IP) アドレスの一部でネットワーク向けのブロードキャスト アドレスを使用することができます。</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</source>
          <target state="translated">たとえば、お客様の IP アドレスは 192.168.1.40 (255.255.255.0--ネットマスク付きのクラス C アドレスは、ネットワーク部分は、最初の 3 つのオクテットでは、およびホスト部分は、最後のオクテット、)、ブロードキャスト アドレスは 192.168.1.255 します。</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>This option is valid for a datagram socket only.</source>
          <target state="translated">このオプションは、データグラム ソケットに対してだけ有効です。</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Asynchronously accepts an incoming connection attempt.</source>
          <target state="translated">受信接続の試行を非同期的に受け入れます。</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">転送されたバイト数を格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">受信接続の試行を非同期的に受け入れ、新しい <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトを作成してリモート ホスト通信を処理します。</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data transferred.</source>
          <target state="translated">このメソッドは、転送される初期データを格納するバッファーを返します。</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">リモート ホストとの通信を処理する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 呼び出しを完了<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、によって呼び出されるコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを返します。</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">`asyncResult`</ph>を取得するパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>になる接続の試行が行われています。</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドが、接続試行を正常に完了します。</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated"><ph id="ph1">`buffer`</ph>このオーバー ロードのパラメーターへの呼び出しで受け取ったデータを格納して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>と<ph id="ph3">`bytesTransferred`</ph>パラメーターには呼び出しで転送されたバイト数が含まれています。</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドは、受信接続を許可し、新しい返します<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">次のコード例では<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>作成、ソケットを接続して、最初の 10 バイトのデータをそのまま使用します。</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">コールバック デリゲート呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>非同期要求を終了します。</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">送信バイト数と、データが返されます、<ph id="ph1">`buffer`</ph>と<ph id="ph2">`bytesTransferred`</ph>このメソッドのパラメーター、コンソールに表示されます。</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> への呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が作成されませんでした。</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> メソッドは既に呼び出されました。</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> へのアクセスを試みているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle remote host communication.</source>
          <target state="translated">受信接続の試行を非同期的に受け入れ、新しい <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> を作成してリモート ホスト通信を処理します。</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle communication with the remote host.</source>
          <target state="translated">リモート ホストとの通信を処理する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 呼び出しを完了<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを返します。</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">これに同意する必要があります、<ph id="ph1">`asyncResult`</ph>パラメーターから返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">`asyncResult`</ph>を取得するパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>になる接続の試行が行われています。</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドが、接続試行を正常に完了します。</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドは、受信接続を許可し、新しい返します<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The following code example ends an asynchronous request and creates a new <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept an incoming connection request.</source>
          <target state="translated">次のコード例は、非同期要求を終了し、新たに作成<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>受信接続要求を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">完全な例には、ソケットと非同期通信には、次を参照してください。<bpt id="p1">[</bpt>ソケットのコード例<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> への呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が作成されませんでした。</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>See the Remarks section for more information.</source>
          <target state="translated">詳細については、次の「解説」を参照してください。</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> メソッドは既に呼び出されました。</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">転送されたバイト数を格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transferred.</source>
          <target state="translated">転送されたバイト数。</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">受信接続の試行を非同期的に受け入れ、新しい <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトを作成してリモート ホスト通信を処理します。</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data and the number of bytes transferred.</source>
          <target state="translated">このメソッドは、初期データと、転送されたバイト数を格納するバッファーを返します。</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">リモート ホストとの通信を処理する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> 呼び出しを完了<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、によって呼び出されるコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドを返します。</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">これに同意する必要があります、<ph id="ph1">`asyncResult`</ph>パラメーターから返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">`asyncResult`</ph>を取得するパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>になる接続の試行が行われています。</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドが、接続試行を正常に完了します。</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated"><ph id="ph1">`buffer`</ph>このオーバー ロードのパラメーターへの呼び出しで受け取ったデータを格納して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>と<ph id="ph3">`bytesTransferred`</ph>パラメーターには呼び出しで転送されたバイト数が含まれています。</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>メソッドは、受信接続を許可し、新しい返します<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">次のコード例では<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>作成、ソケットを接続して、最初の 10 バイトのデータをそのまま使用します。</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">コールバック デリゲート呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>非同期要求を終了します。</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">送信バイト数と、データが返されます、<ph id="ph1">`buffer`</ph>と<ph id="ph2">`bytesTransferred`</ph>このメソッドのパラメーター、コンソールに表示されます。</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> への呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が作成されませんでした。</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> メソッドは既に呼び出されました。</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> へのアクセスを試みているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous connection request.</source>
          <target state="translated">保留中の非同期接続要求を終了します。</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> 非同期リモート ホスト接続要求を完了したブロッキング メソッド内で起動、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>を取得するパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>になる接続の試行が行われています。</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>メソッドが、接続試行を正常に完了します。</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The following code example ends the asynchronous connection attempt.</source>
          <target state="translated">次のコード例では、非同期接続の試行を終了します。</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">完全な例には、ソケットと非同期通信には、次を参照してください。<bpt id="p1">[</bpt>ソケットのコード例<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> は、非同期接続のために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.</source>
          <target state="translated">この非同期操作のステータス情報およびユーザー定義データを格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous disconnect request.</source>
          <target state="translated">保留中の非同期切断要求を終了します。</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> 呼び出しを完了<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph>メソッドは、切断が完了するまでブロックします。</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</source>
          <target state="translated">非同期操作については、MSDN ライブラリの非同期プログラミングの概要のトピックを参照してください。</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">データが送信されると、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>送信を停止し、受信アクティビティのために呼び出されます。</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>切断要求を開始すると呼びます。</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">コールバック デリゲート呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph>非同期要求を終了します。</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">要求が完了したら、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> は、非同期接続のために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The disconnect request has timed out.</source>
          <target state="translated">切断要求がタイムアウトしました。</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">保留中の非同期読み取りを終了します。</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">保留中の非同期読み取りを終了します。</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドで開始された非同期の読み取り操作が完了すると、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>に渡される状態オブジェクトを取得する、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">受信側の抽出<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>この状態オブジェクトから。</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、<ph id="ph2">`size`</ph>のパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">受信したデータを取得する呼び出し、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">[キャンセル] を保留中<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous read.</source>
          <target state="translated">次のコード例では、保留中の非同期読み取りを終了します。</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">完全な例には、ソケットと非同期通信には、次を参照してください。<bpt id="p1">[</bpt>ソケットのコード例<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> が、非同期の読み取りのために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated">この非同期操作の状態情報およびユーザー定義データを格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">保留中の非同期読み取りを終了します。</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドで開始された非同期の読み取り操作が完了すると、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>に渡される状態オブジェクトを取得する、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">受信側の抽出<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>この状態オブジェクトから。</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、<ph id="ph2">`size`</ph>のパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">受信したデータを取得する呼び出し、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、 <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> が、非同期の読み取りのために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">特定のエンドポイントからの、保留中の非同期読み込みを終了します。</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">正常に完了した場合は、受信したバイト数。</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">失敗した場合は、0 を返します。</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>メソッドで開始された非同期の読み取り操作が完了すると、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>に渡される状態オブジェクトを取得する、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">受信側の抽出<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>この状態オブジェクトから。</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、<ph id="ph2">`size`</ph>のパラメーター、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">受信したデータを取得する呼び出し、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>オブジェクト、および結果の状態オブジェクトに含まれているバッファーを抽出します。</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To identify the originating host, extract the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</source>
          <target state="translated">元のホストを識別するための抽出、<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>にキャストし、<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to obtain the IP address and the <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to obtain the port number.</source>
          <target state="translated">使用して、 <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> IP アドレスを取得するメソッドと<ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph>ポート番号を取得します。</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The following code example ends a pending asynchronous read from a specific <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</source>
          <target state="translated">次のコード例は、特定の保留中の非同期読み込みを終了<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> が、非同期の読み取りのために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated">この非同期操作の状態情報およびユーザー定義データを格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values for the received packet.</source>
          <target state="translated">受信パケットの <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</source>
          <target state="translated">コピー元 <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and interface of the received packet.</source>
          <target state="translated">受信パケットの <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> とインターフェイス。</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">特定のエンドポイントからの、保留中の非同期読み込みを終了します。</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method also reveals more information about the packet than <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</source>
          <target state="translated">また、このメソッドは、<ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> よりもパケットに関するより多くの情報を示します。</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">正常に完了した場合は、受信したバイト数。</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">失敗した場合は、0 を返します。</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If the operation has not completed, this method blocks until it does.</source>
          <target state="translated">操作が完了していない場合、このメソッドはそれまでブロックします。</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To perform this operation synchronously, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">この操作を同期的に実行するを使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Examine <ph id="ph1">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">調べる<ph id="ph1">`ipPacketInformation`</ph>かどうか、ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを知る必要があります。</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph> です</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> が、非同期の読み取りのために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">保留中の非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">保留中の非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">正常に終了した場合は <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信したバイト数。それ以外の場合は無効な <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> エラー。</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> 開始された非同期送信操作が完了した<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>送信を取得するパラメーター<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>バッファーの一部が送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">戻り値の場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>バッファーができなかったことを示します呼び出す完全に送信される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドを再度、未送信のデータを保持するバッファーを変更します。</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous send.</source>
          <target state="translated">次のコード例では、保留中の非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> が、非同期送信のために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information for this asynchronous operation.</source>
          <target state="translated">この非同期操作の状態情報を格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">保留中の非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">正常に終了した場合は <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信したバイト数。それ以外の場合は無効な <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> エラー。</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> 開始された非同期送信操作が完了した<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>送信を取得するパラメーター<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>バッファーの一部が送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">戻り値の場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph>バッファーができなかったことを示します呼び出す完全に送信される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドを再度、未送信のデータを保持するバッファーを変更します。</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> が、非同期送信のために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation.</source>
          <target state="translated">この非同期操作の状態情報を格納する <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Ends a pending asynchronous send of a file.</source>
          <target state="translated">ファイルの保留中の非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> 開始された非同期送信操作が完了した<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返されるオブジェクト、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>送信を取得するパラメーター<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>メソッドが正常に送信操作を完了します。</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>データグラムを送信するまでブロックします。</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>ファイル全体を送信するまでブロックします。</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">コールバック デリゲート呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph>転送を完了します。</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">このメソッドには Windows NT が必要です。</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> が、非同期の <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> のために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Ends a pending asynchronous send to a specific location.</source>
          <target state="translated">特定の場所への、保留中の非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If successful, the number of bytes sent; otherwise, an invalid <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">正常に完了した場合は送信したバイト数。それ以外の場合は無効な <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> エラー。</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> 開始された非同期送信操作が完了した<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>を実装するコールバック メソッドを作成する必要があります、<ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph>を委任します。</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>を返します。</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">コールバック メソッドに同意する必要があります、<ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドのパラメーターとして。</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">コールバック メソッド内で、<ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph>のメソッド、<ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>送信を取得するパラメーター<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">取得した後に、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、呼び出すことができます、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph>要求されたバイト数を送信するまでブロックされます。</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The following code example ends an asynchronous send to a specific location.</source>
          <target state="translated">次のコード例では、特定の場所への非同期送信を終了します。</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> メソッドへの呼び出しで <ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> が返されませんでした。</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> が、非同期送信のために以前に呼び出されています。</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one process to bind to a port.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> で 1 つのプロセスだけにポートのバインドを許可するかどうかを指定する <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> 値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> で 1 つのソケットだけに特定のポートのバインドを許可する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for all other versions.</source>
          <target state="translated">既定値は<ph id="ph1">&lt;see langword="true" /&gt;</ph>Windows Server 2003 および Windows XP Service Pack 2、および<ph id="ph2">&lt;see langword="false" /&gt;</ph>他のすべてのバージョン。</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`false`</ph>, multiple sockets can use the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph>は<ph id="ph2">`false`</ph>、複数のソケットを使用することができます、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>特定のポートにバインドするメソッド以外の場合は、ソケットの 1 つのみただしがポートに送信されるネットワーク トラフィックの操作を実行できます。</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If more than one socket attempts to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</source>
          <target state="translated">複数のソケットが使用を試みると、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph>より特定の IP アドレスを持つ 1 つはそのポートに送信されるネットワーク トラフィックを処理し、特定のポートにバインドするメソッド。</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the first use of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.</source>
          <target state="translated">場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph>は<ph id="ph2">`true`</ph>の最初の使用、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>インターネット プロトコル (IP) アドレスに関係なく、特定のポートにバインドしようとするメソッドは成功します。 の後続のすべての使用、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>元は、ソケットをバインドするまでのポートが失敗するようにバインドしようとするメソッドが破棄されます。</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>This property must be set before <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.</source>
          <target state="translated">このプロパティは、前に設定する必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>が呼び出された場合、<ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> has been called for this <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">この <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に対して <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> が呼び出されました。</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>Frees resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> クラスによって使用されていたリソースを解放します。</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスのファイナライザーの呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>を終了するメソッド、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>に関連付けられているリソースを解放し、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Returns the value of a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションの値を返します。</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Returns the value of a specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option, represented as an object.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションの値をオブジェクトとして返します。</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An object that represents the value of the option.</source>
          <target state="translated">オプションの値を表すオブジェクト。</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When the <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> parameter is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> the return value is an instance of the <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> パラメーターを <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> に設定した場合、戻り値は <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> クラスのインスタンスです。</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, the return value is an instance of the <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> を <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> または <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph> に設定した場合、戻り値は <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> クラスのインスタンスです。</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is any other value, the return value is an integer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> が他の値の場合、戻り値は整数です。</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、現在の動作を決定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Use this overload to get the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">このオーバー ロードを使用して取得する、 <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプション。</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>オプションを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の<ph id="ph3">`optionLevel`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>を使用して<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you want to set the value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">上記のオプションのいずれかの値の設定を使用する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">次のコード例の取得、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>タイムアウト値し、それらをコンソールに表示します。</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> was set to the unsupported value <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> が、サポートされていない値 <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph> に設定されました。</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is to receive the option setting.</source>
          <target state="translated">オプション設定を受信する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Returns the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option setting, represented as a byte array.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプション設定をバイト配列として返します。</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、現在の動作を決定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Upon successful completion of this method, the array specified by the <ph id="ph1">`optionValue`</ph> parameter contains the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</source>
          <target state="translated">このメソッドの正常完了時に、によって指定された配列、<ph id="ph1">`optionValue`</ph>パラメーターには、指定した値が含まれています。<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプション。</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>When the length of the <ph id="ph1">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">ときの長さ、<ph id="ph1">`optionValue`</ph>配列は、指定した値を格納するために必要なバイト数よりも小さい<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプション、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>がスローされます、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">このオーバー ロードを使用して、任意のソケットのブール値または整数値で表されます。</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">次のコード例の取得、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>タイムアウト値し、それらをコンソールに表示します。</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> または</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">ソケットごとのバッファー領域は、<ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph> を呼び出して変更できます。</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The length, in bytes, of the expected return value.</source>
          <target state="translated">予期される戻り値のバイト単位の長さ。</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Returns the value of the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option in an array.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションの値を配列で返します。</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the value of the socket option.</source>
          <target state="translated">ソケット オプションの値を格納している <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">`optionLength`</ph> parameter sets the maximum size of the returned byte array.</source>
          <target state="translated"><ph id="ph1">`optionLength`</ph>パラメーターが返されるバイト配列の最大サイズを設定します。</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires fewer bytes, the array will contain only that many bytes.</source>
          <target state="translated">オプションの値には、以下のバイト数が必要とする場合、配列にはそれだけ多くのバイト数。</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires more bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">オプションの値より多くの容量が必要な場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">このオーバー ロードを使用して、任意のソケットのブール値または整数値で表されます。</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">次のコード例の取得、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>タイムアウト値し、それらをコンソールに表示します。</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> または</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">ソケットごとのバッファー領域は、<ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph> を呼び出して変更できます。</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Handle">
          <source>Gets the operating system handle for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> のオペレーティング システム ハンドルを取得します。</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Handle">
          <source>An <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that represents the operating system handle for the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> のオペレーティング システム ハンドルを表す <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の下位操作モードを設定します。</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">実行する操作の制御コードを指定する <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> 値。</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the input data required by the operation.</source>
          <target state="translated">操作に必要な入力データを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 配列。</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the output data returned by the operation.</source>
          <target state="translated">操作によって返された出力データを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 配列。</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using numerical control codes.</source>
          <target state="translated">数値制御コードを使用して、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の下位操作モードを設定します。</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> パラメーターのバイト数。</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph>メソッドは、オペレーティング システムへの低レベルのアクセスを提供<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の現在のインスタンスの基になる、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of FIONREAD and the Available property.</source>
          <target state="translated">次のコード例では、FIONREAD と使用可能なプロパティの結果を比較します。</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">アンマネージ コードを実行します。</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">実行する操作の制御コードを指定する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> 値。</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the input data required by the operation.</source>
          <target state="translated">操作に必要な入力データを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the output data returned by the operation.</source>
          <target state="translated">操作によって返された出力データを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> enumeration to specify control codes.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> 列挙型を使用して制御コードを指定し、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の下位操作モードを設定します。</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> パラメーターのバイト数。</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This method provides low-level access to the operating system <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">このメソッドは、オペレーティング システムへの低レベルのアクセスを提供<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の現在のインスタンスの基になる、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>クラスです。</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> and the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property.</source>
          <target state="translated">次のコード例は、呼び出し元の結果を比較して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph>で<ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph>と<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">アンマネージ コードを実行します。</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a specific local port.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が特定のローカル ポートにバインドされているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a local port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がローカル ポートにバインドされている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>A socket is considered bound to a local port if it is explicitly bound by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.</source>
          <target state="translated">呼び出すことによって明示的にバインドされている場合、ソケットは、ローカル ポートにバインドされたと見なされます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド、またはのようなメンバーを呼び出すことによって暗黙的にバインドされた<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、または<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>、一時的なローカル ポート (空きポート 1024、オペレーティング システムによって選択されているより大きいです) を使用する。サーバーを使用して、<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>クライアントがそれらに接続できるように、既知のポートにバインドするメソッド。</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Gets or sets a value that specifies whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will delay closing a socket in an attempt to send all pending data.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> で、すべての保留中のデータを送信しようとするときにソケットを遅延して閉じるかどうかを指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> that specifies how to linger while closing a socket.</source>
          <target state="translated">ソケットを閉じているときの待機方法を指定する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>プロパティ方法を変更<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドは動作します。</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property when set modifies the conditions under which the connection can be reset by Winsock.</source>
          <target state="translated">このプロパティ セットが Winsock によってする接続をリセットすることができます、条件を変更する場合。</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Connection resets can still occur based on the IP protocol behavior.</source>
          <target state="translated">接続のリセットに IP プロトコルの動作に基づいて引き続き発生します。</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.</source>
          <target state="translated">このプロパティは、接続指向の接続を開いたまま呼び出しの後に時間の長さを制御<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>データが送信するのには残ります。</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</source>
          <target state="translated">呼び出すと、ピアにデータを送信する方法は、このデータが出力方向のネットワーク バッファーに配置されます。</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property can be used to ensure that this data is sent to the remote host before the <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.</source>
          <target state="translated">このプロパティは、前に、リモート ホストにこのデータが送信されるように使用できる、<ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph>メソッドは、接続を切断します。</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>To enable lingering, create a <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.</source>
          <target state="translated">接続を維持できるように、作成、 <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> 、目的の値を含むをインスタンス化し、設定、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>プロパティをこのインスタンスにします。</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following table describes the behavior of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">次の表の動作、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>メソッドの有効な値を<ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph>プロパティおよび<ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>に格納されているプロパティ、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.Enabled</source>
          <target state="translated">LingerState.Enabled</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.LingerTime</source>
          <target state="translated">LingerState.LingerTime</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Behavior</source>
          <target state="translated">動作</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`false`</ph> (disabled), the default value</source>
          <target state="translated"><ph id="ph1">`false`</ph> (無効)、既定値</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The time-out is not applicable, (default).</source>
          <target state="translated">タイムアウトは適用、されません (既定値)。</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the default IP protocol time-out expires.</source>
          <target state="translated">既定の IP プロトコル タイムアウトの期限が切れるまで、保留中のデータ送信を試みます。</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (有効)</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A nonzero time-out</source>
          <target state="translated">0 以外のタイムアウト</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</source>
          <target state="translated">指定したタイムアウトが経過するまでの試行が失敗した場合は、Winsock 接続がリセット保留中のデータ送信を試みます。</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (有効)</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A zero timeout.</source>
          <target state="translated">0 のタイムアウト</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Discards any pending data.</source>
          <target state="translated">保留中のデータを破棄します。</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>For connection-oriented socket (TCP, for example), Winsock resets the connection.</source>
          <target state="translated">接続志向ソケット (たとえば、TCP) の場合は、Winsock は接続をリセットします。</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</source>
          <target state="translated">IP スタックは、接続のラウンド トリップ時間に基づいて使用する既定の IP プロトコルのタイムアウト期間を計算します。</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>In most cases, the time-out computed by the stack is more relevant than one defined by an application.</source>
          <target state="translated">ほとんどの場合、スタックによって計算されたタイムアウトは、アプリケーションで定義された 1 より関連性が高いです。</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This is the default behavior for a socket when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.</source>
          <target state="translated">ソケットの既定の動作は、このとき、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>プロパティが設定されていません。</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</source>
          <target state="translated">ときに、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph>に格納されているプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>プロパティは、既定の IP プロトコル タイムアウトよりも大きい設定、既定の IP プロトコル タイムアウトを引き続き適用を上書きします。</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The maximum length of the pending connections queue.</source>
          <target state="translated">保留中の接続のキューの最大長。</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Places a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in a listening state.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> をリッスン状態にします。</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> 接続指向により<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>受信試行の接続をリッスンするようにします。</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.</source>
          <target state="translated"><ph id="ph1">`backlog`</ph>パラメーターできますのキューへの同意に着信接続の数を指定します。</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>To determine the maximum number of connections you can specify, retrieve the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.</source>
          <target state="translated">調べるには、接続の最大数を指定することができます、取得、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph>値。</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> ブロックされません。</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.</source>
          <target state="translated">使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>キューからの接続を受け入れます。</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>がスローされます、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The backlog parameter is limited to different values depending on the Operating System.</source>
          <target state="translated">バックログ パラメーターは、オペレーティング システムに応じて異なる値に制限されます。</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You may specify a higher value, but the backlog will be limited based on the Operating System.</source>
          <target state="translated">高い値を指定することがありますが、バックログは限られたオペレーティング システムに基づくです。</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connections.</source>
          <target state="translated">次のコード例では<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>受信接続をリッスンするようにします。</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>Gets the local endpoint.</source>
          <target state="translated">ローカル エンドポイントを取得します。</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using for communications.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> が通信に使用している <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>プロパティを取得、<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>するローカル IP アドレスとポート番号を格納している、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>がバインドされています。</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">これをキャストする必要があります<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>を<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>すべての情報を取得する前にします。</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local port number.</source>
          <target state="translated">呼び出すことができます、<ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph>ローカルを取得する方法を<ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph>ローカル ポート番号を取得します。</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>通常プロパティへの呼び出しを加えた後、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you allow the system to assign your socket's local IP address and port number, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.</source>
          <target state="translated">ソケットのローカル IP アドレスとポート番号を割り当てるシステムを許可する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>最初の I/O 操作の後にプロパティが設定されます。</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connection-oriented protocols, the first I/O operation would be a call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">接続指向プロトコルでは、最初の I/O 操作になりますへの呼び出し、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connectionless protocols, the first I/O operation would be any of the send or receive calls.</source>
          <target state="translated">コネクションレスのプロトコルを最初の I/O 操作では、送信のいずれかまたは受信呼び出しは。</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</source>
          <target state="translated">発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> receives outgoing multicast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が発信マルチキャスト パケットを受け取る場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Multicast is a scalable method for many-to-many communication on the Internet.</source>
          <target state="translated">マルチキャストは、インターネット上の多対多の通信用のスケーラブルな方法です。</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</source>
          <target state="translated">マルチキャスト アドレスをサブスクライブしているプロセス次に、サブスクライブしているプロセスが送信したすべてのパケットは、マルチキャスト アドレスをサブスクライブしている他のすべてのプロセスによって受信されます。</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the stream <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using the Nagle algorithm.</source>
          <target state="translated">ストリーム <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が Nagle アルゴリズムを使用するかどうかを指定する <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> 値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses the Nagle algorithm; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が Nagle アルゴリズムを使用する場合は <ph id="ph1">&lt;see langword="false" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</source>
          <target state="translated">Nagle アルゴリズムは、ソケット バッファーの小さなパケットを結合し、特定の状況で 1 つのパケットで送信したりすることで、ネットワーク トラフィックを減らすために設計されています。</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>A TCP packet consists of 40 bytes of header plus the data being sent.</source>
          <target state="translated">TCP パケットは、header、および送信されるデータの 40 バイトで構成されます。</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</source>
          <target state="translated">Tcp の小さいデータ パケットが送信されると、TCP ヘッダーに起因するオーバーヘッドは、ネットワーク トラフィックのかなりの部分になります。負荷の高いネットワークでは、このオーバーヘッドの結果として得られる輻輳失われたデータグラムと再送信、だけでなく輻輳による過剰な伝達時間なることができます。</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</source>
          <target state="translated">Nagle アルゴリズムでは、送信の新しい TCP segmentswhen 新しい未確認の接続で previouslytransmitted データが残っている場合、ユーザーから到着するデータを送信を禁止します。</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The majority of network applications should use the Nagle algorithm.</source>
          <target state="translated">ネットワーク アプリケーションの大部分は、Nagle アルゴリズムを使用する必要があります。</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</source>
          <target state="translated">ユーザー データグラム プロトコル (UDP) ソケットにこのプロパティを設定しても影響します。</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> へのアクセスを試みているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</source>
          <target state="translated">基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">オペレーティング システムおよびネットワーク アダプターが IPv4 プロトコルをサポートしている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</source>
          <target state="translated">基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">オペレーティング システムおよびネットワーク アダプターが IPv6 プロトコルをサポートしている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The time to wait for a response, in microseconds.</source>
          <target state="translated">マイクロ秒単位の待機時間。</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Determines the status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の状態を確認します。</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> based on the polling mode value passed in the <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="mode" /&gt;</ph> パラメーターで渡されるポーリング モードの値に基づいた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の状態。</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Mode</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> モード</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return Value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> 戻り値</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> has been called and a connection is pending;</source>
          <target state="translated"><ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> が呼び出されており、接続が保留中の場合は <ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data is available for reading;</source>
          <target state="translated">データを読み取ることができる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the connection has been closed, reset, or terminated;</source>
          <target state="translated">接続が閉じている、リセットされている、または終了している場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">それ以外の場合、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph>, and the connection has succeeded;</source>
          <target state="translated"><ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> を処理し、接続に成功した場合は <ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data can be sent;</source>
          <target state="translated">データを送信できる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">それ以外の場合、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> that does not block, and the connection has failed;</source>
          <target state="translated">ブロックしない <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> を処理し、接続に失敗した場合は <ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> is not set and out-of-band data is available;</source>
          <target state="translated"><ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> が設定されておらず、帯域外データを使用できる場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">それ以外の場合、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>メソッドの状態を確認、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`selectMode`</ph> parameter to determine if the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph>の<ph id="ph2">`selectMode`</ph>パラメーターかどうかを<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を読み取ることができます。</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.</source>
          <target state="translated">指定<ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph>かどうかを<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が書き込み可能です。</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> to detect an error condition.</source>
          <target state="translated">使用して<ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph>エラー状態を検出するためにします。</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id="ph2">`microseconds`</ph>, elapses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> 単位で指定された期間までの実行がブロックされます<ph id="ph2">`microseconds`</ph>が経過しました。</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Set the <ph id="ph1">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.</source>
          <target state="translated">設定、<ph id="ph1">`microSeconds`</ph>の応答を無限に待機する場合は負の整数へのパラメーターです。</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you want to check the status of multiple sockets, you might prefer to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">複数のソケットの状態を確認するには、使用を好む場合がある、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できない場合や、リモート ホストが異常停止されたことです。</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The following code example creates a socket, connects to a server, and uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> to check the status of the socket.</source>
          <target state="translated">次のコード例は、ソケットを作成しは、サーバーに接続を使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>ソケットの状態を確認します。</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="mode" /&gt;</ph> パラメーターが、<ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> 値の 1 つではありません。</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>See remarks below.</source>
          <target state="translated">以下の「解説」を参照してください。</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>Gets the protocol type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> のプロトコルの種類を取得します。</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph>場合、プロパティが設定、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が作成されを使用するプロトコルを指定<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">次のコード例では表示、 <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>コンソールにします。</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信します。</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer.</source>
          <target state="translated">バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信し、受信バッファーに格納します。</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">呼び出すことができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>接続指向とコネクションレス ソケットの両方からです。</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This overload only requires you to provide a receive buffer.</source>
          <target state="translated">のみこのオーバー ロードでは、受信バッファーを提供する必要があります。</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">バッファーの既定値は 0、サイズの既定値は、パラメーターの長さ、バッファー、オフセット、および<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>値の既定値は<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレス型を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffer`</ph>パラメーター、<ph id="ph2">`buffer`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The following code example receives data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、接続上のデータを受け取る<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">受信したデータを格納する <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> 型の複数の <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> のリスト。</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers.</source>
          <target state="translated">バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信して、受信バッファーのリストに格納します。</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method reads data into the buffers parameter and returns the number of bytes successfully read.</source>
          <target state="translated">このメソッドは、バッファー パラメーターにデータを読み取りますを正常に読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">接続指向とコネクションレス ソケットの両方から呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">場合は、コネクションレス型を使用している<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffers`</ph>パラメーター、<ph id="ph2">`buffers`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated"><bpt id="p1">**</bpt>注<ept id="p1">**</ept>このメンバーは、アプリケーションでネットワーク トレースを有効にする場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> パラメーターが <ph id="ph2">&lt;see langword="null" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試みているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信して受信バッファーに格納します。</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">呼び出すことができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>接続指向とコネクションレス ソケットの両方からです。</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">このオーバー ロードだけ指定する必要が受信バッファーと、必要な<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</source>
          <target state="translated">バッファーのオフセットの既定値は 0 で、サイズの既定値はバイト パラメーターの長さ。</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、プロトコル スタック バッファーの使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、再試行してください、受信操作します。</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、バッファーのサイズの最大使用量のデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">場合は、コネクションレス型を使用している<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffer`</ph>パラメーター、<ph id="ph2">`buffer`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for receiving data on a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、データ バッファーを指定し、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>接続上のデータを受信するため<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">受信したデータを格納する <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> 型の複数の <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> のリスト。</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信して受信バッファーのリストに格納します。</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">このメソッドにデータを読み込みます、<ph id="ph1">`buffers`</ph>パラメーターと正常に読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">接続指向とコネクションレス ソケットの両方から呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>値の既定値は<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>スローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">場合は、コネクションレス型を使用している<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffers`</ph>パラメーター、<ph id="ph2">`buffers`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates how to receive data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、接続上のデータを受信する方法を示します<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count が 0 です。</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試みているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes of data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> から指定したバイト数のデータを受信して受信バッファーに格納します。</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドへのデータを読み取り、<ph id="ph2">`buffer`</ph>パラメーターと正常に読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">呼び出すことができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>接続指向とコネクションレス ソケットの両方からです。</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">このオーバー ロードだけが必要です、受信バッファー、バイトを受信して、必要な数を指定する<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、再試行してください、受信操作します。</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id="ph3">`size`</ph> parameter.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、数で指定したバイトの使用可能な多くのデータを読み取る、<ph id="ph3">`size`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレス型を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffer`</ph>パラメーター、<ph id="ph2">`buffer`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following receives the data found into <ph id="ph1">`buffer`</ph>, and specifies <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">次にデータを受信する<ph id="ph1">`buffer`</ph>を指定して<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>の<ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> のサイズを超えています。</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">受信したデータを格納する <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> 型の複数の <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> のリスト。</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信して受信バッファーのリストに格納します。</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">このメソッドにデータを読み込みます、<ph id="ph1">`buffers`</ph>パラメーターと正常に読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">接続指向とコネクションレス ソケットの両方から呼び出すことができます。</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>値の既定値は<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>スローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレス型を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffers`</ph>パラメーター、<ph id="ph2">`buffers`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count が 0 です。</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試みているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">受信したデータの格納場所である、<ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">受信データを格納する <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> 内の場所。</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> から指定したバイト数のデータを受信して、受信バッファー内の指定したオフセット位置に格納します。</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">呼び出すことができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>接続指向とコネクションレス ソケットの両方からです。</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>See Remarks below.</source>
          <target state="translated">以下の「解説」を参照してください。</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な多くのデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレス型を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffer`</ph>パラメーター、<ph id="ph2">`buffer`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、接続上のデータを受信する前に、データ バッファー、オフセット、サイズ、およびソケット フラグを指定します。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> プロパティが設定されていませんでした。</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">受信したデータを格納する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の位置。</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、バインドされた <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> からデータを受信して受信バッファーに格納します。</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">呼び出すことができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>接続指向とコネクションレス ソケットの両方からです。</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している必要がありますか呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>を呼び出す前に着信接続を受け入れるように<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、使用することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> すべてのホストから着信するデータを受信できます。</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>しないデータがある、タイムアウト値を使用して設定された場合を除き、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>See Remarks below.</source>
          <target state="translated">以下の「解説」を参照してください。</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">接続指向を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な多くのデータを読み取る。</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">コネクションレス型を使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか、<ph id="ph1">`buffer`</ph>パラメーター、<ph id="ph2">`buffer`</ph>設定します。 メッセージの最初の部分に余分なデータは失われますと<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property is not set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> プロパティが設定されていません。</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトからデータを受信する非同期要求を開始します。</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>メソッドを使用してのソケットまたはバインドされたコネクションレス ソケットを接続および着信データの読み取りに使用します。</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">ソケットのローカル アドレスは認識されている必要があります。</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</source>
          <target state="translated">バインドのコネクションレス ソケットは、この関数は、受信したメッセージの受け入れ元となるアドレスを制限します。</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The function only returns messages from the remote address specified in the connection.</source>
          <target state="translated">関数には、接続で指定されたリモート アドレスからのメッセージのみを返します。</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Messages from other addresses are silently discarded.</source>
          <target state="translated">その他のアドレスからのメッセージが自動的に破棄されます。</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">`e`</ph>パラメーターが読み取り要求に関する追加情報がウィンドウのソケットのサービス プロバイダーを提供します。</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">このパラメーターを使用する方法の詳細については、次を参照してください。<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが正常にこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> または <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> 場合<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> 場合<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">バイト ストリーム スタイルのソケットの受信データが、バッファーが指定された、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id="ph1">`e`</ph> parameter.</source>
          <target state="translated">関連付けられているバッファーの合計サイズの最大バッファーにメッセージ指向のソケットの場合は、受信メッセージが配置されて、<ph id="ph1">`e`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the message is larger than the buffer, the buffer is filled with the first part of the message.</source>
          <target state="translated">メッセージがバッファーよりも大きい場合は、バッファーがメッセージの最初の部分が入力されます。</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For connection-oriented sockets, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</source>
          <target state="translated">接続指向のソケットに対して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph>メソッドが正常に終了するかどうか、ソケットは、バイト ストリーム メッセージ指向に依存している 2 つの方法のいずれかで仮想回線を示すことができます。</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</source>
          <target state="translated">バイト ストリーム、正常に閉じられたと以上のバイトを読み取ることが 0 バイトが読み取られたことを示します。</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, where a zero byte message is often allowable, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</source>
          <target state="translated">ここで、ゼロ バイトのメッセージがで使用できる多くの場合、メッセージ指向のソケットの<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>で、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>ネイティブ Winsock WSAEDISCON エラー コード (10101) に設定が正常に閉じられたを示すために使用します。</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In any case, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</source>
          <target state="translated">いずれの場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>で、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>ネイティブ Winsock WSAECONNRESET に設定エラー コード (10054) を示す強制終了が発生しました。</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument was invalid.</source>
          <target state="translated">引数が無効です。</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> プロパティまたは <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> プロパティは、有効なバッファーを参照する必要があります。</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターに指定された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Gets or sets a value that specifies the size of the receive buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の受信バッファーのサイズを指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the receive buffer.</source>
          <target state="translated">受信バッファーのサイズ (バイト単位) を格納している <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">既定値は 8192 です。</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</source>
          <target state="translated">大きなバッファー サイズは可能性がある空の受信確認 (TCP パケット データ部分はありません) の数を削減は、接続に関する問題を認識を遅らせるも可能性があります。</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなどです。) を使用している場合は、バッファー サイズを増やすことを検討してください。</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">設定操作として指定された値が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives a datagram and stores the source endpoint.</source>
          <target state="translated">データグラムを受信し、ソース エンドポイントを格納します。</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">受信したデータの格納場所である、<ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">リモート サーバーを表す、参照渡しされた <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer and stores the endpoint.</source>
          <target state="translated">データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドへのデータを読み取り、<ph id="ph2">`buffer`</ph>パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive <ph id="ph1">`buffer`</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">このオーバー ロードだけ指定する必要が receive <ph id="ph1">`buffer`</ph>、および<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>リモート ホストを表すです。</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">バッファーは、既定値は 0 をオフセットします。</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The size defaults to the length of the <ph id="ph1">`buffer`</ph> parameter and the <ph id="ph2">`socketFlags`</ph> value defaults to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">既定値の長さは、サイズ、<ph id="ph1">`buffer`</ph>パラメーターおよび<ph id="ph2">`socketFlags`</ph>値の既定値は<ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>、明示的にバインドする必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、ローカル エンドポイントを<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">そうしない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">コネクションレスのプロトコルで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは入力<ph id="ph3">`buffer`</ph>メッセージは、可能であれば、throw の多くで、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">信頼性の低いプロトコルを使用している場合、余分なデータが失われます。</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>のに十分な大きさのバッファーを持つメソッドです。</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、接続を呼び出す前に許可しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドが表示されます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">接続指向のソケットと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>のサイズの最大使用量のデータを読み取る<ph id="ph2">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>と一致する必要があります、<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">次のコード例では、リモート ホストからコネクションレス データグラムを受信します。</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">受信したデータの保存場所となる <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">リモート サーバーを表す、参照渡しされた <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドへのデータを読み取り、<ph id="ph2">`buffer`</ph>パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">このオーバー ロードだけ指定する必要が受信バッファー、必要な<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>、および<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>リモート ホストを表すです。</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset defaults to 0 and the size defaults to the length of the buffer parameter.</source>
          <target state="translated">オフセットの既定値 0 およびサイズの既定値は、バッファーのパラメーターの長さ。</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>、明示的にバインドする必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、ローカル エンドポイントを<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">そうしない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">コネクションレスのプロトコルで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは入力<ph id="ph3">`buffer`</ph>メッセージは、可能であれば、throw の多くで、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">信頼性の低いプロトコルを使用している場合、余分なデータが失われます。</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>のに十分な大きさのバッファーを持つメソッドです。</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、接続を呼び出す前に許可しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドが表示されます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">接続指向のソケットと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>のサイズの最大使用量のデータを読み取る<ph id="ph2">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>と一致する必要があります、<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">次のコード例では、リモート ホストからコネクションレス データグラムを受信します。</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> 渡される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">受信したデータの格納場所である、<ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">リモート サーバーを表す、参照渡しされた <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、指定したバイト数のデータを受信してデータ バッファーに格納します。さらに、エンドポイントを格納します。</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドへのデータを読み取り、<ph id="ph2">`buffer`</ph>パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">このオーバー ロードだけ指定する必要が、必要なを受信するバイト数、受信バッファー <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>、および<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>リモート ホストを表すです。</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">バッファーは、既定値は 0 をオフセットします。</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">コネクションレスのプロトコルで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは入力<ph id="ph3">`buffer`</ph>メッセージは、可能であれば、throw の多くで、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">信頼性の低いプロトコルを使用している場合、余分なデータが失われます。</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>のに十分な大きさのバッファーを持つメソッドです。</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、接続を呼び出す前に許可しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドが表示されます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">接続指向のソケットと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>がで指定したバイトの数まで使用できる多くのデータを読み取り、<ph id="ph2">`size`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>、明示的にバインドする必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、ローカル エンドポイントを<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">そうしない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>と一致する必要があります、<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">次のコード例では、リモート ホストからコネクションレス データグラムを受信します。</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">バッファー サイズ、および<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>に渡される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> プロパティが設定されていませんでした。</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">受信したデータの格納場所である、<ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">受信したデータを格納する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の位置。</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">リモート サーバーを表す、参照渡しされた <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドへのデータを読み取り、<ph id="ph2">`buffer`</ph>パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">コネクションレスのプロトコルで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">受信したデータグラムがのサイズよりも大きいかどうか<ph id="ph1">`buffer`</ph>、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは入力<ph id="ph3">`buffer`</ph>メッセージは、可能であれば、throw の多くで、<ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">信頼性の低いプロトコルを使用している場合、余分なデータが失われます。</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>のに十分な大きさのバッファーを持つメソッドです。</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">読み取り、使用可能なデータがない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはデータが読み取られるまでブロックします。</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">使用することができます、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>プロパティ データが読み取り可能かを判断します。</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">ときに<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph>0 以外の場合は、受信操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、接続を呼び出す前に許可しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドが表示されます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドは無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">接続指向のソケットと<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>はバイト単位で指定された量まで利用可能な量のデータを読み取り、<ph id="ph2">`size`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">リモート ホストがシャット ダウンした場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>との接続、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッド、および利用可能なすべてのデータを受信、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドはすぐに完了し、0 バイトを返します。</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>、明示的にバインドする必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を使用して、ローカル エンドポイントを<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">そうしない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>と一致する必要があります、<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">次のコード例では、リモート ホストからコネクションレス データグラムを受信します。</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset, buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">オフセット、バッファー サイズ、および<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>に渡される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さからオフセット パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> プロパティが設定されていませんでした。</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">指定したネットワーク デバイスから、データの非同期の受信を開始します。</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>コネクションレス ソケット上のデータを受信するには、主にメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">ソケットのローカル アドレスは認識されている必要があります。</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">呼び出し元を設定する必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>リモート ホストの元のデータを受信することです。</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">`e`</ph>パラメーターが読み取り要求に関する追加情報がウィンドウのソケットのサービス プロバイダーを提供します。</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">このパラメーターを使用する方法の詳細については、次を参照してください。<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが正常にこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">バイト ストリーム – スタイルのソケットの受信データが、バッファーが指定された、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> に null 値を指定することはできません。</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターに指定された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">受信したデータの格納場所である、<ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">受信したデータを格納する、<bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> パラメーター内の位置。</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">受信するバイト数。</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">リモート サーバーを表す、参照渡しされた <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> holding address and interface information.</source>
          <target state="translated">アドレスとインターフェイスの情報を保持する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes received.</source>
          <target state="translated">受信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>メソッドへのデータを読み取り、<ph id="ph2">`buffer`</ph>パラメーターが正常に読み取られたバイト数を返し、データの送信元、受信したパケットに関する情報だけでなく、リモート ホストのエンドポイントをキャプチャします。</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>コネクションレス ソケットでメッセージ データを受信するには、主にメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket's local address must be known.</source>
          <target state="translated">ソケットのローカル アドレスは認識されている必要があります。</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">このメソッドは、データグラムと生のソケットとのみ使用できます。</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">ソケットの種類に設定されたソケットを初期化する必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph>このメソッドを呼び出す前にします。</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">これを使用して、ソケットを作成するとき<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For message-oriented sockets, an incoming message is placed into the <ph id="ph1">`buffer`</ph> parameter up to the total size specified in the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">メッセージ指向のソケットでは、受信メッセージに配置、<ph id="ph1">`buffer`</ph>パラメーターで指定された合計サイズの最大、<ph id="ph2">`size`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">`offset`</ph> parameter determines where in the <ph id="ph2">`buffer`</ph> the data is placed.</source>
          <target state="translated"><ph id="ph1">`offset`</ph>パラメーター内の場所を決定する、<ph id="ph2">`buffer`</ph>データが配置されます。</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The actual amount of data placed into the <ph id="ph1">`buffer`</ph> is returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">配置している実際のデータ量、<ph id="ph1">`buffer`</ph>によって返される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>メソッドに自動的にメソッドを設定、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>ソケット オプションに<ph id="ph3">`true`</ph>初めて呼び出された、指定された<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>However, the returned <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">ただし、返された<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>オブジェクトがのみ有効になります、ソケット オプションが設定された後に、ローカル コンピューターに到達するパケットです。</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">ローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドまたはの 1 つによって暗黙的に、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッド) とその最初の呼び出し、<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>へのメソッドを呼び出し<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph>メソッドは無効な<ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>これらのパケットのオブジェクト。</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">ようにすべて<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>オブジェクトが有効で、アプリケーションを設定する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>ソケット オプションに<ph id="ph3">`true`</ph>を使用して、ローカル エンドポイントにバインドされる前に、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An application can examine the <ph id="ph1">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">アプリケーションを調べることができます、<ph id="ph1">`ipPacketInformation`</ph>ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを把握する必要がある場合のパラメーターです。</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>と一致する必要があります、<ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>の<ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph>で使用される<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">\-</ph> or-</source>
          <target state="translated"><ph id="ph1">\-</ph> または</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さからオフセット パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> プロパティが設定されていませんでした。</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The .NET Framework is running on an AMD 64-bit processor.</source>
          <target state="translated">.NET Framework が、AMD 64 ビット プロセッサ上で実行されています。</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">ネットワークからの接続を受け入れるため。</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph> (関連する列挙体)</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">指定された <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph> を使用し、指定されたバイト数のデータの非同期受信を開始して、データ バッファー内の指定された場所に格納します。さらに、エンドポイントとパケットの情報を格納します。</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>コネクションレス ソケットでメッセージ データを受信するには、主にメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">ソケットのローカル アドレスは認識されている必要があります。</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">このメソッドは、データグラムと生のソケットとのみ使用できます。</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">ソケットの種類に設定されたソケットを初期化する必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph>このメソッドを呼び出す前にします。</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">これを使用して、ソケットを作成するとき<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">呼び出し元を設定する必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>リモート ホストの元のデータを受信することです。</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが正常にこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>メソッドが自動的に設定、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>ソケット オプションに<ph id="ph3">`true`</ph>初めて呼び出された、指定された<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>However, the <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">ただし、<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>オブジェクトがのみ有効になります、ソケット オプションが設定された後に、ローカル コンピューターに到達するパケットです。</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">ソケットがローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドまたはの 1 つによって暗黙的に、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、または<ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッド) および最初の呼び出し、<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>へのメソッドを呼び出し<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>メソッドは無効になります<ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>これらのパケットのオブジェクト。</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">ようにすべて<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>オブジェクトが有効で、アプリケーションを設定する必要があります、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>ソケット オプションに<ph id="ph3">`true`</ph>を使用して、ローカル エンドポイントにバインドされる前に、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An application can examine the resulting <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">アプリケーションは、その結果を調べることができます<ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph>オブジェクトのかどうか、ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを知る必要があります。</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> に null 値を指定することはできません。</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> call will time out.</source>
          <target state="translated">同期の <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">タイムアウト値 (ミリ秒)。</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">既定値は 0 です。タイムアウトが無期限であることを示します。</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">-1 の指定も、タイムアウトが無期限であることを示します。</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.</source>
          <target state="translated">このオプションを適用する同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>呼び出しのみです。</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト期間を超えた場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">設定操作として指定された値が -1 未満です。</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>Gets the remote endpoint.</source>
          <target state="translated">リモート エンドポイントを取得します。</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> with which the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is communicating.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> の通信先の <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.</source>
          <target state="translated">接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>プロパティを取得、<ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph>するリモート IP アドレスとポート番号を格納している、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が接続されています。</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>既定リモート IP アドレスとポート番号が含まれています、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>と通信します。</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">これをキャストする必要があります<ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>を<ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>すべての情報を取得する前にします。</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote port number.</source>
          <target state="translated">呼び出すことができます、<ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph>リモートを取得する方法を<ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph>をリモートのポート番号を取得する方法です。</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>いずれかへの呼び出し後に設定されている<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you try to access this property earlier, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">以前にこのプロパティにアクセスしようとする場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for readability.</source>
          <target state="translated">読みやすさを確認する <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> インスタンスの <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for writability.</source>
          <target state="translated">書き込み機能をチェックする <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> インスタンスの <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for errors.</source>
          <target state="translated">エラーをチェックする <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> インスタンスの <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The time-out value, in microseconds.</source>
          <target state="translated">タイムアウト値 (マイクロ秒)。</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>A -1 value indicates an infinite time-out.</source>
          <target state="translated">値が -1 の場合は、タイムアウトが無限であることを示します。</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Determines the status of one or more sockets.</source>
          <target state="translated">1 つまたは複数のソケットのステータスを判断します。</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> 1 つまたは複数のステータスを決定する静的メソッドは、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must place one or more sockets into an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">1 つまたは複数のソケットを配置する必要があります、<ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph>使用する前に、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Check for readability by calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id="ph3">`checkRead`</ph> parameter.</source>
          <target state="translated">読みやすさを呼び出して確認<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>で、<ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>として、<ph id="ph3">`checkRead`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>To check your sockets for writability, use the <ph id="ph1">`checkWrite`</ph> parameter.</source>
          <target state="translated">確認するには、どうを使用して、<ph id="ph1">`checkWrite`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>For detecting error conditions, use <ph id="ph1">`checkError`</ph>.</source>
          <target state="translated">エラー条件を検出するため使用<ph id="ph1">`checkError`</ph>です。</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.</source>
          <target state="translated">呼び出した後<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>、<ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>の条件を満たすソケットのみが格納されます。</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you are in a listening state, readability means that a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.</source>
          <target state="translated">リッスン状態の場合は、読みやすくすることを意味する呼び出し<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>ブロックすることがなくは成功します。</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have already accepted the connection, readability means that data is available for reading.</source>
          <target state="translated">接続を受け入れている場合、読みやすさはデータが読み取り可能であるを意味します。</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>In these cases, all receive operations will succeed without blocking.</source>
          <target state="translated">このような場合は、すべての受信操作はブロックすることがなく成功します。</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Readability can also indicate whether the remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.</source>
          <target state="translated">読みやすくすることもあるかどうか、リモート<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>がシャット ダウン接続以外の場合はそのケースへの呼び出し<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>は返されたゼロのバイト数で、すぐに戻ります。</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, and <ph id="ph4">`checkError`</ph> lists) meets its specified criteria, or the <ph id="ph5">`microSeconds`</ph> parameter is exceeded, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> 時に返す目的のソケットの少なくとも 1 つ (におけるソケット、 <ph id="ph2">`checkRead`</ph>、 <ph id="ph3">`checkWrite`</ph>、および<ph id="ph4">`checkError`</ph>を一覧表示) が、指定した条件を満たしている、または<ph id="ph5">`microSeconds`</ph>パラメーターを超過すると、どちらか早い方です。</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Setting <ph id="ph1">`microSeconds`</ph> to -1 specifies an infinite time-out.</source>
          <target state="translated">設定<ph id="ph1">`microSeconds`</ph>を-1 に無限のタイムアウトを指定します。</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you make a nonblocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.</source>
          <target state="translated">非ブロッキング呼び出しを行う場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、書き込みの許可が正常に接続していることを意味します。</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you already have a connection established, writability means that all send operations will succeed without blocking.</source>
          <target state="translated">確立された接続がある場合、書き込みの許可は、すべての送信操作はブロックすることがなく成功を意味します。</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have made a non-blocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id="ph2">`checkerror`</ph> parameter identifies sockets that have not connected successfully.</source>
          <target state="translated">非ブロッキング呼び出しを行ったかどうか<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、<ph id="ph2">`checkerror`</ph>パラメーターが正常に接続されていないソケットを識別します。</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">使用して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph>メソッドの場合は、1 つの状態を判別する<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できない場合や、リモート ホストが異常停止されたことです。</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> to determine which listening sockets have a connection request.</source>
          <target state="translated">次のコード例では<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>接続要求をリッスンしているソケットを決定します。</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> パラメーターは <ph id="ph2">&lt;see langword="null" /&gt;</ph> または空です。</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">および</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> パラメーターは <ph id="ph2">&lt;see langword="null" /&gt;</ph> または空です。</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">および</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> パラメーターは <ph id="ph2">&lt;see langword="null" /&gt;</ph> または空です。</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを送信します。</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを送信します。</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 指定されたリモート ホストにデータを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドを正常に送信したバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 接続指向とコネクションレス プロトコルの両方を使用できます。</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This overload requires a buffer that contains the data you want to send.</source>
          <target state="translated">このオーバー ロードには、送信するデータを格納しているバッファーが必要です。</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>を 0 に初期値として、バッファーのオフセットの既定値は 0、およびバッファーのサイズを既定値を送信するバイト数。</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドを呼び出す必要が<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>への各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例を示しますに接続されたデータの送信<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信するデータを格納する <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> 型の <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> のリスト。</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">リスト内のバッファーのセットを接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信します。</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 接続指向とコネクションレス プロトコルの両方を使用できます。</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドを呼び出す必要が<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>への各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>See remarks section below.</source>
          <target state="translated">以下の解説を参照してください。</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にデータを送信します。</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 確立されているリモート ホストにデータを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドを正常に送信したバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>接続指向とコネクションレス プロトコルの両方のメソッドを使用できます。</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">このオーバー ロードは、送信するデータを格納するバッファーとビットごとの組み合わせが必要です。<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">バッファーは、既定値は 0、およびバッファーのサイズを既定値を送信するバイト数をオフセットします。</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter value, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターの値に、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドを呼び出す必要が、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドに対する各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例を示しますに接続されたデータの送信<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信するデータを格納する <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> 型の <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> のリスト。</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、リスト内のバッファーのセットを接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信します。</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>値の既定値は 0 です。</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketFlags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドを呼び出す必要が<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>への各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、指定したバイト数のデータを、接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信します。</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 確立されているリモート ホストにデータを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドを正常に送信したバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 接続指向とコネクションレス プロトコルの両方を使用できます。</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">このオーバー ロードには、送信するバイト数といずれかのビットごとの組み合わせを送信するデータを格納するバッファーが必要です。<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">使用しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドを呼び出す必要が、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドに対する各呼び出しの前に、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>With a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向プロトコルが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example sends the data found in buffer, and specifies <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">次のコード例は、バッファーで見つかったデータを送信し、指定<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>の<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>します。</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0 or exceeds the size of the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満か、バッファーのサイズを超える値です。</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the socket.</source>
          <target state="translated">ソケットへのアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信するデータを格納する <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> 型の <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> のリスト。</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、リスト内のバッファーのセットを接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信します。</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>値の既定値は 0 です。</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketFlags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドを呼び出す必要が<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>への各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することができます<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> が空です。</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">データの送信を開始する、データ バッファー内の位置。</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定したオフセットから開始し、指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、指定したバイト数のデータを接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信します。</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 指定されたリモート ホストにデータを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドを正常に送信したバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 接続指向とコネクションレス プロトコルの両方を使用できます。</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、オーバー ロードでは、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>を呼び出す必要が<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>への各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>に接続されたデータを送信するため<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">データの送信を開始する、データ バッファー内の位置。</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">ソケット エラーを格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph></source>
          <target state="translated">指定したオフセットから開始し、指定した <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、指定したバイト数のデータを接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信します。</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 指定されたリモート ホストにデータを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドを正常に送信したバイト数を返します。</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> 接続指向とコネクションレス プロトコルの両方を使用できます。</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、オーバー ロードでは、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>このメソッドを呼び出す前に、または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">使用しない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>を呼び出す必要が<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>への各呼び出しの前に<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">使用することが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>で既定のリモート ホストを確立した後でも<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">呼び出しの前に既定のリモート ホストを変更することもできます。<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を別の呼び出しを行って<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト値を超えている場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">送信が正常に完了しても、データが正常に配信されることは示しません。</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see<bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。<bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>に接続されたデータを送信するため<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトに、データを非同期に送信します。</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドを使用して、接続指向のソケットで 1 つ以上のバッファーの送信データを書き込みます。</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</source>
          <target state="translated">このメソッドこともできます、ただし、コネクションレス型のソケット接続操作でリモート ホストが指定されています。</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが正常にこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> または <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> 場合<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> 場合<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph>設定されています。</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドが例外をスロー最初に呼び出す必要はありません<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</source>
          <target state="translated">メッセージ指向のソケットでは、基になる Windows sockets サービス プロバイダーのメッセージの最大サイズを超えないようにしないでください。</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).</source>
          <target state="translated">データが長すぎて、基になるサービス プロバイダーの場合は、データは送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>で、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph>ネイティブ Winsock WSAEMSGSIZE エラー コード (10040) に設定します。</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that the successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">なおが正常に完了、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドは、データが正常に送信されたことを指定していません。</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated"><ph id="ph3">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> プロパティまたは <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> プロパティは、有効なバッファーを参照する必要があります。</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターに指定された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected or was not obtained via an <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>,or <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>, method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がまだ接続されていないか、<ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>、<ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>、または <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph> の各メソッドによって取得されませんでした。</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Gets or sets a value that specifies the size of the send buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の送信バッファーのサイズを指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the send buffer.</source>
          <target state="translated">送信バッファーのサイズ (バイト単位) を格納している <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">既定値は 8192 です。</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>A larger buffer size might delay the recognition of connection difficulties.</source>
          <target state="translated">大きなバッファー サイズは、接続に関する問題を認識に遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなどです。) を使用している場合は、バッファー サイズを増やすことを検討してください。</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">設定操作として指定された値が 0 未満です。</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file and optional data synchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">接続された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> に、ファイルおよびオプション データを同期的に送信します。</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated">送信されるファイルのパスと名前を含む <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object with the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> transmit flag.</source>
          <target state="translated"><ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> 送信フラグを使用して、接続されている <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトにファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> を送信します。</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">このオーバー ロードは、そのファイルを送信<ph id="ph1">`fileName`</ph>接続されたソケットにします。</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">`flags`</ph> parameter defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id="ph3">`preBuffer`</ph> and <ph id="ph4">`postBuffer`</ph> parameters default to <ph id="ph5">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`flags`</ph>パラメーターの既定値<ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph>(0)、および<ph id="ph3">`preBuffer`</ph>と<ph id="ph4">`postBuffer`</ph>パラメーターに既定の<ph id="ph5">`null`</ph>します。</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">場合<ph id="ph1">`fileName`</ph>されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">ワイルドカード ("..<ph id="ph1">\\</ph>\myfile.txt") と UNC 共有名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared ディレクトリ<ph id="ph5">\\</ph>\myfile.txt") はサポートされています。</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">ファイルが見つからない場合、例外<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">このメソッドを使用して、 <ph id="ph1">`TransmitFile`</ph> Windows Sockets 2 API である関数。</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">詳細については、<ph id="ph1">`TransmitFile`</ph>関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 指定されたリモート ホストにファイルを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 接続指向両方とコネクションレスのプロトコルを使用できます。</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>それ以外の場合、このメソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>スロー、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>ファイルを送信するまでブロックします。</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>ファイル全体が送信される前に正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The following code example creates and connects a socket and then sends a file to the remote host.</source>
          <target state="translated">次のコード例は、作成しソケットを接続し、リモート ホストにファイルを送信します。</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">ソケットがリモート ホストに接続されていません。</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">ファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> が見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated">送信されるファイルのパスと名前を含む <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">ファイルが送信される前に送信されるデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 配列。</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">ファイルが送信された後で送信されるデータを格納する <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 配列。</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">このパラメーターは、<ph id="ph1">&lt;see langword="null" /&gt;</ph> に設定できます。</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>One or more of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">1 つ以上の <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> 値。</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> and buffers of data to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the specified <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> value.</source>
          <target state="translated">指定した <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> 値を使用して、接続された <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトにファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> およびデータのバッファーを送信します。</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>値。</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated"><ph id="ph1">`preBuffer`</ph>パラメーターには、ファイルの前にすべてのデータが含まれています。</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> ファイルを使用するデータが含まれています。</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If <ph id="ph1">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">場合<ph id="ph1">`fileName`</ph>されますが、現在の作業ディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">ワイルドカード ("..<ph id="ph1">\\</ph>\myfile.txt") と UNC 共有名 ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared ディレクトリ<ph id="ph5">\\</ph>\myfile.txt") はサポートされています。</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated"><ph id="ph1">`flags`</ph>パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">このパラメーターを使用する方法の詳細については、次を参照してください。<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">このメソッドを使用して、 <ph id="ph1">`TransmitFile`</ph> Windows Sockets 2 API である関数。</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">詳細については、<ph id="ph1">`TransmitFile`</ph>関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 指定されたリモート ホストにファイルを同期的に送信、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> 接続指向両方とコネクションレスのプロトコルを使用できます。</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合を呼び出す必要があります<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>です。 このメソッドを呼び出す前にそれ以外の場合<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>スロー、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">いずれかを使用する必要があります、接続指向プロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>リモート ホスト接続を確立するかを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>着信接続を受け入れるようにします。</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">接続指向のプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>ファイル全体を送信するまでブロックします。</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">モードでは非ブロッキング、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>ファイル全体が送信される前に正常に完了場合があります。</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The following code example creates and connects a socket.</source>
          <target state="translated">次のコード例では、作成し、ソケットを接続します。</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</source>
          <target state="translated">この例では事前バッファリングと事後バッファリングのデータを作成し、ファイルのあるリモート ホストに送信します。</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The default <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> are used.</source>
          <target state="translated">既定値<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>使用されます。</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">オペレーティング システムは Windows NT 以降ではありません。</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> または</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">ソケットがリモート ホストに接続されていません。</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">ファイル <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> が見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends a collection of files or in memory data buffers asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">接続されている <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトに、ファイルのコレクションまたはメモリ内のデータ バッファーを非同期に送信します。</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>リモート ホストにデータ バッファーをメモリ内、またはファイルのコレクションに送信するメソッドを使用します。</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>リモート ホストに既に接続されている必要があります。</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph>作業ディレクトリでファイルを参照、ファイルの名前だけで識別できること以外の場合はそれ以外の場合、完全なパスとファイルの名前を指定する必要があります。</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Wildcards and UNC share names are supported.</source>
          <target state="translated">ワイルドカードおよび UNC 共有名がサポートされています。</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">ファイルが見つからない場合<ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph>がスローされます。</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; を委任し、アタッチするためのコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph2">`e`</ph>パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">このパラメーターを使用する方法の詳細については、次を参照してください。<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが正常にこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method uses the TransmitPackets function found in the Windows Sockets 2 API.</source>
          <target state="translated">このメソッドは、Windows ソケット 2 API で見つかった TransmitPackets 関数を使用します。</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">TransmitPackets 関数およびそのフラグの詳細については、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although intended for connection-oriented protocols, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">接続指向プロトコルでは、意図したものが、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>メソッドに対しても機能コネクションレスのプロトコルを最初に呼び出すこと、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>既定のリモート ホストを構築する方法です。</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>スロー、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外。</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>が使用されるオペレーティング システムに従ってメソッドを最適化します。</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows server editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.</source>
          <target state="translated">Windows server のエディションで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>メソッドは高パフォーマンスを最適化します。</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows client editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.</source>
          <target state="translated">Windows クライアントの各エディションで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>メソッドが最低限のメモリとリソース使用率を最適化します。</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use of the <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph3">`e`</ph> parameter can deliver significant performance benefits.</source>
          <target state="translated">使用、<ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph>フラグ、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph>プロパティを<ph id="ph3">`e`</ph>パラメーターは、大幅なパフォーマンス上の利点を提供できます。</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the thread initiating the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</source>
          <target state="translated">場合、スレッドを開始する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph>大量の計算には、メソッドの呼び出しを使用している、可能であればもわずかながら、Apc が起動できない可能性があることもできます。</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that there is a difference between kernel and user-mode APCs.</source>
          <target state="translated">カーネルとユーザー モードの Apc の違いがあることに注意してください。</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Kernel APCs launch when a thread is in a wait state.</source>
          <target state="translated">スレッドが待機状態には、カーネル Apc が起動します。</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>User-mode APCs launch when a thread is in an alertable wait state</source>
          <target state="translated">ユーザー モード Apc スレッドは、アラートの待機状態での起動します。</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The file specified in the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> property was not found.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> プロパティで指定されたファイルが見つかりませんでした。</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターに指定された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not connected to a remote host.</source>
          <target state="translated">この例外は、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がリモート ホストに接続されていない場合にも発生します。</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A connectionless <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</source>
          <target state="translated">コネクションレスの <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が使用されており、送信するファイルが基になるトランスポートの最大パケット サイズを超えています。</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> call will time out.</source>
          <target state="translated">同期の <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">タイムアウト値 (ミリ秒)。</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If you set the property with a value between 1 and 499, the value will be changed to 500.</source>
          <target state="translated">プロパティに 1 から 499 までの値を設定しても、その値は 500 に変更されます。</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">既定値は 0 です。タイムアウトが無期限であることを示します。</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">-1 の指定も、タイムアウトが無期限であることを示します。</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.</source>
          <target state="translated">このオプションを適用する同期<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>呼び出しのみです。</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">タイムアウト期間を超えた場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドがスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">設定操作として指定された値が -1 未満です。</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a specific endpoint.</source>
          <target state="translated">データを特定のエンドポイントに送信します。</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination for the data.</source>
          <target state="translated">データの送信先を表す <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Sends data to the specified endpoint.</source>
          <target state="translated">指定したエンドポイントにデータを送信します。</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph> parameter, and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">このオーバー ロードでは、バッファーのオフセットの既定値は 0 の場合のサイズに既定値を送信するバイトの数、<ph id="ph1">`buffer`</ph>パラメーター、および<ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>値の既定値は 0 です。</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">この呼び出しをする場合にだけ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">呼び出す場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">必要はありませんを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>後プロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドが正常に完了するとします。</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">コネクションレス プロトコルは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>接続指向プロトコルでも動作します。</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド、着信要求を使用して接続を受け入れるか、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、リモート ホスト接続を許可しない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>は無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータを送信する、接続または既定のリモート ホストします。</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Blocking sockets will block until the all of the bytes in the buffer are sent.</source>
          <target state="translated">ブロッキング ソケットは、すべてのバッファー内のバイトが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">非ブロッキング<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が完了する、すぐにその可能性がありますいないすべての送信内のバイト、<ph id="ph2">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの責任である、<ph id="ph1">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">ブロッキング モードは、コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">データの送信先の位置を表す <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends data to a specific endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用して、特定のエンドポイントにデータを送信します。</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">このオーバー ロードでは、バッファーのオフセットの既定値は 0、およびのサイズに既定値を送信するバイト数、<ph id="ph1">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">この呼び出しをする場合にだけ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">呼び出す場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">必要はありませんを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>後プロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドが正常に完了するとします。</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">コネクションレス プロトコルは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>接続指向プロトコルでも動作します。</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド、着信要求を使用して接続を受け入れるか、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、リモート ホスト接続を許可しない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>は無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータを送信する、接続または既定のリモート ホストします。</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested all of the bytes in the <ph id="ph1">`buffer`</ph> are sent.</source>
          <target state="translated">ブロッキング ソケットはブロックされるまで、要求されたすべてのバイト数の<ph id="ph1">`buffer`</ph>送信されます。</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">非ブロッキング<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>が完了する、すぐにその可能性がありますいないすべての送信内のバイト、<ph id="ph2">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの責任である、<ph id="ph1">`buffer`</ph>です。</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">ブロッキング モードは、コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> 渡される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">データの送信先の位置を表す <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0.</source>
          <target state="translated">このオーバー ロードでは、バッファーは、既定値は 0 をオフセットします。</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">この呼び出しをする場合にだけ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">呼び出す場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">必要はありませんを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>後プロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドが正常に完了するとします。</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">コネクションレス プロトコルは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>接続指向プロトコルでも動作します。</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド、着信要求を使用して接続を受け入れるか、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、リモート ホスト接続を許可しない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>は無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータを送信する、接続または既定のリモート ホストします。</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">ブロッキング ソケットは、要求されたバイト数が送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">非ブロッキング<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完了いない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">ブロッキング モードは、コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The size and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">サイズと<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>に渡される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The specified <ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;paramref name="size" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> のサイズを超えています。</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">送信されるデータを含む <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">データの送信を開始する、データ バッファー内の位置。</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">送信するバイト数。</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> 値のビットごとの組み合わせ。</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">データの送信先の位置を表す <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。送信はバッファー内の指定した位置から開始されます。</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">送信されたバイト数。</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">指定した場合、オーバー ロードでは、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph>としてフラグを設定、<ph id="ph2">`socketflags`</ph>パラメーターに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">この呼び出しをする場合にだけ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">呼び出す場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>、<ph id="ph3">`remoteEP`</ph>パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">必要はありませんを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>後プロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドが正常に完了するとします。</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">コネクションレス プロトコルは、意図したものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>接続指向プロトコルでも動作します。</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>メソッド、着信要求を使用して接続を受け入れるか、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">確立したり、リモート ホスト接続を許可しない場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">このような場合は、のいずれかで<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>は無視されます、<ph id="ph2">`remoteEP`</ph>パラメーターとのみデータを送信する、接続または既定のリモート ホストします。</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">ブロッキング ソケットは、要求されたバイト数が送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">非ブロッキング以降<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>完了いない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">アプリケーション送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行してください。</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">正常に完了する、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">ブロッキング モードは、コネクションレスのプロトコルを使用している場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>データグラムが送信されるまでブロックされます。</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The offset, size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">オフセット、サイズ、および<ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>に渡される、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> が <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さを超えています。</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が 0 未満です。</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> が、<ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> の長さから <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> パラメーターの値を引いた値を超えています。</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> は、値の有効な組み合わせではありません。</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- または -</target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> にアクセス中にオペレーティング システム エラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">この非同期ソケット操作に使用する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクト。</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">特定のリモート ホストにデータを非同期的に送信します。</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">I/O 操作が保留中の場合は、<ph id="ph1">&lt;see langword="true" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">操作の完了時に、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントが発生します。</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">I/O 操作が同期的に完了した場合は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> を返します。</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">この場合、<ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターの <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <ph id="ph3">&lt;paramref name="e" /&gt;</ph> オブジェクトを調べて操作の結果を取得できます。</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">`e`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッドで指定されたリモート ホストへの非同期送信操作を開始、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>のプロパティ、<ph id="ph3">`e`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although this method is intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">このメソッドはコネクションレスのプロトコルのものが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>コネクションレス型との接続指向プロトコルの両方で動作します。</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; を委任し、アタッチするためのコールバック、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベント。</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">次のプロパティとイベントを<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph>オブジェクトが正常にこのメソッドを呼び出す必要があります。</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">呼び出し元の設定、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッド情報をコールバック メソッドで取得できるようにします。</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">最初に呼び出す必要がある接続指向のプロトコルを使用している場合、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>、 <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Otherwise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">それ以外の場合<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">接続指向のプロトコルを使用する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッドは無視されます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>プロパティと送信のデータを<ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph>で確立されている、 <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>、 <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>、 <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>、 <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.</source>
          <target state="translated">この呼び出しをする場合にだけ、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>または<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property will override the specified default remote host for that send operation only.</source>
          <target state="translated">呼び出す場合、 <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>メソッドを呼び出す前に<ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>、<ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph>操作のみを送信するのプロパティで指定された既定のリモート ホストは無効です。</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">必要はありませんを呼び出して、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</source>
          <target state="translated">この場合、基になるサービス プロバイダーは、最も適切なローカル ネットワーク IP アドレスとポート番号を割り当てます。</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">基になるサービス プロバイダーは、空いているポートを選択する場合は、ゼロのポート番号を使用します。</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you need to identify the assigned local network IP address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event is signaled and the associated delegates are called.</source>
          <target state="translated">使用することができます、割り当てられているローカル ネットワーク IP アドレスとポート番号を識別する必要がある場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>後プロパティ、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph>イベントがシグナル状態にし、関連付けられているデリゲートが呼び出されます。</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> to true.</source>
          <target state="translated">ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph>メソッドと set ソケット オプションを<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>true に設定します。</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">場合は、データグラムが送信されず<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you specify the DontRoute flag in the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property, the data you are sending will not be routed.</source>
          <target state="translated">DontRoute フラグを指定する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph>プロパティに、データを送信すると、ルーティングされません。</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</source>
          <target state="translated">メッセージ指向のソケットでは、基になるトランスポートのメッセージの最大サイズを超えないように注意する必要があります。</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">バッファーのサイズは、基になるサービス プロバイダーのパケットの最大サイズを超えている場合、データグラムが送信されず、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>がスローされます、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The successful completion of a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">正常に完了、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>メソッドは、データが正常に送信されたことを指定していません。</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> に null 値を指定することはできません。</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph2">&lt;paramref name="e" /&gt;</ph> パラメーターに指定された <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> オブジェクトを使用してソケット操作が既に進行していました。</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">このメソッドには Windows XP 以降が必要です。</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The protocol specified is connection-oriented, but the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected.</source>
          <target state="translated">指定されたプロトコルは接続指向ですが、<ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> がまだ接続されていません。</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level to set on this socket.</source>
          <target state="translated">このソケットに設定する IP 保護レベル。</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Set the IP protection level on a socket.</source>
          <target state="translated">ソケットの IP 保護レベルを設定します。</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph>メソッドにより、制限、IPv6、または IP ソケット アドレスと同じローカル リンクまたはサイト ローカル プレフィックスなど、特定のスコープをリッスンするようにします。</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option enables applications to place access restrictions on IPv6 or IP sockets.</source>
          <target state="translated">このソケット オプションでは、IPv6、または IP ソケットにアクセス制限を設定するアプリケーションを使用します。</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</source>
          <target state="translated">この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option can also be used to remove access restrictions if the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</source>
          <target state="translated">このソケット オプションは、アクセスの制限を削除する場合にも使用できます、<ph id="ph1">`level`</ph>にパラメーターが設定されている<ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</source>
          <target state="translated">このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option has defined protection levels specified in the <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.</source>
          <target state="translated">このソケット オプションには、<ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> 列挙型で指定されている定義済みの保護レベルが設定されています。</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph>メソッドを使用を有効または無効のように、ネットワーク アドレス トラバーサル (NAT) を<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</source>
          <target state="translated">NAT トラバーサルを指定するには、Teredo、6to4、または ISATAP トンネルを使用します。</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">ときに、<ph id="ph1">`level`</ph>にパラメーターが設定されている<ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>、または<ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>、NAT トラバーサルが明示的に無効になります、<ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>インスタンス。</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.</source>
          <target state="translated">ときに、<ph id="ph1">`level`</ph>にパラメーターが設定されている<ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>、NAT トラバーサルを許可するこの可能性があります、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>によっては、システム上でファイアウォール規則です。</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;paramref name="level" /&gt;</ph> parameter cannot be <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="level" /&gt;</ph> パラメーターとして <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph> を使用することはできません。</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level cannot be set to unspecified.</source>
          <target state="translated">IP 保護レベルを未指定に設定することはできません。</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> of the socket must be either <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</source>
          <target state="translated">ソケットの <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> は、<ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> または <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> である必要があります。</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションを設定します。</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The value of the option, represented as a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> として表されるオプションの値。</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションを、指定した <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> 値に設定します。</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、現在の動作を決定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Set <ph id="ph1">`optionValue`</ph> to <ph id="ph2">`true`</ph> to enable the option, or to <ph id="ph3">`false`</ph> to disable the option.</source>
          <target state="translated">設定<ph id="ph1">`optionValue`</ph>に<ph id="ph2">`true`</ph>オプションを有効にまたは<ph id="ph3">`false`</ph>オプションを無効にします。</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、プロトコルのサポートのレベルでグループ化されます。</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">次のとおり、さまざまな<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプションをこのオーバー ロードを使用して設定できます。</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.</source>
          <target state="translated">これらのオプションが適切にグループ化<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>値。</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">これらのオプションのいずれかを設定する場合は、必ず使用して、適切な<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>値を<ph id="ph2">`optionLevel`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">設定を選択するオプションを指定する必要があります、<ph id="ph1">`optionName`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">記載されているオプションのいずれかの現在の値を取得するには、使用する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>For more information on these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">これらのオプションの詳細についてを参照してください、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>例外を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The following code example opens a socket and enables the <ph id="ph1">`DontLinger`</ph> and the <ph id="ph2">`OutOfBandInline`</ph> socket options.</source>
          <target state="translated">ソケットを開き、により、次のコード例、<ph id="ph1">`DontLinger`</ph>と<ph id="ph2">`OutOfBandInline`</ph>ソケット オプション。</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オブジェクトは閉じられています。</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that represents the value of the option.</source>
          <target state="translated">オプションの値を表す <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> 型の配列。</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as a byte array.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションを、指定した値に設定します。この値はバイト配列で表されます。</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、現在の動作を決定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload to set those <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.</source>
          <target state="translated">このオーバー ロードを使用して、それらを設定する<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプションの値としてバイト配列を必要とするオプションです。</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">次のコード例のセット、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>タイムアウト値。</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>A value of the option.</source>
          <target state="translated">オプションの値。</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified integer value.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションを、指定した整数値に設定します。</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、現在の動作を決定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</source>
          <target state="translated">オプションである場合の<ph id="ph1">&lt;xref:System.Boolean&gt;</ph>0 以外の値をこのオプションを有効にして、オプションを無効にゼロ値を指定、データ型します。</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with an integer data type, specify the appropriate value.</source>
          <target state="translated">整数データ型のオプションでは、適切な値を指定します。</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、プロトコルのサポートのレベルでグループ化されます。</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">次のとおり、さまざまな<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプションをこのオーバー ロードを使用して設定できます。</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</source>
          <target state="translated">これらのオプションが適切にグループ化<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">これらのオプションのいずれかを設定する場合は、必ず使用して、適切な<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>の<ph id="ph2">`optionLevel`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">設定を選択するオプションを指定する必要があります、<ph id="ph1">`optionName`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">記載されているオプションのいずれかの現在の値を取得するには、使用する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> このオーバー ロードを使用して設定できるオプションです。</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information about these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">これらのオプションの詳細についてを参照してください、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph>列挙します。</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">次のコード例のセット、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>タイムアウト値。</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> that contains the value of the option.</source>
          <target state="translated">オプションの値を格納する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> または <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as an object.</source>
          <target state="translated">指定した <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> オプションを、指定した値に設定します。この値はオブジェクトで表されます。</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> オプションは、現在の動作を決定<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Use this overload to set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">このオーバー ロードを使用して、設定、 <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>オプション。</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>オプションを使用して<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>の<ph id="ph3">`optionLevel`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>を使用して<ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you want to get the current value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">上記のオプションのいずれかの現在の値を取得するには、使用する場合、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph>メソッドです。</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time out values.</source>
          <target state="translated">次のコード例のセット、<ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>と<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>のタイムアウト値。</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> は <ph id="ph2">&lt;see langword="null" /&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> values that specifies the operation that will no longer be allowed.</source>
          <target state="translated">許可されなくなる操作を指定する <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> 値の 1 つ。</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disables sends and receives on a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> での送受信を無効にします。</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>When using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">接続指向の使用時に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>、常に呼び出し、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>閉じる前にメソッド、<ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">呼び出す、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>マネージし、アンマネージに関連付けられているリソースのすべてを解放するメソッド、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Do not attempt to reuse the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.</source>
          <target state="translated">再利用しないで、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>終了後にします。</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id="ph2">`how`</ph> parameter.</source>
          <target state="translated">次の表に、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph>に対して有効な列挙値、<ph id="ph2">`how`</ph>パラメーター。</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Value</source>
          <target state="translated">[値]</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Description</source>
          <target state="translated">説明</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Send</source>
          <target state="translated">送信</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable sending on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">この送信は無効に<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Receive</source>
          <target state="translated">Receive</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">この受信を無効にする<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Both</source>
          <target state="translated">両方</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable both sending and receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">両方の送受信にこれを無効にする<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.</source>
          <target state="translated">設定<ph id="ph1">`how`</ph>に<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph>後続のことを指定するために呼び出す<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>は許可されていません。</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.</source>
          <target state="translated">場合は、コネクションレス型を使用している<ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を指定して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph>効果はありません。</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.</source>
          <target state="translated">設定<ph id="ph1">`how`</ph>に<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph>後続のことを指定するために呼び出す<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>は許可されていません。</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This has no effect on lower protocol layers.</source>
          <target state="translated">下位のプロトコル層への影響はありません。</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</source>
          <target state="translated">接続指向のプロトコルを使用している呼び出しの後に、次の条件のいずれかが存在する場合、接続が終了<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>:</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Data is in the incoming network buffer waiting to be received.</source>
          <target state="translated">データは受信を待機しているネットワークの着信バッファーです。</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>More data has arrived.</source>
          <target state="translated">多くのデータが到着しました。</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless protocol, datagrams are accepted and queued.</source>
          <target state="translated">コネクションレスのプロトコルを使用している場合は、データグラムが受け入れてし、キューに置かれました。</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</source>
          <target state="translated">ただし、追加の受信データグラムの使用可能なバッファー領域がない場合は破棄され、送信者にエラーが返されません。</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.</source>
          <target state="translated">使用して<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>、コネクションレスで<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>はお勧めしません。</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.</source>
          <target state="translated">設定<ph id="ph1">`how`</ph>に<ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph>両方の送信を無効にし、前述のように受信します。</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を呼び出すときに、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>メソッドを使用して、<ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">詳細については、次を参照してください。 <bpt id="p1">[</bpt>.NET Framework のネットワークのトレース<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>です。</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">次のコード例では<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>を無効にする、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>Gets the type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> の型を取得します。</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> 値のいずれか 1 つ。</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> 読み取り専用と設定されているときに、<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を作成します。</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">次のコード例では表示、 <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>、 <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>、および<ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>コンソールにします。</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>Gets a value indicating whether IPv4 support is available and enabled on the current host.</source>
          <target state="translated">現在のホストで IPv4 サポートが使用可能で有効になっているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current host supports the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">現在のホストが IPv4 プロトコルをサポートしている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph2">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> members.</source>
          <target state="translated">互換性のために残されている特定の <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> メンバー向けに、フレームワークが IPv6 をサポートしているかどうかを示す値を取得します。</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the Framework supports IPv6 for certain obsolete <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> methods; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">互換性のために残されている特定の <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> メソッド向けに、フレームワークが IPv6 をサポートしている場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> によって送信されたインターネット プロトコル (IP) パケットの有効期間 (TTL) の値を指定する値を取得または設定します。</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value.</source>
          <target state="translated">TTL の値。</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</source>
          <target state="translated">TTL 値は、ルーターはパケットとインターネット制御メッセージ プロトコル (ICMP) の"TTL を超えています"を破棄する前に、パケットが走査できるルーターの最大数を示すエラー メッセージが送信者に返されます。</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value may be set to a value from 0 to 255.</source>
          <target state="translated">TTL 値は、0 255 からの値に設定可能性があります。</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>When this property is not set, the default TTL value for a socket is 32.</source>
          <target state="translated">このプロパティが設定されていないときに、ソケットの既定の TTL 値は 32 です。</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</source>
          <target state="translated">伝送制御プロトコル (TCP) ソケットでこのプロパティの設定は無視されますスタックによって、TCP/IP ソケットを使用して正常な接続が確立された場合。</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">表示された場合、<ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>を使用して、<ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph>固有のエラー コードを取得するプロパティです。</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> property.</source>
          <target state="translated">使用を次のコード例に示します、<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph>プロパティです。</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value can't be set to a negative number.</source>
          <target state="translated">TTL 値には、負の数を設定できません。</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">このプロパティは、<ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> ファミリまたは <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> ファミリのソケットに対してだけ設定できます。</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">ソケットへのアクセスを試行しているときにエラーが発生しました。</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This error is also returned when an attempt was made to set TTL to a value higher than 255.</source>
          <target state="translated">このエラーは、TTL に 255 より大きい値を設定しようとしたときにも返されます。</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が閉じられました。</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Specifies whether the socket should only use Overlapped I/O mode.</source>
          <target state="translated">ソケットが重複 I/O モードだけを使用する必要があるかどうかを指定します。</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses only overlapped I/O; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> が重複 I/O モードだけを使用する場合は <ph id="ph1">&lt;see langword="true" /&gt;</ph>。それ以外の場合は <ph id="ph3">&lt;see langword="false" /&gt;</ph>。</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">既定値は、<ph id="ph1">&lt;see langword="false" /&gt;</ph> です。</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Set this property to <ph id="ph1">`true`</ph> for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">このプロパティを設定<ph id="ph1">`true`</ph>の<ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>を呼び出そうと<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">それ以外の場合、フレームワークは、ソケットは、の使用を禁止するように、完了ポートを割り当てることが<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>です。</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The socket has been bound to a completion port.</source>
          <target state="translated">ソケットが完了ポートにバインドされています。</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>