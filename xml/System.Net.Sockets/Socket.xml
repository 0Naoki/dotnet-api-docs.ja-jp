<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cd8d44e0c7c90628715e33486e5644cee71c5205" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34254803" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley ソケット インターフェイスを実装します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>クラスは、ネットワーク通信について豊富な一連のメソッドとプロパティを提供します。 <xref:System.Net.Sockets.Socket>クラスはどちらも実行を同期できに示されている通信プロトコルのいずれかを使用して非同期のデータ転送、<xref:System.Net.Sockets.ProtocolType>列挙します。  
  
 <xref:System.Net.Sockets.Socket>クラスが非同期メソッド用の .NET Framework 名前付けパターンに従います。 たとえば、同期<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは非同期に対応<xref:System.Net.Sockets.Socket.BeginReceive%2A>と<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。  
  
 アプリケーションには、実行中に 1 つのスレッドのみ必要とする場合は、次のメソッドは、同期動作モード用に設計されてを使用します。  
  
-   使用した接続に、サーバーがリッスンできる TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Listen%2A>メソッドです。 <xref:System.Net.Sockets.Socket.Accept%2A>メソッド プロセスすべての着信接続を要求しを返します、<xref:System.Net.Sockets.Socket>ことは、データをリモート ホストに通信するために使用することができます。 この返さ<xref:System.Net.Sockets.Socket>を呼び出して、<xref:System.Net.Sockets.Socket.Send%2A>または<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。 呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A>メソッドのローカル IP アドレスとポート番号を指定する場合。 基になるサービス プロバイダーのポートを割り当てる空きをする場合は、ゼロのポート番号を使用します。 リッスンしているホストに接続する場合は、呼び出し、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 データを通信するために呼び出す、<xref:System.Net.Sockets.Socket.Send%2A>または<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合は、すべての接続をリッスンする必要はありません。 呼び出す、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを受信データグラムを受け入れるようにします。 使用して、<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムをリモート ホストに送信するメソッド。  
  
 実行中に個別のスレッドを使用して通信を処理するには、次のメソッドは、非同期の操作モード用に設計されてを使用します。  
  
-   TCP などの接続指向プロトコルを使用している場合を使用して、 <xref:System.Net.Sockets.Socket>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、および<xref:System.Net.Sockets.Socket.EndConnect%2A>リッスン中のホストに接続する方法です。 使用して、<xref:System.Net.Sockets.Socket.BeginSend%2A>と<xref:System.Net.Sockets.Socket.EndSend%2A>または<xref:System.Net.Sockets.Socket.BeginReceive%2A>と<xref:System.Net.Sockets.Socket.EndReceive%2A>データを非同期的に通信するメソッド。 使用して接続要求を処理できる<xref:System.Net.Sockets.Socket.BeginAccept%2A>と<xref:System.Net.Sockets.Socket.EndAccept%2A>です。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合を使用できます<xref:System.Net.Sockets.Socket.BeginSendTo%2A>と<xref:System.Net.Sockets.Socket.EndSendTo%2A>、データグラムを送信して<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>と<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>データグラムを受信します。  
  
 ソケットに対して複数の非同期操作を実行する場合、必ずしもで完了しなかった開始される順序。  
  
 完成した送信とデータを受信したらを使用して、<xref:System.Net.Sockets.Socket.Shutdown%2A>無効にする方法、<xref:System.Net.Sockets.Socket>です。 呼び出した後<xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>に関連付けられているすべてのリソースを解放するメソッド、<xref:System.Net.Sockets.Socket>です。  
  
 <xref:System.Net.Sockets.Socket>クラスでは、構成することができます、<xref:System.Net.Sockets.Socket>を使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。 使用してこれらの設定を取得、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  比較的単純なアプリケーションを作成して、最大のパフォーマンスは必要ない場合、は、使用を検討して<xref:System.Net.Sockets.TcpClient>、 <xref:System.Net.Sockets.TcpListener>、および<xref:System.Net.Sockets.UdpClient>です。 これらのクラスに簡素化され、ユーザーにわかりやすいインターフェイスを提供する<xref:System.Net.Sockets.Socket>通信します。  
  
   
  
## Examples  
 次のコード例に示す方法、<xref:System.Net.Sockets.Socket>クラスは、HTTP サーバーにデータを送信し、応答を受信するために使用できます。 この例は、ページ全体を受信するまでブロックします。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">発信接続を確立するか、受信要求を受け入れます。</permission>
    <threadsafe>このクラスのインスタンスでは、スレッド セーフです。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">
          <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> によって返されるソケット情報。</param>
        <summary>
          <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> から返された値を指定して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す場合は、<xref:System.Net.Sockets.Socket.%23ctor%2A>複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成する、<xref:System.Net.Sockets.Socket>同一の基になるソケットで秒です。 この方法はお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <summary>指定したソケットの種類とプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`パラメーターの型を指定、<xref:System.Net.Sockets.Socket>クラスおよび`protocolType`パラメーターで使用されるプロトコルを指定<xref:System.Net.Sockets.Socket>です。 2 つのパラメーターが独立してではありません。 多くの場合、<xref:System.Net.Sockets.Socket>型は、プロトコルで暗黙の型。 場合の組み合わせ<xref:System.Net.Sockets.Socket>種類とプロトコル型の結果、無効な<xref:System.Net.Sockets.Socket>、このコンス トラクターをスロー、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このコンス トラクターをスローした場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketType" /> と <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">
          <see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</param>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <summary>指定したアドレス ファミリ、ソケットの種類、およびプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`パラメーターを指定するアドレス指定スキーム、<xref:System.Net.Sockets.Socket>クラスの使用方法、`socketType`パラメーターの型を指定、<xref:System.Net.Sockets.Socket>クラス、および`protocolType`パラメーターで使用されるプロトコルを指定<xref:System.Net.Sockets.Socket>です。 次の 3 つのパラメーターが独立してではありません。 一部のアドレス ファミリを制限、および多くの場合、どのプロトコルを使用することができます、<xref:System.Net.Sockets.Socket>型は、プロトコルで暗黙の型。 場合、アドレス ファミリの組み合わせ<xref:System.Net.Sockets.Socket>型、およびプロトコルの種類は、無効な<xref:System.Net.Sockets.Socket>、このコンス トラクターをスロー、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このコンス トラクターをスローした場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、のインスタンスを作成する方法を示します、<xref:System.Net.Sockets.Socket>クラスです。  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="addressFamily" />、<paramref name="socketType" />、および <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しく作成された接続に対して新しい <see cref="T:System.Net.Sockets.Socket" /> を作成します。</summary>
        <returns>新しく作成された接続に対する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 同期的に待機中のソケットの接続要求のキューから最初の保留中の接続要求を抽出を作成し、新しい<xref:System.Net.Sockets.Socket>です。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 ただし、呼び出すことができます、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>メソッドの返された<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別します。  
  
 ブロッキング モード<xref:System.Net.Sockets.Socket.Accept%2A>受信接続の試行がキューに登録するまでブロックします。 接続を受け入れる元<xref:System.Net.Sockets.Socket>キューの着信接続を要求するまで閉じることが続行されます。  
  
 非ブロッキングを使用してこのメソッドを呼び出すかどうか<xref:System.Net.Sockets.Socket>、および接続要求がキューに入れ、<xref:System.Net.Sockets.Socket.Accept%2A>をスロー、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  呼び出しの前に、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、単純なを受け入れる<xref:System.Net.Sockets.Socket>接続します。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.Accept" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、それを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、既存のオプションで指定できます<xref:System.Net.Sockets.Socket>を指定して、着信接続に使用する、<xref:System.Net.Sockets.Socket>で使用する、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティです。  
  
 場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティが null、新しい<xref:System.Net.Sockets.Socket>が同じで構築されて<xref:System.Net.Sockets.Socket.AddressFamily%2A>、 <xref:System.Net.Sockets.Socket.SocketType%2A>、および<xref:System.Net.Sockets.Socket.ProtocolType%2A>現在<xref:System.Net.Sockets.Socket>として設定し、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 必要に応じて、後にソケット上のデータの最初のブロックを受信するためのバッファーを指定する場合があります、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功します。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティを受信するデータを格納しているバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティをバッファーに受信するデータのバイトの最大数に設定する必要があります。 使用してこれらのプロパティを設定することができます、<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>メソッドです。 渡されたバッファーの一部で使用される内部的に使用する基になる Winsock AcceptEx 呼び出しです。 つまり、返されるデータの量が常の値より小さい、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>指定されたインスタンスです。 内部的に使用されるバッファーの容量は、ソケット アドレス ファミリに変わります。 必要な最小バッファー サイズは、288 バイトです。 大きなバッファー サイズが指定されている場合、 <xref:System.Net.Sockets.Socket> Winsock AcceptEx 呼び出しで受け取ったアドレス データ以外のいくつかの余分なデータを必要として、この余分なデータが受信されるまで待機します。 タイムアウトが発生した場合、接続がリセットされます。 それで余分なデータが特定の容量の予測される場合、最小バッファー サイズとこの金額に、バッファーのサイズを設定する必要があります。  
  
 完了コールバック メソッドを調べる必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>プロパティかどうかを<xref:System.Net.Sockets.Socket.AcceptAsync%2A>操作は成功しました。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントの接続が許可されていない場合に発生して発生することができます、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>設定するプロパティを<xref:System.Net.Sockets.SocketError.ConnectionReset>です。 これは、ポートを半開 SYN 型スキャンを使用してスキャンの結果として発生することができます (SYN SYN ACK]-> [RST シーケンス ->)。 アプリケーションを使用して、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>この条件を処理するメソッドを準備する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、提供されたバッファーのサイズが不足している場合に発生します。 バッファーは、2 * (sizeof(SOCKADDR_STORAGE + 16) バイト以上であることが必要です。  この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合にも発生します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引数が範囲外です。 この例外は、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> が 0 未満の場合に発生します。</exception>
        <exception cref="T:System.InvalidOperationException">無効な操作が要求されました。 この例外は、受け入れ側の <see cref="T:System.Net.Sockets.Socket" /> が接続をリッスンしていない場合、または受け入れられたソケットがバインドされている場合に発生します。  <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドを呼び出す前に、<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> メソッドと <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> メソッドを呼び出す必要があります。  この例外は、ソケットが既に接続されている、またはソケット操作が指定された <paramref name="e" /> パラメーターを使用して既に進行中の場合にも発生します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> のアドレス ファミリを取得します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>をアドレス指定スキームを指定のインスタンス、<xref:System.Net.Sockets.Socket>クラスを使用できます。 このプロパティは読み取り専用と設定されているときに、<xref:System.Net.Sockets.Socket>を作成します。  
  
   
  
## Examples  
 次のコード例では表示、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非ブロッキングを使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Available%2A>を呼び出す前に、読み取り用のデータがキューに置かれたかどうかを決定することをお勧めは<xref:System.Net.Sockets.Socket.Receive%2A>します。 使用可能なデータは、読み取り用のネットワーク バッファーにキューに置かれたデータの合計サイズです。 ネットワーク バッファーにデータがキューにない場合<xref:System.Net.Sockets.Socket.Available%2A>0 を返します。  
  
 リモート ホストがシャット ダウン、または、接続を閉じる場合<xref:System.Net.Sockets.Socket.Available%2A>スローすることができます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、呼び出し元の IOControl FIONREAD と使用可能なプロパティを使用した結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 そのためには、少なくとも、リッスンを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しい戻ります<xref:System.Net.Sockets.Socket>オブジェクトをリモート ホストとのデータの送受信に使用できます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティで返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に完了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケット バージョン 2 API エラー コードのドキュメントに MSDN でエラーの詳細な説明を参照してください。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、非同期的に受信接続を受信しようとします。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  または、受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">送信元から受け入れるバイト数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期接続の受け入れを使用すると、個別の実行スレッド内でデータを送受信できます。 このオーバー ロードでは、初期の転送に同意するバイト数を指定することができます、`receiveSize`パラメーター。  
  
 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 そのためには、少なくとも、リッスンを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しいを返します<xref:System.Net.Sockets.Socket>リモート ホストとのデータの送受信を行えます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティで返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に完了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。  ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  使用してを呼び出すことができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは、最初の 10 バイトのデータを受け取っています。 受信したバイト数と、データは、コールバック デリゲートをコンソールに表示されます。 参照してください<xref:System.Net.Sockets.Socket.BeginReceive%2A>残りのデータを受信する方法の詳細についてはします。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  または、受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">受け入れた <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。 この値は <see langword="null" /> の場合もあります。</param>
        <param name="receiveSize">受信する最大バイト数。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したソケットから受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトの作成を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>着信接続を非同期的に処理するメソッドと試みます。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 このオーバー ロードで受け入れられたソケットを指定することができます、`acceptSocket`パラメーター。 このパラメーターは場合`null`、受け入れられたソケットがによって作成された、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 初期転送に同意するバイト数を指定することができます、`receiveSize`パラメーター。  
  
 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、接続要求をキューにメソッドです。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 そのためには、少なくとも、リッスンを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、通常、システムは別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しいを返します<xref:System.Net.Sockets.Socket>オブジェクトをリモート ホストとのデータの送受信に使用できます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティで返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に完了しました。  
  
 コールバック メソッドの作成方法の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>をリモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の 10 バイトのデータを受け入れます。 と`acceptSocket`パラメーターは`null`、強制的に実行する、<xref:System.Net.Sockets.Socket.BeginAccept%2A>受け入れられたソケットを作成する方法です。 受信したバイト数と、データは、コールバック デリゲートをコンソールに表示されます。 参照してください<xref:System.Net.Sockets.Socket.BeginReceive%2A>残りのデータを受信する方法の詳細についてはします。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  または、受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">To be added.</param>
        <param name="end_point">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの接続への非同期要求の開始、`remoteEP`パラメーター。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを確立します。 接続するか、既定のリモート ホストの設定を非同期的に個別の実行スレッド内でデータを送受信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドです。 少なくとも、渡す必要があります、<xref:System.Net.Sockets.Socket>に<xref:System.Net.Sockets.Socket.BeginConnect%2A>を通じて、`state`パラメーター。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket>、およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginConnect%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndConnect%2A>まで、<xref:System.Net.Sockets.Socket>が正常に接続するか、例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A>です。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.BeginConnect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.BeginSendTo%2A>と<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります<xref:System.Net.Sockets.Socket.SetSocketOption%2A>にブロードキャストを設定および`true`です。 できない場合は、<xref:System.Net.Sockets.Socket.BeginConnect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.BeginConnect%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.BeginConnect%2A>目的のエンドポイントを使用してメソッドです。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは <see cref="T:System.Net.IPAddress" /> とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 通常、このメソッドはによって、`requestCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードまたは<xref:System.Net.Sockets.Socket.EndConnect%2A>です。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>は別にする必要がありますを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">
          <see cref="T:System.Net.Sockets.Socket" /> はソケット ファミリに含まれません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストを指定する、少なくとも 1 つの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 通常、このメソッドはによって、`requestCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>は別にする必要がありますを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> を使用するソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">To be added.</param>
        <param name="callback">To be added.</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <c>requestCallback</c> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストはホスト名とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 通常、このメソッドはによって、`requestCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセルする、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>です。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出すための非同期操作が進行中に渡されたコールバック、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>操作が取り消されましたことを示すためにします。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出す必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>は別にする必要がありますを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>非同期操作を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合は、呼び出す、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>リモート エンドポイントからの切断要求を送信します。 場合`reuseSocket`は`true`ソケットを再利用することができます。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>メソッドは、指定されたコールバック メソッドを呼び出す別のスレッドを使用します。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>メソッドは、保留中の切断までブロックが完了しました。 コールバック メソッドの作成方法の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A>送信を停止し、受信アクティビティのために呼び出されます。 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>切断要求を開始すると呼びます。 要求が完了したら、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する、<c>buffer</c> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、接続からデータを非同期的に受信を開始<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError&amp;" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <c>buffer</c> 内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="flags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドです。 通常、このメソッドはによって、`callback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでブロックするには、いずれかを使用、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。[同期のメソッドを非同期に呼び出す](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint&amp;" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<c>buffer</c> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドが、リモート ホストからコネクションレス データグラムを非同期的に読み取りを開始します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは、個別の実行スレッド内でデータを受信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、システムが、指定されたコールバック メソッドを実行する別のスレッドを使用、およびを<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>まで、<xref:System.Net.Sockets.Socket>データを読み取るか例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>です。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの作成方法の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、または<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 このメソッドにデータを読み込みます、`buffer`パラメーター、およびデータの送信元となるエンドポイントをホストするリモート キャプチャします。 このエンドポイントを取得する方法についてを参照してください<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>です。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。 このような場合は、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 リモート ホストのエンドポイントが常に返される、アプリケーションでは明示的にバインドする必要がありますのことを保証するために、<xref:System.Net.Sockets.Socket>ローカル エンドポイントを使用して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドと、呼び出し、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを`optionLevel`パラメーターに設定<xref:System.Net.Sockets.SocketOptionLevel.IP>または<xref:System.Net.Sockets.SocketOptionLevel.IPv6>、必要に応じて、`optionName`パラメーターに設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>、および`optionValue`を呼び出す前にこのオプションを有効にするパラメーター、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 それ以外の場合、可能であれば、受信側が呼び出される前に、送信者のデータグラムの数が送信する場合は、返されていないリモート ホストのエンドポイントの<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、 <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して、受信接続要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 呼び出す場合は、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>確立するか、接続を受け入れる前にメソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>がで指定したバイトの数まで使用できる多くのデータを読み取り、`size`パラメーター。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、リモート ホストから非同期的にコネクションレス データグラムを受信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<c>buffer</c> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータの非同期受信を開始して、データ バッファー内の指定した位置に格納します。さらに、エンドポイントとパケット情報を格納します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の受信操作呼び出しで完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>メソッドです。 通常、このメソッドはによって、`asyncCallback`を委任します。  
  
 このメソッドは、操作が完了するまでにはブロックされません。 操作が完了するまでをブロックするを使用して、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドです。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[同期のメソッドを非同期に呼び出す。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 このメソッドにデータを読み込みます、`buffer`パラメーター、およびデータの送信元となるエンドポイントをホストするリモート キャプチャだけでなく、受信したパケットに関する情報。 このエンドポイントを取得する方法についてを参照してください<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>です。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 Set メソッドを呼び出す、<xref:System.Threading.ManualResetEvent>元のスレッドに実行を継続する場合は、コールバック メソッドにします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、<c>buffer</c> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、<c>buffer</c> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出す必要はない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。 使用することが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、リモート ホストへのデータを非同期的に送信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">送信するファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>
          <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <returns>非同期送信を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、そのファイルを送信`fileName`接続されたソケットにします。 場合`fileName`されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出す必要はありませんは例外をスロー <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドでは、個別の実行スレッド内のファイルを送信することができます。  
  
 操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<xref:System.AsyncCallback>パラメーターを委任します。 これを行う、非常に最小値で、`state`パラメーターを含める必要があります、<xref:System.Net.Sockets.Socket>の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このカスタム オブジェクトのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndSendFile%2A>まで、<xref:System.Net.Sockets.Socket>ファイル全体を送信または例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 コネクションレスのプロトコルを使用してファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例では、作成し、非同期通信のソケットを接続します。 最初に、ファイル"text.txt"は、リモート ホストに非同期的に送信されます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">
          <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">このオプションの完了時に呼び出される <see cref="T:System.AsyncCallback" /> デリゲート。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="state">この要求の状態情報を格納するユーザー定義のオブジェクト。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルとデータのバッファーを非同期的に送信します。</summary>
        <returns>非同期操作を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<xref:System.Net.Sockets.TransmitFileOptions>値。 `preBuffer`パラメーターには、ファイルの前にすべてのデータが含まれています。 `postBuffer` ファイルを使用するデータが含まれています。 場合`fileName`されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 `flags`パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>です。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出す必要はありませんは例外をスロー <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>です。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドは、個別の実行スレッド内のファイルを送信する機能を提供します。  
  
 操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<xref:System.AsyncCallback>パラメーターを委任します。 これを行う、非常に最小値で、`state`パラメーターを含める必要があります、<xref:System.Net.Sockets.Socket>の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>およびその他の必要な情報です。 このカスタム オブジェクトのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndSendFile%2A>まで、<xref:System.Net.Sockets.Socket>ファイル全体を送信または例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 接続指向プロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初を呼び出すことのコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを構築する方法です。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。 この例では、`preBuffer`と`postBuffer`データのファイルとその既定値を送信するために作成が<xref:System.Net.Sockets.TransmitFileOptions>値を使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  \- または -  ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データ送信を開始する、<c>buffer</c> 内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">To be added.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remoteEP">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">
          <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求の状態情報を格納するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドで指定されたリモート ホストへの非同期送信操作を開始、`remoteEP`パラメーター。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>コネクションレス型との接続指向プロトコルの両方で動作します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドです。 これを行う、非常に最小値で、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、保持するために小さなクラスを作成することができます、 <xref:System.Net.Sockets.Socket>、およびその他の必要な情報です。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドです。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendTo%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用しでブロックされます<xref:System.Net.Sockets.Socket.EndSendTo%2A>まで、<xref:System.Net.Sockets.Socket>を要求したバイト数を送信または例外をスローします。 場合は、元のスレッドをブロックを呼び出した後、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッドです。 元のスレッドに実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述に関する追加情報を参照してください。[コールバック メソッドとしてのデリゲートをマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)です。  
  
 最初に呼び出す必要がある接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、または<xref:System.Net.Sockets.Socket.BeginSendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 無視されます、`remoteEP`パラメーターと送信のデータを<xref:System.Net.EndPoint>で確立されている、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 この場合、基になるサービス プロバイダーは、最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。 基になるサービス プロバイダーは、空いているポートを選択する場合は、ゼロのポート番号を使用します。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドが正常に完了するとします。  
  
 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>です。 のバッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.EndSendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッドです。 特定のコンテキストの初回使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および、特定のコールバック)、そのコンテキストの後の使用はパフォーマンスの向上を参照してください。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにデータを非同期的に送信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">
          <see cref="T:System.Net.Sockets.Socket" /> に関連付けるローカル <see cref="T:System.Net.EndPoint" />。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> をローカル エンドポイントと関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを特定のローカル エンドポイントを使用する必要がある場合。 呼び出す必要があります<xref:System.Net.Sockets.Socket.Bind%2A>を呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A>メソッドです。 呼び出す必要はありません<xref:System.Net.Sockets.Socket.Bind%2A>使用する前に、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、ローカルの特定のエンドポイントを使用する必要があります。 使用することができます、<xref:System.Net.Sockets.Socket.Bind%2A>コネクションレス型との接続指向プロトコルの両方のメソッドです。  
  
 呼び出す前に<xref:System.Net.Sockets.Socket.Bind%2A>、ローカルを作成する必要がありますまず<xref:System.Net.IPEndPoint>データをやり取りするからです。 ローカル アドレスの割り当てを限定しない場合は、作成、<xref:System.Net.IPEndPoint>を使用して<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>アドレス パラメーターと、基になるサービス プロバイダーは、最も適切なネットワーク アドレスを割り当てます。 これにより、複数のネットワーク インターフェイスがある場合に、アプリケーションを簡略化のに役立ちます。 使用されているローカル ポートを限定しない場合は、作成、<xref:System.Net.IPEndPoint>ポート番号として 0 を使用します。 この場合、サービス プロバイダーは 1024 ~ 5000 で、使用可能なポート番号を割り当てます。  
  
 上記の方法を使用する場合は、呼び出すことによってどのようなローカル ネットワーク アドレスとポート番号が割り当てられてを検出することができます、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>です。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>への呼び出しを行った後まで、ローカルで割り当てられているネットワーク アドレスは返されません、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドです。 コネクションレスのプロトコルを使用している場合はありませんこの情報にアクセスする送信を完了したかが表示されるまでです。  
  
 UDP ソケットがインターフェイスについては、受信したパケットを受信する場合は、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>と共にソケット オプションに設定して、メソッドを明示的に呼び出されなければなりません<xref:System.Net.Sockets.SocketOptionName.PacketInformation>呼び出し直後後、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。  
  
> [!NOTE]
>  マルチキャスト データグラムを受信する場合は、呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>マルチキャストのポート番号を持つメソッドです。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド コネクションレス データグラムを使用して受信する場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を呼び出すときに、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例のバインド、<xref:System.Net.Sockets.Socket>指定したローカル エンドポイントを使用します。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <permission cref="T:System.Net.SocketPermission">によって定義されたホストからの接続を受け入れるため<paramref name="localEP" />です。 関連する列挙。 <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> がブロッキング モードかどうかを示す値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> がブロックする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを示すかどうか、<xref:System.Net.Sockets.Socket>ブロッキング モードでは、します。  
  
 ブロッキング モードでは、すると、メソッドがすぐに完了しない場合、アプリケーションは、要求された操作が完了するまで実行をブロックします。 要求された操作の完了がいない場合でも続行、変更を実行する場合、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`です。 <xref:System.Net.Sockets.Socket.Blocking%2A>プロパティが非同期メソッドに対して影響を与えません。 使用している場合を送信し、データの非同期受信の実行をブロックする、<xref:System.Threading.ManualResetEvent>クラスです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドの 1 つを呼び出してリモート ホストへの接続を要求するために使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を取り消します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>メソッドは、リモート ホスト接続への非同期要求をキャンセルします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージおよびアンマネージ リソースに関連付けられている、<xref:System.Net.Sockets.Socket>です。 決算時に、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティに設定されている`false`です。  
  
 接続指向プロトコルは勧めを呼び出すこと<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。 これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Close%2A>最初呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、データ キューを設定して送信される出力方向の送信にあることを確認することができます、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket>オプションを`false`と 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Close%2A> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションに`false`、作成、 <xref:System.Net.Sockets.LingerOption>、enabled プロパティを設定`true`、設定と、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>プロパティ、目的のタイムアウト期間をします。 これを使用して<xref:System.Net.Sockets.LingerOption>と共に、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例が閉じ、<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">最大 <c>timeout</c> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>メソッドは、リモート ホスト接続を閉じると、リリースのすべてのマネージおよびアンマネージ リソースに関連付けられている、<xref:System.Net.Sockets.Socket>です。 決算時に、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティに設定されている`false`です。  
  
 接続指向プロトコルは勧めを呼び出すこと<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Close%2A>です。 これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Close%2A>最初呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、データ キューを設定して送信される出力方向の送信にあることを確認することができます、<xref:System.Net.Sockets.SocketOptionName.DontLinger>オプションを`false`と 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Close%2A> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションに`false`、作成、<xref:System.Net.Sockets.LingerOption>に有効なプロパティを設定`true`、設定と、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>プロパティを目的のタイムアウト期間。 これを使用して<xref:System.Net.Sockets.LingerOption>と共に、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を終了する方法を示しています、<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストへの接続を確立します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>リモート ホストへの接続を確立します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>メソッド ブロックを明示的に設定する場合を除き、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
        <permission cref="T:System.Net.SocketPermission">リモート ホストに接続します。 関連する列挙。 <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスとポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスの配列とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはすぐに呼び出しの後に通常使用<xref:System.Net.Dns.GetHostAddresses%2A>、1 つのホストの複数の IP アドレスを返すことができます。 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストはホスト名とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート ホストします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>のリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、またはリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドです。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>リモート ホストを同期的に通信するためにします。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定された既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストが、ブロードキャスト アドレスを設定する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出しの前に<xref:System.Net.Sockets.Socket.Connect%2A>です。 TCP とする無効化をブロックするように、接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時接続を確立する必要があるためです。 既定のリモート ホストを確立するだけであるために、コネクションレスのプロトコルは例外をスローしません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 接続指向で、リモート ホスト接続が開始されて、エラーに WSAEWOULDBLOCK が返される場合は<xref:System.Net.Sockets.Socket>、まだ完了していませんが正常にします。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了した接続です。  
  
 IPv6 が有効になっている場合、<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>メソッドは両方とも IPv6 に解決されるホストに接続して IPv4 アドレス、IPv4 アドレスの前に最初に、IPv6 アドレスに接続試行します。 これには、ホストが、IPv6 アドレスでリッスンしていない場合、接続の確立に時間が遅延の影響があります。  
  
> [!NOTE]
>  接続指向のプロトコルを使用しているしを呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーは、ローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号の送信を完了するか、操作が表示されるまでです。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを指定しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元する、このメソッドを使用できません。 非同期のいずれかを使用して<xref:System.Net.Sockets.Socket.BeginConnect%2A>を再接続する方法です。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続し、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドは、リモート ホストに接続するための非同期要求を開始します。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>既定のリモート ホストを確立します。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストに接続するのです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.ConnectAsync%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendToAsync%2A>と<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>のリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>目的のエンドポイントを使用してメソッドです。  
  
 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります<xref:System.Net.Sockets.Socket.SetSocketOption%2A>にブロードキャストを設定および`true`です。 これが行われていない場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功します。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティが送信するデータを格納しているバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティをバッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。  
  
 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドでのスロー<xref:System.NotSupportedException>場合のアドレス ファミリ、<xref:System.Net.Sockets.Socket>と<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>このメソッドを呼び出したときに使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</param>
        <param name="protocolType">
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</param>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) メソッドは、リモート ホストに接続するための非同期要求を開始します。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>で指定された既定のリモート ホストを確立、`socketType`と`protocolType`パラメーター。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストに接続するのです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合を呼び出す必要はありません<xref:System.Net.Sockets.Socket.ConnectAsync%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendToAsync%2A>と<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>のリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、指定した既定以外のアドレスから受信する任意のデータグラムは破棄されます。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>目的のエンドポイントを使用してメソッドです。  
  
 ブロードキャスト アドレスに既定のリモート ホストを設定する場合は、最初に呼び出す必要があります<xref:System.Net.Sockets.Socket.SetSocketOption%2A>にブロードキャストを設定および`true`です。 これが行われていない場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 必要に応じて、バッファー提供することが後に、ソケットにアトミックに送信されます、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功します。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティが送信するデータを格納しているバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティをバッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向のプロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てます。  
  
 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドでのスロー<xref:System.NotSupportedException>場合のアドレス ファミリ、<xref:System.Net.Sockets.Socket>と<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>このメソッドを呼び出したときに使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">呼び出し履歴の上位にある呼び出し元には、要求された操作に対するアクセス許可がありません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後に実行された <see cref="Overload:System.Net.Sockets.Socket.Send" /> 操作または <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていたかどうかを示す値を取得します。</summary>
        <value>最後に実行された操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート リソースに接続されていた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`プロパティ、接続の状態を取得、<xref:System.Net.Sockets.Socket>最後の I/O 操作の時点でします。 返す場合`false`、<xref:System.Net.Sockets.Socket>されたか、接続されていない、または接続されていません。  
  
 値、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティには、最新の操作の時点で接続の状態が反映されます。 接続の現在の状態を確認する必要がある場合は、非ブロッキングを持つ 0 バイトの Send 呼び出しをください。 呼び出しの成功または WAEWOULDBLOCK エラー コード (10035) がスローされる場合、は、ソケットがまだ接続しているです。それ以外の場合、ソケットが接続していません。  
  
 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>ユーザー データグラム プロトコル (UDP) ソケット上、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは常に返します`true`。 ただし、この操作では、UDP のコネクションレス型固有であるは変更されません。  
  
   
  
## Examples  
 次のコード例は、チェックをリモート エンドポイントに接続する、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティ、接続の現在の状態を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">現在の接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>ソケット接続を閉じ、ソケットを再利用できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合は、ソケットを閉じるにこのメソッドを使用できます。 このメソッドが設定されている接続およびセットには、終了、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティを`false`です。 ただし場合、`reuseSocket`は`true`ソケットを再利用することができます。  
  
 すべてのデータで送信および受信ソケットが閉じられる前にするを呼び出す必要があります<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に、<xref:System.Net.Sockets.Socket.Disconnect%2A>メソッドです。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Disconnect%2A>最初呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、設定することができます、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket>オプションを`false`データ キューは送信方向の送信にあることを確認する 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Disconnect%2A> データが送信されるまで、または指定したタイムアウトが経過するまでブロックします。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、同期通信のソケットを作成し、リモート ホストにいくつかのデータを送信します。 呼び出して<xref:System.Net.Sockets.Socket.Shutdown%2A>を送信を停止し、受信アクティビティ、および<xref:System.Net.Sockets.Socket.Disconnect%2A>、ソケット接続を閉じます。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 2000 以前でのみサポートされます。それ以外の場合は、例外がスローされます。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用する場合の呼び出し、<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>メソッドがリモート エンドポイントからの接続が切断を要求します。 設定した場合<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>に`true`で、`e`パラメーター、ソケットを再利用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="e" /> パラメーターを null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Dispose` を使い終わったら <xref:System.Net.Sockets.Socket> を呼び出します。 `Dispose` メソッドによって、<xref:System.Net.Sockets.Socket> は使用不可の状態になります。 呼び出した後`Dispose`へのすべての参照を解放する必要があります、<xref:System.Net.Sockets.Socket>ガベージ コレクターがメモリを再利用できるようにする、<xref:System.Net.Sockets.Socket>占有されていた。  
  
 詳細については、次を参照してください。[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)です。  
  
> [!NOTE]
>  `Dispose` への最後の参照を解放する前に、必ず <xref:System.Net.Sockets.Socket> を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージ リソースとアンマネージ リソースの両方を解放する場合は <see langword="true" />。アンマネージ リソースだけを解放する場合は <see langword="false" />。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージ リソースを解放します。オプションでマネージ リソースも破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドおよび<xref:System.Object.Finalize%2A>メソッドです。 `Dispose()` プロテクト呼び出します`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`です。 <xref:System.Object.Finalize%2A> 呼び出す`Dispose`で`disposing`'éý'`false`です。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Net.Sockets.Socket> が参照しているすべてのマネージ オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> 複数回呼び出す他のオブジェクトから。<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。実装する方法の詳細についての<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />、[Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md) を実装を参照してください。 します。詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください [アンマネージ Resources](~/docs/standard/garbage-collection/unmanaged.md) をクリーンアップし、[Finalize メソッドをオーバーライドする] (http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)です。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> でインターネット プロトコル (IP) データグラムの断片化を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を、取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> でデータグラムの断片化を許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データグラムでは、そのサイズが、最大転送単位 (MTU) の伝送媒体を超えたときに断片化が必要です。 データグラムは、送信ホスト (すべてのインターネット プロトコル バージョン) または中間ルーター (インターネット プロトコル バージョン 4 のみ) で断片化している可能性があります。 場合は、データグラムを断片化している必要があります、および<xref:System.Net.Sockets.Socket.DontFragment%2A>オプションが設定されている、データグラム破棄され、インターネット制御メッセージ プロトコル (ICMP) エラー メッセージが、データグラムの送信者に返されます。  
  
 伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.DontFragment%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> がデュアルモードのソケットの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">ソケット参照の複製が作成されるターゲット プロセスの ID。</param>
        <summary>ターゲット プロセスのソケット参照を複製してこのプロセスのソケットを閉じます。</summary>
        <returns>ターゲット プロセスに渡されるソケット参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ターゲット プロセスを使用する必要があります<xref:System.Net.Sockets.Socket.%23ctor%2A>重複するソケットのインスタンスを作成します。  
  
 呼び出す場合は、<xref:System.Net.Sockets.Socket.%23ctor%2A>複数回の各呼び出しの引数と同じバイト配列を持つコンス トラクターは、複数の管理を作成する、<xref:System.Net.Sockets.Socket>と基になるソケットの同じインスタンスです。 この方法はお勧めします。  
  
 ソケットを作成するプロセスは、非同期メソッドを使用している場合 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>または<xref:System.Net.Sockets.Socket.BeginSend%2A>)、プロセスを設定する必要があります最初、<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>プロパティをソケットを引き起こす可能性があります、作成したプロセスの完了ポートへバインド true をそれ以外の場合、<xref:System.ArgumentNullException>ターゲット プロセスでスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> が有効なプロセス ID ではありません。または、ソケット参照の複製に失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットの送受信を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ブロードキャストが、特定のサブネットに制限されており、ユーザー データグラム プロトコル (UDP) を使用する必要があります。255.255.255.255 以外にパケットを送信することによってインターネット プロトコル バージョン 4 では、ローカル サブネットにブロードキャストことができます。または、ホストの部分を設定するすべてのビットをインターネット プロトコル (IP) アドレスの一部でネットワーク向けのブロードキャスト アドレスを使用することができます。 たとえば、お客様の IP アドレスは 192.168.1.40 (255.255.255.0--ネットマスク付きのクラス C アドレスは、ネットワーク部分は、最初の 3 つのオクテットでは、およびホスト部分は、最後のオクテット、)、ブロードキャスト アドレスは 192.168.1.255 します。  
  
 伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">このオプションは、データグラム ソケットに対してだけ有効です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を非同期的に受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、転送される初期データを格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しを完了<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、によって呼び出されるコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドが、接続試行を正常に完了します。 `buffer`このオーバー ロードのパラメーターへの呼び出しで受け取ったデータを格納して<xref:System.Net.Sockets.Socket.BeginAccept%2A>と`bytesTransferred`パラメーターには呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しい返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.BeginAccept%2A>作成、ソケットを接続して、最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndAccept%2A>非同期要求を終了します。 送信バイト数と、データが返されます、`buffer`と`bytesTransferred`このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> を作成してリモート ホスト通信を処理します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しを完了<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。 これに同意する必要があります、`asyncResult`パラメーターから返される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドが、接続試行を正常に完了します。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しい返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、非同期要求を終了し、新たに作成<xref:System.Net.Sockets.Socket>受信接続要求を受け入れるようにします。 完全な例には、ソケットと非同期通信には、次を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)です。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、次の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="bytesTransferred">転送されたバイト数。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、初期データと、転送されたバイト数を格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しを完了<xref:System.Net.Sockets.Socket.BeginAccept%2A>です。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、によって呼び出されるコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。 これに同意する必要があります、`asyncResult`パラメーターから返される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドです。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドが、接続試行を正常に完了します。 `buffer`このオーバー ロードのパラメーターへの呼び出しで受け取ったデータを格納して<xref:System.Net.Sockets.Socket.BeginAccept%2A>と`bytesTransferred`パラメーターには呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留状態になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しい返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.BeginAccept%2A>作成、ソケットを接続して、最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndAccept%2A>非同期要求を終了します。 送信バイト数と、データが返されます、`buffer`と`bytesTransferred`このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>保留中の非同期接続要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> 非同期リモート ホスト接続要求を完了したブロッキング メソッド内で起動、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginConnect%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginConnect%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>を取得するパラメーター、<xref:System.Net.Sockets.Socket>になる接続の試行が行われています。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドが、接続試行を正常に完了します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を終了します。 完全な例には、ソケットと非同期通信には、次を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)です。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>保留中の非同期切断要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 呼び出しを完了<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>です。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>メソッドは、切断が完了するまでブロックします。 非同期操作については、MSDN ライブラリの非同期プログラミングの概要のトピックを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、非同期通信のソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A>送信を停止し、受信アクティビティのために呼び出されます。 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>切断要求を開始すると呼びます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndDisconnect%2A>非同期要求を終了します。 要求が完了したら、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.Net.WebException">切断要求がタイムアウトしました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期読み取りを終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceive%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 受信側の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはデータが読み取られるまでブロックします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceive%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、 <xref:System.IAsyncResult>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
 [キャンセル] を保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期読み取りを終了します。 完全な例には、ソケットと非同期通信には、次を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)です。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceive%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 受信側の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはデータが読み取られるまでブロックします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceive%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドです。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、 <xref:System.IAsyncResult>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint&amp;" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <param name="endPoint">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 受信側の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドを正常に読み取り操作を完了して、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドは現状有姿で指定したバイトの数まで使用可能な多くのデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドです。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>オブジェクト、および結果の状態オブジェクトに含まれているバッファーを抽出します。 元のホストを識別するための抽出、<xref:System.Net.EndPoint>にキャストし、<xref:System.Net.IPEndPoint>です。 使用して、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> IP アドレスを取得するメソッドと<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>ポート番号を取得します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、特定の保留中の非同期読み込みを終了<xref:System.Net.EndPoint>です。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="socketFlags">受信パケットの <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">受信パケットの <see cref="T:System.Net.IPAddress" /> とインターフェイス。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。 また、このメソッドは、<see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> よりもパケットに関するより多くの情報を示します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作が完了していない場合、このメソッドはそれまでブロックします。  
  
 この操作を同期的に実行するを使用して、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドです。  
  
 調べる`ipPacketInformation`かどうか、ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを知る必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が <see langword="null" /> です。または、<paramref name="endPoint" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期送信を終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSend%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSend%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSend%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSend%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーの一部が送信されるまでブロックされます。 戻り値の場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーができなかったことを示します呼び出す完全に送信される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSend%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSend%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSend%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSend%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーの一部が送信されるまでブロックされます。 戻り値の場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーができなかったことを示します呼び出す完全に送信される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 操作が完了する前に、スレッドが終了した場合、保留中の非同期操作が失敗することができます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>ファイルの保留中の非同期送信を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSendFile%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSendFile%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSendFile%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返されるオブジェクト、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッドが正常に送信操作を完了します。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendFile%2A>データグラムを送信するまでブロックします。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendFile%2A>ファイル全体を送信するまでブロックします。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を作成し、非同期通信のソケットを接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> が、非同期の <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netcore-2.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7.1;netstandard-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" FrameworkAlternate="netframework-4.7;netcore-2.0;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">To be added.</param>
        <param name="result">To be added.</param>
        <summary>特定の場所への、保留中の非同期送信を終了します。</summary>
        <returns>正常に完了した場合は送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 開始された非同期送信操作が完了した<xref:System.Net.Sockets.Socket.BeginSendTo%2A>です。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSendTo%2A>を実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドが別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドに同意する必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドのパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>です。 取得した後に、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSendTo%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendTo%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendTo%2A>要求されたバイト数を送信するまでブロックされます。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、特定の場所への非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> で 1 つのプロセスだけにポートのバインドを許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> で 1 つのソケットだけに特定のポートのバインドを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は<see langword="true" />Windows Server 2003 および Windows XP Service Pack 2、および<see langword="false" />他のすべてのバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>は`false`、複数のソケットを使用することができます、<xref:System.Net.Sockets.Socket.Bind%2A>特定のポートにバインドするメソッド以外の場合は、ソケットの 1 つのみただしがポートに送信されるネットワーク トラフィックの操作を実行できます。 複数のソケットが使用を試みると、<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>より特定の IP アドレスを持つ 1 つはそのポートに送信されるネットワーク トラフィックを処理し、特定のポートにバインドするメソッド。  
  
 場合<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>は`true`の最初の使用、<xref:System.Net.Sockets.Socket.Bind%2A>インターネット プロトコル (IP) アドレスに関係なく、特定のポートにバインドしようとするメソッドは成功します。 の後続のすべての使用、<xref:System.Net.Sockets.Socket.Bind%2A>元は、ソケットをバインドするまでのポートが失敗するようにバインドしようとするメソッドが破棄されます。  
  
 このプロパティは、前に設定する必要があります<xref:System.Net.Sockets.Socket.Bind%2A>が呼び出された場合、<xref:System.InvalidOperationException>がスローされます。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Net.Sockets.Socket" /> に対して <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> が呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>クラスのファイナライザーの呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>を終了するメソッド、<xref:System.Net.Sockets.Socket>に関連付けられているリソースを解放し、<xref:System.Net.Sockets.Socket>です。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> オプションの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値をオブジェクトとして返します。</summary>
        <returns>オプションの値を表すオブジェクト。 <paramref name="optionName" /> パラメーターを <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.LingerOption" /> クラスのインスタンスです。 <paramref name="optionName" /> を <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> または <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.MulticastOption" /> クラスのインスタンスです。 <paramref name="optionName" /> が他の値の場合、戻り値は整数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このオーバー ロードを使用して取得する、 <xref:System.Net.Sockets.SocketOptionName.Linger>、 <xref:System.Net.Sockets.SocketOptionName.AddMembership>、および<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>オプション。 <xref:System.Net.Sockets.SocketOptionName.Linger>オプションを使用して<xref:System.Net.Sockets.Socket>の`optionLevel`パラメーター。 <xref:System.Net.Sockets.SocketOptionName.AddMembership>と<xref:System.Net.Sockets.SocketOptionName.DropMembership>を使用して<xref:System.Net.Sockets.SocketOptionLevel.IP>です。 上記のオプションのいずれかの値の設定を使用する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例の取得、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、それらをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  または、<paramref name="optionName" /> が、サポートされていない値 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> に設定されました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプション設定を受信する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプション設定をバイト配列として返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このメソッドの正常完了時に、によって指定された配列、`optionValue`パラメーターには、指定した値が含まれています。<xref:System.Net.Sockets.Socket>オプション。  
  
 ときの長さ、`optionValue`配列は、指定した値を格納するために必要なバイト数よりも小さい<xref:System.Net.Sockets.Socket>オプション、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 このオーバー ロードを使用して、任意のソケットのブール値または整数値で表されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例の取得、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、それらをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  \- または -  .NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionLength">予期される戻り値のバイト単位の長さ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値を配列で返します。</summary>
        <returns>ソケット オプションの値を格納している <see cref="T:System.Byte" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`パラメーターが返されるバイト配列の最大サイズを設定します。 オプションの値には、以下のバイト数が必要とする場合、配列にはそれだけ多くのバイト数。 オプションの値より多くの容量が必要な場合<xref:System.Net.Sockets.Socket.GetSocketOption%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 このオーバー ロードを使用して、任意のソケットのブール値または整数値で表されます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例の取得、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、それらをコンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  \- または -  .NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> のオペレーティング システム ハンドルを取得します。</summary>
        <value>
          <see cref="T:System.IntPtr" /> のオペレーティング システム ハンドルを表す <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Int32" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <summary>数値制御コードを使用して、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns>
          <paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>メソッドは、オペレーティング システムへの低レベルのアクセスを提供<xref:System.Net.Sockets.Socket>の現在のインスタンスの基になる、<xref:System.Net.Sockets.Socket>クラスです。 詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、FIONREAD と使用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを実行します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Net.Sockets.IOControlCode" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>
          <see cref="T:System.Net.Sockets.IOControlCode" /> 列挙型を使用して制御コードを指定し、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns>
          <paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、オペレーティング システムへの低レベルのアクセスを提供<xref:System.Net.Sockets.Socket>の現在のインスタンスの基になる、<xref:System.Net.Sockets.Socket>クラスです。 詳細については、MSDN ライブラリの WSAIoctl ドキュメントを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、呼び出し元の結果を比較して<xref:System.Net.Sockets.Socket.IOControl%2A>で<xref:System.Net.Sockets.IOControlCode.DataToRead>と<xref:System.Net.Sockets.Socket.Available%2A>プロパティです。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを実行します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> が特定のローカル ポートにバインドされているかどうかを示す値を取得します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> がローカル ポートにバインドされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによって明示的にバインドされている場合、ソケットは、ローカル ポートにバインドされたと見なされます、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、またはのようなメンバーを呼び出すことによって暗黙的にバインドされた<xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、一時的なローカル ポート (空きポート 1024、オペレーティング システムによって選択されているより大きいです) を使用する。サーバーを使用して、<xref:System.Net.Sockets.Socket.Bind%2A>クライアントがそれらに接続できるように、既知のポートにバインドするメソッド。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.IsBound%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> で、すべての保留中のデータを送信しようとするときにソケットを遅延して閉じるかどうかを指定する値を取得または設定します。</summary>
        <value>ソケットを閉じているときの待機方法を指定する <see cref="T:System.Net.Sockets.LingerOption" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>プロパティ方法を変更<xref:System.Net.Sockets.Socket.Close%2A>メソッドは動作します。 このプロパティ セットが Winsock によってする接続をリセットすることができます、条件を変更する場合。 接続のリセットに IP プロトコルの動作に基づいて引き続き発生します。  
  
 このプロパティは、接続指向の接続を開いたまま呼び出しの後に時間の長さを制御<xref:System.Net.Sockets.Socket.Close%2A>データが送信するのには残ります。  
  
 呼び出すと、ピアにデータを送信する方法は、このデータが出力方向のネットワーク バッファーに配置されます。 このプロパティは、前に、リモート ホストにこのデータが送信されるように使用できる、<xref:System.Net.Sockets.TcpClient.Close%2A>メソッドは、接続を切断します。  
  
 接続を維持できるように、作成、 <xref:System.Net.Sockets.LingerOption> 、目的の値を含むをインスタンス化し、設定、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティをこのインスタンスにします。  
  
 次の表の動作、<xref:System.Net.Sockets.Socket.Close%2A>メソッドの有効な値を<xref:System.Net.Sockets.LingerOption.Enabled%2A>プロパティおよび<xref:System.Net.Sockets.LingerOption.LingerTime%2A>に格納されているプロパティ、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティです。  
  
|LingerState.Enabled|LingerState.LingerTime|動作|  
|-------------------------|----------------------------|--------------|  
|`false` (無効)、既定値|タイムアウトは適用、されません (既定値)。|既定の IP プロトコル タイムアウトの期限が切れるまで、保留中のデータ送信を試みます。|  
|`true` (有効)|0 以外のタイムアウト|指定したタイムアウトが経過するまでの試行が失敗した場合は、Winsock 接続がリセット保留中のデータ送信を試みます。|  
|`true` (有効)|0 のタイムアウト|保留中のデータを破棄します。 接続志向ソケット (たとえば、TCP) の場合は、Winsock は接続をリセットします。|  
  
 IP スタックは、接続のラウンド トリップ時間に基づいて使用する既定の IP プロトコルのタイムアウト期間を計算します。 ほとんどの場合、スタックによって計算されたタイムアウトは、アプリケーションで定義された 1 より関連性が高いです。 ソケットの既定の動作は、このとき、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティが設定されていません。  
  
 ときに、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>に格納されているプロパティ、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティは、既定の IP プロトコル タイムアウトよりも大きい設定、既定の IP プロトコル タイムアウトを引き続き適用を上書きします。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">保留中の接続のキューの最大長。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> をリッスン状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 接続指向により<xref:System.Net.Sockets.Socket>受信試行の接続をリッスンするようにします。 `backlog`パラメーターできますのキューへの同意に着信接続の数を指定します。 調べるには、接続の最大数を指定することができます、取得、<xref:System.Net.Sockets.SocketOptionName.MaxConnections>値。 <xref:System.Net.Sockets.Socket.Listen%2A> ブロックされません。  
  
 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。 使用して<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>キューからの接続を受け入れます。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.Listen%2A>、または<xref:System.Net.Sockets.Socket.Listen%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
> [!NOTE]
>  バックログ パラメーターは、オペレーティング システムに応じて異なる値に制限されます。 高い値を指定することがありますが、バックログは限られたオペレーティング システムに基づくです。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket>受信接続をリッスンするようにします。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル エンドポイントを取得します。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> が通信に使用している <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティを取得、<xref:System.Net.EndPoint>するローカル IP アドレスとポート番号を格納している、<xref:System.Net.Sockets.Socket>がバインドされています。 これをキャストする必要があります<xref:System.Net.EndPoint>を<xref:System.Net.IPEndPoint>すべての情報を取得する前にします。 呼び出すことができます、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>ローカルを取得する方法を<xref:System.Net.IPAddress>、および<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>ローカル ポート番号を取得します。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>通常プロパティへの呼び出しを加えた後、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 ソケットのローカル IP アドレスとポート番号を割り当てるシステムを許可する場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>最初の I/O 操作の後にプロパティが設定されます。 接続指向プロトコルでは、最初の I/O 操作になりますへの呼び出し、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを最初の I/O 操作では、送信のいずれかまたは受信呼び出しは。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> が発信マルチキャスト パケットを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マルチキャストは、インターネット上の多対多の通信用のスケーラブルな方法です。 マルチキャスト アドレスをサブスクライブしているプロセス次に、サブスクライブしているプロセスが送信したすべてのパケットは、マルチキャスト アドレスをサブスクライブしている他のすべてのプロセスによって受信されます。  
  
 伝送制御プロトコル (TCP) ソケットにこのプロパティを設定する効果はありません。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリーム <see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用する場合は <see langword="false" />。それ以外の場合は <see langword="true" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle アルゴリズムは、ソケット バッファーの小さなパケットを結合し、特定の状況で 1 つのパケットで送信したりすることで、ネットワーク トラフィックを減らすために設計されています。 TCP パケットは、header、および送信されるデータの 40 バイトで構成されます。 Tcp の小さいデータ パケットが送信されると、TCP ヘッダーに起因するオーバーヘッドは、ネットワーク トラフィックのかなりの部分になります。負荷の高いネットワークでは、このオーバーヘッドの結果として得られる輻輳失われたデータグラムと再送信、だけでなく輻輳による過剰な伝達時間なることができます。 Nagle アルゴリズムでは、送信の新しい TCP segmentswhen 新しい未確認の接続で previouslytransmitted データが残っている場合、ユーザーから到着するデータを送信を禁止します。  
  
 ネットワーク アプリケーションの大部分は、Nagle アルゴリズムを使用する必要があります。  
  
 ユーザー データグラム プロトコル (UDP) ソケットにこのプロパティを設定しても影響します。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.NoDelay%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv6 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">マイクロ秒単位の待機時間。</param>
        <param name="mode">
          <see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか 1 つ。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> の状態を確認します。</summary>
        <returns>
          <paramref name="mode" /> パラメーターで渡されるポーリング モードの値に基づいた <see cref="T:System.Net.Sockets.Socket" /> の状態。  
  
 <list type="table"><listheader><term> モード  </term><description> 戻り値  <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> が呼び出されており、接続が保留中の場合は </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />または、データを読み取ることができる場合は <see langword="true" /> または、接続が閉じている、リセットされている、または終了されている場合は <see langword="true" />、それ以外の場合は <see langword="false" /> を返します。<see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に成功した場合は </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" /> または、データを送信できる場合は <see langword="true" />、それ以外の場合は <see langword="false" /> を返します。ブロックしない <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に失敗した場合は </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />または、<see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> が設定されておらず、帯域外データを使用できる場合は <see langword="true" />、それ以外の場合は <see langword="false" /> を返します。</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>メソッドの状態を確認、<xref:System.Net.Sockets.Socket>です。 指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>の`selectMode`パラメーターかどうかを<xref:System.Net.Sockets.Socket>を読み取ることができます。 指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>かどうかを<xref:System.Net.Sockets.Socket>が書き込み可能です。 使用して<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>エラー状態を検出するためにします。 <xref:System.Net.Sockets.Socket.Poll%2A> 単位で指定された期間までの実行がブロックされます`microseconds`が経過しました。 設定、`microSeconds`の応答を無限に待機する場合は負の整数へのパラメーターです。 複数のソケットの状態を確認するには、使用を好む場合がある、<xref:System.Net.Sockets.Socket.Select%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できない場合や、リモート ホストが異常停止されたことです。 このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、ソケットを作成しは、サーバーに接続を使用して<xref:System.Net.Sockets.Socket.Poll%2A>ソケットの状態を確認します。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="mode" /> パラメーターが、<see cref="T:System.Net.Sockets.SelectMode" /> 値の 1 つではありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> のプロトコルの種類を取得します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>場合、プロパティが設定、<xref:System.Net.Sockets.Socket>が作成されを使用するプロトコルを指定<xref:System.Net.Sockets.Socket>です。  
  
   
  
## Examples  
 次のコード例では表示、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 のみこのオーバー ロードでは、受信バッファーを提供する必要があります。 バッファーの既定値は 0、サイズの既定値は、パラメーターの長さ、バッファー、オフセット、および<xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、接続上のデータを受け取る<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して、受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、バッファー パラメーターにデータを読み取りますを正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
 **注**このメンバーは、アプリケーションでネットワーク トレースを有効にする場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードだけ指定する必要が受信バッファーと、必要な<xref:System.Net.Sockets.SocketFlags>します。 バッファーのオフセットの既定値は 0 で、サイズの既定値はバイト パラメーターの長さ。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、プロトコル スタック バッファーの使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、再試行してください、受信操作します。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用量のデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、データ バッファーを指定し、<xref:System.Net.Sockets.SocketFlags>接続上のデータを受信するため<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにデータを読み込みます、`buffers`パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。 <xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>スローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスから最初にキュー入れられたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、接続上のデータを受信する方法を示します<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。  または、<paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドへのデータを読み取り、`buffer`パラメーターと正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 このオーバー ロードだけが必要です、受信バッファー、バイトを受信して、必要な数を指定する<xref:System.Net.Sockets.SocketFlags>です。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、再試行してください、受信操作します。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、数で指定したバイトの使用可能な多くのデータを読み取る、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次にデータを受信する`buffer`を指定して<xref:System.Net.Sockets.SocketFlags.None>の<xref:System.Net.Sockets.SocketFlags>します。  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにデータを読み込みます、`buffers`パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、どちらかを指定する必要があります。 または以上の受信バッファー。 <xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、リモート ホストでの接続確立から到着するデータのみ読み取る、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>スローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。  または、<paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <c>buffer</c> 内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して、受信バッファー内の指定したオフセット位置に格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、接続上のデータを受信する前に、データ バッファー、オフセット、サイズ、およびソケット フラグを指定します。<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  または、<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<c>buffer</c> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドがバッファー パラメーターにデータを読み取り、読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方からです。  
  
 接続指向のプロトコルを使用している必要がありますか呼び出し<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立または<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に着信接続を受け入れるように<xref:System.Net.Sockets.Socket.Receive%2A>です。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから到着するデータを読み取るだけが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>しないデータがある、タイムアウト値を使用して設定された場合を除き、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがサイズ パラメーターで指定したバイトの数までの使用可能な多くのデータを読み取る。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドです。 受信したデータグラムがのサイズよりも大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分に余分なデータは失われますと<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。  または、<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトからデータを受信する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドを使用してのソケットまたはバインドされたコネクションレス ソケットを接続および着信データの読み取りに使用します。 ソケットのローカル アドレスは認識されている必要があります。  
  
 バインドのコネクションレス ソケットは、この関数は、受信したメッセージの受け入れ元となるアドレスを制限します。 関数には、接続で指定されたリモート アドレスからのメッセージのみを返します。 その他のアドレスからのメッセージが自動的に破棄されます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターが読み取り要求に関する追加情報がウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 バイト ストリーム スタイルのソケットの受信データが、バッファーが指定された、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。  
  
 関連付けられているバッファーの合計サイズの最大バッファーにメッセージ指向のソケットの場合は、受信メッセージが配置されて、`e`パラメーター。 メッセージがバッファーよりも大きい場合は、バッファーがメッセージの最初の部分が入力されます。  
  
 接続指向のソケットに対して、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドが正常に終了するかどうか、ソケットは、バイト ストリーム メッセージ指向に依存している 2 つの方法のいずれかで仮想回線を示すことができます。 バイト ストリーム、正常に閉じられたと以上のバイトを読み取ることが 0 バイトが読み取られたことを示します。 ここで、ゼロ バイトのメッセージがで使用できる多くの場合、メッセージ指向のソケットの<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAEDISCON エラー コード (10101) に設定が正常に閉じられたを示すために使用します。 いずれの場合、<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAECONNRESET に設定エラー コード (10054) を示す強制終了が発生しました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が無効です。 <paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> の受信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>受信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大きなバッファー サイズは可能性がある空の受信確認 (TCP パケット データ部分はありません) の数を削減は、接続に関する問題を認識を遅らせるも可能性があります。 大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなどです。) を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データグラムを受信し、ソース エンドポイントを格納します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が receive `buffer`、および<xref:System.Net.EndPoint>リモート ホストを表すです。 バッファーは、既定値は 0 をオフセットします。 既定値の長さは、サイズ、`buffer`パラメーターおよび`socketFlags`値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のサイズの最大使用量のデータを読み取る`buffer`です。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が受信バッファー、必要な<xref:System.Net.Sockets.SocketFlags>、および<xref:System.Net.EndPoint>リモート ホストを表すです。 オフセットの既定値 0 およびサイズの既定値は、バッファーのパラメーターの長さ。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のサイズの最大使用量のデータを読み取る`buffer`です。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。 <xref:System.Net.Sockets.SocketFlags> 渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを受信してデータ バッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が、必要なを受信するバイト数、受信バッファー <xref:System.Net.Sockets.SocketFlags>、および<xref:System.Net.EndPoint>リモート ホストを表すです。 バッファーは、既定値は 0 をオフセットします。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がで指定したバイトの数まで使用できる多くのデータを読み取り、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。 バッファー サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が <paramref name="buffer" /> の長さを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  または、<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<c>buffer</c> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元となるリモート ホストのエンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレス データグラムを受信する場合に便利です。  
  
 コネクションレスのプロトコルで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに書き込まれる最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズよりも大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`メッセージは、可能であれば、throw の多くで、<xref:System.Net.Sockets.SocketException>です。 信頼性の低いプロトコルを使用している場合、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合、超過データは、サービス プロバイダーによって保持するを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファーを持つメソッドです。  
  
 読み取り、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが読み取られるまでブロックします。 モードの非ブロッキングであるし、利用可能なデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>です。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能かを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>向けコネクションレスのプロトコルを接続指向プロトコルも使用できます。 これを行う場合は、する必要がありますまずか、リモート ホスト接続を確立するを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド着信リモートを受け入れるかを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドが表示されます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターとのみデータが、接続されているまたは既定のリモート ホストを受信します。  
  
 接続指向のソケットと<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はバイト単位で指定された量まで利用可能な量のデータを読み取り、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および利用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 そうしない場合<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレス データグラムを受信します。 オフセット、バッファー サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  または、ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>コネクションレス ソケット上のデータを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスは認識されている必要があります。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストの元のデータを受信することです。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターが読み取り要求に関する追加情報がウィンドウのソケットのサービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 バイト ストリーム – スタイルのソケットの受信データが、バッファーが指定された、接続を終了すると、または内部バッファー内のデータがなくなるまで、バッファーに配置されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<c>buffer</c> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">アドレスとインターフェイスの情報を保持する <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが正常に読み取られたバイト数を返し、データの送信元、受信したパケットに関する情報だけでなく、リモート ホストのエンドポイントをキャプチャします。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>コネクションレス ソケットでメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスは認識されている必要があります。 このメソッドは、データグラムと生のソケットとのみ使用できます。 ソケットの種類に設定されたソケットを初期化する必要があります<xref:System.Net.Sockets.SocketType.Dgram>または<xref:System.Net.Sockets.SocketType.Raw>このメソッドを呼び出す前にします。 これを使用して、ソケットを作成するとき<xref:System.Net.Sockets.Socket.%23ctor%2A>です。  
  
 メッセージ指向のソケットでは、受信メッセージに配置、`buffer`パラメーターで指定された合計サイズの最大、`size`パラメーター。 `offset`パラメーター内の場所を決定する、`buffer`データが配置されます。 配置している実際のデータ量、`buffer`によって返される、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドです。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドに自動的にメソッドを設定、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`初めて呼び出された、指定された<xref:System.Net.Sockets.Socket>です。 ただし、返された<xref:System.Net.Sockets.IPPacketInformation>オブジェクトがのみ有効になります、ソケット オプションが設定された後に、ローカル コンピューターに到達するパケットです。 ローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドまたはの 1 つによって暗黙的に、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド) とその最初の呼び出し、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>へのメソッドを呼び出し<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドは無効な<xref:System.Net.Sockets.IPPacketInformation>これらのパケットのオブジェクト。  
  
 ようにすべて<xref:System.Net.Sockets.IPPacketInformation>オブジェクトが有効で、アプリケーションを設定する必要があります、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`を使用して、ローカル エンドポイントにバインドされる前に、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッドです。  
  
 アプリケーションを調べることができます、`ipPacketInformation`ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを把握する必要がある場合のパラメーターです。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  \- または -  <paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  または、.NET Framework が、AMD 64 ビット プロセッサ上で実行されています。  または、ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定された <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> を使用し、指定されたバイト数のデータの非同期受信を開始して、データ バッファー内の指定された場所に格納します。さらに、エンドポイントとパケットの情報を格納します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>コネクションレス ソケットでメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスは認識されている必要があります。 このメソッドは、データグラムと生のソケットとのみ使用できます。 ソケットの種類に設定されたソケットを初期化する必要があります<xref:System.Net.Sockets.SocketType.Dgram>または<xref:System.Net.Sockets.SocketType.Raw>このメソッドを呼び出す前にします。 これを使用して、ソケットを作成するとき<xref:System.Net.Sockets.Socket.%23ctor%2A>です。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストの元のデータを受信することです。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドが自動的に設定、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`初めて呼び出された、指定された<xref:System.Net.Sockets.Socket>です。 ただし、<xref:System.Net.Sockets.IPPacketInformation>オブジェクトがのみ有効になります、ソケット オプションが設定された後に、ローカル コンピューターに到達するパケットです。 ソケットがローカル エンドポイントにバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドまたはの 1 つによって暗黙的に、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド) および最初の呼び出し、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>へのメソッドを呼び出し<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドは無効になります<xref:System.Net.Sockets.IPPacketInformation>これらのパケットのオブジェクト。  
  
 ようにすべて<xref:System.Net.Sockets.IPPacketInformation>オブジェクトが有効で、アプリケーションを設定する必要があります、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプションに`true`を使用して、ローカル エンドポイントにバインドされる前に、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッドです。  
  
 アプリケーションは、その結果を調べることができます<xref:System.Net.Sockets.IPPacketInformation>オブジェクトのかどうか、ユニキャスト、マルチキャスト、またはブロードキャスト アドレスを使用してデータグラムが送信されたかを知る必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションを適用する同期<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しのみです。 タイムアウト期間を超えた場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート エンドポイントを取得します。</summary>
        <value>
          <see cref="T:System.Net.EndPoint" /> の通信先の <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>プロパティを取得、<xref:System.Net.EndPoint>するリモート IP アドレスとポート番号を格納している、<xref:System.Net.Sockets.Socket>が接続されています。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>既定リモート IP アドレスとポート番号が含まれています、<xref:System.Net.Sockets.Socket>と通信します。 これをキャストする必要があります<xref:System.Net.EndPoint>を<xref:System.Net.IPEndPoint>すべての情報を取得する前にします。 呼び出すことができます、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>リモートを取得する方法を<xref:System.Net.IPAddress>、および<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>をリモートのポート番号を取得する方法です。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>いずれかへの呼び出し後に設定されている<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.Connect%2A>です。 以前にこのプロパティにアクセスしようとする場合<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">書き込み機能をチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">エラーをチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">タイムアウト値 (マイクロ秒)。 値が -1 の場合は、タイムアウトが無限であることを示します。</param>
        <summary>1 つまたは複数のソケットのステータスを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 1 つまたは複数のステータスを決定する静的メソッドは、<xref:System.Net.Sockets.Socket>インスタンス。 1 つまたは複数のソケットを配置する必要があります、<xref:System.Collections.IList>使用する前に、<xref:System.Net.Sockets.Socket.Select%2A>メソッドです。 読みやすさを呼び出して確認<xref:System.Net.Sockets.Socket.Select%2A>で、<xref:System.Collections.IList>として、`checkRead`パラメーター。 確認するには、どうを使用して、`checkWrite`パラメーター。 エラー条件を検出するため使用`checkError`です。 呼び出した後<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>の条件を満たすソケットのみが格納されます。  
  
 リッスン状態の場合は、読みやすくすることを意味する呼び出し<xref:System.Net.Sockets.Socket.Accept%2A>ブロックすることがなくは成功します。 接続を受け入れている場合、読みやすさはデータが読み取り可能であるを意味します。 このような場合は、すべての受信操作はブロックすることがなく成功します。 読みやすくすることもあるかどうか、リモート<xref:System.Net.Sockets.Socket>がシャット ダウン接続以外の場合はそのケースへの呼び出し<xref:System.Net.Sockets.Socket.Receive%2A>は返されたゼロのバイト数で、すぐに戻ります。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 時に返す目的のソケットの少なくとも 1 つ (におけるソケット、 `checkRead`、 `checkWrite`、および`checkError`を一覧表示) が、指定した条件を満たしている、または`microSeconds`パラメーターを超過すると、どちらか早い方です。 設定`microSeconds`を-1 に無限のタイムアウトを指定します。  
  
 非ブロッキング呼び出しを行う場合<xref:System.Net.Sockets.Socket.Connect%2A>、書き込みの許可が正常に接続していることを意味します。 確立された接続がある場合、書き込みの許可は、すべての送信操作はブロックすることがなく成功を意味します。  
  
 非ブロッキング呼び出しを行ったかどうか<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`パラメーターが正常に接続されていないソケットを識別します。  
  
> [!NOTE]
>  使用して、<xref:System.Net.Sockets.Socket.Poll%2A>メソッドの場合は、1 つの状態を判別する<xref:System.Net.Sockets.Socket>です。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できない場合や、リモート ホストが異常停止されたことです。 このようなエラーを検出するためにデータの送受信を送信しようとする必要があります。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.Select%2A>接続要求をリッスンしているソケットを決定します。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。  - および -  <paramref name="checkWrite" /> パラメーターが <see langword="null" /> または空です。  - および -  <paramref name="checkError" /> パラメーターが <see langword="null" /> または空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するデータを格納しているバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>を 0 に初期値として、バッファーのオフセットの既定値は 0、およびバッファーのサイズを既定値を送信するバイト数。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を示しますに接続されたデータの送信<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 確立されているリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>接続指向とコネクションレス プロトコルの両方のメソッドを使用できます。  
  
 このオーバー ロードは、送信するデータを格納するバッファーとビットごとの組み合わせが必要です。<xref:System.Net.Sockets.SocketFlags>です。 バッファーは、既定値は 0、およびバッファーのサイズを既定値を送信するバイト数をオフセットします。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターの値に、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドに対する各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例を示しますに接続されたデータの送信<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>値の既定値は 0 です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketFlags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 確立されているリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 このオーバー ロードには、送信するバイト数といずれかのビットごとの組み合わせを送信するデータを格納するバッファーが必要です。<xref:System.Net.Sockets.SocketFlags>です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドに対する各呼び出しの前に、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向プロトコルが<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、バッファーで見つかったデータを送信し、指定<xref:System.Net.Sockets.SocketFlags.None>の<xref:System.Net.Sockets.SocketFlags>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> が 0 未満か、バッファーのサイズを超える値です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、ソケットへのアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するデータを含む、少なくとも 1 つのバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>値の既定値は 0 です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketFlags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、すべてのバッファー内のバイトを送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数より小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが、バッファー内のバイトを送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>です。 使用しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することが<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<xref:System.Net.Sockets.SocketFlags>に接続されたデータを送信するため<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns>
          <see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス プロトコルの両方を使用できます。  
  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要があります複数の異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>です。 使用しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す必要が<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>です。 使用することが<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>です。 呼び出しの前に既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>を別の呼び出しを行って<xref:System.Net.Sockets.Socket.Connect%2A>です。  
  
 サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定されていない限り、要求されたバイト数を送信するまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>です。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>です。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも少ない場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されることは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されている場合を除きがブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<xref:System.Net.Sockets.SocketFlags>に接続されたデータを送信するため<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、データを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドを使用して、接続指向のソケットで 1 つ以上のバッファーの送信データを書き込みます。 このメソッドこともできます、ただし、コネクションレス型のソケット接続操作でリモート ホストが指定されています。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドです。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定されています。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドが例外をスロー最初に呼び出す必要はありません<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>です。  
  
 呼び出す、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。  
  
 メッセージ指向のソケットでは、基になる Windows sockets サービス プロバイダーのメッセージの最大サイズを超えないようにしないでください。 データが長すぎて、基になるサービス プロバイダーの場合は、データは送信されず<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ Winsock WSAEMSGSIZE エラー コード (10040) に設定します。  
  
 なおが正常に完了、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドは、データが正常に送信されたことを指定していません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていないか、<see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />、または <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> の各メソッドによって取得されませんでした。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> の送信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>送信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大きなバッファー サイズは、接続に関する問題を認識に遅れる可能性があります。 大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなどです。) を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.SendBufferSize%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> に、ファイルおよびオプション データを同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>
          <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 送信フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、そのファイルを送信`fileName`接続されたソケットにします。 `flags`パラメーターの既定値<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)、および`preBuffer`と`postBuffer`パラメーターに既定の`null`します。 場合`fileName`されますが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 指定されたリモート ホストにファイルを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.SendFile%2A> 接続指向両方とコネクションレスのプロトコルを使用できます。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>それ以外の場合、このメソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendFile%2A>ファイルを送信するまでブロックします。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信される前に正常に完了場合があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendFile%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、作成しソケットを接続し、リモート ホストにファイルを送信します。 ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<xref:System.Net.Sockets.TransmitFileOptions>値。 `preBuffer`パラメーターには、ファイルの前にすべてのデータが含まれています。 `postBuffer` ファイルを使用するデータが含まれています。 場合`fileName`されますが、現在の作業ディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。  
  
 `flags`パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>です。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API である関数。 詳細については、`TransmitFile`関数およびそのフラグは、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 指定されたリモート ホストにファイルを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 <xref:System.Net.Sockets.Socket.SendFile%2A> 接続指向両方とコネクションレスのプロトコルを使用できます。  
  
 コネクションレスのプロトコルを使用している場合を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>です。 このメソッドを呼び出す前にそれ以外の場合<xref:System.Net.Sockets.Socket.SendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>です。 いずれかを使用する必要があります、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>リモート ホスト接続を確立するかを使用して<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体を送信するまでブロックします。 モードでは非ブロッキング、<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信される前に正常に完了場合があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendFile%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では、作成し、ソケットを接続します。 ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。 この例では事前バッファリングと事後バッファリングのデータを作成し、ファイルのあるリモート ホストに送信します。 既定値<xref:System.Net.Sockets.TransmitFileOptions>使用されます。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  \- または -  ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルのコレクションまたはメモリ内のデータ バッファーを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>リモート ホストにデータ バッファーをメモリ内、またはファイルのコレクションに送信するメソッドを使用します。 <xref:System.Net.Sockets.Socket>リモート ホストに既に接続されている必要があります。  
  
 場合、<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>作業ディレクトリでファイルを参照、ファイルの名前だけで識別できること以外の場合はそれ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカードおよび UNC 共有名がサポートされています。 ファイルが見つからない場合<xref:System.IO.FileNotFoundException>がスローされます。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターは、ファイルの転送に関する追加情報がウィンドウのソケット サービス プロバイダーを提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>です。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 このメソッドは、Windows ソケット 2 API で見つかった TransmitPackets 関数を使用します。 TransmitPackets 関数およびそのフラグの詳細については、MSDN ライブラリの Windows Sockets ドキュメントを参照してください。  
  
 接続指向プロトコルでは、意図したものが、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドに対しても機能コネクションレスのプロトコルを最初に呼び出すこと、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>既定のリモート ホストを構築する方法です。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>が使用されるオペレーティング システムに従ってメソッドを最適化します。 Windows server のエディションで、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドは高パフォーマンスを最適化します。  
  
 Windows クライアントの各エディションで、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドが最低限のメモリとリソース使用率を最適化します。  
  
 使用、<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>フラグ、<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターは、大幅なパフォーマンス上の利点を提供できます。 場合、スレッドを開始する、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>大量の計算には、メソッドの呼び出しを使用している、可能であればもわずかながら、Apc が起動できない可能性があることもできます。 カーネルとユーザー モードの Apc の違いがあることに注意してください。 スレッドが待機状態には、カーネル Apc が起動します。 ユーザー モード Apc スレッドは、アラートの待機状態での起動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> プロパティで指定されたファイルが見つかりませんでした。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">コネクションレスの <see cref="T:System.Net.Sockets.Socket" /> が使用されており、送信するファイルが基になるトランスポートの最大パケット サイズを超えています。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 プロパティに 1 から 499 までの値を設定しても、その値は 500 に変更されます。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションを適用する同期<xref:System.Net.Sockets.Socket.Send%2A>呼び出しのみです。 タイムアウト期間を超えた場合、<xref:System.Net.Sockets.Socket.Send%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.SendTimeout%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データを特定のエンドポイントに送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">データの送信先を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定したエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーのオフセットの既定値は 0 の場合のサイズに既定値を送信するバイトの数、`buffer`パラメーター、および<xref:System.Net.Sockets.SocketFlags>値の既定値は 0 です。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットは、すべてのバッファー内のバイトが送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了する、すぐにその可能性がありますいないすべての送信内のバイト、`buffer`です。 送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの責任である、`buffer`です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の送信データが収集されるまでに伝送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>です。 送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、特定のエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーのオフセットの既定値は 0、およびのサイズに既定値を送信するバイト数、`buffer`です。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットはブロックされるまで、要求されたすべてのバイト数の`buffer`送信されます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了する、すぐにその可能性がありますいないすべての送信内のバイト、`buffer`です。 送信されたバイト数を追跡して、アプリケーションでは、すべてのバイトを送信するまで、操作を再試行する、アプリケーションの責任である、`buffer`です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>です。 送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。 <xref:System.Net.Sockets.SocketFlags> 渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーは、既定値は 0 をオフセットします。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>完了いない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの責任です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>です。 送信されたバイト数が、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。 サイズと<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した <paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags">
          <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。送信はバッファー内の指定した位置から開始されます。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーターに、データを送信すると、ルーティングされません。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.Send%2A>メソッドです。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信するため、指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することができます、割り当てられているローカル ネットワーク アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了するとします。  
  
 コネクションレス プロトコルは、意図したものが<xref:System.Net.Sockets.Socket.SendTo%2A>接続指向プロトコルでも動作します。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信要求を使用して接続を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドです。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 呼び出しの前にコネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとのみデータを送信する、接続または既定のリモート ホストします。  
  
 ブロッキング ソケットは、要求されたバイト数が送信されるまでブロックされます。 非ブロッキング以降<xref:System.Net.Sockets.Socket>完了いない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。 アプリケーション送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行してください。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワーク効率を向上させるのに基になるシステムは大量の発信データが収集されるまで転送を遅れる可能性があります。 正常に完了する、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムが実際のデータをネットワークに送信バッファーする領域がいることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>です。 サイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例は、指定したリモート ホストにコネクションレス データグラムを送信します。 オフセット、サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドです。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> は <see langword="null" />です。  または、<paramref name="remoteEP" /> が <see langword="null" /> です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> が 0 未満です。  または、<paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  または、<paramref name="size" /> が 0 未満です。  または、<paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  または、<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>I/O 操作が保留中の場合は、<see langword="true" /> を返します。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  I/O 操作が同期的に完了した場合は、<see langword="false" /> を返します。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドで指定されたリモート ホストへの非同期送信操作を開始、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>のプロパティ、`e`パラメーター。 呼び出す、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは、個別の実行スレッド内でデータを送信する機能を提供します。 このメソッドはコネクションレスのプロトコルのものが<xref:System.Net.Sockets.Socket.SendToAsync%2A>コネクションレス型との接続指向プロトコルの両方で動作します。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、アタッチするためのコールバック、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが正常にこのメソッドを呼び出す必要があります。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持するために、小さいクラスを作成できます。  
  
 最初に呼び出す必要がある接続指向のプロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドです。 それ以外の場合<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 接続指向のプロトコルを使用する場合、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは無視されます、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティと送信のデータを<xref:System.Net.EndPoint?displayProperty=nameWithType>で確立されている、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドです。  
  
 コネクションレスのプロトコルを使用している場合は既定のリモート ホストとの確立する必要はありません、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendToAsync%2A>です。 この呼び出しをする場合にだけ、<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドです。 呼び出す場合、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendToAsync%2A>、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>操作のみを送信するのプロパティで指定された既定のリモート ホストは無効です。 必要はありませんを呼び出して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドです。 この場合、基になるサービス プロバイダーは、最も適切なローカル ネットワーク IP アドレスとポート番号を割り当てます。 基になるサービス プロバイダーは、空いているポートを選択する場合は、ゼロのポート番号を使用します。 使用することができます、割り当てられているローカル ネットワーク IP アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>後プロパティ、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントがシグナル状態にし、関連付けられているデリゲートが呼び出されます。  
  
 ブロードキャスト アドレスにデータを送信する場合は、最初に呼び出す必要があります、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>true に設定します。 バッファーのサイズが、基になるサービス プロバイダーのパケットの最大サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。  
  
 DontRoute フラグを指定する場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティに、データを送信すると、ルーティングされません。  
  
 メッセージ指向のソケットでは、基になるトランスポートのメッセージの最大サイズを超えないように注意する必要があります。 バッファーのサイズは、基になるサービス プロバイダーのパケットの最大サイズを超えている場合、データグラムが送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>です。 正常に完了、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは、データが正常に送信されたことを指定していません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定されたプロトコルは接続指向ですが、<see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">このソケットに設定する IP 保護レベル。</param>
        <summary>ソケットの IP 保護レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドにより、制限、IPv6、または IP ソケット アドレスと同じローカル リンクまたはサイト ローカル プレフィックスなど、特定のスコープをリッスンするようにします。 このソケット オプションでは、IPv6、または IP ソケットにアクセス制限を設定するアプリケーションを使用します。 この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。 このソケット オプションは、アクセスの制限を削除する場合にも使用できます、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>です。 このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。  
  
 このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドを使用を有効または無効のように、ネットワーク アドレス トラバーサル (NAT) を<xref:System.Net.Sockets.Socket>インスタンス。 NAT トラバーサルを指定するには、Teredo、6to4、または ISATAP トンネルを使用します。  
  
 ときに、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>、または<xref:System.Net.Sockets.IPProtectionLevel.Restricted>、NAT トラバーサルが明示的に無効になります、<xref:System.Net.Sockets.Socket>インスタンス。  
  
 ときに、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>、NAT トラバーサルを許可するこの可能性があります、<xref:System.Net.Sockets.Socket>によっては、システム上でファイアウォール規則です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="level" /> パラメーターとして <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> を使用することはできません。 IP 保護レベルを未指定に設定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">ソケットの <see cref="T:System.Net.Sockets.AddressFamily" /> は、<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> である必要があります。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> オプションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">
          <see cref="T:System.Boolean" /> として表されるオプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した <see cref="T:System.Boolean" /> 値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 設定`optionValue`に`true`オプションを有効にまたは`false`オプションを無効にします。  
  
 <xref:System.Net.Sockets.Socket> オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次のとおり、さまざまな<xref:System.Net.Sockets.Socket>オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化<xref:System.Net.Sockets.SocketOptionLevel>値。 これらのオプションのいずれかを設定する場合は、必ず使用して、適切な<xref:System.Net.Sockets.SocketOptionLevel>値を`optionLevel`パラメーター。 設定を選択するオプションを指定する必要があります、`optionName`パラメーター。 記載されているオプションのいずれかの現在の値を取得するには、使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 これらのオプションの詳細についてを参照してください、<xref:System.Net.Sockets.SocketOptionName>列挙します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 ソケットを開き、により、次のコード例、`DontLinger`と`OutOfBandInline`ソケット オプション。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値を表す <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はバイト配列で表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このオーバー ロードを使用して、それらを設定する<xref:System.Net.Sockets.Socket>オプションの値としてバイト配列を必要とするオプションです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した整数値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 オプションである場合の<xref:System.Boolean>0 以外の値をこのオプションを有効にして、オプションを無効にゼロ値を指定、データ型します。 整数データ型のオプションでは、適切な値を指定します。 <xref:System.Net.Sockets.Socket> オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次のとおり、さまざまな<xref:System.Net.Sockets.Socket>オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化<xref:System.Net.Sockets.SocketOptionLevel>です。 これらのオプションのいずれかを設定する場合は、必ず使用して、適切な<xref:System.Net.Sockets.SocketOptionLevel>の`optionLevel`パラメーター。 設定を選択するオプションを指定する必要があります、`optionName`パラメーター。 記載されているオプションのいずれかの現在の値を取得するには、使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 これらのオプションの詳細についてを参照してください、<xref:System.Net.Sockets.SocketOptionName>列挙します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">
          <see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか 1 つ。</param>
        <param name="optionName">
          <see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか 1 つ。</param>
        <param name="optionValue">オプションの値を格納する <see cref="T:System.Net.Sockets.LingerOption" /> または <see cref="T:System.Net.Sockets.MulticastOption" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はオブジェクトで表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>です。 このオーバー ロードを使用して、設定、 <xref:System.Net.Sockets.SocketOptionName.Linger>、 <xref:System.Net.Sockets.SocketOptionName.AddMembership>、および<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>オプション。 <xref:System.Net.Sockets.SocketOptionName.Linger>オプションを使用して<xref:System.Net.Sockets.Socket>の`optionLevel`パラメーター。 <xref:System.Net.Sockets.SocketOptionName.AddMembership>と<xref:System.Net.Sockets.SocketOptionName.DropMembership>を使用して<xref:System.Net.Sockets.SocketOptionLevel.IP>です。 上記のオプションのいずれかの現在の値を取得するには、使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッドです。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>のタイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">許可されなくなる操作を指定する <see cref="T:System.Net.Sockets.SocketShutdown" /> 値の 1 つ。</param>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> での送受信を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向の使用時に<xref:System.Net.Sockets.Socket>、常に呼び出し、<xref:System.Net.Sockets.Socket.Shutdown%2A>閉じる前にメソッド、<xref:System.Net.Sockets.Socket>です。 これにより、すべてのデータが送信されが閉じる前に、接続されたソケットで受信したことです。  
  
 呼び出す、<xref:System.Net.Sockets.Socket.Close%2A>マネージし、アンマネージに関連付けられているリソースのすべてを解放するメソッド、<xref:System.Net.Sockets.Socket>です。 再利用しないで、<xref:System.Net.Sockets.Socket>終了後にします。  
  
 次の表に、<xref:System.Net.Sockets.SocketShutdown>に対して有効な列挙値、`how`パラメーター。  
  
|[値]|説明|  
|-----------|-----------------|  
|送信|この送信は無効に<xref:System.Net.Sockets.Socket>です。|  
|Receive|この受信を無効にする<xref:System.Net.Sockets.Socket>です。|  
|両方|両方の送受信にこれを無効にする<xref:System.Net.Sockets.Socket>です。|  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Send>後続のことを指定するために呼び出す<xref:System.Net.Sockets.Socket.Send%2A>は許可されていません。 場合は、コネクションレス型を使用している<xref:System.Net.Sockets.Socket>を指定して、<xref:System.Net.Sockets.SocketShutdown.Send>効果はありません。  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Receive>後続のことを指定するために呼び出す<xref:System.Net.Sockets.Socket.Receive%2A>は許可されていません。 下位のプロトコル層への影響はありません。 接続指向のプロトコルを使用している呼び出しの後に、次の条件のいずれかが存在する場合、接続が終了<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   データは受信を待機しているネットワークの着信バッファーです。  
  
-   多くのデータが到着しました。  
  
 コネクションレスのプロトコルを使用している場合は、データグラムが受け入れてし、キューに置かれました。 ただし、追加の受信データグラムの使用可能なバッファー領域がない場合は破棄され、送信者にエラーが返されません。 使用して<xref:System.Net.Sockets.Socket.Shutdown%2A>、コネクションレスで<xref:System.Net.Sockets.Socket>はお勧めしません。  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Both>両方の送信を無効にし、前述のように受信します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を呼び出すときに、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドを使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。 [.NET Framework のネットワークのトレース](~/docs/framework/network-programming/network-tracing.md)です。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.Shutdown%2A>を無効にする、<xref:System.Net.Sockets.Socket>です。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか 1 つ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 読み取り専用と設定されているときに、<xref:System.Net.Sockets.Socket>を作成します。  
  
   
  
## Examples  
 次のコード例では表示、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のホストで IPv4 サポートが使用可能で有効になっているかどうかを示す値を取得します。</summary>
        <value>現在のホストが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メンバー向けに、フレームワークが IPv6 をサポートしているかどうかを示す値を取得します。</summary>
        <value>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メソッド向けに、フレームワークが IPv6 をサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Net.Sockets.Socket" /> によって送信されたインターネット プロトコル (IP) パケットの有効期間 (TTL) の値を指定する値を取得または設定します。</summary>
        <value>TTL の値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL 値は、ルーターはパケットとインターネット制御メッセージ プロトコル (ICMP) の"TTL を超えています"を破棄する前に、パケットが走査できるルーターの最大数を示すエラー メッセージが送信者に返されます。  
  
 TTL 値は、0 255 からの値に設定可能性があります。 このプロパティが設定されていないときに、ソケットの既定の TTL 値は 32 です。  
  
 伝送制御プロトコル (TCP) ソケットでこのプロパティの設定は無視されますスタックによって、TCP/IP ソケットを使用して正常な接続が確立された場合。  
  
 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>固有のエラー コードを取得するプロパティです。 このコードを取得した後 Windows ソケットのバージョン 2 API エラー コードのドキュメント、MSDN ライブラリを参照エラーの詳細な説明。  
  
   
  
## Examples  
 使用を次のコード例に示します、<xref:System.Net.Sockets.Socket.Ttl%2A>プロパティです。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 値には、負の数を設定できません。</exception>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 このエラーは、TTL に 255 より大きい値を設定しようとしたときにも返されます。</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソケットが重複 I/O モードだけを使用する必要があるかどうかを指定します。</summary>
        <value>
          <see cref="T:System.Net.Sockets.Socket" /> が重複 I/O モードだけを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定`true`の<xref:System.Net.Sockets.Socket>を呼び出そうと<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>です。 それ以外の場合、フレームワークは、ソケットは、の使用を禁止するように、完了ポートを割り当てることが<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>です。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ソケットが完了ポートにバインドされています。</exception>
      </Docs>
    </Member>
  </Members>
</Type>