<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="771bc63ed8e74a35e152dfca4c416071c5963605" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57962603" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Berkeley ソケット インターフェイスを実装します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>クラスは、ネットワーク通信のメソッドとプロパティの豊富なセットを提供します。 <xref:System.Net.Sockets.Socket>クラスを使用すると、両方を実行する同期と記載されている通信プロトコルを使用して非同期データ転送、<xref:System.Net.Sockets.ProtocolType>列挙体。  
  
 <xref:System.Net.Sockets.Socket>クラスが非同期メソッドの場合は、.NET Framework 名前付けパターンに従います。 たとえば、同期<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは非同期に対応<xref:System.Net.Sockets.Socket.BeginReceive%2A>と<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッド。  
  
 アプリケーションには、実行中に 1 つのスレッドのみ必要とする場合は、同期操作モード用に設計された次のメソッドを使用します。  
  
-   接続を使用して、サーバーをリッスンできる TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Listen%2A>メソッド。 <xref:System.Net.Sockets.Socket.Accept%2A>メソッド プロセスのすべての着信接続を要求し、返します、<xref:System.Net.Sockets.Socket>データをリモート ホストと通信するために使用することできます。 この返さ<xref:System.Net.Sockets.Socket>を呼び出す、<xref:System.Net.Sockets.Socket.Send%2A>または<xref:System.Net.Sockets.Socket.Receive%2A>メソッド。 呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す前に、<xref:System.Net.Sockets.Socket.Listen%2A>メソッド ローカル IP アドレスとポート番号を指定する場合。 空きポートを割り当てるには、基になるサービス プロバイダーが必要な場合は、0 のポート番号を使用します。 リッスンしているホストに接続する場合は、呼び出し、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 データを通信するために呼び出す、<xref:System.Net.Sockets.Socket.Send%2A>または<xref:System.Net.Sockets.Socket.Receive%2A>メソッド。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合は、すべての接続をリッスンする必要はありません。 呼び出す、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドを受信データグラムをそのまま使用します。 使用して、<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムをリモート ホストに送信するメソッド。  
  
 実行中に個別のスレッドを使用して通信を処理するには、非同期の操作モード用に設計された次のメソッドを使用します。  
  
-   TCP などの接続指向プロトコルを使用している場合は、使用、 <xref:System.Net.Sockets.Socket>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、および<xref:System.Net.Sockets.Socket.EndConnect%2A>リッスン中のホストに接続する方法。 使用して、<xref:System.Net.Sockets.Socket.BeginSend%2A>と<xref:System.Net.Sockets.Socket.EndSend%2A>または<xref:System.Net.Sockets.Socket.BeginReceive%2A>と<xref:System.Net.Sockets.Socket.EndReceive%2A>データを非同期的に通信するメソッド。 使用して受信接続要求を処理できる<xref:System.Net.Sockets.Socket.BeginAccept%2A>と<xref:System.Net.Sockets.Socket.EndAccept%2A>します。  
  
-   UDP などのコネクションレスのプロトコルを使用している場合を使用できます<xref:System.Net.Sockets.Socket.BeginSendTo%2A>と<xref:System.Net.Sockets.Socket.EndSendTo%2A>、データグラムを送信して<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>と<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>データグラムを受信します。  
  
 ソケットでの複数の非同期操作を実行する場合、必ずしもで完了しなかった開始される順序。  
  
 送信を完了して、データを受信したらを使用して、<xref:System.Net.Sockets.Socket.Shutdown%2A>無効にする方法、<xref:System.Net.Sockets.Socket>します。 呼び出した後<xref:System.Net.Sockets.Socket.Shutdown%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>に関連付けられているすべてのリソースを解放するメソッド、<xref:System.Net.Sockets.Socket>します。  
  
 <xref:System.Net.Sockets.Socket>クラスを使用すると、構成、<xref:System.Net.Sockets.Socket>を使用して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッド。 使用してこれらの設定を取得、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッド。  
  
> [!NOTE]
>  比較的単純なアプリケーションを作成して最大のパフォーマンスを必要としない場合は、使用を検討して<xref:System.Net.Sockets.TcpClient>、 <xref:System.Net.Sockets.TcpListener>、および<xref:System.Net.Sockets.UdpClient>します。 これらのクラスに簡素化されよりユーザー フレンドリなインターフェイスを提供する<xref:System.Net.Sockets.Socket>通信します。  
  
   
  
## Examples  
 次のコード例に示す方法、 <xref:System.Net.Sockets.Socket> HTTP サーバーにデータを送信し、応答を受信するクラスを使用できます。 この例は、ページ全体を受信するまでブロックします。  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">送信接続を確立するか、受信要求を受け入れます。</permission>
    <threadsafe>このクラスのインスタンスはスレッド セーフです。</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">.NET Framework のネットワーク プログラミング</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">System.Net クラスのベスト プラクティス</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">ネットワーク アプリケーションのキャッシュ管理</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">インターネット プロトコル バージョン 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">ネットワーク プログラミングのサンプル</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">.NET Framework のネットワークのトレース</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">ネットワーク プログラミングにおけるセキュリティ</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">バージョン 3.5 のソケット パフォーマンスの強化</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> によって返されるソケット情報。</param>
        <summary><see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> から返された値を指定して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出す場合、<xref:System.Net.Sockets.Socket.%23ctor%2A>の各呼び出しの引数と同じバイト配列で複数回コンス トラクターは、複数の管理を作成、<xref:System.Net.Sockets.Socket>同じ基になるソケットで s。 この方法はお勧めします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>指定したソケットの種類とプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `socketType`パラメーターの型を指定、<xref:System.Net.Sockets.Socket>クラスおよび`protocolType`パラメーターで使用されるプロトコルを指定する<xref:System.Net.Sockets.Socket>します。 2 つのパラメーターは独立していません。 多くの場合、<xref:System.Net.Sockets.Socket>型は、プロトコルで暗黙の型。 場合の組み合わせ<xref:System.Net.Sockets.Socket>種類およびプロトコルの種類が無効結果<xref:System.Net.Sockets.Socket>、このコンス トラクターがスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  このコンス トラクターがスローした場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを特定のエラー コードを取得します。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketType" /> と <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか。</param>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <summary>指定したアドレス ファミリ、ソケットの種類、およびプロトコルを使用して、<see cref="T:System.Net.Sockets.Socket" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `addressFamily`パラメーターをアドレッシング スキームを指定します、<xref:System.Net.Sockets.Socket>クラスで使用、`socketType`パラメーターの型を指定、<xref:System.Net.Sockets.Socket>クラス、および`protocolType`パラメーターで使用されるプロトコルを指定<xref:System.Net.Sockets.Socket>します。 3 つのパラメーターは独立していません。 どのプロトコルを使用して、多くの場合、一部のアドレス ファミリを制限する、<xref:System.Net.Sockets.Socket>型は、プロトコルで暗黙の型。 場合、アドレス ファミリの組み合わせ<xref:System.Net.Sockets.Socket>型、およびプロトコルの種類は、無効な<xref:System.Net.Sockets.Socket>、このコンス トラクターがスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  このコンス トラクターがスローした場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>プロパティを特定のエラー コードを取得します。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、のインスタンスを作成する方法を示します、<xref:System.Net.Sockets.Socket>クラス。  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="addressFamily" />、<paramref name="socketType" />、および <paramref name="protocolType" /> を組み合わせると、無効なソケットになります。</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>新しく作成された接続に対して新しい <see cref="T:System.Net.Sockets.Socket" /> を作成します。</summary>
        <returns>新しく作成された接続に対する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> 同期的にリッスン ソケットの接続要求のキューから最初の保留中の接続要求を抽出します。 を作成し、新しい<xref:System.Net.Sockets.Socket>します。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 ただし、呼び出すことができます、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>メソッドは、返された<xref:System.Net.Sockets.Socket>リモート ホストのネットワーク アドレスとポート番号を識別するためにします。  
  
 ブロッキング モード<xref:System.Net.Sockets.Socket.Accept%2A>受信接続の試行がキューに登録するまでブロックします。 接続が受け入れられると、元の<xref:System.Net.Sockets.Socket>キューの着信接続を要求するまで閉じることが続行されます。  
  
 非ブロッキングを使用してこのメソッドを呼び出すかどうか<xref:System.Net.Sockets.Socket>、し、要求がキューに接続できない<xref:System.Net.Sockets.Socket.Accept%2A>スロー、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  呼び出しの前に、<xref:System.Net.Sockets.Socket.Accept%2A>メソッドを呼び出す必要があります最初、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、受信接続要求をキューのメソッド。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、単純な<xref:System.Net.Sockets.Socket>接続します。  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.Accept" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、キューの受信接続要求メソッド。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > を委任し、それを<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元は、既存の必要に応じて指定できます<xref:System.Net.Sockets.Socket>を指定して、着信接続に使用する、<xref:System.Net.Sockets.Socket>で使用する、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティ。  
  
 場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティが null の場合、新しい<xref:System.Net.Sockets.Socket>が同じで構築されて<xref:System.Net.Sockets.Socket.AddressFamily%2A>、 <xref:System.Net.Sockets.Socket.SocketType%2A>、および<xref:System.Net.Sockets.Socket.ProtocolType%2A>現在<xref:System.Net.Sockets.Socket>として設定し、<xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType>プロパティ。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 必要に応じて、後にソケット上のデータの最初のブロックを受信するバッファーを指定することがあります、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功しました。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティを受信するデータを含むバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティは、バッファーを受信するデータのバイトの最大数に設定する必要があります。 使用して、これらのプロパティを設定することができます、<xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType>メソッド。 渡されたバッファーの一部で使用される内部的に使用するため、基になる Winsock AcceptEx 呼び出し。 つまり、返されるデータ量が常の値より小さい、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>指定されたインスタンス。 内部的に使用されるバッファーの量は、ソケットのアドレス ファミリによって異なります。 必要な最小バッファー サイズは、288 バイトです。 大きなバッファー サイズが指定されている場合、 <xref:System.Net.Sockets.Socket> Winsock AcceptEx 呼び出しで受信したアドレス データ以外のいくつかの余分なデータを求めるし、この余分なデータを受信するまで待機します。 タイムアウトが発生する場合は、接続がリセットされます。 その追加のデータは、特定の金額の予測されますが場合に、最小バッファー サイズにこの量が加わりますバッファー サイズを設定する必要があります。  
  
 完了コールバック メソッドを調べる必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>プロパティかどうかを<xref:System.Net.Sockets.Socket.AcceptAsync%2A>操作は成功しました。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントは接続が許可されていないときに、いくつかの場合に発生して、原因、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>プロパティを設定する<xref:System.Net.Sockets.SocketError.ConnectionReset>します。 これは、ポートをハーフ オープン SYN の種類のスキャンを使用してスキャンの結果として発生 (SYN SYN ACK]-> [RST のシーケンスを ->)。 アプリケーションを使用して、<xref:System.Net.Sockets.Socket.AcceptAsync%2A>メソッドは、この条件を処理するために準備する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、提供されたバッファーのサイズが不足している場合に発生します。 バッファーは、2 * (sizeof(SOCKADDR_STORAGE + 16) バイト以上であることが必要です。  
  
この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合にも発生します。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">引数が範囲外です。 この例外は、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> が 0 未満の場合に発生します。</exception>
        <exception cref="T:System.InvalidOperationException">無効な操作が要求されました。 この例外は、受け入れ側の <see cref="T:System.Net.Sockets.Socket" /> が接続をリッスンしていない場合、または受け入れられたソケットがバインドされている場合に発生します。  
  
<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドを呼び出す前に、<see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> メソッドと <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> メソッドを呼び出す必要があります。  
  
この例外は、ソケットが既に接続されている、またはソケット操作が指定された <paramref name="e" /> パラメーターを使用して既に進行中の場合にも発生します。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のアドレス ファミリを取得します。</summary>
        <value><see cref="T:System.Net.Sockets.AddressFamily" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.AddressFamily>をアドレッシング スキームを指定します。 のインスタンス、<xref:System.Net.Sockets.Socket>クラスを使用できます。 このプロパティは読み取り専用と場合、設定は、<xref:System.Net.Sockets.Socket>が作成されます。  
  
   
  
## Examples  
 次のコード例が表示されます、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ネットワークから受信した、読み取り可能なデータ量を取得します。</summary>
        <value>ネットワークから受信した、読み取り可能なデータのバイト数。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非ブロッキングを使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Available%2A>を呼び出す前に、読み取り用のデータがキューに置かれたかどうかを決定する良い方法は、<xref:System.Net.Sockets.Socket.Receive%2A>します。 使用可能なデータは、読み取り用のネットワーク バッファーにデータの総量がキューに登録します。 場合は、ネットワーク バッファーにデータがキューにありません。 <xref:System.Net.Sockets.Socket.Available%2A> 0 を返します。  
  
 リモート ホストがシャット ダウンまたは、接続を閉じる場合<xref:System.Net.Sockets.Socket.Available%2A>スローすることができます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、呼び出し元の IOControl FIONREAD と利用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、キューの受信接続要求メソッド。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 最低限、リスニングを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 保持するために小さなクラスを作成するには、コールバックは、詳細を必要とする場合、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、システムは、通常は別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しい戻ります<xref:System.Net.Sockets.Socket>リモート ホストでのデータの送受信に使用できるオブジェクトします。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>します。 Set メソッドを呼び出し、<xref:System.Threading.ManualResetEvent>元のスレッドの実行を続行する場合は、コールバック メソッドで。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティを返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に終了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>リモート ホストのネットワーク アドレスとポート番号を識別するためにします。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例は、非同期的に受信接続を受信しようとします。  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
または 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="receiveSize">送信元から受け入れるバイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> 作成を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを非同期的に受信接続を処理しようとします。 非同期接続の受け入れを使用すると、個別の実行スレッド内でデータを送受信できます。 このオーバー ロードでは、初期転送に同意するバイト数を指定できます。、`receiveSize`パラメーター。  
  
 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、キューの受信接続要求メソッド。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 最低限、リスニングを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 保持するために小さなクラスを作成するには、コールバックは、詳細を必要とする場合、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、システムは、通常は別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しいを返します<xref:System.Net.Sockets.Socket>リモート ホストでのデータの送受信を行えます。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>します。 Set メソッドを呼び出し、<xref:System.Threading.ManualResetEvent>元のスレッドの実行を続行する場合は、コールバック メソッドで。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティを返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に終了しました。  
  
 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。  ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
> [!NOTE]
>  使用して呼び出すことができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>リモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例は、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは、最初の 10 バイトのデータを受け入れます。 受信したバイト数と、データは、コールバック デリゲートによって、コンソールに表示されます。 参照してください<xref:System.Net.Sockets.Socket.BeginReceive%2A>の残りのデータを受信する方法の説明。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
または 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">受け入れた <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。 この値は <see langword="null" /> の場合もあります。</param>
        <param name="receiveSize">受信する最大バイト数。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>指定したソケットから受信接続の試行を受け入れる非同期操作を開始し、クライアント アプリケーションによって送信されるデータの最初のブロックを受信します。</summary>
        <returns>非同期の <see cref="T:System.Net.Sockets.Socket" /> オブジェクトの作成を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用できる、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを非同期的に受信接続を処理しようとします。 非同期的に接続を受け入れると、個別の実行スレッド内でデータを送受信する機能を提供します。 このオーバー ロードで受け入れられたソケットを指定できます。、`acceptSocket`パラメーター。 このパラメーターが場合`null`、によって受け入れられたソケットが作成された、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 初期転送に同意するバイト数を指定することができます、`receiveSize`パラメーター。  
  
 呼び出しの前に、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.Listen%2A>をリッスンし、キューの受信接続要求メソッド。  
  
 実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 最低限、リスニングを渡す必要があります<xref:System.Net.Sockets.Socket>オブジェクトを<xref:System.Net.Sockets.Socket.BeginAccept%2A>を通じて、`state`パラメーター。 保持するために小さなクラスを作成するには、コールバックは、詳細を必要とする場合、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginAccept%2A>、システムは、通常は別のスレッドを使用して、指定されたコールバック メソッドを実行してでブロック<xref:System.Net.Sockets.Socket.EndAccept%2A>保留中の接続が取得されるまでです。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 新しいを返します<xref:System.Net.Sockets.Socket>リモート ホストでのデータの送受信に使用できるオブジェクトします。 返されるこれを使用することはできません<xref:System.Net.Sockets.Socket>接続キューからその他の接続を受け入れるようにします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>します。 Set メソッドを呼び出し、<xref:System.Threading.ManualResetEvent>元のスレッドの実行を続行する場合は、コールバック メソッドで。  
  
 システムは、呼び出し元のスレッドを使用して、コールバック メソッドを呼び出す可能性があります。 ここで、<xref:System.IAsyncResult.CompletedSynchronously%2A>プロパティを返された<xref:System.IAsyncResult>ことを示すために設定されます、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドは同期的に終了しました。  
  
 コールバック メソッドの記述に関する詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
> [!NOTE]
>  使用することができます、 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> 、返されたプロパティ<xref:System.Net.Sockets.Socket>リモート ホストのネットワーク アドレスとポート番号を識別するオブジェクト。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例は、ソケットを開き、非同期接続を受け入れます。 この例では、ソケットは最初の 10 バイトのデータを受け入れます。、`acceptSocket`パラメーターが`null`、どの強制的、<xref:System.Net.Sockets.Socket.BeginAccept%2A>受け入れられたソケットを作成する方法。 受信したバイト数と、データは、コールバック デリゲートによって、コンソールに表示されます。 参照してください<xref:System.Net.Sockets.Socket.BeginReceive%2A>の残りのデータを受信する方法の説明。  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.InvalidOperationException">受け入れ元のソケットが、接続をリッスンしていません。 <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> の前に <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> および <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出す必要があります。  
  
または 
受け入れられたソケットがバインドされています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> が 0 未満です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">リモート ホストを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドへの接続の非同期要求の開始、`remoteEP`パラメーター。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>既定のリモート ホストを確立します。 接続または既定のリモート ホストの設定を非同期的に個別の実行スレッド内でデータを送受信する機能を提供します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド。 渡す必要があります、極端に言えば、<xref:System.Net.Sockets.Socket>に<xref:System.Net.Sockets.Socket.BeginConnect%2A>を通じて、`state`パラメーター。 保持するために小さなクラスを作成するには、コールバックは、詳細を必要とする場合、 <xref:System.Net.Sockets.Socket>、およびその他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginConnect%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行して、ブロックされます<xref:System.Net.Sockets.Socket.EndConnect%2A>まで、<xref:System.Net.Sockets.Socket>正常に接続または例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A>します。 Set メソッドを呼び出し、<xref:System.Threading.ManualResetEvent>元のスレッドの実行を続行する場合は、コールバック メソッドで。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.BeginConnect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.BeginSendTo%2A>と<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>リモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>、指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 最初に呼び出す必要がある場合は、ブロードキャスト アドレスに既定のリモート ホストを設定するには、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>に`true`します。 できない場合は、<xref:System.Net.Sockets.Socket.BeginConnect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 接続指向プロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.BeginConnect%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワーク アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを使用して、目的のエンドポイント。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは <see cref="T:System.Net.IPAddress" /> とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッド。 通常、メソッドは、によって呼び出される、`requestCallback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードまたは<xref:System.Net.Sockets.Socket.EndConnect%2A>します。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[Calling Synchronous Methods Asynchronously。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>が使用されます。 異なる指定する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.Net.Sockets.Socket" /> はソケット ファミリに含まれません。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストを指定する、少なくとも 1 つの <see cref="T:System.Net.IPAddress" />。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストは、<see cref="T:System.Net.IPAddress" /> 配列とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッド。 通常、メソッドは、によって呼び出される、`requestCallback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>が使用されます。 異なる指定する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> を使用するソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <param name="requestCallback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="callback">接続操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">接続操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <paramref name="requestCallback" /> デリゲートに渡されます。</param>
        <summary>リモート ホスト接続への非同期要求を開始します。 ホストはホスト名とポート番号で指定されます。</summary>
        <returns>非同期接続を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッド。 通常、メソッドは、によって呼び出される、`requestCallback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドのオーバー ロードします。  
  
 保留中の呼び出しをキャンセル、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド、閉じる、<xref:System.Net.Sockets.Socket>します。 ときに、<xref:System.Net.Sockets.Socket.Close%2A>メソッドを呼び出す非同期操作の進行中に、コールバックが提供されて、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドが呼び出されます。  後続の呼び出し、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドがスローされます、<xref:System.ObjectDisposedException>を示す、操作がキャンセルされました。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[Calling Synchronous Methods Asynchronously。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このソケットが解除されていたし場合<xref:System.Net.Sockets.Socket.BeginConnect%2A>操作が完了するまで終了しないスレッドで呼び出される必要があります。 これは、基になるプロバイダーの制限です。 また、<xref:System.Net.EndPoint>が使用されます。 異なる指定する必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を開始します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっているか、非同期操作は既に実行されています。</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>非同期操作を参照する <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことができます、接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>リモート エンドポイントからの接続が切断を要求するメソッド。 場合`reuseSocket`は`true`ソケットを再利用することができます。  
  
 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>メソッドでは、個別のスレッドを使用して、指定されたコールバック メソッドを呼び出します。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>保留中の切断までメソッドのブロックが完了します。 コールバック メソッドの記述に関する詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、非同期通信用ソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A>を送信を停止し、receive アクティビティが呼び出されます。 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>切断要求を開始すると呼びます。 要求が完了したら、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッド。 通常、メソッドは、によって呼び出される、`callback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッド。 通常、メソッドは、によって呼び出される、`callback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッド。 通常、メソッドは、によって呼び出される、`callback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例が、接続からデータを非同期的に受信を開始<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <paramref name="buffer" />内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="error">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback">操作の完了時に呼び出すメソッドを参照する <see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">受信操作に関する情報を格納するユーザー定義のオブジェクト。 このオブジェクトは、操作の完了時に <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> デリゲートに渡されます。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> からの非同期のデータ受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の<xref:System.Net.Sockets.Socket.BeginReceive%2A>操作を呼び出すことによって完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッド。 通常、メソッドは、によって呼び出される、`callback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするのいずれかの操作を使用して、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドのオーバー ロードします。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください。 [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは、リモート ホストからコネクションレスのデータグラムを非同期的に読み取りを開始します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを使用すると、個別の実行スレッド内でデータを受信できます。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 最低限、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 保持するために小さなクラスを作成するには、コールバックは、詳細を必要とする場合、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、システムは、指定されたコールバック メソッドを実行する別のスレッドを使用およびを<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>まで、<xref:System.Net.Sockets.Socket>データを読み取るか、例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドを使用して<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>します。 元のスレッドが実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述に関する詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、または<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 このメソッドにデータを読み取り、`buffer`パラメーター、およびデータの送信元エンドポイントをホストするリモート キャプチャします。 このエンドポイントを取得する方法についてを参照してください<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>します。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。 このような場合は、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>はローカル ネットワーク バッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは入力`buffer`、メッセージをそのまま可能であれば、および throw の多くで、<xref:System.Net.Sockets.SocketException>します。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合は、余分なデータは、サービス プロバイダーによって保持されますを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>のに十分な大きさのバッファー。  
  
 リモート ホストのエンドポイントは常に返される、アプリケーションが明示的にバインドする必要があることを保証するために、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドを`optionLevel`にパラメーターが設定<xref:System.Net.Sockets.SocketOptionLevel.IP>または<xref:System.Net.Sockets.SocketOptionLevel.IPv6>、必要に応じて、`optionName`パラメーターに設定<xref:System.Net.Sockets.SocketOptionName.PacketInformation>、および`optionValue`呼び出す前に、このオプションを有効にするパラメーター、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 それ以外の場合、受信側が呼び出される前に、送信者のデータグラムの数が送信するときに、返されるしないリモート ホスト エンドポイントのことは、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。  
  
 <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>コネクションレスのプロトコルのものはでも接続指向プロトコルを使用することができます。 これを行う場合は、する必要がありますまずか接続を確立するリモート ホストを呼び出して、 <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出して、受信接続要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 呼び出す場合、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>確立するか、接続を受け入れる前にメソッドが表示されます、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットで<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>数までで指定したバイトの使用量のデータを読み取る、`size`パラメーター。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例は、リモート ホストから非同期的にコネクションレスのデータグラムを受信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データを格納する、<paramref name="buffer" />パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データのソースを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータの非同期受信を開始して、データ バッファー内の指定した位置に格納します。さらに、エンドポイントとパケット情報を格納します。</summary>
        <returns>非同期の読み取りを参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期の受信操作を呼び出して完了する必要があります、<xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A>メソッド。 通常、メソッドは、によって呼び出される、`asyncCallback`を委任します。  
  
 操作が完了するまで、このメソッドはブロックされません。 操作が完了するまでにブロックするを使用して、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッド。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
 詳細については、非同期プログラミング モデルを使用して、次を参照してください[Calling Synchronous Methods Asynchronously。](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 このメソッドにデータを読み取り、`buffer`パラメーターとキャプチャをリモート データの送信元エンドポイントをホストするほか、受信したパケットに関する情報。 このエンドポイントを取得する方法についてを参照してください<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>します。 このメソッドは非同期的に不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すしない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッド。 最低限、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行して、ブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>要求されたバイト数を送信します。 または、例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッド。 元のスレッドが実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 接続指向のプロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出すことが指定のコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを既定のリモート ホストを確立します。 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>します。 使用しても問題が<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すしない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッド。 最低限、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行して、ブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>要求されたバイト数を送信します。 または、例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッド。 Set メソッドを呼び出し、<xref:System.Threading.ManualResetEvent>元のスレッドの実行を続行する場合は、コールバック メソッドで。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 接続指向のプロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出すことが指定のコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを既定のリモート ホストを確立します。 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>します。 使用しても問題が<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すしない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッド。 最低限、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行して、ブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>要求されたバイト数を送信します。 または、例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッド。 元のスレッドが実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 接続指向のプロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出すことが指定のコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを既定のリモート ホストを確立します。 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>します。 使用しても問題が<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">送信を開始する、<paramref name="buffer" /> パラメーター内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> にデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 <xref:System.Net.Sockets.Socket.BeginSend%2A> 最初に呼び出すしない場合、例外がスローされます<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッド。 最低限、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 コールバックは、詳細を必要とする場合は、小さなクラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSend%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSend%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行して、ブロックされます<xref:System.Net.Sockets.Socket.EndSend%2A>まで、<xref:System.Net.Sockets.Socket>要求されたバイト数を送信します。 または、例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッド。 元のスレッドが実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 接続指向のプロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSend%2A>最初に呼び出すことが指定のコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを既定のリモート ホストを確立します。 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合<xref:System.Net.Sockets.Socket.BeginSendTo%2A>します。 使用しても問題が<xref:System.Net.Sockets.Socket.BeginSendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.BeginSend%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 コネクションレスのプロトコルを使用している場合は、バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.BeginSend%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  `state` ユーザー定義のクラスのインスタンス化されます。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例では、リモート ホストへのデータを非同期的に送信を開始します。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さより小さい値です。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">非同期クライアント ソケットの例</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">非同期サーバー ソケットの例</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルを非同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">送信するファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <returns>非同期送信を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、ファイルを送信`fileName`に接続されたソケットにします。 場合`fileName`ですが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかりました。 詳細については、`TransmitFile`関数とそのフラグを参照してください、 [Windows Sockets](/windows/desktop/WinSock/)ドキュメント。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、<xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出すしない場合は、例外をスローします<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドでは、個別の実行スレッド内でファイルを送信することができます。  
  
 操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<xref:System.AsyncCallback>デリゲート パラメーター。 最低限、`state`パラメーターを含める必要があります、<xref:System.Net.Sockets.Socket>の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このカスタム オブジェクトのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロック<xref:System.Net.Sockets.Socket.EndSendFile%2A>まで、<xref:System.Net.Sockets.Socket>ファイル全体を送信します。 または、例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 接続指向のプロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初に呼び出すことが指定のコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを既定のリモート ホストを確立します。 コネクションレスのプロトコルでは、ファイルのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要があります。 データグラムが送信しない場合と<xref:System.Net.Sockets.Socket.BeginSendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例では、作成し、非同期通信用ソケットが接続します。 最初に、"text.txt"ファイルは、リモート ホストに非同期的に送信されます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を格納する文字列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値のビットごとの組み合わせ。</param>
        <param name="callback">このオプションの完了時に呼び出される <see cref="T:System.AsyncCallback" /> デリゲート。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="state">この要求の状態情報を格納するユーザー定義のオブジェクト。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルとデータのバッファーを非同期的に送信します。</summary>
        <returns>非同期操作を表す <see cref="T:System.IAsyncResult" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<xref:System.Net.Sockets.TransmitFileOptions>値。 `preBuffer`パラメーターには、ファイルの前にすべてのデータが含まれています。 `postBuffer` ファイルを実行するデータが含まれています。 場合`fileName`ですが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 `flags`パラメーターには、ファイルの転送に関する追加情報をウィンドウのソケット サービス プロバイダーが提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>します。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかりました。 詳細については、`TransmitFile`関数とそのフラグを参照してください、 [Windows Sockets](/windows/desktop/WinSock/)ドキュメント。  
  
 <xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。 <xref:System.Net.Sockets.Socket.BeginSendFile%2A> 最初に呼び出すしない場合は、例外をスローします<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.BeginConnect%2A>します。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドを使用すると、個別の実行スレッド内でファイルを送信できます。  
  
 操作を完了するには、によって呼び出されるコールバック メソッドを作成することができます、<xref:System.AsyncCallback>デリゲート パラメーター。 最低限、`state`パラメーターを含める必要があります、<xref:System.Net.Sockets.Socket>の通信に使用されているオブジェクトします。 コールバックは、詳細を必要とする場合は、クラスまたは構造体を作成することができます、<xref:System.Net.Sockets.Socket>と、その他の必要な情報。 このカスタム オブジェクトのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要があります、<xref:System.Net.Sockets.Socket.EndSendFile%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行してブロック<xref:System.Net.Sockets.Socket.EndSendFile%2A>まで、<xref:System.Net.Sockets.Socket>ファイル全体を送信します。 または、例外をスローします。 コールバック メソッドの記述の詳細については、次を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 接続指向のプロトコルでは、意図したものが<xref:System.Net.Sockets.Socket.BeginSendFile%2A>最初に呼び出すことが指定のコネクションレスのプロトコルでも、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを既定のリモート ホストを確立します。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 データグラムが送信しない場合と<xref:System.Net.Sockets.Socket.BeginSendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例は、作成し非同期通信用ソケットが接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。 この例で、`preBuffer`と`postBuffer`ファイルとその既定値を送信するデータが作成<xref:System.Net.Sockets.TransmitFileOptions>値が使用されます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
または 
ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信するデータを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データ送信を開始する、<paramref name="buffer" /> 内の、インデックス番号が 0 から始まる位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="socket_flags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="remote_end">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <param name="callback"><see cref="T:System.AsyncCallback" /> デリゲート。</param>
        <param name="state">この要求のステータス情報を格納するオブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>非同期の送信を参照する <see cref="T:System.IAsyncResult" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドで指定されたリモート ホストへの非同期送信操作を開始、`remoteEP`パラメーター。 呼び出す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。 コネクションレスのプロトコルを対象としていますが<xref:System.Net.Sockets.Socket.BeginSendTo%2A>コネクションレス型との接続指向の両方のプロトコルで動作します。  
  
 実装するコールバック メソッドを作成することができます、<xref:System.AsyncCallback>を委任し、その名前を渡す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッド。 最低限、`state`パラメーターが、接続されているを含む必要がありますまたは既定の<xref:System.Net.Sockets.Socket>の通信に使用されています。 保持するために小さなクラスを作成するには、コールバックは、詳細を必要とする場合、 <xref:System.Net.Sockets.Socket>、およびその他の必要な情報。 このクラスのインスタンスを渡す、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドによって、`state`パラメーター。  
  
 コールバック メソッドを呼び出す必要がある、<xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッド。 アプリケーションを呼び出すと<xref:System.Net.Sockets.Socket.BeginSendTo%2A>、システムを別のスレッドを使用して、指定されたコールバック メソッドを実行して、ブロックされます<xref:System.Net.Sockets.Socket.EndSendTo%2A>まで、<xref:System.Net.Sockets.Socket>要求されたバイト数を送信します。 または、例外をスローします。 元のスレッドを呼び出した後にブロックするかどうか、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドを使用して、<xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>メソッド。 元のスレッドが実行を継続する場合は、コールバック メソッドにはセット メソッドを呼び出します。 コールバック メソッドの記述に関する追加情報を参照してください。[コールバック メソッドとしてデリゲートのマーシャ リング](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)します。  
  
 最初に呼び出す必要がある接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド、または<xref:System.Net.Sockets.Socket.BeginSendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 <xref:System.Net.Sockets.Socket.BeginSendTo%2A> 無視されます、`remoteEP`パラメーターと送信のデータを<xref:System.Net.EndPoint>で確立されている、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Accept%2A>、または<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。  
  
 コネクションレスのプロトコルを使用している場合はで、既定のリモート ホストを確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>します。 これを呼び出す場合にのみ必要があります、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッド。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信する指定された既定のリモート ホストに上書きされます。 また必要はありませんを呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 この場合は、基になるサービス プロバイダーは、最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。 基になるサービス プロバイダーは、空いているポートを選択する場合は、0 のポート番号を使用します。 使用することが割り当てられているローカル ネットワーク アドレスとポート番号を特定する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの後、<xref:System.Net.Sockets.Socket.EndSendTo%2A>メソッドが正常に完了します。  
  
 最初に呼び出す必要がある場合は、ブロードキャスト アドレスにデータを送信する、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>します。 -バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認します必要もあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.EndSendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  非同期の実行コンテキスト (セキュリティ コンテキスト、権限を借用したユーザー、および呼び出し元のコンテキスト) がキャッシュされる<xref:System.Net.Sockets.Socket>メソッド。 特定のコンテキストの最初の使用後に (特定の非同期<xref:System.Net.Sockets.Socket>メソッドは、特定の<xref:System.Net.Sockets.Socket>インスタンス、および特定のコールバック)、それ以降はそのコンテキストのパフォーマンスの向上が表示されます。  
  
   
  
## Examples  
 次のコード例は、指定されたリモート ホストにデータを非同期的に送信します。  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">コールバック メソッドとしてのデリゲートのマーシャ リング</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><see cref="T:System.Net.Sockets.Socket" /> に関連付けるローカル <see cref="T:System.Net.EndPoint" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> をローカル エンドポイントと関連付けます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドの特定のローカル エンドポイントを使用する必要がある場合。 呼び出す必要があります<xref:System.Net.Sockets.Socket.Bind%2A>を呼び出すには、<xref:System.Net.Sockets.Socket.Listen%2A>メソッド。 呼び出す必要はありません<xref:System.Net.Sockets.Socket.Bind%2A>を使用する前に、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド固有のローカル エンドポイントを使用する必要がある場合を除き、します。 使用することができます、<xref:System.Net.Sockets.Socket.Bind%2A>コネクションレス型との接続指向の両方のプロトコルのメソッド。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.Bind%2A>、ローカルを作成する必要がありますまず<xref:System.Net.IPEndPoint>からデータをやり取りします。 ローカル アドレスが割り当てられているを限定しない場合は作成、<xref:System.Net.IPEndPoint>を使用して<xref:System.Net.IPAddress.Any?displayProperty=nameWithType>プロバイダーと基になるサービスのアドレス パラメーターとして最も適切なネットワーク アドレスが割り当てられます。 これには、複数のネットワーク インターフェイスがある場合は、アプリケーションを簡素化がのに役立ちます。 ローカル ポートを使用しない場合は作成、 <xref:System.Net.IPEndPoint> 0 ポート番号を使用しています。 この場合、サービス プロバイダーは、1024 ~ 5000 で、使用可能なポート番号を割り当てられます。  
  
 上記の方法を使用する場合は、呼び出すことによってどのようなローカル ネットワーク アドレスとポート番号が割り当てられているを検出することができます、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>します。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>への呼び出しを行った後まで割り当てられているローカル ネットワーク アドレスは返されません、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッド。 コネクションレスのプロトコルを使用している場合はありません情報へのアクセス、送信が完了するか、受信するまでです。  
  
 UDP ソケットがインターフェイスについては、受信したパケットを受信する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>ソケット オプションに設定、メソッドを明示的に呼び出す必要が<xref:System.Net.Sockets.SocketOptionName.PacketInformation>呼び出した直後後、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。  
  
> [!NOTE]
>  マルチキャスト データグラムを受信する場合を呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>マルチキャストのポート番号を持つメソッド。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>コネクションレスのデータグラムを使用して受信する場合、メソッド、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を呼び出すときに、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例のバインドを<xref:System.Net.Sockets.Socket>指定したローカル エンドポイントを使用します。  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">によって定義されたホストからの接続を受け入れるため<paramref name="localEP" />します。 関連付けられた列挙体。 <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> がブロッキング モードかどうかを示す値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がブロックする場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを示すかどうかを<xref:System.Net.Sockets.Socket>がブロッキング モード。  
  
 ブロックのモードでは、すると、メソッドがすぐに完了しない場合、アプリケーションは、要求された操作が完了するまで実行をブロックします。 要求された操作が完了しない場合でもを続行するには、変更を実行する場合、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`します。 <xref:System.Net.Sockets.Socket.Blocking%2A>プロパティには、非同期メソッドへの影響はありません。 送信、データを非同期的に受信し実行をブロックしては場合、使用して、<xref:System.Threading.ManualResetEvent>クラス。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> メソッドの 1 つを呼び出してリモート ホストへの接続を要求するために使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホスト接続への非同期要求を取り消します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A>メソッドがリモート ホスト接続への非同期要求を取り消します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、関連付けられたすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>メソッドがリモート ホスト接続を閉じると、リリースのすべてのマネージしアンマネージ リソースに関連付けられている、<xref:System.Net.Sockets.Socket>します。 終了時に、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティに設定されて`false`します。  
  
 接続指向のプロトコルは勧めを呼び出して<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。 これにより、すべてのデータが送信されており、それを閉じる前に、接続のソケットで受信したこと。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Close%2A>最初に呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、キュー データを設定して送信される出力方向の送信のことを確認できる、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket>オプションを`false`0 以外のタイムアウト間隔を指定するとします。 <xref:System.Net.Sockets.Socket.Close%2A> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプション`false`、作成、<xref:System.Net.Sockets.LingerOption>が有効なプロパティを設定`true`、設定、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>プロパティを目的のタイムアウト期間。 これを使用して、<xref:System.Net.Sockets.LingerOption>と共に、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッド。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例が閉じ、<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="timeout">最大 <paramref name="timeout" /> 秒まで待ってから残りのデータを送信し、ソケットを閉じます。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> 接続を閉じ、すべての関連付けられているリソースを指定したタイムアウトで解放して、キューに置かれたデータの送信を許可します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Close%2A>メソッドがリモート ホスト接続を閉じると、リリースのすべてのマネージしアンマネージ リソースに関連付けられている、<xref:System.Net.Sockets.Socket>します。 終了時に、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティに設定されて`false`します。  
  
 接続指向のプロトコルは勧めを呼び出して<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Close%2A>します。 これにより、すべてのデータが送信されており、それを閉じる前に、接続のソケットで受信したこと。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Close%2A>最初に呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>、キュー データを設定して送信される出力方向の送信のことを確認できる、<xref:System.Net.Sockets.SocketOptionName.DontLinger>オプションを`false`0 以外のタイムアウト間隔を指定するとします。 <xref:System.Net.Sockets.Socket.Close%2A> このデータが送信されるまで、または指定したタイムアウトの期限が切れるまで、ブロックされます。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  設定する、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプション`false`、作成、<xref:System.Net.Sockets.LingerOption>が有効なプロパティを設定`true`、設定と、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>プロパティを目的のタイムアウト期間。 これを使用して、<xref:System.Net.Sockets.LingerOption>と共に、<xref:System.Net.Sockets.SocketOptionName.DontLinger>ソケット オプションを呼び出して、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッド。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、閉じる方法を示します、<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストへの接続を確立します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP">リモート デバイスを表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>リモート ホストへの接続を確立します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>、リモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッド、または使用したリモート デバイスからデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッド。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>同期的にリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>、指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 最初に呼び出す必要がある既定のリモート ホストが、ブロードキャスト アドレスを設定する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>します。 ブロックが無効にし、TCP と同様に、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時間、接続を作成する必要があるためです。 コネクションレスのプロトコルを既定のリモート ホストを確立するだけであるため、例外はスローされません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。 接続指向でリモート ホスト接続が開始された場合は、エラーには、WSAEWOULDBLOCK が返されます、<xref:System.Net.Sockets.Socket>が正常にまだ完了がありません。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了接続します。  
  
> [!NOTE]
>  接続指向プロトコルを使用しているし、呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーはローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合は、送信を完了するか、操作が表示されるまで、サービス プロバイダーはないローカル ネットワーク アドレスとポート番号を割り当てられます。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元するこのメソッドを使用することはできません。 非同期のいずれかを使用して、<xref:System.Net.Sockets.Socket.BeginConnect%2A>再接続する方法。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続して、接続を検証します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
        <permission cref="T:System.Net.SocketPermission">リモート ホストに接続します。 関連付けられた列挙体。 <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="address">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスとポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>でリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモート デバイスからデータを受信または、<xref:System.Net.Sockets.Socket.Receive%2A>メソッド。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>同期的にリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 最初に呼び出す必要がある既定のリモート ホストが、ブロードキャスト アドレスを設定する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>します。 ブロックが無効にし、TCP と同様に、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時間、接続を作成する必要があるためです。 コネクションレスのプロトコルを既定のリモート ホストを確立するだけであるため、例外はスローされません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。 接続指向でリモート ホスト接続が開始された場合は、エラーには、WSAEWOULDBLOCK が返されます、<xref:System.Net.Sockets.Socket>が正常にまだ完了がありません。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了接続します。  
  
> [!NOTE]
>  接続指向プロトコルを使用しているし、呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーはローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合は、送信を完了するか、操作が表示されるまで、サービス プロバイダーはないローカル ネットワーク アドレスとポート番号を割り当てられます。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元するこのメソッドを使用することはできません。 非同期のいずれかを使用して、<xref:System.Net.Sockets.Socket.BeginConnect%2A>再接続する方法。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続して、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="addresses">リモート ホストの IP アドレス。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストは、IP アドレスの配列とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは呼び出しの直後に通常使用<xref:System.Net.Dns.GetHostAddresses%2A>、これを単一のホストの複数の IP アドレスを返すことができます。 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート エンドポイント。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>でリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモート デバイスからデータを受信または、<xref:System.Net.Sockets.Socket.Receive%2A>メソッド。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>同期的にリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 最初に呼び出す必要がある既定のリモート ホストが、ブロードキャスト アドレスを設定する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>します。 ブロックが無効にし、TCP と同様に、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時間、接続を作成する必要があるためです。 コネクションレスのプロトコルを既定のリモート ホストを確立するだけであるため、例外はスローされません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。 接続指向でリモート ホスト接続が開始された場合は、エラーには、WSAEWOULDBLOCK が返されます、<xref:System.Net.Sockets.Socket>が正常にまだ完了がありません。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了接続します。  
  
> [!NOTE]
>  接続指向プロトコルを使用しているし、呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーはローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合は、送信を完了するか、操作が表示されるまで、サービス プロバイダーはないローカル ネットワーク アドレスとポート番号を割り当てられます。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元するこのメソッドを使用することはできません。 非同期のいずれかを使用して、<xref:System.Net.Sockets.Socket.BeginConnect%2A>再接続する方法。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続して、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="address" /> の長さが 0 です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="host">リモート ホストの名前。</param>
        <param name="port">リモート ホストのポート番号。</param>
        <summary>リモート ホストへの接続を確立します。 ホストはホスト名とポート番号で指定されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TCP などの接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドは同期的に間のネットワーク接続を確立<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>と指定したリモート ホスト。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>既定のリモート ホストを確立します。 呼び出した後<xref:System.Net.Sockets.Socket.Connect%2A>でリモート デバイスにデータを送信することができます、<xref:System.Net.Sockets.Socket.Send%2A>メソッドを使用してリモート デバイスからデータを受信または、<xref:System.Net.Sockets.Socket.Receive%2A>メソッド。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.Connect%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>と<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>同期的にリモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 最初に呼び出す必要がある既定のリモート ホストが、ブロードキャスト アドレスを設定する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>、または<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> 具体的に設定していない場合、メソッドはブロック、<xref:System.Net.Sockets.Socket.Blocking%2A>プロパティを`false`呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>します。 ブロックが無効にし、TCP と同様に、接続指向プロトコルを使用している場合<xref:System.Net.Sockets.Socket.Connect%2A>がスローされます、<xref:System.Net.Sockets.SocketException>時間、接続を作成する必要があるためです。 コネクションレスのプロトコルを既定のリモート ホストを確立するだけであるため、例外はスローされません。 使用することができます<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得します。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。 接続指向でリモート ホスト接続が開始された場合は、エラーには、WSAEWOULDBLOCK が返されます、<xref:System.Net.Sockets.Socket>が正常にまだ完了がありません。 使用して、<xref:System.Net.Sockets.Socket.Poll%2A>タイミングを決定するメソッド、<xref:System.Net.Sockets.Socket>が終了接続します。  
  
 IPv6 が有効になっている場合、<xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29>メソッドが呼び出され、IPv6 の両方に解決されるホストに接続し、IPv4 アドレス、IPv6 のアドレスへの接続試行の IPv4 アドレスに実行する前。 これには、ホストが IPv6 アドレスでリッスンしていない場合、接続の確立に時間が遅延の影響があります。  
  
> [!NOTE]
>  接続指向プロトコルを使用しているし、呼び出さなかったかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.Connect%2A>、基になるサービス プロバイダーはローカル ネットワーク アドレスとポート番号を割り当てます。 コネクションレスのプロトコルを使用している場合は、送信を完了するか、操作が表示されるまで、サービス プロバイダーはないローカル ネットワーク アドレスとポート番号を割り当てられます。 既定のリモート ホストを変更する場合は、呼び出す<xref:System.Net.Sockets.Socket.Connect%2A>目的のエンドポイントを使用しています。  
  
> [!NOTE]
>  ソケットが以前切断された場合は、接続を復元するこのメソッドを使用することはできません。 非同期のいずれかを使用して、<xref:System.Net.Sockets.Socket.BeginConnect%2A>再接続する方法。 これは、基になるプロバイダーの制限です。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート エンドポイントに接続して、接続を検証します。  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">ポート番号が無効です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットで有効です。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> は <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> を呼び出すことでリッスン状態になっています。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドは、リモート ホストへの接続の非同期要求を開始します。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>既定のリモート ホストを確立します。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > デリゲートおよびコールバックをアタッチ、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストに接続するのです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.ConnectAsync%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendToAsync%2A>と<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>リモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを使用して、目的のエンドポイント。  
  
 最初に呼び出す必要がある場合は、ブロードキャスト アドレスに既定のリモート ホストを設定するには、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>に`true`します。 これが行われていない場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 後にソケットをアトミックに送信されますバッファーを指定できます必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功しました。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティを送信するデータを含むバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向プロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。  
  
 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッド。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます<xref:System.NotSupportedException>場合のアドレス ファミリ、 <xref:System.Net.Sockets.Socket> 、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>使用して、このメソッドを呼び出すときに、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</param>
        <param name="protocolType"><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</param>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート ホストに接続する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) メソッドの非同期要求を開始接続指向プロトコルを使用している場合、リモート ホストに接続します。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>で指定された既定のリモート ホストを確立、`socketType`と`protocolType`パラメーター。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > デリゲートおよびコールバックをアタッチ、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>リモート ホストに接続するのです。  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 UDP などのコネクションレスのプロトコルを使用している場合は呼び出しする必要はありません<xref:System.Net.Sockets.Socket.ConnectAsync%2A>データを送受信する前にします。 使用することができます<xref:System.Net.Sockets.Socket.SendToAsync%2A>と<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>リモート ホストと通信します。 呼び出す場合<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、指定した既定以外のアドレスから配信される任意のデータグラムは破棄されます。 既定のリモート ホストを変更する場合は、呼び出し、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを使用して、目的のエンドポイント。  
  
 最初に呼び出す必要がある場合は、ブロードキャスト アドレスに既定のリモート ホストを設定するには、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>に`true`します。 これが行われていない場合、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトが必要です。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 後にソケットをアトミックに送信されますバッファーを指定できます必要に応じて、<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドが成功しました。 ここで、<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>プロパティを送信するデータを含むバッファーに設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>プロパティは、バッファーから送信するデータのバイト数に設定する必要があります。 接続が確立されると、このバッファーのデータが送信されます。  
  
 接続指向プロトコルを使用しているし、呼び出さないかどうか<xref:System.Net.Sockets.Socket.Bind%2A>呼び出す前に<xref:System.Net.Sockets.Socket.ConnectAsync%2A>、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てられます。  
  
 コネクションレスのプロトコルを使用している場合、サービス プロバイダーを割り当てませんローカル ネットワークの IP アドレスとポート番号を呼び出すまで、<xref:System.Net.Sockets.Socket.SendAsync%2A>または<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッド。  
  
 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドがスローされます<xref:System.NotSupportedException>場合のアドレス ファミリ、 <xref:System.Net.Sockets.Socket> 、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>同じアドレス ファミリではありません。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>使用して、このメソッドを呼び出すときに、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が有効ではありません。 この例外は、複数のバッファーが指定されているときに、<see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティが null 値ではない場合に発生します。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターおよび <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> を null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> がリッスンしているか、<paramref name="e" /> パラメーターで指定されている <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、ローカル エンドポイントと <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> が同じアドレス ファミリではない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタックの上位にある呼び出し元が、要求された操作のアクセス許可を保持していません。</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>最後に実行された <see cref="Overload:System.Net.Sockets.Socket.Send" /> 操作または <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていたかどうかを示す値を取得します。</summary>
        <value>最後に実行された操作の時点で、<see cref="T:System.Net.Sockets.Socket" /> がリモート リソースに接続されていた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Connected`プロパティの接続の状態の取得、<xref:System.Net.Sockets.Socket>最後の I/O 操作の時点でします。 返す場合`false`、<xref:System.Net.Sockets.Socket>されたか、接続していない、または接続されていません。  
  
 値、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティには、最新の操作の時点で接続の状態が反映されます。 接続の現在の状態を確認する必要がある場合は、呼び出し、ゼロ バイトの非ブロッキング送信をください。 呼び出しは正常に終了または WAEWOULDBLOCK エラー コード (10035) をスローします。 は、ソケットが接続されているまま;それ以外の場合、ソケットが接続していません。  
  
 呼び出す場合<xref:System.Net.Sockets.Socket.Connect%2A>、ユーザー データグラム プロトコル (UDP) のソケットで、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは常に返します`true`。 ただし、この操作には、UDP のコネクションレス型固有の性質は変わりません。  
  
   
  
## Examples  
 次のコード例は、リモート エンドポイントをチェックする接続、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティ、および接続の現在の状態を確認します。  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">現在の接続の終了後、このソケットが再利用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</param>
        <summary>ソケット接続を閉じ、ソケットを再利用できるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用している場合は、ソケットを閉じるにこのメソッドを使用できます。 このメソッドが終了接続とセット、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティを`false`します。 ただし場合、`reuseSocket`は`true`ソケットを再利用することができます。  
  
 すべてのデータが送信されており、ソケットを閉じる前に受信したことを確実に呼び出す必要がある<xref:System.Net.Sockets.Socket.Shutdown%2A>呼び出す前に、<xref:System.Net.Sockets.Socket.Disconnect%2A>メソッド。  
  
 呼び出す必要がある場合<xref:System.Net.Sockets.Socket.Disconnect%2A>最初に呼び出さず<xref:System.Net.Sockets.Socket.Shutdown%2A>を設定することができます、 <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket>オプションを`false`キュー データを伝送の送信が送信されるを確実に 0 以外のタイムアウト間隔を指定します。 <xref:System.Net.Sockets.Socket.Disconnect%2A> データが送信されるまで、または指定したタイムアウトが経過するまでブロックします。 設定した場合<xref:System.Net.Sockets.SocketOptionName.DontLinger>に`false`0 のタイムアウト間隔を指定して<xref:System.Net.Sockets.Socket.Close%2A>の接続を解放し、送信キューに置かれたデータを自動的に破棄します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、同期通信用ソケットを作成し、リモート ホストにデータを送信します。 呼び出して<xref:System.Net.Sockets.Socket.Shutdown%2A>を送信を停止し、receive アクティビティ、および<xref:System.Net.Sockets.Socket.Disconnect%2A>、ソケット接続を閉じます。  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">このメソッドは、Windows 2000 以前でのみサポートされます。それ以外の場合は、例外がスローされます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>リモート エンドポイントからの切断の非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向プロトコルを使用する場合は、呼び出し、<xref:System.Net.Sockets.Socket.DisconnectAsync%2A>メソッドがリモート エンドポイントからの接続が切断を要求します。 設定した場合<xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType>に`true`で、`e`パラメーター、ソケットを再利用できます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="e" /> パラメーターを null 値にすることはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスの現在のインスタンスによって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> を使い終わったら、`Dispose`を呼び出します。 `Dispose`メソッドによって、<xref:System.Net.Sockets.Socket> は使用不可の状態になります。 `Dispose`呼び出し後は、<xref:System.Net.Sockets.Socket>によって占有されていたメモリをガベージ コレクターがクリアできるよう、<xref:System.Net.Sockets.Socket> へのすべての参照を解放する必要があります。  
  
 詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.Socket>への最後の参照を解放する前に、必ず`Dispose`を呼び出してください。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">マネージド リソースとアンマネージド リソースの両方を解放する場合は <see langword="true" />。アンマネージド リソースだけを解放する場合は <see langword="false" />。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が使用しているアンマネージド リソースを解放します。オプションでマネージド リソースも破棄します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、パブリック`Dispose()`メソッドと<xref:System.Object.Finalize%2A>メソッド。 `Dispose()` 保護された起動`Dispose(Boolean)`メソッドを`disposing`パラメーターに設定`true`します。 <xref:System.Object.Finalize%2A> 呼び出す`Dispose`で`disposing`に設定`false`します。  
  
 `disposing` パラメーターが `true` の場合、このメソッドは、この <xref:System.Net.Sockets.Socket> が参照しているすべてのマネージド オブジェクトによって保持されているリソースをすべて解放します。 このメソッドは、参照される各オブジェクトの `Dispose()` メソッドを呼び出します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> は、他のオブジェクトから複数回呼び出すことができます。 <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> をオーバーライドする場合は、以前に <see langword="Dispose" /> を呼び出したときに破棄されたオブジェクトを参照しないように注意する必要があります。 実装する方法についての詳細は<see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />を参照してください[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)します。  
  
詳細については<see langword="Dispose" />と<see cref="M:System.Object.Finalize" />を参照してください[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)と[Finalize メソッドをオーバーライドする](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100))します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> でインターネット プロトコル (IP) データグラムの断片化を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を、取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> でデータグラムの断片化を許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データグラムには、そのサイズを超えたら、最大転送単位 (MTU)、伝送中の断片化が必要です。 データグラムは、送信ホスト (すべてのインターネット プロトコル バージョン) または中間ルーター (インターネット プロトコル バージョン 4 のみ) によって断片化している可能性があります。 データグラムを断片化しなければならない場合、<xref:System.Net.Sockets.Socket.DontFragment%2A>オプションが設定されている、データグラムを破棄すると、およびインターネット コントロール メッセージ プロトコル (ICMP) エラー メッセージは、データグラムの送信者に送信します。  
  
 伝送制御プロトコル (TCP) のソケットにこのプロパティを設定しても影響します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.DontFragment%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が IPv4 と IPv6 の両方に使用されるデュアル モード ソケットであるかどうか指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がデュアルモードのソケットの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">ソケット参照の複製が作成されるターゲット プロセスの ID。</param>
        <summary>ターゲット プロセスのソケット参照を複製してこのプロセスのソケットを閉じます。</summary>
        <returns>ターゲット プロセスに渡されるソケット参照。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ターゲット プロセスを使用する必要があります<xref:System.Net.Sockets.Socket.%23ctor%2A>ソケットが重複するインスタンスを作成します。  
  
 呼び出す場合、<xref:System.Net.Sockets.Socket.%23ctor%2A>の各呼び出しの引数と同じバイト配列で複数回コンス トラクターは、複数の管理を作成、<xref:System.Net.Sockets.Socket>と基になるソケットの同じインスタンスです。 この方法はお勧めします。  
  
 ソケットを作成するプロセスは非同期メソッドを使用している場合 (<xref:System.Net.Sockets.Socket.BeginReceive%2A>または<xref:System.Net.Sockets.Socket.BeginSend%2A>)、プロセスを設定する必要があります最初、<xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A>プロパティをを引き起こす可能性があります、作成したプロセスの完了ポートに、ソケットがバインドされているtrueそれ以外の場合、。<xref:System.ArgumentNullException>ターゲット プロセスでスローされます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> が有効なプロセス ID ではありません。 
または 
ソケット参照の複製に失敗しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットの送受信を許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> でブロードキャスト パケットを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ブロードキャストが特定のサブネットに制限されており、ユーザー データグラム プロトコル (UDP。) を使用する必要があります。255.255.255.255; にパケットを送信してインターネット プロトコル バージョン 4 では、ローカル サブネットにブロードキャストできます。または、すべてのビットのホスト部分で設定を持つインターネット プロトコル (IP) アドレスのネットワーク部分は、有向ブロードキャスト アドレスを使用することができます。 たとえば、自分の IP アドレスが 192.168.1.40 (255.255.255.0 のネットマスク クラス C アドレスはネットワークの部分は、最初の 3 つのオクテット、ホスト部分は、最後のオクテット、)、指定されたブロードキャスト アドレス 192.168.1.255 が。  
  
 伝送制御プロトコル (TCP) のソケットにこのプロパティを設定しても影響します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.EnableBroadcast%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">このオプションは、データグラム ソケットに対してだけ有効です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>受信接続の試行を非同期的に受け入れます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、転送される初期データを格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しが完了すると<xref:System.Net.Sockets.Socket.BeginAccept%2A>します。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、によって呼び出されるコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>で接続試行が行わします。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続の試行を正常に完了します。 `buffer`このオーバー ロードのパラメーターへの呼び出しで受信したデータを格納して<xref:System.Net.Sockets.Socket.BeginAccept%2A>と`bytesTransferred`パラメーターには、呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留中になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しいを返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.BeginAccept%2A>作成と、ソケットを接続および最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndAccept%2A>非同期要求を終了します。 転送されるバイト数と、データが返されます、`buffer`と`bytesTransferred`このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> を作成してリモート ホスト通信を処理します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しが完了すると<xref:System.Net.Sockets.Socket.BeginAccept%2A>します。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。 これに同意する必要があります、`asyncResult`パラメーターから返される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>で接続試行が行わします。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続の試行を正常に完了します。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留中になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しいを返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例の非同期要求を終了し、新たに作成します<xref:System.Net.Sockets.Socket>受信接続要求を受け入れるようにします。 ソケットでの非同期通信を示す完全な例を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)します。  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 詳細については、次の「解説」を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">転送されたバイト数を格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="bytesTransferred">転送されたバイト数。</param>
        <param name="asyncResult">この非同期操作のステータス情報だけではなく、任意のユーザー定義のデータも格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>受信接続の試行を非同期的に受け入れ、新しい <see cref="T:System.Net.Sockets.Socket" /> オブジェクトを作成してリモート ホスト通信を処理します。 このメソッドは、初期データと、転送されたバイト数を格納するバッファーを返します。</summary>
        <returns>リモート ホストとの通信を処理する <see cref="T:System.Net.Sockets.Socket" /> オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> 呼び出しが完了すると<xref:System.Net.Sockets.Socket.BeginAccept%2A>します。 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginAccept%2A>、によって呼び出されるコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、個別のスレッドで実行され、後にシステムによって呼び出される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッドを返します。 これに同意する必要があります、`asyncResult`パラメーターから返される、<xref:System.Net.Sockets.Socket.BeginAccept%2A>メソッド。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、`asyncResult`を取得するパラメーター、<xref:System.Net.Sockets.Socket>で接続試行が行わします。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続の試行を正常に完了します。 `buffer`このオーバー ロードのパラメーターへの呼び出しで受信したデータを格納して<xref:System.Net.Sockets.Socket.BeginAccept%2A>と`bytesTransferred`パラメーターには、呼び出しで転送されたバイト数が含まれています。  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、接続が保留中になるまで、ブロック、着信接続のキューにします。 <xref:System.Net.Sockets.Socket.EndAccept%2A>メソッドは、受信接続を許可し、新しいを返します<xref:System.Net.Sockets.Socket>を使用して、データを送信し、リモート ホストからデータを受け取ることができます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.BeginAccept%2A>作成と、ソケットを接続および最初の 10 バイトのデータをそのまま使用します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndAccept%2A>非同期要求を終了します。 転送されるバイト数と、データが返されます、`buffer`と`bytesTransferred`このメソッドのパラメーター、コンソールに表示されます。  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> への呼び出しで <paramref name="asyncResult" /> が作成されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> メソッドは既に呼び出されました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期接続要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> で開始された非同期のリモート ホスト接続要求を完了するブロッキング メソッド、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッド。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginConnect%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginConnect%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginConnect%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>を取得するパラメーター、<xref:System.Net.Sockets.Socket>で接続試行が行わします。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndConnect%2A>メソッドは、接続の試行を正常に完了します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、非同期接続の試行を終了します。 ソケットでの非同期通信を示す完全な例を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)します。  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作のステータス情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>保留中の非同期切断要求を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> 呼び出しが完了すると<xref:System.Net.Sockets.Socket.BeginDisconnect%2A>します。 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>メソッドは、切断が完了するまでブロックします。 非同期操作については、MSDN ライブラリの非同期プログラミングの概要トピックを参照してください。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、非同期通信用ソケットを作成し、リモート ホストにデータを送信します。 データが送信されると、<xref:System.Net.Sockets.Socket.Shutdown%2A>を送信を停止し、receive アクティビティが呼び出されます。 <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>切断要求を開始すると呼びます。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndDisconnect%2A>非同期要求を終了します。 要求が完了したら、<xref:System.Net.Sockets.Socket.Connected%2A>プロパティは、ソケットが切断されているかどうかをテストするクエリを実行します。  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> は、非同期接続のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.Net.WebException">切断要求がタイムアウトしました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期読み取りを終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッド。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceive%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッド。 受信の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了し、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはデータが利用可能になるまでブロックされます。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceive%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドがで指定されたバイト数まで使用量のデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッド。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、 <xref:System.IAsyncResult>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
 キャンセルする、保留中<xref:System.Net.Sockets.Socket.BeginReceive%2A>を呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>メソッド。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期読み取りを終了します。 ソケットでの非同期通信を示す完全な例を参照してください。[ソケットのコード例](~/docs/framework/network-programming/socket-code-examples.md)します。  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期読み取りを終了します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッド。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceive%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッド。 受信の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドを正常に読み取り操作を完了し、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはデータが利用可能になるまでブロックされます。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceive%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドがで指定されたバイト数まで使用量のデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceive%2A>メソッド。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、 <xref:System.IAsyncResult>、し、結果の状態オブジェクトに含まれているバッファーを抽出します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="end_point">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドで開始された非同期の読み取り操作が完了すると、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>に渡される状態オブジェクトを取得する、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 受信の抽出<xref:System.Net.Sockets.Socket>この状態オブジェクトから。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドを正常に読み取り操作を完了し、読み取られたバイト数を返します。  
  
 <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドはデータが利用可能になるまでブロックされます。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>はネットワークの着信バッファーで使用できる最初のエンキューされたデータグラムを読み取ります。 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドがで指定されたバイト数まで使用量のデータを読み取る、`size`のパラメーター、<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>メソッド。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。 受信したデータを取得する呼び出し、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>オブジェクト、および結果の状態オブジェクトに含まれているバッファーを抽出します。 元のホストを識別するためには、抽出、<xref:System.Net.EndPoint>にキャスト、<xref:System.Net.IPEndPoint>します。 使用して、 <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> IP アドレスを取得するメソッドと<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>ポート番号を取得します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、特定の保留中の非同期読み取りを終了<xref:System.Net.EndPoint>します。  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="socketFlags">受信パケットの <see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="endPoint">コピー元 <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">受信パケットの <see cref="T:System.Net.IPAddress" /> とインターフェイス。</param>
        <summary>特定のエンドポイントからの、保留中の非同期読み込みを終了します。 また、このメソッドは、<see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> よりもパケットに関するより多くの情報を示します。</summary>
        <returns>正常に完了した場合は、受信したバイト数。 失敗した場合は、0 を返します。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 操作が完了していない場合、このメソッドは、終了する前をブロックします。  
  
 この操作を同期的に実行するには、使用、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッド。  
  
 調べる`ipPacketInformation`かどうかは、ユニキャスト、マルチキャストまたはブロードキャスト アドレスを使用してデータグラムが送信されたかを把握する必要があります。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" /> です  
  
または 
 <paramref name="endPoint" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> が、非同期の読み取りのために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>保留中の非同期送信を終了します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 開始された非同期送信操作が完了すると<xref:System.Net.Sockets.Socket.BeginSend%2A>します。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSend%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSend%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSend%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーの一部が送信されるまでブロックされます。 戻り値の場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーがなかったことを示します。 呼び出す、完全に送信される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、保留中の非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>保留中の非同期送信を終了します。</summary>
        <returns>正常に終了した場合は <see cref="T:System.Net.Sockets.Socket" /> に送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> 開始された非同期送信操作が完了すると<xref:System.Net.Sockets.Socket.BeginSend%2A>します。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSend%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSend%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSend%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーの一部が送信されるまでブロックされます。 戻り値の場合<xref:System.Net.Sockets.Socket.EndSend%2A>バッファーがなかったことを示します。 呼び出す、完全に送信される、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドを再度、未送信のデータを保持するバッファーを変更します。  
  
 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.BeginSend%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  そのスレッドが終了する場合は、特定のスレッドによって開始されたすべての I/O が取り消されました。 保留中の非同期操作は、操作が完了する前に、スレッドが終了した場合に失敗します。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報を格納する <see cref="T:System.IAsyncResult" /> オブジェクト。</param>
        <summary>ファイルの保留中の非同期送信を終了します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> 開始された非同期送信操作が完了すると<xref:System.Net.Sockets.Socket.BeginSendFile%2A>します。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSendFile%2A>、実装するコールバック メソッドを作成する必要があります、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginSendFile%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返されるオブジェクト、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSendFile%2A>送信操作を正常に完了するメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendFile%2A>データグラムが送信されるまでブロックします。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendFile%2A>ファイル全体が送信されるまでブロックします。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.BeginSendFile%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、作成し非同期通信用ソケットが接続し、リモート ホストにファイルの"text.txt"を非同期的に送信を開始します。 コールバック デリゲート呼び出し<xref:System.Net.Sockets.Socket.EndSendFile%2A>転送を完了します。  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows NT が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> が空です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> が、非同期の <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <param name="result">この非同期操作の状態情報およびユーザー定義データを格納する <see cref="T:System.IAsyncResult" />。</param>
        <summary>特定の場所への、保留中の非同期送信を終了します。</summary>
        <returns>正常に完了した場合は送信したバイト数。それ以外の場合は無効な <see cref="T:System.Net.Sockets.Socket" /> エラー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> 開始された非同期送信操作が完了すると<xref:System.Net.Sockets.Socket.BeginSendTo%2A>します。  
  
 呼び出しの前に<xref:System.Net.Sockets.Socket.BeginSendTo%2A>、実装するコールバック メソッドを作成する必要がある、<xref:System.AsyncCallback>を委任します。 このコールバック メソッドは、別のスレッドで実行され、後にシステムによって呼び出される<xref:System.Net.Sockets.Socket.BeginReceive%2A>を返します。 コールバック メソッドが受け入れる必要があります、<xref:System.IAsyncResult>によって返される、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドをパラメーターとして。  
  
 コールバック メソッド内で、<xref:System.IAsyncResult.AsyncState%2A>のメソッド、<xref:System.IAsyncResult>送信を取得するパラメーター<xref:System.Net.Sockets.Socket>します。 取得した後、 <xref:System.Net.Sockets.Socket>、呼び出すことができます、<xref:System.Net.Sockets.Socket.EndSendTo%2A>を正常に送信操作を完了し、送信されたバイト数を返すメソッド。  
  
 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendTo%2A>データグラムが送信されるまでブロックされます。 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.EndSendTo%2A>要求されたバイト数が送信されるまでブロックされます。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.BeginSendTo%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、特定の場所への非同期送信を終了します。  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> メソッドへの呼び出しで <paramref name="asyncResult" /> が返されませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> が、非同期送信のために以前に呼び出されています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> で 1 つのプロセスだけにポートのバインドを許可するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> で 1 つのソケットだけに特定のポートのバインドを許可する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は<see langword="true" />Windows Server 2003 および Windows XP Service Pack 2、および<see langword="false" />の他のすべてのバージョン。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>は`false`、複数のソケットを使用できる、<xref:System.Net.Sockets.Socket.Bind%2A>特定のポートにバインドするメソッドは、ソケットは 1 つのみが、ポートに送信されるネットワーク トラフィックの操作を実行できます。 1 つ以上のソケットを使用するしようとすると、<xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29>し、そのポートに送信されるネットワーク トラフィックを処理する 1 つ以上の特定の IP アドレスを持つ特定のポートにバインドするメソッド。  
  
 場合<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>は`true`の最初の使用、<xref:System.Net.Sockets.Socket.Bind%2A>インターネット プロトコル (IP) アドレスに関係なく、特定のポートにバインドしようとするメソッドが成功とは、後続のすべての使用、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドしようとすると、そのポートにバインドされます元のバインドされたソケットが破棄されるまで失敗します。  
  
 このプロパティは、前に設定する必要があります<xref:System.Net.Sockets.Socket.Bind%2A>が呼び出された、それ以外、<xref:System.InvalidOperationException>がスローされます。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException">この <see cref="T:System.Net.Sockets.Socket" /> に対して <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> が呼び出されました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> クラスによって使用されていたリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>クラスのファイナライザーの呼び出し、<xref:System.Net.Sockets.Socket.Close%2A>を終了するメソッド、<xref:System.Net.Sockets.Socket>に関連付けられているリソースを解放し、<xref:System.Net.Sockets.Socket>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> インスタンスのハッシュ値を返します。</summary>
        <returns>整数ハッシュ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
GetHashCode メソッドでは、このインスタンスのハッシュ コードを返します。 この値は、ハッシュ テーブル内のキーとして使用できます。

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> オプションの値を返します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値をオブジェクトとして返します。</summary>
        <returns>オプションの値を表すオブジェクト。 <paramref name="optionName" /> パラメーターを <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.LingerOption" /> クラスのインスタンスです。 <paramref name="optionName" /> を <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> または <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> に設定した場合、戻り値は <see cref="T:System.Net.Sockets.MulticastOption" /> クラスのインスタンスです。 <paramref name="optionName" /> が他の値の場合、戻り値は整数です。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>します。 このオーバー ロードを使用して取得する、 <xref:System.Net.Sockets.SocketOptionName.Linger>、 <xref:System.Net.Sockets.SocketOptionName.AddMembership>、および<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>オプション。 <xref:System.Net.Sockets.SocketOptionName.Linger>オプションを使用して<xref:System.Net.Sockets.Socket>の`optionLevel`パラメーター。 <xref:System.Net.Sockets.SocketOptionName.AddMembership>と<xref:System.Net.Sockets.SocketOptionName.DropMembership>を使用して、<xref:System.Net.Sockets.SocketOptionLevel.IP>します。 上記のオプションのいずれかの値の設定を使用する場合、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッド。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例を取得します、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
または 
 <paramref name="optionName" /> が、サポートされていない値 <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> に設定されました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">オプション設定を受信する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプション設定をバイト配列として返します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>します。 このメソッドが正常に完了すると、によって指定された配列、`optionValue`パラメーターには、指定した値が含まれています。<xref:System.Net.Sockets.Socket>オプション。  
  
 ときの長さ、`optionValue`配列が指定した値を格納するために必要なバイト数よりも小さい<xref:System.Net.Sockets.Socket>オプション、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。 ブール値または整数値で表されるソケットに対して、このオーバー ロードを使用します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例を取得します、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
または 
.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionLength">予期される戻り値のバイト単位の長さ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションの値を配列で返します。</summary>
        <returns>ソケット オプションの値を格納している <see cref="T:System.Byte" /> 型の配列。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `optionLength`パラメーターは、返されたバイト配列の最大サイズを設定します。 オプションの値には、以下のバイトが必要とする場合、配列にはそれだけ多くのバイト数。 オプションの値がより多くの容量が必要な場合<xref:System.Net.Sockets.Socket.GetSocketOption%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 ブール値または整数値で表されるソケットに対して、このオーバー ロードを使用します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例を取得します、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値し、コンソールに表示します。  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。  
  
または 
.NET Compact Framework アプリケーションでは、Windows CE の既定のバッファー領域は 32768 バイトに設定されます。 ソケットごとのバッファー領域は、<see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> を呼び出して変更できます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のオペレーティング システム ハンドルを取得します。</summary>
        <value><see cref="T:System.IntPtr" /> のオペレーティング システム ハンドルを表す <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Int32" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 配列。</param>
        <summary>数値制御コードを使用して、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns><paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.IOControl%2A>メソッドは、オペレーティング システムに低レベルのアクセスを提供します。<xref:System.Net.Sockets.Socket>の現在のインスタンスの基になる、<xref:System.Net.Sockets.Socket>クラス。 詳細については、次を参照してください。、 [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)ドキュメント。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、FIONREAD と利用可能なプロパティの結果を比較します。  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを実行します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">実行する操作の制御コードを指定する <see cref="T:System.Net.Sockets.IOControlCode" /> 値。</param>
        <param name="optionInValue">操作に必要な入力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="optionOutValue">操作によって返された出力データを格納する <see cref="T:System.Byte" /> 型の配列。</param>
        <summary><see cref="T:System.Net.Sockets.IOControlCode" /> 列挙型を使用して制御コードを指定し、<see cref="T:System.Net.Sockets.Socket" /> の下位操作モードを設定します。</summary>
        <returns><paramref name="optionOutValue" /> パラメーターのバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、オペレーティング システムに低レベルのアクセスを提供します。<xref:System.Net.Sockets.Socket>の現在のインスタンスの基になる、<xref:System.Net.Sockets.Socket>クラス。 詳細については、次を参照してください。、 [WSAIoctl](/windows/desktop/api/winsock2/nf-winsock2-wsaioctl)ドキュメント。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、呼び出し元の結果を比較します。<xref:System.Net.Sockets.Socket.IOControl%2A>で<xref:System.Net.Sockets.IOControlCode.DataToRead>と<xref:System.Net.Sockets.Socket.Available%2A>プロパティ。  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="P:System.Net.Sockets.Socket.Blocking" /> プロパティを使用せずに、ブロッキング モードを変更しようとしました。</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">アンマネージ コードを実行します。 <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> (関連する列挙体)</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> が特定のローカル ポートにバインドされているかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> がローカル ポートにバインドされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出すことによって明示的にバインドされている場合、ソケットは、ローカル ポートにバインドされたと見なされます、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド、またはのようなメンバーを呼び出すことによって暗黙的にバインドされた<xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、一時的なローカル ポート (free 以上のポートを使用します。1024、オペレーティング システムで選択されています。)サーバーを使用して、<xref:System.Net.Sockets.Socket.Bind%2A>にクライアントが接続されるように、既知のポートにバインドするメソッド。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.IsBound%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> で、すべての保留中のデータを送信しようとするときにソケットを遅延して閉じるかどうかを指定する値を取得または設定します。</summary>
        <value>ソケットを閉じているときの待機方法を指定する <see cref="T:System.Net.Sockets.LingerOption" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LingerState%2A>プロパティの変更方法<xref:System.Net.Sockets.Socket.Close%2A>メソッドの動作はします。 このプロパティ セットを接続をリセットして Winsock によって条件を変更するとします。 接続のリセットは、IP プロトコルの動作に基づいて引き続き発生します。  
  
 このプロパティは、接続指向の接続は呼び出しの後に開いたまま時間の長さを制御<xref:System.Net.Sockets.Socket.Close%2A>データが送信するのには残ります。  
  
 ピアにデータを送信するメソッドを呼び出すときに、このデータは、送信のネットワーク バッファーに配置されます。 このプロパティは、前に、リモート ホストにこのデータを送信することを使用できます、<xref:System.Net.Sockets.TcpClient.Close%2A>メソッドは、接続を切断します。  
  
 接続を維持できるように、作成、 <xref:System.Net.Sockets.LingerOption> 、目的の値を格納しているインスタンスし、設定、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティをこのインスタンスにします。  
  
 次の表の動作、<xref:System.Net.Sockets.Socket.Close%2A>メソッドの使用できる値について、<xref:System.Net.Sockets.LingerOption.Enabled%2A>プロパティと<xref:System.Net.Sockets.LingerOption.LingerTime%2A>にプロパティが格納されている、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティ。  
  
|LingerState.Enabled|LingerState.LingerTime|動作|  
|-------------------------|----------------------------|--------------|  
|`false` (無効)、既定値|タイムアウトが適用可能で、ない (既定値)。|既定の IP プロトコル タイムアウトの期限が切れるまで、保留中のデータ送信を試みます。|  
|`true` (有効)|0 以外のタイムアウト|指定したタイムアウトが経過すると、失敗した場合、Winsock 接続をリセットするまで、保留中のデータ送信を試行します。|  
|`true` (有効)|0 のタイムアウト。|保留中のデータを破棄します。 接続志向ソケット (たとえば、TCP) の場合は、Winsock は接続をリセットします。|  
  
 IP スタックは、接続の往復時間に基づいて使用する既定の IP プロトコルのタイムアウト期間を計算します。 ほとんどの場合は、スタックによって計算されたタイムアウトは、アプリケーションで定義された 1 つ以上です。 これは、ソケットの既定の動作と、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティは設定されません。  
  
 ときに、<xref:System.Net.Sockets.LingerOption.LingerTime%2A>にプロパティが格納されている、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティは、既定の IP プロトコル タイムアウトよりも大きい設定は、既定の IP プロトコル タイムアウトの表示およびオーバーライドはまだ適用されます。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.LingerState%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">保留中の接続のキューの最大長。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> をリッスン状態にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> 接続指向により<xref:System.Net.Sockets.Socket>受信接続の試行をリッスンするようにします。 `backlog`パラメーターが承認キューに置かれることが着信接続の数を指定します。 指定できる接続の最大数を確認するのには、取得、<xref:System.Net.Sockets.SocketOptionName.MaxConnections>値。 <xref:System.Net.Sockets.Socket.Listen%2A> ブロックされません。  
  
 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。 使用<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.BeginAccept%2A>キューからの接続を受け入れます。  
  
> [!NOTE]
>  呼び出す必要があります、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.Listen%2A>、または<xref:System.Net.Sockets.Socket.Listen%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
> [!NOTE]
>  バックログのパラメーターは、オペレーティング システムに応じて異なる値に制限されます。 高い値を指定することがありますが、バックログが制限されます、オペレーティング システムに基づきます。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket>着信接続をリッスンするようにします。  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ローカル エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" /> が通信に使用している <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの取得、<xref:System.Net.EndPoint>するローカル IP アドレスとポート番号を格納している、<xref:System.Net.Sockets.Socket>がバインドされています。 これをキャストする必要があります<xref:System.Net.EndPoint>を<xref:System.Net.IPEndPoint>すべての情報を取得する前にします。 呼び出して、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>ローカルを取得するメソッドを<xref:System.Net.IPAddress>、および<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>ローカル ポート番号を取得するメソッド。  
  
 <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>への呼び出しを行った後にプロパティが設定は、通常、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 ソケットのローカル IP アドレスとポート番号を割り当てる、システムを許可する場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>最初の I/O 操作の後にプロパティが設定されます。 接続指向のプロトコルでは、最初の I/O 操作の呼び出しでなければ、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを最初の I/O 操作では、送信のいずれかまたは呼び出しの受信は。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>発信マルチキャスト パケットが送信元アプリケーションに配信されるかどうかを指定する値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が発信マルチキャスト パケットを受け取る場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マルチキャストは、インターネットでの多対多の通信にスケーラブルな方法です。 プロセスをサブスクライブするマルチキャスト アドレス。次に、サブスクライブしているプロセスによって送信されたすべてのパケットは、マルチキャスト アドレスにサブスクライブしている他のすべてのプロセスによって受信されます。  
  
 伝送制御プロトコル (TCP) のソケットにこのプロパティを設定しても影響します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.MulticastLoopback%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ストリーム <see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用するかどうかを指定する <see cref="T:System.Boolean" /> 値を取得または設定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が Nagle アルゴリズムを使用する場合は <see langword="false" />。それ以外の場合は <see langword="true" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nagle のアルゴリズムは、小さなパケット バッファーを結合し、特定の状況で 1 つのパケットで送信するソケットでのネットワーク トラフィックの削減に設計されています。 TCP パケットは、header、および送信されるデータの 40 バイトで構成されます。 小さなデータ パケットを TCP で送信されると、TCP ヘッダーに起因するオーバーヘッドは、ネットワーク トラフィックのかなりの部分になります。負荷の高いネットワークでは、このオーバーヘッドの結果の輻輳が失われたデータグラムと再送信、ほかの輻輳による過剰な伝達時間が発生できます。 Nagle のアルゴリズムでは、送信の新しい TCP segmentswhen 新しい previouslytransmitted データ接続での受信確認されていないままの場合、ユーザーから到着するデータの送信を禁止します。  
  
 ネットワーク アプリケーションの大部分は、Nagle アルゴリズムを使用する必要があります。  
  
 ユーザー データグラム プロトコル (UDP) のソケットにこのプロパティを設定しても影響します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.NoDelay%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> へのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 4 (IPv4) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>基になるオペレーティング システムおよびネットワーク アダプターが、インターネット プロトコル バージョン 6 (IPv6) をサポートするかどうかを示します。</summary>
        <value>オペレーティング システムおよびネットワーク アダプターが IPv6 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="microSeconds">マイクロ秒単位の待機時間。</param>
        <param name="mode"><see cref="T:System.Net.Sockets.SelectMode" /> 値のいずれか。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の状態を確認します。</summary>
        <returns><paramref name="mode" /> パラメーターで渡されるポーリング モードの値に基づいた <see cref="T:System.Net.Sockets.Socket" /> の状態。  
  
 <list type="table"><listheader><term> モード 
 </term><description> 戻り値 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> が呼び出されており、接続が保留中の場合は <see langword="true" />。 
または 
 データを読み取ることができる場合は <see langword="true" />。 
または 
 接続が閉じている、リセットされている、または終了している場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に成功した場合は <see langword="true" />。 
または 
 データを送信できる場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description>ブロックしない <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> を処理し、接続に失敗した場合は <see langword="true" />。 
または 
 <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> が設定されておらず、帯域外データを使用できる場合は <see langword="true" />。 
それ以外の場合、<see langword="false" /> を返します。  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Poll%2A>メソッドの状態を確認、<xref:System.Net.Sockets.Socket>します。 指定<xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType>の`selectMode`パラメーターかどうかを<xref:System.Net.Sockets.Socket>を読み取ることができます。 指定<xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType>どうかを判断、<xref:System.Net.Sockets.Socket>が書き込み可能です。 使用<xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType>エラー状態を検出します。 <xref:System.Net.Sockets.Socket.Poll%2A> 単位で指定された期間までの実行がブロックされます`microseconds`が経過するとします。 設定、`microSeconds`パラメーターを負の整数の応答を無期限に待機したい場合。 複数のソケットの状態を確認する場合を使いたい場合があります、<xref:System.Net.Sockets.Socket.Select%2A>メソッド。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できないこと、またはリモート ホストが異常停止されました。 この種のエラーを検出するためにデータ送信または受信しようとする必要があります。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、ソケットを作成、サーバーに接続し、使用<xref:System.Net.Sockets.Socket.Poll%2A>ソケットの状態を確認します。  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="mode" /> パラメーターが、<see cref="T:System.Net.Sockets.SelectMode" /> 値の 1 つではありません。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> のプロトコルの種類を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.ProtocolType" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ProtocolType%2A>場合、プロパティが設定、<xref:System.Net.Sockets.Socket>が作成されを使用するプロトコルを指定します<xref:System.Net.Sockets.Socket>します。  
  
   
  
## Examples  
 次のコード例が表示されます、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信し、受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>バッファー パラメーターにデータを読み取ってを正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方から。  
  
 のみこのオーバー ロードでは、受信バッファーを提供する必要があります。 バッファーのオフセットの既定値は 0、サイズの既定値は、バッファー パラメーターの長さと<xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例で、接続されたデータを受信する<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して、受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、バッファー パラメーターにデータを読み取るし、正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、いずれかを指定する必要があります。 または以上の受信バッファー。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホスト接続から受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のエンキューされたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
 **注**このメンバーが、アプリケーションでネットワークのトレースを有効にすると、トレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> パラメーターが <see langword="null" /> です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>バッファー パラメーターにデータを読み取ってを正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方から。  
  
 このオーバー ロードだけ指定する必要が受信バッファーと、必要な<xref:System.Net.Sockets.SocketFlags>します。 バッファーのオフセットの既定値は 0 で、サイズの既定値はバイトのパラメーターの長さ。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはデータが利用可能になるまでブロックされます。 モードの非ブロッキングであることと、プロトコル スタック バッファーできるデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、再試行、受信操作。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用量のデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のエンキューされたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、データ バッファーを指定し、<xref:System.Net.Sockets.SocketFlags>で接続されたデータを受信するため<xref:System.Net.Sockets.Socket>。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにデータを読み取り、`buffers`パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、いずれかを指定する必要があります。 または以上の受信バッファー。 <xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホスト接続から受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>スローを呼び出し、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のエンキューされたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、接続されたデータを受信する方法を示します<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。  
  
または 
 <paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドへのデータを読み取り、`buffer`パラメーターと正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方から。  
  
 このオーバー ロード受信バッファー、バイト、受信するために必要な数を指定する必要のみ<xref:System.Net.Sockets.SocketFlags>します。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、再試行、受信操作。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがで指定したバイト数まで使用可能な多くのデータを読み取る、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次に検出されたデータを受信する`buffer`を指定して<xref:System.Net.Sockets.SocketFlags.None>の<xref:System.Net.Sockets.SocketFlags>します。  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">受信したデータを格納する <see cref="T:System.Byte" /> 型の複数の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーのリストに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドにデータを読み取り、`buffers`パラメーターと正常に読み取られたバイト数を返します。 接続指向とコネクションレス ソケットの両方から呼び出すことができます。  
  
 このオーバー ロードでは、いずれかを指定する必要があります。 または以上の受信バッファー。 <xref:System.Net.Sockets.SocketFlags>値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホスト接続から受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>スローを呼び出し、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、バッファーのサイズの最大使用可能な多くのデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffers`パラメーター、`buffers`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。  
  
または 
 <paramref name="buffers" />.Count が 0 です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試みているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信データを格納する <paramref name="buffer" />内の場所。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> から指定したバイト数のデータを受信して、受信バッファー内の指定したオフセット位置に格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>バッファー パラメーターにデータを読み取ってを正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方から。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、サイズのパラメーターで指定したバイト数まで使用可能な多くのデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、接続されたデータを受信する前にデータ バッファー、オフセット、サイズ、およびソケット フラグを指定します。<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、バインドされた <see cref="T:System.Net.Sockets.Socket" /> からデータを受信して受信バッファーに格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Receive%2A>バッファー パラメーターにデータを読み取ってを正常に読み取られたバイト数を返します。 呼び出すことができます<xref:System.Net.Sockets.Socket.Receive%2A>接続指向とコネクションレス ソケットの両方から。  
  
 接続指向プロトコルを使用している場合、呼び出し必要があります。 <xref:System.Net.Sockets.Socket.Connect%2A> 、リモート ホスト接続を確立するためにまたは<xref:System.Net.Sockets.Socket.Accept%2A>を呼び出す前に受信接続を受け入れる<xref:System.Net.Sockets.Socket.Receive%2A>します。 <xref:System.Net.Sockets.Socket.Receive%2A>メソッドで確立されているリモート ホストから受信したデータの読み取りのみが、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 コネクションレスのプロトコルを使用している場合は、使用することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> すべてのホストから着信するデータを受信できます。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはブロックを使用して、タイムアウト値が設定されていない場合は、データが使用可能なまで<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の「解説」を参照してください。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 接続指向を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドは、サイズのパラメーターで指定したバイト数まで使用可能な多くのデータを読み取ります。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>、<xref:System.Net.Sockets.Socket.Receive%2A>で指定した宛先アドレスの最初のキューに置かれたデータグラムを読み取り、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド。 受信したデータグラムがのサイズより大きいかどうか、`buffer`パラメーター、`buffer`設定します。 メッセージの最初の部分には、余分なデータが失われると、<xref:System.Net.Sockets.SocketException>がスローされます。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていません。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトからデータを受信する非同期要求を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドを使用してソケットまたはコネクションレス ソケットがバインドされた接続し、着信データの読み取りに使用します。 ソケットのローカル アドレスを認識する必要があります。  
  
 コネクションレス型のバインドのソケットは、この関数は、受信したメッセージの受け入れ元のアドレスを制限します。 関数は、接続で指定されたリモート アドレスからのみメッセージを返します。 その他のアドレスからのメッセージは自動的に破棄されます。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターには、読み取り要求に関する追加情報をウィンドウのソケット サービス プロバイダーが提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>します。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトを正常にこのメソッドを呼び出す必要は。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 バイト ストリーム スタイルのソケットの受信データは、バッファーの読み込みが、接続を終了すると、または内部的にバッファー内のデータがなくなるまで、バッファーに格納されます。  
  
 関連付けられているバッファーの合計サイズの最大バッファーに配置は、受信メッセージのメッセージ指向のソケット、`e`パラメーター。 メッセージがバッファーよりも大きい場合は、バッファーには、メッセージの最初の部分が入力されます。  
  
 接続指向のソケット、<xref:System.Net.Sockets.Socket.ReceiveAsync%2A>メソッドは、バイト ストリームまたはメッセージ指向のソケットがかどうかに依存する 2 つの方法のいずれかで仮想回線の正常な終了処理を示すことができます。 バイト ストリームでは正常に閉じられたと以上のバイトを読み取ることが既読 0 バイトを示します。 場所、ゼロ バイトのメッセージでは、使用できる多くの場合、メッセージ指向のソケットを<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ WSAEDISCON の Winsock エラー コード (10101) に設定が正常な終了を示すためです。 いずれの場合、<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>エラー コード (10054) 示すネイティブの Winsock WSAECONNRESET に設定を強制終了が発生しました。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">引数が無効です。 <paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の受信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>受信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 可能性のあるより大きなバッファー サイズは、空の受信確認 (TCP パケット データ部分はありません) の数を減らしますが、接続に関する問題を認識を遅らせるも可能性があります。 大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなど。) を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データグラムを受信し、ソース エンドポイントを格納します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが、正常に読み取られたバイト数を返し、データの送信元のリモート ホスト エンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバー ロードだけ指定する必要が、受信`buffer`、および<xref:System.Net.EndPoint>リモート ホストを表します。 バッファーのオフセットの既定値は 0。 既定値の長さは、サイズ、`buffer`パラメーターと`socketFlags`値の既定値は<xref:System.Net.Sockets.SocketFlags.None>します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 表示されない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 コネクションレスのプロトコル使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`、メッセージをそのまま可能であれば、および throw の多くで、<xref:System.Net.Sockets.SocketException>します。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合は、余分なデータは、サービス プロバイダーによって保持されますを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファー。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが利用可能になるまでブロックされます。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>コネクションレスのプロトコルのものはでも接続指向プロトコルを使用することができます。 これを行う場合は、する必要がありますまずか接続を確立するリモート ホストを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドか、着信リモートを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>取得は、メソッド、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のサイズの最大使用量のデータを読み取る`buffer`します。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの保存場所となる <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、データグラムを受信してデータバッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが、正常に読み取られたバイト数を返し、データの送信元のリモート ホスト エンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバー ロードするために必要な受信バッファーを提供する必要のみ<xref:System.Net.Sockets.SocketFlags>、および<xref:System.Net.EndPoint>リモート ホストを表します。 オフセットの既定値 0 とサイズの既定値はバッファー パラメーターの長さにします。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 表示されない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 コネクションレスのプロトコル使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`、メッセージをそのまま可能であれば、および throw の多くで、<xref:System.Net.Sockets.SocketException>します。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合は、余分なデータは、サービス プロバイダーによって保持されますを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファー。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが利用可能になるまでブロックされます。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>コネクションレスのプロトコルのものはでも接続指向プロトコルを使用することができます。 これを行う場合は、する必要がありますまずか接続を確立するリモート ホストを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドか、着信リモートを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>取得は、メソッド、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のサイズの最大使用量のデータを読み取る`buffer`します。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。 <xref:System.Net.Sockets.SocketFlags> 渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを受信してデータ バッファーに格納します。さらに、エンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが、正常に読み取られたバイト数を返し、データの送信元のリモート ホスト エンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 このオーバー ロードのために必要なを受信するバイト数、受信バッファーを提供する必要のみ<xref:System.Net.Sockets.SocketFlags>と<xref:System.Net.EndPoint>リモート ホストを表します。 バッファーのオフセットの既定値は 0。  
  
 コネクションレスのプロトコル使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`、メッセージをそのまま可能であれば、および throw の多くで、<xref:System.Net.Sockets.SocketException>します。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合は、余分なデータは、サービス プロバイダーによって保持されますを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファー。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが利用可能になるまでブロックされます。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>コネクションレスのプロトコルのものはでも接続指向プロトコルを使用することができます。 これを行う場合は、する必要がありますまずか接続を確立するリモート ホストを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドか、着信リモートを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>取得は、メソッド、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>数までで指定したバイトの使用量のデータを読み取る、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 表示されない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。 バッファー サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が <paramref name="buffer" /> の長さを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを受信して、データ バッファー内の指定した位置に格納します。またエンドポイントを格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが、正常に読み取られたバイト数を返し、データの送信元のリモート ホスト エンドポイントをキャプチャします。 このメソッドは、不明なホストまたは複数のホストからコネクションレスのデータグラムを受信する場合に便利です。  
  
 コネクションレスのプロトコル使用<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>はローカル ネットワーク バッファーに受信した最初のエンキューされたデータグラムを読み取ります。 受信したデータグラムがのサイズより大きいかどうか`buffer`、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは入力`buffer`、メッセージをそのまま可能であれば、および throw の多くで、<xref:System.Net.Sockets.SocketException>します。 信頼性の低いプロトコルを使用している場合は、余分なデータが失われます。 信頼性の高いプロトコルを使用している場合は、余分なデータは、サービス プロバイダーによって保持されますを呼び出して取得することができます、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>のに十分な大きさのバッファー。  
  
 読み取りについては、使用可能なデータがない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはデータが利用可能になるまでブロックされます。 モードの非ブロッキングであることで使用できるデータがない場合、プロトコル スタック バッファー、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、スロー、<xref:System.Net.Sockets.SocketException>します。 使用することができます、<xref:System.Net.Sockets.Socket.Available%2A>プロパティ データが読み取り可能なかどうかを判断します。 ときに<xref:System.Net.Sockets.Socket.Available%2A>0 以外の場合は、受信操作を再試行してください。  
  
 <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>コネクションレスのプロトコルのものはでも接続指向プロトコルを使用することができます。 これを行う場合は、する必要がありますまずか接続を確立するリモート ホストを呼び出して、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドか、着信リモートを呼び出して接続をホスト、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、接続を呼び出す前に許可しない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>取得は、メソッド、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。 このような場合は、のいずれかで、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドは無視されます、`remoteEP`パラメーターのみから、接続されているデータや既定のリモート ホストを受信します。  
  
 接続指向のソケットで<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>で指定したバイトの最大使用量のデータを読み取る、`size`パラメーター。 リモート ホストがシャット ダウンした場合、<xref:System.Net.Sockets.Socket>との接続、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッド、および使用可能なすべてのデータを受信、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッドはすぐに完了し、0 バイトを返します。  
  
> [!NOTE]
>  呼び出しの前に<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>、明示的にバインドする必要があります、<xref:System.Net.Sockets.Socket>を使用して、ローカル エンドポイントを<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 表示されない場合、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、リモート ホストからコネクションレスのデータグラムを受信します。 オフセット、バッファーのサイズと<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>メソッド。  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
または 
ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定したネットワーク デバイスから、データの非同期の受信を開始します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>コネクションレス ソケット上のデータを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスを認識する必要があります。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>データの受信元のリモート ホストの。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターには、読み取り要求に関する追加情報をウィンドウのソケット サービス プロバイダーが提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>します。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトを正常にこのメソッドを呼び出す必要は。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 バイト ストリーム スタイルのソケットの受信データは、バッファーの読み込みが、接続を終了すると、または内部的にバッファー内のデータがなくなるまで、バッファーに格納されます。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">受信したデータの格納場所である、<see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">受信したデータを格納する、<paramref name="buffer" /> パラメーター内の位置。</param>
        <param name="size">受信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">リモート サーバーを表す、参照渡しされた <see cref="T:System.Net.EndPoint" />。</param>
        <param name="ipPacketInformation">アドレスとインターフェイスの情報を保持する <see cref="T:System.Net.Sockets.IPPacketInformation" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータをデータ バッファー内の指定した位置で受信して、エンドポイントおよびパケット情報を格納します。</summary>
        <returns>受信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドへのデータを読み取り、`buffer`パラメーターが、正常に読み取られたバイト数を返し、データの送信元、受信したパケットに関する情報と、リモート ホスト エンドポイントをキャプチャします。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>コネクションレス ソケットでのメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスを認識する必要があります。 このメソッドは、データグラムと raw ソケットでのみ使用できます。 ソケットの種類に設定されたソケットを初期化する必要があります<xref:System.Net.Sockets.SocketType.Dgram>または<xref:System.Net.Sockets.SocketType.Raw>このメソッドを呼び出す前にします。 これを使用して、ソケットが作成されるときに<xref:System.Net.Sockets.Socket.%23ctor%2A>します。  
  
 受信メッセージをまとめてメッセージ指向のソケット、`buffer`パラメーターで指定された合計サイズまで、`size`パラメーター。 `offset`のどの場所を指定します、`buffer`データが配置されます。 実際のデータ量がまとめて、`buffer`によって返される、<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッド。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドに自動的にメソッドを設定、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプション`true`初めて呼び出された、指定された<xref:System.Net.Sockets.Socket>します。 ただし、返された<xref:System.Net.Sockets.IPPacketInformation>オブジェクトがソケット オプションが設定された後に、ローカル コンピューターに到達するパケットの有効のみになります。 ローカル エンドポイントにバインドされているときに、ソケットの間でパケットが送信する場合 (によって明示的に、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドのいずれかによって暗黙的にまたは、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド) とその最初の呼び出し、 <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドの呼び出しに<xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A>メソッドは無効な返します<xref:System.Net.Sockets.IPPacketInformation>これらのパケットのオブジェクト。  
  
 確実にすべて<xref:System.Net.Sockets.IPPacketInformation>オブジェクトが正しいこと、アプリケーションを設定する必要があります、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプション`true`を使用して、ローカル エンドポイントにバインドされる前に、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッド。  
  
 アプリケーションを調べることができます、`ipPacketInformation`ユニキャスト、マルチキャストまたはブロードキャスト アドレスを使用してデータグラムが送信されたかを把握する必要がある場合は、パラメーター。  
  
> [!NOTE]
>  <xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.ReceiveFrom%2A>と一致する必要があります、<xref:System.Net.Sockets.AddressFamily>の<xref:System.Net.EndPoint>で使用される<xref:System.Net.Sockets.Socket.SendTo%2A>します。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
\- または 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さからオフセット パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> プロパティが設定されていませんでした。  
  
または 
.NET Framework が、AMD 64 ビット プロセッサ上で実行されています。  
  
または 
ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.NotSupportedException">Windows 2000 以前のオペレーティング システムです。このメソッドを使用するには、Windows XP が必要です。</exception>
        <permission cref="T:System.Net.SocketPermission">ネットワークからの接続を受け入れるため。 <see cref="F:System.Net.NetworkAccess.Accept" /> (関連する列挙体)</permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>指定された <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> を使用し、指定されたバイト数のデータの非同期受信を開始して、データ バッファー内の指定された場所に格納します。さらに、エンドポイントとパケットの情報を格納します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>コネクションレス ソケットでのメッセージ データを受信するには、主にメソッドを使用します。 ソケットのローカル アドレスを認識する必要があります。 このメソッドは、データグラムと raw ソケットでのみ使用できます。 ソケットの種類に設定されたソケットを初期化する必要があります<xref:System.Net.Sockets.SocketType.Dgram>または<xref:System.Net.Sockets.SocketType.Raw>このメソッドを呼び出す前にします。 これを使用して、ソケットが作成されるときに<xref:System.Net.Sockets.Socket.%23ctor%2A>します。  
  
 呼び出し元を設定する必要があります、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティを<xref:System.Net.IPEndPoint>データの受信元のリモート ホストの。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトを正常にこのメソッドを呼び出す必要は。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 メッセージ指向のソケットでは、受信メッセージは、バッファーの合計サイズの最大バッファーに配置します。 <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>と<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>プロパティは、バッファー内のデータの配置場所と、データの量を決定します。  
  
 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドが自動的に設定、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプション`true`初めて呼び出された、指定された<xref:System.Net.Sockets.Socket>します。 ただし、<xref:System.Net.Sockets.IPPacketInformation>オブジェクトがソケット オプションが設定された後に、ローカル コンピューターに到達するパケットの有効のみになります。 ローカル エンドポイントに、ソケットがバインドされている場合、ソケットの間でパケットが送信する場合 (によって明示的に、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドのいずれかによって暗黙的にまたは、 <xref:System.Net.Sockets.Socket.Connect%2A>、 <xref:System.Net.Sockets.Socket.ConnectAsync%2A>、 <xref:System.Net.Sockets.Socket.SendTo%2A>、または<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド) と、最初の呼び出し、 <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドの呼び出しに<xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>メソッドは無効になります<xref:System.Net.Sockets.IPPacketInformation>これらのパケットのオブジェクト。  
  
 確実にすべて<xref:System.Net.Sockets.IPPacketInformation>オブジェクトが正しいこと、アプリケーションを設定する必要があります、<xref:System.Net.Sockets.SocketOptionName.PacketInformation>ソケット オプション`true`を使用して、ローカル エンドポイントにバインドされる前に、<xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29>メソッド。  
  
 アプリケーションが結果を確認することができます<xref:System.Net.Sockets.IPPacketInformation>ユニキャスト、マルチキャストまたはブロードキャスト アドレスを使用してデータグラムが送信されたかどうかの情報が必要なかどうかのオブジェクトします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Receive" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションを適用する同期<xref:System.Net.Sockets.Socket.Receive%2A>呼び出しのみです。 タイムアウト期間を超過した場合、<xref:System.Net.Sockets.Socket.Receive%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>リモート エンドポイントを取得します。</summary>
        <value><see cref="T:System.Net.EndPoint" /> の通信先の <see cref="T:System.Net.Sockets.Socket" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向のプロトコルを使用している場合、<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>プロパティの取得、<xref:System.Net.EndPoint>するリモート IP アドレスとポート番号を格納している、<xref:System.Net.Sockets.Socket>が接続されています。 コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>が、既定のリモート IP アドレスとポート番号が含まれています、<xref:System.Net.Sockets.Socket>は通信します。 これをキャストする必要があります<xref:System.Net.EndPoint>を<xref:System.Net.IPEndPoint>すべての情報を取得する前にします。 呼び出して、<xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>リモートを取得するメソッドを<xref:System.Net.IPAddress>、および<xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>リモート ポート番号を取得するメソッド。  
  
 <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>呼び出しの後にいずれかの設定は<xref:System.Net.Sockets.Socket.Accept%2A>または<xref:System.Net.Sockets.Socket.Connect%2A>します。 以前では、このプロパティにアクセスしようとする場合<xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、取得し、ローカルおよびリモート エンドポイントを表示します。  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="checkRead">読みやすさを確認する <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkWrite">書き込み機能をチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="checkError">エラーをチェックする <see cref="T:System.Net.Sockets.Socket" /> インスタンスの <see cref="T:System.Collections.IList" />。</param>
        <param name="microSeconds">タイムアウト値 (マイクロ秒)。 値が -1 の場合は、タイムアウトが無限であることを示します。</param>
        <summary>1 つまたは複数のソケットのステータスを判断します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> 1 つまたは複数の状態を決定する静的メソッドは、<xref:System.Net.Sockets.Socket>インスタンス。 1 つまたは複数のソケットを配置する必要があります、<xref:System.Collections.IList>使用する前に、<xref:System.Net.Sockets.Socket.Select%2A>メソッド。 呼び出すことで、読みやすさの確認<xref:System.Net.Sockets.Socket.Select%2A>で、<xref:System.Collections.IList>として、`checkRead`パラメーター。 書き込み機能、ソケットを確認するには、使用、`checkWrite`パラメーター。 エラー条件を検出するため使用`checkError`します。 呼び出した後<xref:System.Net.Sockets.Socket.Select%2A>、<xref:System.Collections.IList>条件を満たすソケットのみが格納されます。  
  
 リッスン状態にする場合は、読みやすくすることを意味する呼び出し<xref:System.Net.Sockets.Socket.Accept%2A>はブロックすることがなく成功します。 接続は既に承諾済み場合、読みやすさは、データが読み取り可能なことを意味します。 このような場合は、すべての受信操作はブロックすることがなく成功します。 読みやすさを示すこともかどうか、リモート<xref:System.Net.Sockets.Socket>がシャット ダウン、接続はそのケースでの呼び出しを<xref:System.Net.Sockets.Socket.Receive%2A>は返されたバイト数を 0 で、すぐに戻ります。  
  
 <xref:System.Net.Sockets.Socket.Select%2A> 時に返す対象のソケットの少なくとも 1 つ (でソケット、 `checkRead`、`checkWrite`と`checkError`を一覧表示) が、指定の条件を満たしている、または`microSeconds`パラメーターを超過すると、どちらか早い。 設定`microSeconds`を-1 に無限のタイムアウトを指定します。  
  
 非ブロッキング呼び出しを行った場合<xref:System.Net.Sockets.Socket.Connect%2A>、書き込み機能が正常に接続していることを意味します。 接続が確立されて既にある場合、書き込み機能は、すべての送信操作がブロックすることがなく成功を意味します。  
  
 非ブロッキング呼び出しを行ったかどうか<xref:System.Net.Sockets.Socket.Connect%2A>、`checkerror`パラメーターが正常に接続されていないソケットを識別します。  
  
> [!NOTE]
>  使用して、<xref:System.Net.Sockets.Socket.Poll%2A>メソッドの場合は、1 つの状態を確認する<xref:System.Net.Sockets.Socket>します。  
  
> [!NOTE]
>  このメソッドは、切断されたネットワーク ケーブルなどの接続に関する問題の特定の種類を検出できないこと、またはリモート ホストが異常停止されました。 この種のエラーを検出するためにデータ送信または受信しようとする必要があります。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.Select%2A>接続要求をリッスンするソケットを決定します。  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="checkRead" /> パラメーターは <see langword="null" /> または空です。  
  
および 
<paramref name="checkWrite" /> パラメーターは <see langword="null" /> または空です。 
および 
<paramref name="checkError" /> パラメーターは <see langword="null" /> または空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドと正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス両方のプロトコルを使用できます。  
  
 このオーバー ロードでは、送信するデータを格納しているバッファーが必要です。 <xref:System.Net.Sockets.SocketFlags>を 0 に初期値として、バッファーのオフセットの既定値は 0、およびバッファーのサイズを既定値を送信するバイト数。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>、このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要は<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、すべてのバッファー内のバイトが送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡するアプリケーションは、バッファー内のバイトを送信するまで、操作を再試行して、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例で、接続されたデータの送信を示します<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <summary>リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス両方のプロトコルを使用できます。  
  
 このオーバー ロードでは、少なくとも 1 つのバッファーに送信するデータを格納する必要があります。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>、このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要は<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、すべてのバッファー内のバイトが送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡するアプリケーションは、バッファー内のバイトを送信するまで、操作を再試行して、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 以下の解説を参照してください。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> にデータを送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 設定されているリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドと正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A>の両方の接続指向とコネクションレス プロトコル メソッドを使用できます。  
  
 このオーバー ロードは、送信するデータを格納しているバッファーとビットごとの組み合わせが必要です。<xref:System.Net.Sockets.SocketFlags>します。 バッファーのオフセットの既定値は 0、およびバッファーのサイズを既定値を送信するバイト数。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター値、ルーティングされていないに送信するデータ。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>、このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要は、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドに対する各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、すべてのバッファー内のバイトが送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例で、接続されたデータの送信を示します<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、少なくとも 1 つのバッファーに送信するデータを格納する必要があります。 <xref:System.Net.Sockets.SocketFlags>値の既定値は 0。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketFlags`パラメーター、ルーティングされていないに送信するデータ。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>、このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要は<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、すべてのバッファー内のバイトが送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡するアプリケーションは、バッファー内のバイトを送信するまで、操作を再試行して、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 設定されているリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドと正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス両方のプロトコルを使用できます。  
  
 このオーバー ロードには、いずれかのビットごとの組み合わせと、送信するバイト数、送信するデータを格納するバッファーが必要です。<xref:System.Net.Sockets.SocketFlags>します。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>、このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要は、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドに対する各呼び出しの前に、<xref:System.Net.Sockets.Socket.Send%2A>メソッド。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルと<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、要求されたバイト数が送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要があります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、バッファー内で見つかったデータを送信しを指定します<xref:System.Net.Sockets.SocketFlags.None>の<xref:System.Net.Sockets.SocketFlags>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> が 0 未満か、バッファーのサイズを超える値です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
ソケットへのアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffers">送信するデータを格納する <see cref="T:System.Byte" /> 型の <see cref="T:System.ArraySegment`1" /> のリスト。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、リスト内のバッファーのセットを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、少なくとも 1 つのバッファーに送信するデータを格納する必要があります。 <xref:System.Net.Sockets.SocketFlags>値の既定値は 0。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketFlags`パラメーター、ルーティングされていないに送信するデータ。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>、このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 使用しない場合、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドを呼び出す必要は<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用することができます<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、すべてのバッファー内のバイトが送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信バッファー内のバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡するアプリケーションは、バッファー内のバイトを送信するまで、操作を再試行して、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> が空です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドと正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス両方のプロトコルを使用できます。  
  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合<xref:System.Net.Sockets.Socket.SendTo%2A>します。 使用しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用しても問題が<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、要求されたバイト数が送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<xref:System.Net.Sockets.SocketFlags>を接続されたデータを送信するため<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="errorCode">ソケット エラーを格納する <see cref="T:System.Net.Sockets.SocketError" /> オブジェクト。</param>
        <summary>指定したオフセットから開始し、指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、指定したバイト数のデータを接続された <see cref="T:System.Net.Sockets.Socket" /> に送信します。</summary>
        <returns><see cref="T:System.Net.Sockets.Socket" /> に送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> 指定されたリモート ホストにデータを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッドと正常に送信したバイト数を返します。 <xref:System.Net.Sockets.Socket.Send%2A> 接続指向とコネクションレス両方のプロトコルを使用できます。  
  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>このメソッドを呼び出す前に、または<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 使用する必要がありますをいくつかの異なるホストにデータを送信する、コネクションレスのプロトコルとプランを使用する場合<xref:System.Net.Sockets.Socket.SendTo%2A>します。 使用しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>を呼び出す必要があります<xref:System.Net.Sockets.Socket.Connect%2A>への各呼び出しの前に<xref:System.Net.Sockets.Socket.Send%2A>します。 使用しても問題が<xref:System.Net.Sockets.Socket.SendTo%2A>で既定のリモート ホストを確立した後でも<xref:System.Net.Sockets.Socket.Connect%2A>します。 呼び出しの前に、既定のリモート ホストを変更することもできます。<xref:System.Net.Sockets.Socket.Send%2A>別呼び出すことによって<xref:System.Net.Sockets.Socket.Connect%2A>します。  
  
 サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.Send%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.Send%2A>を使用して、タイムアウトが設定しない限り、要求されたバイト数が送信されるまでブロックされます<xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>します。 タイムアウト値を超えている場合、<xref:System.Net.Sockets.Socket.Send%2A>呼び出しがスローされます、<xref:System.Net.Sockets.SocketException>します。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.Send%2A>送信を要求したバイト数よりも小さい場合でも正常に完了場合があります。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.Send%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  送信が正常に完了しても、データが正常に配信されたことは示しません。 転送するデータを保持するために、トランスポート システム内で使用可能なバッファー領域がない場合は、送信ソケットが非ブロッキング モードに設定されていない場合にブロックされます。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例は、データ バッファー、オフセット、サイズを指定します。 および<xref:System.Net.Sockets.SocketFlags>を接続されたデータを送信するため<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、データを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドを使用して、接続指向のソケットでの 1 つまたは複数のバッファーから送信されるデータを書き込むことです。 このメソッドこともでき、ただし、コネクションレス型のソケット接続操作で、リモート ホストを指定します。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドで確立されているリモート ホストへの非同期送信操作を開始、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトを正常にこのメソッドを呼び出す必要は。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> または <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> 場合<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>設定  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 <xref:System.Net.Sockets.Socket.SendAsync%2A>最初に呼び出すしない場合、メソッドは例外をスローは<xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>します。  
  
 呼び出す、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。  
  
 メッセージ指向のソケットでは、基になる Windows sockets サービス プロバイダーのメッセージの最大サイズを超えないようにしないでください。 データが長すぎて、基になるサービス プロバイダーの場合は、データは送信されません、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>で、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType>ネイティブ WSAEMSGSIZE の Winsock エラー コード (10040) に設定します。  
  
 なおが正常に完了、<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッドは、データが正常に配信されたことを示していません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="e" /> パラメーターの <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> プロパティまたは <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> プロパティは、有効なバッファーを参照する必要があります。 これらのプロパティは、どちらか 1 つを設定できます。一度に両方のプロパティを設定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていないか、<see cref="M:System.Net.Sockets.Socket.Accept" />、<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />、または <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /> の各メソッドによって取得されませんでした。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の送信バッファーのサイズを指定する値を取得または設定します。</summary>
        <value>送信バッファーのサイズ (バイト単位) を格納している <see cref="T:System.Int32" />。 既定値は 8192 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 大きなバッファー サイズは、接続に関する問題を認識を遅らせることができます。 大きなファイルを転送するか、高帯域幅、待機時間の長い接続 (サテライト ブロード バンド プロバイダーなど。) を使用している場合は、バッファー サイズを増やすことを検討してください。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.SendBufferSize%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が 0 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>接続された <see cref="T:System.Net.Sockets.Socket" /> に、ファイルおよびオプション データを同期的に送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <summary><see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> 送信フラグを使用して、接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> を送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードは、ファイルを送信`fileName`に接続されたソケットにします。 `flags`パラメーターの既定値<xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread>(0)、および`preBuffer`と`postBuffer`パラメーターに既定の`null`します。 場合`fileName`ですが、ローカルのディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。 ファイルが見つからない場合、例外<xref:System.IO.FileNotFoundException>がスローされます。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかりました。 詳細については、`TransmitFile`関数とそのフラグを参照してください、 [Windows Sockets](/windows/desktop/WinSock/)ドキュメント。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 指定されたリモート ホストにファイルを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 <xref:System.Net.Sockets.Socket.SendFile%2A> コネクションレスのプロトコル、接続指向の両方に使用できます。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>それ以外の場合、このメソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendFile%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立またはを使用して、<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendFile%2A>ファイルを送信するまでブロックします。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信される前に正常に完了場合があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.SendFile%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例を作成し、ソケットを接続し、リモート ホストにファイルを送信します。 ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">送信されるファイルのパスと名前を含む <see cref="T:System.String" />。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="preBuffer">ファイルが送信される前に送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="postBuffer">ファイルが送信された後で送信されるデータを格納する <see cref="T:System.Byte" /> 配列。 このパラメーターは、<see langword="null" /> に設定できます。</param>
        <param name="flags">1 つ以上の <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.TransmitFileOptions" /> 値を使用して、接続された <see cref="T:System.Net.Sockets.Socket" /> オブジェクトにファイル <paramref name="fileName" /> およびデータのバッファーを送信します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードには、送信するファイルとビットごとの組み合わせの名が必要です。<xref:System.Net.Sockets.TransmitFileOptions>値。 `preBuffer`パラメーターには、ファイルの前にすべてのデータが含まれています。 `postBuffer` ファイルを実行するデータが含まれています。 場合`fileName`ですが、現在の作業ディレクトリでファイルの名前だけで識別可能性があります。 それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカード ("..\\\myfile.txt") と UNC 共有名 ("\\\\\\\shared ディレクトリ\\\myfile.txt") はサポートされています。  
  
 `flags`パラメーターには、ファイルの転送に関する追加情報をウィンドウのソケット サービス プロバイダーが提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>します。  
  
 このメソッドを使用して、 `TransmitFile` Windows Sockets 2 API の関数が見つかりました。 詳細については、`TransmitFile`関数とそのフラグを参照してください、 [Windows Sockets](/windows/desktop/WinSock/)ドキュメント。  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> 指定されたリモート ホストにファイルを同期的に送信、<xref:System.Net.Sockets.Socket.Connect%2A>または<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 <xref:System.Net.Sockets.Socket.SendFile%2A> コネクションレスのプロトコル、接続指向の両方に使用できます。  
  
 呼び出す必要がある場合はコネクションレスのプロトコルを使用している<xref:System.Net.Sockets.Socket.Connect%2A>; このメソッドを呼び出す前にそれ以外の場合<xref:System.Net.Sockets.Socket.SendFile%2A>スロー、 <xref:System.Net.Sockets.SocketException>。 接続指向プロトコルを使用している場合を使用する必要があります。<xref:System.Net.Sockets.Socket.Connect%2A>をリモート ホスト接続を確立または使用<xref:System.Net.Sockets.Socket.Accept%2A>着信接続を受け入れるようにします。  
  
 接続指向のプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信されるまでブロックします。 非ブロッキング モードで<xref:System.Net.Sockets.Socket.SendFile%2A>ファイル全体が送信される前に正常に完了場合があります。 送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.SendFile%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、作成し、ソケットを接続します。 ファイル"test.txt"は、ローカル コンピューターのルート ディレクトリにあります。 この例で事前バッファリングと事後バッファリングのデータを作成し、ファイルを使用して、リモート ホストに送信します。 既定の<xref:System.Net.Sockets.TransmitFileOptions>使用されます。  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">オペレーティング システムは Windows NT 以降ではありません。  
  
または 
ソケットがリモート ホストに接続されていません。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトはブロック モードではなく、この同期呼び出しを受け付けることができません。</exception>
        <exception cref="T:System.IO.FileNotFoundException">ファイル <paramref name="fileName" /> が見つかりませんでした。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>接続されている <see cref="T:System.Net.Sockets.Socket" /> オブジェクトに、ファイルのコレクションまたはメモリ内のデータ バッファーを非同期に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>リモート ホストにデータ バッファーをメモリ内、またはファイルのコレクションに送信するメソッドを使用します。 <xref:System.Net.Sockets.Socket>リモート ホストに既に接続されている必要があります。  
  
 場合、<xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType>作業ディレクトリでファイルを参照、ファイルの名前だけで識別できます;、それ以外の場合、完全なパスとファイルの名前を指定する必要があります。 ワイルドカードと UNC 共有名がサポートされています。 ファイルが見つからない場合<xref:System.IO.FileNotFoundException>がスローされます。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > デリゲートおよびコールバックをアタッチ、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターには、ファイルの転送に関する追加情報をウィンドウのソケット サービス プロバイダーが提供します。 このパラメーターを使用する方法の詳細については、次を参照してください。<xref:System.Net.Sockets.TransmitFileOptions>します。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトを正常にこのメソッドを呼び出す必要は。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 このメソッドは、Windows Sockets 2 の API で見つかった TransmitPackets 関数を使用します。 TransmitPackets 関数とそのフラグの詳細については、次を参照してください。、 [Windows Sockets](/windows/desktop/WinSock/)ドキュメント。  
  
 接続指向のプロトコルでは、対象としていますが、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドに対しても機能コネクションレスのプロトコルを最初に呼び出すことが提供される、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>既定のリモート ホストを構築する方法。 コネクションレスのプロトコルを使用している場合は、ファイルのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認する必要もあります。 データグラムが送信しない場合と<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>スロー、<xref:System.Net.Sockets.SocketException>例外。  
  
 <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドは使用されているオペレーティング システムに従って最適化されています。 Windows server のエディションで、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドは高パフォーマンスの最適化されています。  
  
 Windows クライアントの各エディションで、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドは最低限のメモリとリソース使用率の最適化されています。  
  
 使用、<xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType>フラグ、<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType>プロパティを`e`パラメーターは、パフォーマンスに大きなメリットを提供できます。 場合、スレッドを開始する、<xref:System.Net.Sockets.Socket.SendPacketsAsync%2A>メソッドの呼び出しは、大量の計算の使用されている、可能性は低い、Apc が起動できないことことことができます。 Apc のカーネルとユーザー モードの間に相違があることに注意してください。 スレッドが待機状態の場合、カーネルの Apc が起動します。 ユーザー モードの Apc ステートでスレッドがある場合の起動します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> プロパティで指定されたファイルが見つかりませんでした。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。 この例外は、<see cref="T:System.Net.Sockets.Socket" /> がリモート ホストに接続されていない場合にも発生します。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">コネクションレスの <see cref="T:System.Net.Sockets.Socket" /> が使用されており、送信するファイルが基になるトランスポートの最大パケット サイズを超えています。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>同期の <see cref="Overload:System.Net.Sockets.Socket.Send" /> 呼び出しがタイムアウトするまでの合計時間を指定する値を取得または設定します。</summary>
        <value>タイムアウト値 (ミリ秒)。 プロパティに 1 から 499 までの値を設定しても、その値は 500 に変更されます。 既定値は 0 です。タイムアウトが無期限であることを示します。 -1 の指定も、タイムアウトが無期限であることを示します。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオプションを適用する同期<xref:System.Net.Sockets.Socket.Send%2A>呼び出しのみです。 タイムアウト期間を超過した場合、<xref:System.Net.Sockets.Socket.Send%2A>メソッドがスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.SendTimeout%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">設定操作として指定された値が -1 未満です。</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>データを特定のエンドポイントに送信します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="remoteEP">データの送信先を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定したエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードで、バッファーのオフセットの既定値は 0 の場合のサイズに既定値を送信するバイトの数、`buffer`パラメーター、および<xref:System.Net.Sockets.SocketFlags>値の既定値は 0。  
  
 コネクションレスのプロトコルを使用している場合はで、既定のリモート ホストを確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>します。 これを呼び出す場合にのみ必要があります、<xref:System.Net.Sockets.Socket.Send%2A>メソッド。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信する指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することが割り当てられているローカル ネットワーク アドレスとポート番号を特定する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの後、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了します。  
  
 コネクションレスのプロトコルを対象としていますが<xref:System.Net.Sockets.Socket.SendTo%2A>でも接続指向プロトコルを使用できます。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信接続を使用して要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとデータを送信する、接続または既定のリモート ホストのみです。  
  
 ブロッキング ソケットと、すべてのバッファーにバイトが送信されるまでブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了しない送信すべてのバイト数の可能性がありますが、すぐに、`buffer`します。 送信されたバイト数を追跡するすべてのバイト数のアプリケーションに送信されるまで、操作を再試行して、アプリケーションの責任は、`buffer`します。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の送信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 最初に呼び出す必要がある場合は、ブロードキャスト アドレスにデータを送信する、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>します。 送信されたバイト数が、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、指定されたリモート ホストにコネクションレスのデータグラムを送信します。  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用して、特定のエンドポイントにデータを送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードで、バッファーのオフセットの既定値は 0、およびのサイズを既定値を送信するバイト数、`buffer`します。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合はで、既定のリモート ホストを確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>します。 これを呼び出す場合にのみ必要があります、<xref:System.Net.Sockets.Socket.Send%2A>メソッド。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信する指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することが割り当てられているローカル ネットワーク アドレスとポート番号を特定する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの後、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了します。  
  
 コネクションレスのプロトコルを対象としていますが<xref:System.Net.Sockets.Socket.SendTo%2A>でも接続指向プロトコルを使用できます。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信接続を使用して要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとデータを送信する、接続または既定のリモート ホストのみです。  
  
 ブロッキング ソケットは、要求されたまですべてのブロック内のバイト、`buffer`送信されます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了しない送信すべてのバイト数の可能性がありますが、すぐに、`buffer`します。 送信されたバイト数を追跡するすべてのバイト数のアプリケーションに送信されるまで、操作を再試行して、アプリケーションの責任は、`buffer`します。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の発信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 最初に呼び出す必要がある場合は、ブロードキャスト アドレスにデータを送信する、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>します。 送信されたバイト数が、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、指定されたリモート ホストにコネクションレスのデータグラムを送信します。 <xref:System.Net.Sockets.SocketFlags> 渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードでは、バッファーは、既定値は 0 をオフセットです。 指定した場合、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合はで、既定のリモート ホストを確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>します。 これを呼び出す場合にのみ必要があります、<xref:System.Net.Sockets.Socket.Send%2A>メソッド。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信する指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することが割り当てられているローカル ネットワーク アドレスとポート番号を特定する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの後、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了します。  
  
 コネクションレスのプロトコルを対象としていますが<xref:System.Net.Sockets.Socket.SendTo%2A>でも接続指向プロトコルを使用できます。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信接続を使用して要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとデータを送信する、接続または既定のリモート ホストのみです。  
  
 要求されたバイト数が送信されるまで、ブロッキング ソケットがブロックされます。 非ブロッキング<xref:System.Net.Sockets.Socket>が完了しない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーションの役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の発信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 最初に呼び出す必要がある場合は、ブロードキャスト アドレスにデータを送信する、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>します。 送信されたバイト数が、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、指定されたリモート ホストにコネクションレスのデータグラムを送信します。 サイズと<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">指定した <paramref name="size" /> が <paramref name="buffer" /> のサイズを超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="buffer">送信されるデータを含む <see cref="T:System.Byte" /> 型の配列。</param>
        <param name="offset">データの送信を開始する、データ バッファー内の位置。</param>
        <param name="size">送信するバイト数。</param>
        <param name="socketFlags"><see cref="T:System.Net.Sockets.SocketFlags" /> 値のビットごとの組み合わせ。</param>
        <param name="remoteEP">データの送信先の位置を表す <see cref="T:System.Net.EndPoint" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.SocketFlags" /> を使用し、指定したバイト数のデータを、指定したエンドポイントに送信します。送信はバッファー内の指定した位置から開始されます。</summary>
        <returns>送信されたバイト数。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定した場合、オーバー ロードでは、<xref:System.Net.Sockets.SocketFlags.DontRoute>としてフラグを設定、`socketflags`パラメーター、ルーティングされていないに送信するデータ。  
  
 コネクションレスのプロトコルを使用している場合はで、既定のリモート ホストを確立する必要はありません、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>します。 これを呼び出す場合にのみ必要があります、<xref:System.Net.Sockets.Socket.Send%2A>メソッド。 呼び出す場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendTo%2A>、`remoteEP`パラメーターは、操作のみを送信する指定された既定のリモート ホストに上書きされます。 必要はありませんを呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッドでは、基になるサービス プロバイダーが最も適切なローカル ネットワーク アドレスとポート番号を割り当てるためです。 使用することが割り当てられているローカル ネットワーク アドレスとポート番号を特定する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの後、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドが正常に完了します。  
  
 コネクションレスのプロトコルを対象としていますが<xref:System.Net.Sockets.Socket.SendTo%2A>でも接続指向プロトコルを使用できます。 呼び出してリモート ホスト接続を確立する必要がありますまず接続指向プロトコルを使用している場合、<xref:System.Net.Sockets.Socket.Connect%2A>メソッド、着信接続を使用して要求を受け入れるか、<xref:System.Net.Sockets.Socket.Accept%2A>メソッド。 確立したり、リモート ホスト接続を許可しない場合<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 呼び出しの前に、コネクションレスのプロトコルの既定のリモート ホストを確立することも、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。 このような場合は、のいずれかで<xref:System.Net.Sockets.Socket.SendTo%2A>は無視されます、`remoteEP`パラメーターとデータを送信する、接続または既定のリモート ホストのみです。  
  
 要求されたバイト数が送信されるまで、ブロッキング ソケットがブロックされます。 以降、非ブロッキング<xref:System.Net.Sockets.Socket>が完了しない送信すべて単一の操作で要求されたバイトの可能性がありますが、すぐにします。 送信されたバイト数を追跡して、アプリケーションが要求されたバイト数を送信するまで、操作を再試行する、アプリケーション役目です。 また、送信するデータがすぐに、ネットワーク上に表示される保証はありません。 ネットワークの効率を向上させるのに大量の発信データが収集されるまで、基になるシステムが送信を遅延する可能性があります。 正常に完了、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッドは、基になるシステムがネットワークのデータの送信バッファーする領域を持っていることを意味します。  
  
 ブロッキング モードは、コネクションレスのプロトコルを使用している場合<xref:System.Net.Sockets.Socket.SendTo%2A>データグラムが送信されるまでブロックされます。 最初に呼び出す必要がある場合は、ブロードキャスト アドレスにデータを送信する、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプションを<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>します。 サイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendTo%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では、指定されたリモート ホストにコネクションレスのデータグラムを送信します。 オフセット、サイズ、および<xref:System.Net.Sockets.SocketFlags>に渡される、<xref:System.Net.Sockets.Socket.SendTo%2A>メソッド。  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> は <see langword="null" />です。  
  
- または - 
 <paramref name="remoteEP" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> が 0 未満です。  
  
または 
 <paramref name="offset" /> が <paramref name="buffer" /> の長さを超えています。  
  
または 
 <paramref name="size" /> が 0 未満です。  
  
または 
 <paramref name="size" /> が、<paramref name="buffer" /> の長さから <paramref name="offset" /> パラメーターの値を引いた値を超えています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> は、値の有効な組み合わせではありません。  
  
または 
<see cref="T:System.Net.Sockets.Socket" /> にアクセス中にオペレーティング システム エラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Security.SecurityException">コール スタック内の呼び出し元が、必要なアクセス許可を保持していません。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e">この非同期ソケット操作に使用する <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクト。</param>
        <summary>特定のリモート ホストにデータを非同期的に送信します。</summary>
        <returns>I/O 操作が保留中の場合は <see langword="true" />。 操作の完了時に、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントが発生します。  
  
 I/O 操作が同期的に完了した場合は <see langword="false" />。 この場合、<paramref name="e" /> パラメーターの <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> イベントは発生しません。メソッド呼び出しから制御が戻った直後に、パラメーターとして渡された <paramref name="e" /> オブジェクトを調べて操作の結果を取得できます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドで指定されたリモート ホストへの非同期送信操作を開始、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>のプロパティ、`e`パラメーター。 呼び出す、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドを使用すると、個別の実行スレッド内でデータを送信できます。 コネクションレス プロトコルは、このメソッドが意図したものが<xref:System.Net.Sockets.Socket.SendToAsync%2A>コネクションレス型との接続指向の両方のプロトコルで動作します。  
  
 完了の通知、イベント ハンドラーを実装するコールバック メソッドを作成する必要があります\<SocketAsyncEventArgs > デリゲートおよびコールバックをアタッチ、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベント。  
  
 次のプロパティとイベントを<xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType>オブジェクトを正常にこのメソッドを呼び出す必要は。  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 呼び出し元の設定、<xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType>を呼び出す前に必要なすべてのユーザー状態オブジェクトのプロパティ、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッド情報をコールバック メソッドで取得できるようにします。 コールバックは、1 つのオブジェクトより多くの情報を必要とする場合は、メンバーとして他の必要な状態情報を保持する小さなクラスを作成できます。  
  
 最初に呼び出す必要がある接続指向プロトコルを使用している場合、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド。 それ以外の場合<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 接続指向プロトコルでは、使用する場合、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは無視されます、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティと送信のデータを<xref:System.Net.EndPoint?displayProperty=nameWithType>で確立されている、 <xref:System.Net.Sockets.Socket.Accept%2A>、 <xref:System.Net.Sockets.Socket.AcceptAsync%2A>、 <xref:System.Net.Sockets.Socket.BeginAccept%2A>、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッド。  
  
 コネクションレスのプロトコルを使用している場合はで、既定のリモート ホストを確立する必要はありません、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendToAsync%2A>します。 これを呼び出す場合にのみ必要があります、<xref:System.Net.Sockets.Socket.BeginSend%2A>または<xref:System.Net.Sockets.Socket.SendAsync%2A>メソッド。 呼び出す場合、 <xref:System.Net.Sockets.Socket.BeginConnect%2A>、 <xref:System.Net.Sockets.Socket.Connect%2A>、または<xref:System.Net.Sockets.Socket.ConnectAsync%2A>メソッドを呼び出す前に<xref:System.Net.Sockets.Socket.SendToAsync%2A>、<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>プロパティは、操作のみを送信する指定された既定のリモート ホストに上書きされます。 また必要はありませんを呼び出す、<xref:System.Net.Sockets.Socket.Bind%2A>メソッド。 この場合は、基になるサービス プロバイダーは、最も適切なローカル ネットワーク IP アドレスとポート番号を割り当てられます。 基になるサービス プロバイダーは、空いているポートを選択する場合は、0 のポート番号を使用します。 使用することが割り当てられているローカル ネットワークの IP アドレスとポート番号を識別する必要がある場合、<xref:System.Net.Sockets.Socket.LocalEndPoint%2A>プロパティの後、<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>イベントがシグナル状態し、関連付けられているデリゲートが呼び出されます。  
  
 最初に呼び出す必要がある場合は、ブロードキャスト アドレスにデータを送信する、<xref:System.Net.Sockets.Socket.SetSocketOption%2A>メソッドと set ソケット オプション<xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>を true にします。 バッファーのサイズが、基になるサービス プロバイダーの最大パケット サイズを超えていないことを確認するもあります。 場合は、データグラムが送信されず<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。  
  
 DontRoute フラグを指定する場合、<xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType>プロパティ、ルーティングされていないに送信するデータ。  
  
 メッセージ指向のソケットでは、基になるトランスポートのメッセージの最大サイズを超えないように注意する必要があります。 バッファーのサイズでは、基になるサービス プロバイダーの最大パケット サイズを超えている場合、データグラムが送信されず、<xref:System.Net.Sockets.Socket.SendToAsync%2A>がスローされます、<xref:System.Net.Sockets.SocketException>します。 正常に完了、<xref:System.Net.Sockets.Socket.SendToAsync%2A>メソッドは、データが正常に配信されたことを示していません。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> に null 値を指定することはできません。</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="e" /> パラメーターに指定された <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> オブジェクトを使用してソケット操作が既に進行していました。</exception>
        <exception cref="T:System.NotSupportedException">このメソッドには Windows XP 以降が必要です。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">指定されたプロトコルは接続指向ですが、<see cref="T:System.Net.Sockets.Socket" /> がまだ接続されていません。</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="level">このソケットに設定する IP 保護レベル。</param>
        <summary>ソケットの IP 保護レベルを設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドの使用を制限する、リンク ローカルまたはサイト ローカル プレフィックスを同じアドレスなど、特定のスコープをリッスンするように、IPv6、または IP ソケット。 このソケット オプションは、IPv6、または IP ソケットのアクセスを制限するアプリケーションを使用します。 この制限により、プライベート LAN で実行されるアプリケーションを外部からの攻撃に対して簡単かつ堅牢に強化できます。 このソケット オプションが場合は、アクセス制限を削除することもでき、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>します。 このソケット オプションで待機中のソケットのスコープを変更して、適切な場合はパブリック ユーザーおよびプライベート ユーザーからの無制限のアクセスを許可したり、必要に応じて同じサイトへのアクセスのみに制限したりできます。  
  
 このソケット オプションには、<xref:System.Net.Sockets.IPProtectionLevel> 列挙型で指定されている定義済みの保護レベルが設定されています。  
  
 <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A>メソッドを使用して有効または無効のように、ネットワーク アドレス トラバーサル (NAT) を<xref:System.Net.Sockets.Socket>インスタンス。 Teredo、6to4、または、ISATAP のトンネルを使用して、NAT トラバーサルを指定することがあります。  
  
 ときに、`level`にパラメーターが設定されている<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>、または<xref:System.Net.Sockets.IPProtectionLevel.Restricted>、NAT トラバーサルを明示的に無効になります、<xref:System.Net.Sockets.Socket>インスタンス。  
  
 ときに、`level`パラメーターに設定されて<xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>、NAT トラバーサルを許可することがありますこれを<xref:System.Net.Sockets.Socket>によっては、システム上の場所でのファイアウォール ルール。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="level" /> パラメーターとして <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> を使用することはできません。 IP 保護レベルを未指定に設定することはできません。</exception>
        <exception cref="T:System.NotSupportedException">ソケットの <see cref="T:System.Net.Sockets.AddressFamily" /> は、<see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> または <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> である必要があります。</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> オプションを設定します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue"><see cref="T:System.Boolean" /> として表されるオプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した <see cref="T:System.Boolean" /> 値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>します。 設定`optionValue`に`true`オプションを有効にまたは`false`オプションを無効にします。  
  
 <xref:System.Net.Sockets.Socket> オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次の一覧は、さまざまな<xref:System.Net.Sockets.Socket>オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化<xref:System.Net.Sockets.SocketOptionLevel>値。 これらのオプションを設定する場合は、必ず使用して、適切な<xref:System.Net.Sockets.SocketOptionLevel>値、`optionLevel`パラメーター。 設定するオプションを指定する必要があります、`optionName`パラメーター。 オプションの一覧のいずれかの現在の値を取得するを使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッド。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 これらのオプションの詳細についてを参照してください、<xref:System.Net.Sockets.SocketOptionName>列挙体。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>例外を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
   
  
## Examples  
 次のコード例が、ソケットを開き、により、 `DontLinger` 、`OutOfBandInline`ソケット オプション。  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> オブジェクトは閉じられています。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">オプションの値を表す <see cref="T:System.Byte" /> 型の配列。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はバイト配列で表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>します。 このオーバー ロードを使用して、それらを設定する<xref:System.Net.Sockets.Socket>オプションの値としてバイト配列を必要とするオプション。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">オプションの値。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した整数値に設定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>します。 オプションについては、<xref:System.Boolean>オプションを有効に 0 以外の値とオプションを無効にゼロ値を指定、データ型します。 整数データ型のオプションについては、適切な値を指定します。 <xref:System.Net.Sockets.Socket> オプションは、プロトコルのサポートのレベルでグループ化されます。  
  
 次の一覧は、さまざまな<xref:System.Net.Sockets.Socket>オプションをこのオーバー ロードを使用して設定できます。 これらのオプションが適切にグループ化<xref:System.Net.Sockets.SocketOptionLevel>します。 これらのオプションを設定する場合は、必ず使用して、適切な<xref:System.Net.Sockets.SocketOptionLevel>の`optionLevel`パラメーター。 設定するオプションを指定する必要があります、`optionName`パラメーター。 オプションの一覧のいずれかの現在の値を取得するを使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッド。  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> このオーバー ロードを使用して設定できるオプションです。  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 これらのオプションの詳細についてを参照してください、<xref:System.Net.Sockets.SocketOptionName>列挙体。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><see cref="T:System.Net.Sockets.SocketOptionLevel" /> 値のいずれか。</param>
        <param name="optionName"><see cref="T:System.Net.Sockets.SocketOptionName" /> 値のいずれか。</param>
        <param name="optionValue">オプションの値を格納する <see cref="T:System.Net.Sockets.LingerOption" /> または <see cref="T:System.Net.Sockets.MulticastOption" />。</param>
        <summary>指定した <see cref="T:System.Net.Sockets.Socket" /> オプションを、指定した値に設定します。この値はオブジェクトで表されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> オプションは、現在の動作を決定<xref:System.Net.Sockets.Socket>します。 このオーバー ロードを使用して、設定、 <xref:System.Net.Sockets.SocketOptionName.Linger>、 <xref:System.Net.Sockets.SocketOptionName.AddMembership>、および<xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket>オプション。 <xref:System.Net.Sockets.SocketOptionName.Linger>オプションを使用して<xref:System.Net.Sockets.Socket>の`optionLevel`パラメーター。 <xref:System.Net.Sockets.SocketOptionName.AddMembership>と<xref:System.Net.Sockets.SocketOptionName.DropMembership>を使用して、<xref:System.Net.Sockets.SocketOptionLevel.IP>します。 上記のオプションのいずれかの現在の値を取得するを使用する場合、<xref:System.Net.Sockets.Socket.GetSocketOption%2A>メソッド。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
   
  
## Examples  
 次のコード例のセット、<xref:System.Net.Sockets.LingerOption>と<xref:System.Net.Sockets.Socket.Send%2A>タイムアウト値。  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> は <see langword="null" />です。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">許可されなくなる操作を指定する <see cref="T:System.Net.Sockets.SocketShutdown" /> 値の 1 つ。</param>
        <summary><see cref="T:System.Net.Sockets.Socket" /> での送受信を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 接続指向を使用する場合<xref:System.Net.Sockets.Socket>、常に呼び出し、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドを終了する前に、<xref:System.Net.Sockets.Socket>します。 これにより、すべてのデータが送信されており、それを閉じる前に、接続のソケットで受信したこと。  
  
 呼び出す、<xref:System.Net.Sockets.Socket.Close%2A>マネージし、アンマネージに関連付けられているリソースのすべてを解放するメソッド、<xref:System.Net.Sockets.Socket>します。 再利用しないで、<xref:System.Net.Sockets.Socket>終了後にします。  
  
 次の表は、<xref:System.Net.Sockets.SocketShutdown>に対して有効な列挙値、`how`パラメーター。  
  
|[値]|説明|  
|-----------|-----------------|  
|送信|これで送信を無効に<xref:System.Net.Sockets.Socket>します。|  
|Receive|これで受信を無効にする<xref:System.Net.Sockets.Socket>します。|  
|両方|この受信と送信を無効にする<xref:System.Net.Sockets.Socket>します。|  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Send>後続のことを指定します呼び出し<xref:System.Net.Sockets.Socket.Send%2A>は許可されていません。 コネクションレス型を使用している場合<xref:System.Net.Sockets.Socket>を指定して<xref:System.Net.Sockets.SocketShutdown.Send>効果はありません。  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Receive>後続のことを指定します呼び出し<xref:System.Net.Sockets.Socket.Receive%2A>は許可されていません。 下位のプロトコル層への影響はありません。 接続指向プロトコルを使用している呼び出しの後に、次の条件のいずれかが存在する場合、接続が終了<xref:System.Net.Sockets.Socket.Shutdown%2A>:  
  
-   データは受信を待機しているネットワークの着信バッファーです。  
  
-   多くのデータが到着しました。  
  
 コネクションレスのプロトコルを使用している場合データグラムが受け入れられるし、キューに登録します。 ただし、追加の受信データグラムの使用可能なバッファー領域がない場合は破棄され、送信者にエラーが返されません。 使用して<xref:System.Net.Sockets.Socket.Shutdown%2A>、コネクションレスで<xref:System.Net.Sockets.Socket>はお勧めしません。  
  
 設定`how`に<xref:System.Net.Sockets.SocketShutdown.Both>両方の送信を無効にし、前述のように受信します。  
  
> [!NOTE]
>  表示された場合、<xref:System.Net.Sockets.SocketException>を呼び出すときに、<xref:System.Net.Sockets.Socket.Shutdown%2A>メソッドを使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
> [!NOTE]
>  このメンバーは、アプリケーションでネットワーク トレースが有効にされている場合にトレース情報を出力します。 詳細については、次を参照してください。[ネットワークのトレースを .NET Framework で](~/docs/framework/network-programming/network-tracing.md)します。  
  
   
  
## Examples  
 次のコード例では<xref:System.Net.Sockets.Socket.Shutdown%2A>を無効にする、<xref:System.Net.Sockets.Socket>します。  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> の型を取得します。</summary>
        <value><see cref="T:System.Net.Sockets.SocketType" /> 値のいずれか。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> 読み取り専用であり、ときに設定されます、<xref:System.Net.Sockets.Socket>が作成されます。  
  
   
  
## Examples  
 次のコード例が表示されます、 <xref:System.Net.Sockets.AddressFamily>、 <xref:System.Net.Sockets.SocketType>、および<xref:System.Net.Sockets.ProtocolType>コンソールにします。  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在のホストで IPv4 サポートが使用可能で有効になっているかどうかを示す値を取得します。</summary>
        <value>現在のホストが IPv4 プロトコルをサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メンバー向けに、フレームワークが IPv6 をサポートしているかどうかを示す値を取得します。</summary>
        <value>互換性のために残されている特定の <see cref="T:System.Net.Dns" /> メソッド向けに、フレームワークが IPv6 をサポートしている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 オペレーティング システムでは、IPv4 と IPv6 の両方のプロトコルをサポート可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> によって使用されているすべてのリソースを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
完了したら IDisposable.Dispose の呼び出しを使用して、<xref:System.Net.Sockets.Socket>します。 IDisposable.Dispose メソッドのまま、<xref:System.Net.Sockets.Socket>を使用できない状態です。 IDisposable.Dispose を呼び出して後ですべての参照を解放する必要があります、<xref:System.Net.Sockets.Socket>ガベージ コレクターがメモリをクリアできるようにする、<xref:System.Net.Sockets.Socket>によって占有されていた。 詳細については、[アンマネージ リソースのクリーンアップ](~/docs/standard/garbage-collection/unmanaged.md)および[Dispose メソッドの実装](~/docs/standard/garbage-collection/implementing-dispose.md)を参照してください。

> [!NOTE] 
> 最後の参照を解放する前に常に IDisposable.Dispose を呼び出して、<xref:System.Net.Sockets.Socket>します。 そうしないと、ガベージ コレクターが <xref:System.Net.Sockets.Socket> オブジェクトの `Finalize` メソッドを呼び出すまで、使用されているリソースは解放されません。

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Net.Sockets.Socket" /> によって送信されたインターネット プロトコル (IP) パケットの有効期間 (TTL) の値を指定する値を取得または設定します。</summary>
        <value>TTL の値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 TTL の値がルーターはパケットとインターネット制御メッセージ プロトコル (ICMP) の"TTL を超えています"を破棄する前に、パケットが走査できるルーターの最大数を示すエラー メッセージが送信者に返されます。  
  
 TTL 値は、0 ~ 255 の値に設定可能性があります。 このプロパティが設定されていないときに、ソケットの既定の TTL 値は 32 です。  
  
 伝送制御プロトコル (TCP) のソケットでこのプロパティの設定は、TCP/IP スタックで、このソケットを使用して成功した接続が確立されている場合無視されます。  
  
 表示された場合、<xref:System.Net.Sockets.SocketException>を使用して、<xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>特定のエラー コードを取得するプロパティ。 このコードを取得した後を参照してください、 [Windows Sockets version 2 API エラー コード](/windows/desktop/winsock/windows-sockets-error-codes-2)エラーの詳細な説明のドキュメント。  
  
   
  
## Examples  
 次のコード例は、の使用を示します、<xref:System.Net.Sockets.Socket.Ttl%2A>プロパティ。  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">TTL 値には、負の数を設定できません。</exception>
        <exception cref="T:System.NotSupportedException">このプロパティは、<see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ファミリまたは <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ファミリのソケットに対してだけ設定できます。</exception>
        <exception cref="T:System.Net.Sockets.SocketException">ソケットへのアクセスを試行しているときにエラーが発生しました。 このエラーは、TTL に 255 より大きい値を設定しようとしたときにも返されます。</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> が閉じられました。</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ソケットが重複 I/O モードだけを使用する必要があるかどうかを指定します。</summary>
        <value><see cref="T:System.Net.Sockets.Socket" /> が重複 I/O モードだけを使用する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定`true`の<xref:System.Net.Sockets.Socket>を呼び出そうと<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>します。 それ以外の場合、フレームワークは、ソケットは、の使用を禁止するように、完了ポートを割り当てることが<xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">ソケットが完了ポートにバインドされています。</exception>
      </Docs>
    </Member>
  </Members>
</Type>