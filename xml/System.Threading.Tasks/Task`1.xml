<Type Name="Task&lt;TResult&gt;" FullName="System.Threading.Tasks.Task&lt;TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="38256aa18ea134bbbe29946e5fa0caea3a78a3d4" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52243954" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Task&lt;TResult&gt; : System.Threading.Tasks.Task" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Task`1&lt;TResult&gt; extends System.Threading.Tasks.Task" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Task`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Task(Of TResult)&#xA;Inherits Task" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename TResult&gt;&#xA;public ref class Task : System::Threading::Tasks::Task" />
  <TypeSignature Language="F#" Value="type Task&lt;'Result&gt; = class&#xA;    inherit Task" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TResult" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Threading.Tasks.Task</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="TResult">この <see cref="T:System.Threading.Tasks.Task`1" /> によって生成される結果の型。</typeparam>
    <summary>値を返すことができる非同期操作を表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.Tasks.Task%601>クラスの値を返すが、通常は単一の操作が非同期的に実行を表します。 <xref:System.Threading.Tasks.Task%601> オブジェクトは、中央のコンポーネントの 1 つ、[タスクベースの非同期パターン](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).NET Framework 4 で初めて導入されました。 によって、作業が実行されるため、<xref:System.Threading.Tasks.Task%601>オブジェクト通常は非同期的に実行スレッド プールのスレッドで同期的に、メイン アプリケーション スレッドで使用できますではなく、<xref:System.Threading.Tasks.Task.Status%2A>プロパティだけでなく<xref:System.Threading.Tasks.Task.IsCanceled%2A>、<xref:System.Threading.Tasks.Task.IsCompleted%2A>と<xref:System.Threading.Tasks.Task.IsFaulted%2A>プロパティ、タスクの状態を判断します。 ほとんどの場合、ラムダ式は、タスクを実行する作業の指定に使用されます。  
  
 <xref:System.Threading.Tasks.Task%601> インスタンスは、さまざまな方法で作成できます。 以降で使用できますが、最も一般的なアプローチ、[!INCLUDE[net_v45](~/includes/net-v45-md.md)]は、静的な<xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType>または<xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>メソッド。 これらのメソッドは、既定値を使用して、追加のパラメーターを取得しなくてもタスクを開始する簡単な方法を提供します。 次の例では、<xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType>メソッドをループし、ループのイテレーションの数を表示するタスクを開始します。  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/run1.cs#6)]
 [!code-vb[System.Threading.Tasks.Task\`1#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/run1.vb#6)]  
  
 代わりに、およびタスクを開始する最も一般的な方法、[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]は、静的な<xref:System.Threading.Tasks.TaskFactory.StartNew%2A?displayProperty=nameWithType>または<xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType>メソッド。 <xref:System.Threading.Tasks.Task.Factory%2A?displayProperty=nameWithType>プロパティから返さ、<xref:System.Threading.Tasks.TaskFactory>オブジェクト、および<xref:System.Threading.Tasks.Task%601.Factory%2A?displayProperty=nameWithType>プロパティが返す、<xref:System.Threading.Tasks.TaskFactory%601>オブジェクト。 オーバー ロードの`StartNew`メソッドを使用すると、引数を渡す、タスクの作成オプションを定義およびタスク スケジューラを指定します。 次の例では、<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType>タスクを開始するメソッド。 このメソッドは、前の例のコードには  
  
 [!code-csharp[System.Threading.Tasks.Task\`1#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1/cs/startnew1.cs#7)]
 [!code-vb[System.Threading.Tasks.Task\`1#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1/vb/startnew1.vb#7)]  
  
 詳細な例については、次を参照してください。[タスクベースの非同期プログラミング](~/docs/standard/parallel-programming/task-based-asynchronous-programming.md)します。  
  
 <xref:System.Threading.Tasks.Task%601>クラスには、タスクを初期化するが、実行のスケジュールをそのしないコンス トラクターも用意されています。 パフォーマンス向上のため、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>と`Task.Factory.StartNew`メソッドは、推奨されるメカニズムの作成と計算のタスクをスケジュールが、タスクの作成とスケジュールを区切る必要がありますシナリオでは、コンス トラクターを使用する可能性があります、およびタスクの<xref:System.Threading.Tasks.Task.Start%2A>は後で実行するためのタスクをスケジュールするメソッドを使用し、可能性があります。  
  
 対象に、デスクトップ アプリ以降、[!INCLUDE[net_v46](~/includes/net-v46-md.md)]を作成し、タスクを呼び出すスレッドのカルチャがスレッドのコンテキストの一部になります。 つまり、タスクが実行されるスレッドの現在のカルチャに関係なく、タスクの現在のカルチャは、呼び出し元スレッドのカルチャです。 前のバージョンの .NET Framework のバージョンを対象とするアプリを[!INCLUDE[net_v46](~/includes/net-v46-md.md)]タスクのカルチャは、タスクが実行されるスレッドのカルチャ。 詳細については、の「カルチャとタスク ベースの非同期操作」セクションを参照してください、<xref:System.Globalization.CultureInfo>トピック。 ストア アプリが設定および既定のカルチャを取得するで、Windows ランタイムに従うことに注意してください。  
  
使用する値を返さない操作で、<xref:System.Threading.Tasks.Task>クラス。 参照型ではなく、値型であるより軽量タスクの c# 7 で開発している場合は、使用、<xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType>構造体。 c# 7 以降ではサポートされています。 
  
 ]]></format>
    </remarks>
    <threadsafe>すべてのメンバー<see cref="T:System.Threading.Tasks.Task`1" />を除く<see cref="M:System.Threading.Tasks.Task.Dispose" />スレッド セーフなは、複数のスレッドから同時に使用できます。</threadsafe>
    <altmember cref="T:System.Threading.Tasks.Task" />
    <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
    <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364">.NET Framework による並列プログラミングのサンプル</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>新しい <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; function" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <summary>指定の関数で新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%29?displayProperty=nameWithType>と<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
   
  
## Examples  
 次の例では、パブリッシュされたブックを表すテキスト ファイル内の単語のおおよその数をカウントします。 各タスクは、ファイルを開いて、内容全体を非同期的に読み取り、および正規表現を使用してワード カウントを計算する責任を負います。 <xref:System.Threading.Tasks.Task.WaitAll%28System.Threading.Tasks.Task%5B%5D%29?displayProperty=nameWithType>メソッドが呼び出され、各書籍のワード カウントをコンソールに表示する前にすべてのタスクが完了したことを確認します。  
  
 オブジェクトのインスタンス化は、例では、各ファイルがあることを確認できるように、この例では、オブジェクトの実行から区切られます。 一致しない場合は、不足しているファイルの名前が表示されます。 それ以外の場合、呼び出し、<xref:System.Threading.Tasks.Task.Start%2A?displayProperty=nameWithType>メソッドを各タスクを起動します。  
  
 [!code-csharp[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/cs/run3.cs#2)]
 [!code-vb[System.Threading.Tasks.Task.ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.ctor/vb/run3.vb#2)]  
  
 正規表現パターン`\p{P}*\s+`0、1、または複数の区切り文字の後ろに 1 つまたは複数の空白文字と一致します。 一致の合計数が、おおよそのワード カウントと等しいことが前提としています。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="state">アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>指定の関数と状態で新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="cancellationToken">このタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定の関数で新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.Task.Run%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>と<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of TResult), creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定の関数と作成オプションを使用して新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7B%600%7D%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="state">関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (function As Func(Of Object, TResult), state As Object, creationOptions As TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="state">関数によって使用されるデータを表すオブジェクト。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.Tasks.TaskCreationOptions%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;TResult&gt; function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!TResult&gt; function, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{`0},System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;TResult&gt; ^ function, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;'Result&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;TResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定の関数と作成オプションを使用して新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory.StartNew%60%601%28System.Func%7B%60%600%7D%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>メソッド。  このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Task (Func&lt;object,TResult&gt; function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`2&lt;object, !TResult&gt; function, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskCreationOptions creationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.#ctor(System.Func{System.Object,`0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskCreationOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Task(Func&lt;System::Object ^, TResult&gt; ^ function, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskCreationOptions creationOptions);" />
      <MemberSignature Language="F#" Value="new System.Threading.Tasks.Task&lt;'Result&gt; : Func&lt;obj, 'Result&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskCreationOptions -&gt; System.Threading.Tasks.Task&lt;'Result&gt;" Usage="new System.Threading.Tasks.Task&lt;'Result&gt; (function, state, cancellationToken, creationOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="function" Type="System.Func&lt;System.Object,TResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="creationOptions" Type="System.Threading.Tasks.TaskCreationOptions" />
      </Parameters>
      <Docs>
        <param name="function">タスクで実行するコードを表すデリゲート。 関数の実行が完了すると、タスクの <see cref="P:System.Threading.Tasks.Task`1.Result" /> プロパティが関数の結果値を返すように設定されます。</param>
        <param name="state">関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="creationOptions">タスクの動作のカスタマイズに使用する <see cref="T:System.Threading.Tasks.TaskCreationOptions" />。</param>
        <summary>指定したアクション、状態、およびオプションで新しい <see cref="T:System.Threading.Tasks.Task`1" /> を初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 インスタンスを作成する最も一般的な方法、このコンス トラクターを呼び出すのではなく、<xref:System.Threading.Tasks.Task%601>オブジェクトとタスクは、静的なを呼び出すことによって、起動<xref:System.Threading.Tasks.TaskFactory%601.StartNew%28System.Func%7BSystem.Object%2C%600%7D%2CSystem.Object%2CSystem.Threading.CancellationToken%2CSystem.Threading.Tasks.TaskCreationOptions%2CSystem.Threading.Tasks.TaskScheduler%29?displayProperty=nameWithType>メソッド。 このコンス トラクターによって提供される唯一の利点は、タスクの呼び出しから分離するオブジェクトのインスタンス化できることです。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskCreationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="function" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName="ConfigureAwait">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait (bool continueOnCapturedContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1&lt;!TResult&gt; ConfigureAwait(bool continueOnCapturedContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ConfigureAwait(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConfigureAwait (continueOnCapturedContext As Boolean) As ConfiguredTaskAwaitable(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::ConfiguredTaskAwaitable&lt;TResult&gt; ConfigureAwait(bool continueOnCapturedContext);" />
      <MemberSignature Language="F#" Value="override this.ConfigureAwait : bool -&gt; System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;'Result&gt;" Usage="task.ConfigureAwait continueOnCapturedContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.ConfiguredTaskAwaitable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continueOnCapturedContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="continueOnCapturedContext">継続をキャプチャされた元のコンテキストにマーシャリングする場合は true。それ以外の場合は false。</param>
        <summary>この <see cref="T:System.Threading.Tasks.Task`1" /> を待機するために使用する awaiter を構成します。</summary>
        <returns>このタスクを待機するために使用するオブジェクト。</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ContinueWith">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>別のタスクが完了したときに実行される継続タスクを作成します。</summary>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult))) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith continuationAction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="continuationAction">先行する <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>対象タスクの完了時に、非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早期終了により完了するかどうか。  
  
   
  
## Examples  
 次の例では、Sieve of Eratosthenes を使用して、1 と、ユーザーが入力した値の間の素数を計算する継続元タスクを作成します。 配列は、素数に関する情報を保持するために使用されます。 配列のインデックスが、数を表し、要素の値は、その数が複合かどうかを示します (その値は`true`) 素数か (その値は`false`)。 このタスクは、整数の配列の素数を抽出し、表示することを担当する継続タスクに渡されます。  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue2.cs#2)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトが引数としてデリゲートに渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <summary>状態の情報を渡される継続と、ターゲット <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続を作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
   
  
## Examples  
 次の例では、2 ~ 20 の間の整数が渡されますし、最初の 10 個の指数部を格納する配列を返すタスクを作成します (n から<sup>1</sup> n<sup>10</sup>) 数。 継続タスクは、指数部を表示する責任を負います。 これには、継続元と元の番号、継続元が生成されますが指数部の両方が渡されます。  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continuewith3.cs#3)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continuewith3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクにデリゲートが引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに渡されるキャンセル トークン。</param>
        <summary>対象の <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に、非同期的に実行するキャンセル可能な継続タスクを作成します。</summary>
        <returns>新しい継続タスク。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
   
  
## Examples  
 次の例では、Sieve of Eratosthenes を使用して、1 と、ユーザーが入力した値の間の素数を計算する継続元タスクを作成します。 配列は、素数に関する情報を保持するために使用されます。 配列のインデックスが、数を表し、要素の値は、その数が複合かどうかを示します (その値は`true`) 素数か (その値は`false`)。 このタスクは、整数の配列の素数を抽出し、表示することを担当する継続タスクに渡されます。  
  
 キャンセル トークンは、継続元と継続タスクの両方に渡されます。 A<xref:System.Timers.Timer?displayProperty=nameWithType>オブジェクトは、100 ミリ秒のタイムアウト値を定義するために使用します。 イベントが発生する場合、<xref:System.Threading.CancellationTokenSource.Cancel%2A?displayProperty=nameWithType>メソッドが呼び出され、キャンセル トークンは、タスクのキャンセルを要求するために使用します。  
  
 [!code-csharp[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/cs/continue1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task\`1.ContinueWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task`1.continuewith/vb/continue1.vb#1)]  
  
 タイムアウト間隔が経過すると、約 100,000 の値を提供する通常、および<xref:System.Timers.Timer.Elapsed?displayProperty=nameWithType>イベントを発生させる、および設定する、取り消し要求。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。  
  
- または - 
<paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が <see langword="null" /> です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <paramref name="continuationOptions" /> で指定した条件に従って実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>
          <paramref name="continuationOptions" /> で指定した条件に従って実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>現在のタスクが完了するまで実行のスケジュールされません。 を通じて、継続条件が指定されている場合、`continuationOptions`パラメーターが満たされていない、継続タスクは取り消されますの代わりにスケジュールします。  
  
 詳細については、「[継続タスクを使用したタスクの連結](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult)), scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, continuationOptions As TaskContinuationOptions) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>現在のタスクが完了するまで実行のスケジュールされません。 を通じて、継続条件が指定されている場合、`continuationOptions`パラメーターが満たされていない、継続タスクは取り消されますの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith (continuationAction As Action(Of Task(Of TResult), Object), state As Object, scheduler As TaskScheduler) As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が <see langword="null" /> です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt; continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`1&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;&gt; continuationAction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0}},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^&gt; ^ continuationAction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <paramref name="continuationOptions" /> で指定した条件に従って実行するアクション。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>
          <paramref name="continuationOptions" /> で指定した条件に従って実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>現在のタスクが完了するまで実行のスケジュールされません。 使用条件が指定されている場合、`continuationOptions`パラメーターが満たされていない、継続タスクは取り消されますの代わりにスケジュールします。 詳細については、「[継続タスクを使用したタスクの連結](~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。  
  
- または - 
<paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationAction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task ContinueWith (Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object&gt; continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task ContinueWith(class System.Action`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object&gt; continuationAction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith(System.Action{System.Threading.Tasks.Task{`0},System.Object},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ ContinueWith(Action&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^&gt; ^ continuationAction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Action&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task" Usage="task.ContinueWith (continuationAction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="continuationAction" Type="System.Action&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <param name="continuationAction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行するアクション。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続アクションによって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しい継続タスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task>現在のタスクが完了するまで実行のスケジュールされません。 使用条件が指定されている場合、`continuationOptions`パラメーターが満たされていない、継続タスクは取り消されますの代わりにスケジュールします。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0})" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult)) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith continuationFunction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
   
  
## Examples  
 次の例では、継続タスクのチェーンを作成します。 各タスクは、現在の時刻、<xref:System.DateTime>の状態の引数のオブジェクト、<xref:System.Threading.Tasks.Task.ContinueWith%28System.Action%7BSystem.Threading.Tasks.Task%2CSystem.Object%7D%2CSystem.Object%29>メソッド。 各<xref:System.DateTime>値は、継続タスクが作成された時刻を表します。 各タスクが 1 秒間には、その結果として生成<xref:System.DateTime>タスクが終了する時間を表す値です。 すべてのタスクが完了すると、例では、各継続タスクを開始および終了する日付と時刻を表示します。  
  
 [!code-csharp[TPL_ContinuationState#1](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_continuationstate/cs/continuationstate.cs#1)]
 [!code-vb[TPL_ContinuationState#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_continuationstate/vb/continuationstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。  
  
- または - 
<paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <paramref name="continuationOptions" /> で指定した条件に従って実行する関数。  
  
実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>
          <paramref name="continuationOptions" /> で指定した条件に従って実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 `continuationFunction`を実行すると、返す必要があります、 <xref:System.Threading.Tasks.Task%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), TNewResult), scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに非同期に実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
        <altmember cref="T:System.Threading.Tasks.TaskScheduler" />
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskContinuationOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, continuationOptions As TaskContinuationOptions) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskContinuationOptions continuationOptions);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskContinuationOptions -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, continuationOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 `continuationFunction`を実行すると、返す必要があります、<xref:System.Threading.Tasks.Task%601>します。 このタスクの完了の状態は、ContinueWith の呼び出しから返されるタスクに転送されます。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="VB.NET" Value="Public Function ContinueWith(Of TNewResult) (continuationFunction As Func(Of Task(Of TResult), Object, TNewResult), state As Object, scheduler As TaskScheduler) As Task(Of TNewResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が null です。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt; continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`2&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, !!TNewResult&gt; continuationFunction, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},``0},System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, TNewResult&gt; ^ continuationFunction, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, 'NewResult&gt; * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,TNewResult&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <paramref name="continuationOptions" /> で指定した条件に従って実行する関数。  
  
実行すると、この完了したタスクがデリゲートの引数として渡されます。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>
          <paramref name="continuationOptions" /> で指定した条件に従って実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 `continuationFunction`を実行すると、返す必要があります、<xref:System.Threading.Tasks.Task%601>します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="T:System.Threading.Tasks.Task`1" /> は破棄されています。  
  
- または - 
<paramref name="cancellationToken" /> を作成した <see cref="T:System.Threading.CancellationTokenSource" /> は既に破棄されています。</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="continuationFunction" /> 引数が null です。  
  
- または - 
<paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="ContinueWith&lt;TNewResult&gt;">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;TNewResult&gt; ContinueWith&lt;TNewResult&gt; (Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,object,TNewResult&gt; continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;!!TNewResult&gt; ContinueWith&lt;TNewResult&gt;(class System.Func`3&lt;class System.Threading.Tasks.Task`1&lt;!TResult&gt;, object, !!TNewResult&gt; continuationFunction, object state, valuetype System.Threading.CancellationToken cancellationToken, valuetype System.Threading.Tasks.TaskContinuationOptions continuationOptions, class System.Threading.Tasks.TaskScheduler scheduler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.ContinueWith``1(System.Func{System.Threading.Tasks.Task{`0},System.Object,``0},System.Object,System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TNewResult&gt;&#xA; System::Threading::Tasks::Task&lt;TNewResult&gt; ^ ContinueWith(Func&lt;System::Threading::Tasks::Task&lt;TResult&gt; ^, System::Object ^, TNewResult&gt; ^ continuationFunction, System::Object ^ state, System::Threading::CancellationToken cancellationToken, System::Threading::Tasks::TaskContinuationOptions continuationOptions, System::Threading::Tasks::TaskScheduler ^ scheduler);" />
      <MemberSignature Language="F#" Value="override this.ContinueWith : Func&lt;System.Threading.Tasks.Task&lt;'Result&gt;, obj, 'NewResult&gt; * obj * System.Threading.CancellationToken * System.Threading.Tasks.TaskContinuationOptions * System.Threading.Tasks.TaskScheduler -&gt; System.Threading.Tasks.Task&lt;'NewResult&gt;" Usage="task.ContinueWith (continuationFunction, state, cancellationToken, continuationOptions, scheduler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;TNewResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TNewResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="continuationFunction" Type="System.Func&lt;System.Threading.Tasks.Task&lt;TResult&gt;,System.Object,TNewResult&gt;" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
        <Parameter Name="continuationOptions" Type="System.Threading.Tasks.TaskContinuationOptions" />
        <Parameter Name="scheduler" Type="System.Threading.Tasks.TaskScheduler" />
      </Parameters>
      <Docs>
        <typeparam name="TNewResult">継続タスクによって生成される結果の型。</typeparam>
        <param name="continuationFunction">
          <see cref="T:System.Threading.Tasks.Task`1" /> の完了時に実行する関数。 実行すると、完了したタスクおよび呼び出し元が指定する状態オブジェクトがデリゲートの引数として渡されます。</param>
        <param name="state">継続関数によって使用されるデータを表すオブジェクト。</param>
        <param name="cancellationToken">新しいタスクに割り当てられる <see cref="T:System.Threading.CancellationToken" />。</param>
        <param name="continuationOptions">継続タスクのスケジュールおよびその動作を設定するオプション。 これには、<see cref="F:System.Threading.Tasks.TaskContinuationOptions.OnlyOnCanceled" /> などの基準および <see cref="F:System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously" /> などの実行オプションが含まれます。</param>
        <param name="scheduler">継続タスクに関連付け、それを実行するために使用する <see cref="T:System.Threading.Tasks.TaskScheduler" />。</param>
        <summary>ターゲットの <see cref="T:System.Threading.Tasks.Task`1" /> が完了したときに実行する継続タスクを作成します。</summary>
        <returns>新しい継続 <see cref="T:System.Threading.Tasks.Task`1" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 返された<xref:System.Threading.Tasks.Task%601>はスケジュールされません実行の現在のタスクが完了するまで正常に完了するまで実行されて、ハンドルされない例外、エラー、または取り消されることによって早い段階を終了によって完了するかどうか。  
  
 `continuationFunction`を実行すると、返す必要があります、<xref:System.Threading.Tasks.Task%601>します。 このタスクの完了状態から返されるタスクに転送されます、<xref:System.Threading.Tasks.Task%601.ContinueWith%2A?displayProperty=nameWithType>呼び出します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="scheduler" /> 引数が null です。</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="continuationOptions" /> 引数が、<see cref="T:System.Threading.Tasks.TaskContinuationOptions" /> の無効な値を指定しています。</exception>
        <exception cref="T:System.ObjectDisposedException">指定された <see cref="T:System.Threading.CancellationToken" /> は既に破棄されています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks.md">継続タスクを使用したタスクの連結</related>
      </Docs>
    </Member>
    <Member MemberName="Factory">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskFactory&lt;TResult&gt; Factory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskFactory`1&lt;!TResult&gt; Factory" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Factory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Factory As TaskFactory(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ Factory { System::Threading::Tasks::TaskFactory&lt;TResult&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Factory : System.Threading.Tasks.TaskFactory&lt;'Result&gt;" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Factory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskFactory&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Threading.Tasks.Task`1" /> インスタンスを作成して構成するためのファクトリ メソッドへアクセスを提供します。</summary>
        <value>さまざまな <see cref="T:System.Threading.Tasks.Task`1" /> オブジェクトを作成できるファクトリ オブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの既定のインスタンスを返します、<xref:System.Threading.Tasks.TaskFactory%601>パラメーターなしで呼び出すことによって作成されたものと同じであるクラス<xref:System.Threading.Tasks.TaskFactory%601.%23ctor?displayProperty=nameWithType>コンス トラクター。 次のプロパティ値があります。  
  
|プロパティ|[値]|  
|--------------|-----------|  
|<xref:System.Threading.Tasks.TaskFactory%601.CancellationToken%2A?displayProperty=nameWithType>|<xref:System.Threading.CancellationToken.None%2A?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.ContinuationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskContinuationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.CreationOptions%2A?displayProperty=nameWithType>|<xref:System.Threading.Tasks.TaskCreationOptions.None?displayProperty=nameWithType>|  
|<xref:System.Threading.Tasks.TaskFactory%601.Scheduler%2A?displayProperty=nameWithType>|`null`、または <xref:System.Threading.Tasks.TaskScheduler.Current%2A?displayProperty=nameWithType>|  
  
 このプロパティの最も一般的な使用が作成して 1 回の呼び出しで新しいタスクを開始するには、<xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType>メソッド。  
  
> [!NOTE]
>  以降では、 [!INCLUDE[net_v45](~/includes/net-v45-md.md)]、<xref:System.Threading.Tasks.Task.Run%2A?displayProperty=nameWithType>メソッドを作成する最も簡単な方法を提供する、<xref:System.Threading.Tasks.Task%601>既定の構成値を持つオブジェクト。  
  
 次のコードの例では、静的な<xref:System.Threading.Tasks.Task%601.Factory%2A>プロパティを次の 3 つの呼び出しを行う、<xref:System.Threading.Tasks.TaskFactory%601.StartNew%2A?displayProperty=nameWithType>メソッド。 初めての起動、`Task<Int32>`オブジェクトで、1 を返すラムダ式を実行します。 2 つ目の開始、`Task<Test>`オブジェクトで、新しいをインスタンス化するラムダ式を実行`Test`インスタンス。 3 番目の開始を ' タスク < 文字列]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
      </Docs>
    </Member>
    <Member MemberName="GetAwaiter">
      <MemberSignature Language="C#" Value="public System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt; GetAwaiter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.CompilerServices.TaskAwaiter`1&lt;!TResult&gt; GetAwaiter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Task`1.GetAwaiter" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAwaiter () As TaskAwaiter(Of TResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::CompilerServices::TaskAwaiter&lt;TResult&gt; GetAwaiter();" />
      <MemberSignature Language="F#" Value="override this.GetAwaiter : unit -&gt; System.Runtime.CompilerServices.TaskAwaiter&lt;'Result&gt;" Usage="task.GetAwaiter " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.CompilerServices.TaskAwaiter&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task`1" /> を待機するために使用する awaiter を取得します。</summary>
        <returns>awaiter のインスタンス。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コード内で直接使用ではなく、コンパイラのユーザーのものです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Result">
      <MemberSignature Language="C#" Value="public TResult Result { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !TResult Result" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Task`1.Result" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Result As TResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TResult Result { TResult get(); };" />
      <MemberSignature Language="F#" Value="member this.Result : 'Result" Usage="System.Threading.Tasks.Task&lt;'Result&gt;.Result" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Threading.Tasks.Task`1" /> の結果値を取得します。</summary>
        <value>結果値<see cref="T:System.Threading.Tasks.Task`1" />タスクの型パラメーターと同じ型であります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 非同期操作が完了するまで呼び出し元のスレッドをブロックするプロパティの get アクセサーにアクセスします。呼び出すことと同じである、<xref:System.Threading.Tasks.Task.Wait%2A>メソッド。  
  
 これは格納され、後続の呼び出しですぐに返される操作の結果が利用できると、<xref:System.Threading.Tasks.Task%601.Result%2A>プロパティ。 タスクの操作中に例外が発生した場合、またはタスクがキャンセルされた場合に、注意してください、<xref:System.Threading.Tasks.Task%601.Result%2A>プロパティが値を返しません。 スローされますが代わりに、値プロパティにアクセスしようとすると、<xref:System.AggregateException>例外。  
  
   
  
## Examples  
 次の例は、各ディレクトリ、コマンドラインの引数として渡される名前のファイル内のバイト数を計算するコマンド ライン ユーティリティです。 ディレクトリにファイルが含まれている場合、インスタンス化するラムダ式を実行します。、<xref:System.IO.FileStream>ディレクトリ内の各ファイル オブジェクトの値を取得し、<xref:System.IO.FileStream.Length%2A?displayProperty=nameWithType>プロパティ。 単純に呼び出して、ディレクトリにファイルが含まれていない場合、<xref:System.Threading.Tasks.Task.FromResult%2A>タスクを作成するメソッドが<xref:System.Threading.Tasks.Task%601.Result%2A?displayProperty=nameWithType>プロパティがゼロ (0)。 ディレクトリのすべてのファイルのバイト数の合計数はから利用可能なタスクの終了時に、<xref:System.Threading.Tasks.Task%601.Result%2A>プロパティ。  
  
 [!code-csharp[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/cs/fromresult1.cs#1)]
 [!code-vb[System.Threading.Tasks.Task.FromResult#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.task.fromresult/vb/fromresult1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AggregateException">タスクが取り消されました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションに <see cref="T:System.Threading.Tasks.TaskCanceledException" /> オブジェクトが含まれています。  
  
- または - 
タスクの実行時に例外がスローされました。 <see cref="P:System.AggregateException.InnerExceptions" /> コレクションには、例外に関する情報が含まれています。</exception>
        <related type="Article" href="~/docs/standard/parallel-programming/task-parallel-library-tpl.md">タスク並列ライブラリ (TPL)</related>
        <related type="Article" href="~/docs/standard/parallel-programming/task-based-asynchronous-programming.md">タスク ベースの非同期プログラミング</related>
        <related type="Article" href="~/docs/standard/parallel-programming/how-to-return-a-value-from-a-task.md">方法: タスクから値を返す</related>
      </Docs>
    </Member>
  </Members>
</Type>