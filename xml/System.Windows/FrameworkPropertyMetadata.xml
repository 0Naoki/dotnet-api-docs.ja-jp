<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata><Meta Name="ms.openlocfilehash" Value="b1e91c552a9f1092824655c7f0620903bf1542f2" /><Meta Name="ms.sourcegitcommit" Value="42a3c35677e9d87eeb503607ae50c9d39827d414" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="12/17/2018" /><Meta Name="ms.locfileid" Value="53474425" /></Metadata><TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <TypeSignature Language="F#" Value="type FrameworkPropertyMetadata = class&#xA;    inherit UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>依存関係プロパティのメタデータを報告または適用します。特に、フレームワークに固有のプロパティのシステム特性を追加します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスから派生<xref:System.Windows.PropertyMetadata>(を通じて<xref:System.Windows.UIPropertyMetadata>)。 ほとんどの WPF フレームワーク レベルのアプリケーション開発目的の<xref:System.Windows.FrameworkPropertyMetadata>基本メタデータ型ではなく、依存関係プロパティのメタデータに使用される型<xref:System.Windows.PropertyMetadata>または<xref:System.Windows.UIPropertyMetadata>します。 これは、既存の依存関係プロパティとカスタム依存関係プロパティのほとんどのシナリオの両方に当てはまります。  
  
 これで宣言されたメンバーのクラスを補足、<xref:System.Windows.PropertyMetadata>基底クラスが指定するか、プロパティの継承、データ バインディング、レイアウトなどの WPF フレームワーク レベルのプロパティ システム動作を報告するさまざまなブール型プロパティが含まれます。  
  
 作成するためのいくつかのコンス トラクター シグネチャを<xref:System.Windows.FrameworkPropertyMetadata>インスタンスを<xref:System.Windows.FrameworkPropertyMetadataOptions>パラメーター。 <xref:System.Windows.FrameworkPropertyMetadataOptions>列挙体コンス トラクターの最初の動作を指定するだけ使用され、後はそれ以外の場合は公開されません<xref:System.Windows.FrameworkPropertyMetadata>を構築します。 構築されたインスタンスを取得またはコンス トラクターの呼び出しで使用する列挙値の名前を共有するさまざまなプロパティから対応する情報を設定できます。  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスは、通常では使用されません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、依存関係プロパティのメタデータを特定の所有者のとして取得初期基本<xref:System.Windows.PropertyMetadata>型。 そのメタデータは<xref:System.Windows.FrameworkPropertyMetadata>します。 有効なキャストが返された場合<xref:System.Windows.FrameworkPropertyMetadata>、し、さまざまな<xref:System.Windows.FrameworkPropertyMetadata>プロパティの値は、シンプルな UI を (非表示) で報告されます。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このシグネチャのすべての値を初期化する<xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A>がプロパティの既定値にします。 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> `null`とさまざまな<xref:System.Windows.FrameworkPropertyMetadata>ブール型プロパティになります`false`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata defaultValue" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <summary>指定した既定値を使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata propertyChangedCallback" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した <see cref="T:System.Windows.FrameworkPropertyMetadata" /> コールバックを使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <summary>指定した既定値とフレームワーク レベルのメタデータ オプションを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
 値がセット flags でフラグとしてマークされている、`flags`パラメーターのブール値が設定されます<xref:System.Windows.FrameworkPropertyMetadata>と一致しているプロパティ<xref:System.Windows.FrameworkPropertyMetadataOptions>フラグの名前を`true`します。 メタデータが特定のプロパティ システム操作に適用されていない限り、その後、メタデータでは、プロパティの値を変更できます。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値と <see cref="T:System.Windows.FrameworkPropertyMetadata" /> コールバックを使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこの依存関係プロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定したコールバックを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装の基本の初期化子を呼び出すし、追加、`coerceValueCallback`ベースのインスタンスでプロパティを設定します。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型の値として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、および <see cref="T:System.Windows.FrameworkPropertyMetadata" /> コールバックを使用して、<see cref="T:System.Windows.PropertyChangedCallback" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
 値がセット flags でフラグとしてマークされている、`flags`パラメーターのブール値が設定されます<xref:System.Windows.FrameworkPropertyMetadata>と一致しているプロパティ<xref:System.Windows.FrameworkPropertyMetadataOptions>フラグの名前を`true`します。 メタデータでは、プロパティの値は、メタデータが特定のプロパティ システム操作に適用されていない限り、引き続き変更できます。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこの依存関係プロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値とコールバックを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、およびコールバックを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
 値がセット flags でフラグとしてマークされている、`flags`パラメーターのブール値が設定されます<xref:System.Windows.FrameworkPropertyMetadata>と一致しているプロパティ<xref:System.Windows.FrameworkPropertyMetadataOptions>フラグの名前を`true`します。 メタデータでは、プロパティの値は、メタデータが特定のプロパティ システム操作に適用されていない限り、引き続き変更できます。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこの依存関係プロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <param name="isAnimationProhibited">該当するメタデータが適用されるプロパティがプロパティ システムによってアニメーション化されないようにする場合は <see langword="true" />。 このようなプロパティのアニメーション化を試みると、プロパティ システムでランタイム例外が発生します。 プロパティのアニメーション化を許可する場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、指定したコールバック、およびプロパティでのアニメーションを無効にするブール値を使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
 `isAnimationProhibited`パラメーターの初期値の設定、<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>即時ベースで宣言されたプロパティ<xref:System.Windows.UIPropertyMetadata>クラス。  
  
 値がセット flags でフラグとしてマークされている、`flags`パラメーターのブール値が設定されます<xref:System.Windows.FrameworkPropertyMetadata>と一致しているプロパティ<xref:System.Windows.FrameworkPropertyMetadataOptions>フラグの名前を`true`します。 メタデータでは、プロパティの値は、メタデータが特定のプロパティ システム操作に適用されていない限り、引き続き変更できます。  
  
   
  
## Examples  
 次の例では、このコンス トラクターのシグネチャを呼び出します。  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="F#" Value="new System.Windows.FrameworkPropertyMetadata : obj * System.Windows.FrameworkPropertyMetadataOptions * System.Windows.PropertyChangedCallback * System.Windows.CoerceValueCallback * bool * System.Windows.Data.UpdateSourceTrigger -&gt; System.Windows.FrameworkPropertyMetadata" Usage="new System.Windows.FrameworkPropertyMetadata (defaultValue, flags, propertyChangedCallback, coerceValueCallback, isAnimationProhibited, defaultUpdateSourceTrigger)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">依存関係プロパティの既定値。通常、特定の型として指定されます。</param>
        <param name="flags">メタデータ オプション フラグ (<see cref="T:System.Windows.FrameworkPropertyMetadataOptions" /> 値の組み合わせ)。 これらのオプションは、システムと対話する依存関係プロパティの特性 (レイアウトやデータ バインディングなど) を指定します。</param>
        <param name="propertyChangedCallback">プロパティの有効値が変更されるときにプロパティ システムによって必ず呼び出されるハンドラー実装への参照。</param>
        <param name="coerceValueCallback">プロパティ システムがこのプロパティに対して <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> を呼び出すときに必ず呼び出されるハンドラー実装への参照。</param>
        <param name="isAnimationProhibited">該当するメタデータが適用されるプロパティがプロパティ システムによってアニメーション化されないようにする場合は <see langword="true" />。 このようなプロパティのアニメーション化を試みると、プロパティ システムでランタイム例外が発生します。 既定値は、<see langword="false" /> です。</param>
        <param name="defaultUpdateSourceTrigger"><see cref="T:System.Windows.Data.UpdateSourceTrigger" /> が <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> に設定されているバインディングをこのプロパティに対して適用するときに使用する <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />。</param>
        <summary>指定した既定値、フレームワークのメタデータ オプション、指定したコールバック、プロパティでのアニメーションを無効にするブール値、および既定のデータ バインディング更新トリガーを使用して、<see cref="T:System.Windows.FrameworkPropertyMetadata" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された値の型`defaultValue`と一致するか、このメタデータに適用される依存関係プロパティの元の登録で指定された型に関連しています。 メタデータの既定値の型に適用される依存関係プロパティの型の間に不一致がある場合は、コンパイル時に、不一致が検出できないため、デバッグが困難できます。 既定値の型/プロパティ型の不一致の結果が実行時エラーであるために、プロパティ システムは、実行時までプロパティの有効な値を評価しません。  
  
 値<xref:System.Windows.DependencyProperty.UnsetValue>プロパティ システムで特別な意味があり、依存関係プロパティの既定値として使用できません。  
  
 `isAnimationProhibited`パラメーターの初期値の設定、<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>即時ベースで宣言されたプロパティ<xref:System.Windows.UIPropertyMetadata>クラス。  
  
 バインドの更新ソースの動作の詳細については、次を参照してください。[データ バインディングの概要](~/docs/framework/wpf/data/data-binding-overview.md)します。  
  
 値がセット flags でフラグとしてマークされている、`flags`パラメーターのブール値が設定されます<xref:System.Windows.FrameworkPropertyMetadata>と一致しているプロパティ<xref:System.Windows.FrameworkPropertyMetadataOptions>フラグの名前を`true`します。 メタデータでは、プロパティの値は、メタデータが特定のプロパティ システム操作に適用されていない限り、引き続き変更できます。  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="defaultValue" /> が <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> に設定されます。</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティが配置パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが配置パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>の実装が含まれて<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一部として、依存関係プロパティを変更する有効な値し、を使用してメタデータがある<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>設定`true`がその要素のビジュアルを無効にするための遅延要求を開始 (呼び出し<xref:System.Windows.UIElement.InvalidateArrange%2A>)。 この実装は WPF フレームワーク レベルが既に設定されている、ため、通常必要はありませんで依存関係プロパティを検索する<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>大幅に交換または WPF フレームワーク レベルのレイアウト動作を変更する場合を除き、します。  
  
 カスタム<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>実装の依存関係プロパティの変更と同様の動作を選択、<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>は`true`します。  
  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用か[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、プロパティ フィールドをさまざまな依存関係から、既定のメタデータを取得、さまざまな値をクエリ<xref:System.Windows.FrameworkPropertyMetadata>プロパティを情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティが測定パスに影響する可能性があるかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが測定パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>の実装が含まれて<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一部として、依存関係プロパティを変更する有効な値し、を使用してメタデータがある<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>設定`true`がその要素のビジュアルを無効にするための遅延要求を開始します。 この実装は WPF フレームワーク レベルが既に設定されている、ため、通常必要はありませんで依存関係プロパティを検索する<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>大幅に交換または WPF フレームワーク レベルのレイアウト動作を変更する場合を除き、します。  
  
 カスタム<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>実装の依存関係プロパティの変更と同様の動作を選択、<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>は`true`します。  
  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、プロパティ フィールドをさまざまな依存関係から、既定のメタデータを取得、さまざまな値をクエリ<xref:System.Windows.FrameworkPropertyMetadata>プロパティを情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentArrange : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティがその親要素のレイアウトの配置パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する可能性のある依存関係プロパティが特にその親要素の配置パスに影響する可能性がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>の実装が含まれて<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一部として、依存関係プロパティを変更する有効な値し、を使用してメタデータがある<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>設定`true`が親要素のビジュアルを無効にするための遅延要求を開始します。  
  
 変更を報告する必要がない一般に、<xref:System.Windows.FrameworkElement>プロパティを使用して親要素を<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>要素自体は既に存在して、独自ため<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>として`true`します。 該当する場合に、親が整列子要素の変化を一般に開始するので、通常で十分です。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> ため、<xref:System.Windows.FrameworkContentElement>クラスを派生します。 この場合、子要素のセットが、プロパティ、<xref:System.Windows.FrameworkContentElement>派生クラスでは、自身のレンダリングを制御しません。 によって、レンダリングが処理される、<xref:System.Windows.FrameworkElement>コンテンツのホストとして機能する親要素。 値の変更など、<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>子要素で添付プロパティを無効化、親の子の位置を変更する必要がありますので、親の配置。 そのため、<xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType>添付プロパティがメタデータで<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>は`true`します。 別の例は<xref:System.Windows.Controls.Control.Padding%2A>とき、このプロパティの変更では、親の可能性があります変更に使用可能な領域に応じて、子の位置します。  
  
 この実装は WPF フレームワーク レベルが既に設定されている、ため、通常必要はありませんで依存関係プロパティを検索する<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>大幅に交換または WPF フレームワーク レベルのレイアウト動作を変更する場合を除き、します。  
  
 カスタム<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>実装の依存関係プロパティの変更と同様の動作を選択、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>は`true`します。  
  
 プロパティをいずれかのクラスの派生<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsParentMeasure : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト エンジンの操作中に、依存関係プロパティがその親要素のレイアウトの測定パスに潜在的に影響するかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティが特にその親要素の測定パスに影響する可能性がある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>の実装が含まれて<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一部として、依存関係プロパティを変更する有効な値し、を使用してメタデータがある<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>設定`true`が親要素のビジュアルを無効にするための遅延要求を開始します。 この実装は WPF フレームワーク レベルが既に設定されている、ため、通常必要はありませんで依存関係プロパティを検索する<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>大幅に交換または WPF フレームワーク レベルのレイアウト動作を変更する場合を除き、します。  
  
 変更を報告する必要がない一般に、<xref:System.Windows.FrameworkElement>プロパティを使用して親要素を<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>要素自体は既に存在して、独自ため<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>として`true`します。 子要素の変更は一般的に該当する場合に、親測定パスを開始するため、通常で十分です。 <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> ため、<xref:System.Windows.FrameworkContentElement>クラスを派生します。 この場合、子要素のセットが、プロパティ、<xref:System.Windows.FrameworkContentElement>派生クラスでは、自身のレンダリングを制御しません。 によって、レンダリングが処理される、<xref:System.Windows.FrameworkElement>コンテンツのホストとして機能する親要素。 値の変更など、<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>子要素でプロパティを段落の相対的な間隔から変更可能性がありますとを増やす可能性があります、またはコンテンツ ホストのサイズを小さくために、親のメジャーを無効にします。 そのため、<xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType>プロパティがメタデータで<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>は`true`します。  
  
 コンテンツのホスト要素に依存関係プロパティの変更についてもよくなります、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>は`true`、コンテンツのホストのレンダリング ロジックの一部として。 たとえば、<xref:System.Windows.Controls.TextBox>要素を必要となるテキスト内で特定の変更の境界ボックスとの対応の必要があります、<xref:System.Windows.Controls.TextBox>自体を変更します。  
  
 カスタム<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>実装の依存関係プロパティの変更と同様の動作を選択、<xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A>は`true`します。  
  
 プロパティをいずれかのクラスの派生<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AffectsRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティが一般的なレイアウトに何らかの形で影響する (配置や測定に特に影響を与えないが再描画が必要になる) 可能性があるかどうかを示す値を取得または設定します。</summary>
        <value>このメタデータが存在する依存関係プロパティがレンダリングに影響を与える場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> <xref:System.Windows.FrameworkContentElement>の実装が含まれて<xref:System.Windows.FrameworkElement.OnPropertyChanged%2A>要素に存在するすべての依存関係プロパティに対する有効な値の変更を監視します。 ロジックの一部として、依存関係プロパティを変更する有効な値し、を使用してメタデータがある<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>設定`true`がその要素のビジュアルを無効にするための遅延要求を開始します。 この実装は WPF フレームワーク レベルが既に設定されている、ため、通常必要はありませんで依存関係プロパティを検索する<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>大幅に交換または WPF フレームワーク レベルのレイアウト動作を変更する場合を除き、します。  
  
 カスタム<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>実装の依存関係プロパティの変更と同様の動作を選択、<xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A>は`true`します。  
  
 プロパティをいずれかのクラスの派生<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、プロパティ フィールドをさまざまな依存関係から、既定のメタデータを取得、さまざまな値をクエリ<xref:System.Windows.FrameworkPropertyMetadata>プロパティを情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.BindsTwoWayByDefault : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティが既定で双方向をバインドするかどうかを示す値を取得または設定します。</summary>
        <value>既定でこのメタデータが存在する依存関係プロパティが双方向をバインドする場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティがない場合に`true`、バインドの更新プログラムがの既定の動作に基づいて、既定で一方向、<xref:System.Windows.Data.Binding>コンス トラクターまたはそれと同等[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]構文。  
  
 既存の要素では、このプロパティを通常検索は`true`両方の状態をレポートし、ユーザーの操作によって変更することなどは、依存関係プロパティのメタデータで<xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>します。  
  
 このプロパティはのみ、依存関係プロパティの既定のバインディング更新特性を一般に報告します。 任意のバインディング インスタンスでこのプロパティを設定できるローカルに設定された、<xref:System.Windows.Data.Binding.Mode%2A>バインディングのプロパティと、この既定の設定を変更します。  
  
 プロパティをいずれかのクラスの派生<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、プロパティ フィールドをさまざまな依存関係から、既定のメタデータを取得、さまざまな値をクエリ<xref:System.Windows.FrameworkPropertyMetadata>プロパティを情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberSignature Language="F#" Value="member this.DefaultUpdateSourceTrigger : System.Windows.Data.UpdateSourceTrigger with get, set" Usage="System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>このメタデータを含むプロパティに対して、<see cref="T:System.Windows.Data.UpdateSourceTrigger" /> が <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> に設定されているバインディングを適用するときに使用する <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> の既定値を取得または設定します。</summary>
        <value><see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> 以外の列挙値。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">このプロパティが <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" /> に設定されています。設定した値は、バインディングで要求されたときの既定値になります。</exception>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Inherits : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値が継承可能かどうかを示す値を取得または設定します。</summary>
        <value>プロパティ値が継承可能な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ値の継承の機能である、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]という特定の依存関係プロパティはローカル要素で設定するのルートに近い、WPF フレームワーク レベルのプロパティ システムを[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]要素ツリーし、その値によって継承されますまた、そのプロパティを処理する子要素の論理ツリー内ですべての要素。 既定では、プロパティ値の継承が有効になっていないと、パフォーマンスへの影響が有効にすることです。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
> [!NOTE]
>  プロパティ値の継承は、非添付依存関係プロパティに見える場合があります、ランタイム ツリーで特定オブジェクト間の分割を使用して非添付プロパティの継承動作は定義されていません。 常に使用する<xref:System.Windows.DependencyProperty.RegisterAttached%2A>に指定したプロパティを登録する<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータにします。  
  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、プロパティ フィールドをさまざまな依存関係から、既定のメタデータを取得、さまざまな値をクエリ<xref:System.Windows.FrameworkPropertyMetadata>プロパティを情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDataBindingAllowed : bool" Usage="System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティのデータ バインディングがサポートされているかどうかを示す値を取得します。</summary>
        <value>このメタデータが適用される依存関係プロパティでデータ バインドがサポートされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、報告`false`2 つの可能な条件のいずれかの: 依存関係プロパティには、(に示される依存関係プロパティの識別子、メタデータではなく)、読み取り専用の依存関係プロパティのいずれかのデータ バインディングは許可されませんまたはの値別のメタデータ プロパティ<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>に設定されている`true`このメタデータにします。 呼び出し元は両方を確認する必要があるないように、便利なようにこのプロパティが公開されている<xref:System.Windows.DependencyProperty.ReadOnly%2A>と<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>します。  
  
 それ以外の場合の読み取り/書き込みプロパティがデータ バインディングをサポートされていないことを指定するメタデータを作成しようとする場合は、フラグを指定<xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable>(とわずかな名前付け規則違いに注意してください<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>)。  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
   
  
## Examples  
 次の例では、プロパティ フィールドをさまざまな依存関係から、既定のメタデータを取得、さまざまな値をクエリ<xref:System.Windows.FrameworkPropertyMetadata>プロパティを情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成するとします。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsNotDataBindable : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティがデータ バインディングをサポートしているかどうかを示す値を取得または設定します。</summary>
        <value>プロパティがデータ バインドをサポートしない場合は<see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメタデータ プロパティに設定されている注`true`専用のプロパティを読み取り/書き込みプロパティであるにもかかわらず、データ バインディングをサポートする必要があります。 想定されるが、ことで、依存関係プロパティが宣言されているほとんどの場合、データ バインディングが必要なデータ バインディングは、依存関係プロパティが役立つ主要なシナリオのいずれかのためであることです。 異なり<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>、このだけでは変更後で、特定のバインドを変更できる既定されません。 このプロパティの設定`true`メタデータ依存関係プロパティのメタデータ内にその依存関係プロパティの値を式を適用したすべてのバインドが無効になります。  
  
 読み取り専用の依存関係プロパティは (変更後の値を適用可能な set アクセス操作子がない) ため、データをバインディングをサポートしていませんが、レポートではまだ`false`の<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>します。 これは、プロパティに対応するため、<xref:System.Windows.FrameworkPropertyMetadataOptions>方法、メタデータが実際に確立された、プロパティの名前を付けることを示唆する最後の結果の動作を常にレポートではなくと同等の値を報告します。 指定された依存関係プロパティがデータ バインディングを許可するかどうかを確認するのには、通常確認してください<xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A>代わりにします。 <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> 両方をチェックするための便利なは<xref:System.Windows.DependencyProperty.ReadOnly%2A>と<xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>1 回の操作には、予期される結果を生成します。  
  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Journal : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ジャーナル実装の一部としてアプリケーションが格納できる、または格納する必要のあるジャーナル情報がこのプロパティに格納されているかどうか示す値を取得または設定します。</summary>
        <value>このメタデータが適用される依存関係プロパティに対してジャーナルを実行する必要がある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="override this.Merge : System.Windows.PropertyMetadata * System.Windows.DependencyProperty -&gt; unit" Usage="frameworkPropertyMetadata.Merge (baseMetadata, dp)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">マージする基本のメタデータ。</param>
        <param name="dp">このメタデータが適用されている依存関係プロパティ。</param>
        <summary>ソース メタデータと基本メタデータのマージを有効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、メタデータが上書きされているときに内部的に使用されます。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生するクラス<see cref="T:System.Windows.PropertyMetadata" />(またはこれが特にクラス)、実装に追加したすべてのメタデータ プロパティに対応するには、このメソッドをオーバーライドする必要があります。 たとえば、実装追加可能性が新しいフラグ列挙値、および<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />実装できる必要がありますし、それらのフラグを正しく結合します。  
  
常にマージする前の型階層内に既に定義されているすべてのプロパティの基本の実装が自動的に処理は、独自の実装の前に、基本実装を呼び出します。  
  
によって追加された動作、<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />で実装<see cref="T:System.Windows.FrameworkPropertyMetadata" />は、特定の WPF フレームワーク レベル プロパティなどのメタデータで<see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />演算で結合されますまたは操作。  
  
<see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />動作は、呼び出すことによって既存の依存関係プロパティのプロパティのメタデータをオーバーライドする場合も、動作を実装<see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />は、オーバーライドのメタデータを使用して<see cref="T:System.Windows.FrameworkPropertyMetadata" />します。</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberSignature Language="F#" Value="override this.OnApply : System.Windows.DependencyProperty * Type -&gt; unit" Usage="frameworkPropertyMetadata.OnApply (dp, targetType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">メタデータが適用された依存関係プロパティ。</param>
        <param name="targetType">該当するメタデータが型固有のメタデータの場合、このメタデータに関連付けられている型。 これが既定のメタデータである場合は、この値に <see langword="null" /> を指定できます。</param>
        <summary>このメタデータがプロパティに適用されたときに呼び出され、メタデータがシールされることを示します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 データ構造のすべての変更可能性を<xref:System.Windows.FrameworkPropertyMetadata>インスタンスに設定されなければなりません変更不可としてこのメソッドが呼び出されるとします。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="T:System.Windows.FrameworkPropertyMetadata" />このメソッドの実装は基本実装を呼び出す以外何も行いません。</para></block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.OverridesInheritanceBehavior : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素の論理ツリー内の特定のコンテンツ境界にまたがってプロパティ値の継承を評価するかどうかを示す値を取得または設定します。</summary>
        <value>プロパティ値の継承が特定のコンテンツ境界をまたがる場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメタデータは、特別な親要素の子要素の境界を越えてプロパティ値継承の動作をほとんど適用の変更を報告します。 このような境界の標準的な例は、の内容を<xref:System.Windows.Controls.Frame>ここで、<xref:System.Windows.Controls.Frame>の存在とは無関係に、コンテンツを再読み込み取得可能性があります、<xref:System.Windows.Controls.Frame>します。 目的のプロパティ システムの動作は、プロパティ値の継承の内容を経由する必要があります、 <xref:System.Windows.Controls.Frame>、これらの内容の要素をフレームをホストするアプリケーションが所有または管理していない可能性があるためです。 使用してメタデータを指定する<xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A>に設定`true`も指定することと、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>として`true`、プロパティを継承可能でも、メタデータが適用されると、<xref:System.Windows.Controls.Frame>境界または境界が似ています。  
  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし後の呼び出しの一部として、メタデータが消費される<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SubPropertiesDoNotAffectRender : bool with get, set" Usage="System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティのサブプロパティが格納オブジェクトのレンダリングに影響しないかどうかを示す値を取得または設定します。</summary>
        <value>サブプロパティ値の変更がレンダリングに影響しない場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメタデータ オプションは、関連する型が、独自のプロパティの値を参照型の場合に依存関係プロパティです。 通常、レイアウト システムのロジックは、サブプロパティを含む任意の依存関係プロパティは可能性のあるレイアウトを影響は、別の描画パスの変更のすべてのサブプロパティをチェックすることが実際に実行されているよりも時間がかかるためのことを想定することです。 このオプションを設定`true`は WPF フレームワーク レベルのレイアウト システムの実装のパフォーマンスを最適化するために便利です。  
  
 派生クラスでプロパティ<xref:System.Windows.PropertyMetadata>通常は読み取り/書き込みとしてオブジェクト モデルで定義します。 これは、インスタンスの初期化後に調整できるようにします。 ただし、呼び出しの一部として使用されるメタデータと<xref:System.Windows.DependencyProperty.Register%2A>、 <xref:System.Windows.DependencyProperty.AddOwner%2A>、または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>、プロパティ システムはそのメタデータ インスタンスを封印およびメタデータの詳細を伝えるためのプロパティを変更できないと見なされますようになりました。 後は、このプロパティを設定しようとしています。<xref:System.Windows.PropertyMetadata.IsSealed%2A>は`true`でこのメタデータ インスタンスで例外が発生します。  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>XAML テキストの使用状況  
 このクラスのメンバーは、通常では使用しない[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">メタデータがシールされるよう、かつメタデータのプロパティを設定できないように、メタデータは依存関係プロパティの操作に既に適用されています。</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>