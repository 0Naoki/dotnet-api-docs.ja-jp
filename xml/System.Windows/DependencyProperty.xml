<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata><Meta Name="ms.openlocfilehash" Value="21210545d8206e6e4e474c2b2e8040e528891f8a" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69434645" /></Metadata><TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スタイル設定、データ バインディング、アニメーション、および継承などの方法によって設定できるプロパティを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 は<xref:System.Windows.DependencyProperty> 、の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]次の機能をサポートしています。  
  
-   プロパティは、スタイルで設定できます。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
-   プロパティは、データバインディングを使用して設定できます。 データバインディングの依存関係プロパティの詳細につい[ては、「」を参照してください。2つのコントロール](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)のプロパティをバインドします。  
  
-   プロパティは、動的リソース参照を使用して設定できます。 詳細については、「[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
-   プロパティは、要素ツリー内の親要素から自動的に値を継承できます。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
-   プロパティはアニメーション化できます。 詳しくは、「 [アニメーションの概要](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)」をご覧ください。  
  
-   プロパティは、プロパティの前の値が変更されたときに報告でき、プロパティ値を強制的に変更できます。 詳しくは、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
-   プロパティは、プロパティ値[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]を変更するときに、レイアウトシステムが要素のビジュアルを再構成する必要があるかどうかなどの情報をに報告します。  
  
-   プロパティは、 [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]でサポートを受け取ります。  たとえば、プロパティは **[プロパティ]** ウィンドウで編集できます。  
  
 依存関係プロパティの詳細については、「[依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)」を参照してください。 カスタム型のプロパティで前の一覧の機能をサポートするには、依存関係プロパティを作成する必要があります。  カスタム依存関係プロパティを作成する方法については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」を参照してください。  
  
 添付プロパティは、任意のオブジェクトが添付プロパティを定義する型に情報を報告できるようにするプロパティです。 で[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]は、型がプロパティを<xref:System.Windows.DependencyObject>定義する型から継承されているかどうかに関係なく、から継承されるすべての型で、添付プロパティを使用できます。 添付プロパティは、 [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]言語の機能です。  添付プロパティをで[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]設定するには、 *ownerType*を使用します。*propertyName*構文。 添付プロパティの例としては<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 、プロパティがあります。 すべて<xref:System.Windows.DependencyObject>の型で使用できるプロパティを作成する場合は、添付プロパティを作成する必要があります。 添付プロパティの作成方法など、添付プロパティの詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```xaml 
<object property="dependencyPropertyName"/>  
```

または

```xaml
<object property="ownerType.dependencyPropertyName"/>  
```

または

```xaml
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 値  
 `dependencyPropertyName`  
 目的の依存関係プロパティ<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>のを指定する文字列。 このプロパティが既定の XML 名前空間にない場合は、前に XML 名前空間プレフィックスを付けることができます (詳細については、「 [WPF xaml の Xaml 名前空間と名前空間のマッピング](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)」を参照してください)。  
  
 `ownerType`.`dependencyPropertyName`  
 依存関係プロパティの所有者の種類、ドット (.)、および<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>を指定する文字列。 `ownerType`の前に XML 名前空間プレフィックスを付けることもできます。 この使用方法は、 `TargetType`遅延バインディングされたスタイルとテンプレートに固有のものであり、がまだ知られていないため、コンテキストを解析するために依存関係プロパティの所有者を指定する必要があります。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
 `attachedPropertyOwnerType` *のハッシュ コードを返します。* `attachedPropertyName`  
 添付プロパティの所有者、ドット (.)、添付プロパティ名を指定する文字列。 `attachedPropertyOwnerType`の前に XML 名前空間プレフィックスを付けることもできます。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に登録済みの依存関係プロパティの所有者として、ある型に別の型を追加します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">この依存関係プロパティの所有者として追加する型。</param>
        <summary>登録済みの依存関係プロパティの所有者として、別の型を追加します。</summary>
        <returns>依存関係プロパティを識別する元の <see cref="T:System.Windows.DependencyProperty" /> 識別子への参照。 この識別子は、追加するクラスが <see langword="public static readonly" /> フィールドとして公開する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、プロパティシステムは、特定の依存関係プロパティを最初に登録しなかった型の依存関係プロパティを認識できます。  
  
 通常、 <xref:System.Windows.DependencyProperty.AddOwner%2A>は、マネージクラスの継承によって依存関係プロパティを公開していないクラスに依存関係プロパティを追加するために使用されます (クラスの継承によって、ラッパープロパティが派生クラスに継承されるため、では、一般的なメンバー-テーブルに依存関係プロパティへのアクセス権が既に与えられています)。 <xref:System.Windows.DependencyProperty.AddOwner%2A>プロパティシステムが、その依存関係プロパティを最初に登録しなかった型の依存関係プロパティを認識できるようにします。  
  
 この署名では、メタデータを指定することはできません。  このメソッドを使用すると、新しい<xref:System.Windows.DependencyProperty>とその所有者の種類に対してメタデータが自動的に生成されます。 自動生成されるメタデータは、このプロパティが定義されているすべての基本型からのマージされたメタデータの結果です。 結合されたメタデータが使用できない場合は、プロパティの既定のメタデータが使用されます。 <xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッドを使用してプロパティが登録されている場合、既定のメタデータは、が呼び出された<xref:System.Windows.DependencyProperty.RegisterAttached%2A>ときに作成されたメタデータと同じになります。 それ以外の場合は、プロパティが<xref:System.Windows.PropertyMetadata.DefaultValue%2A>プロパティ型の既定値に設定され、の他の<xref:System.Windows.PropertyMetadata>すべてのプロパティが`null`に設定されて、オブジェクトが作成されます。<xref:System.Windows.PropertyMetadata> 指定さ<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>れた型に追加された依存関係プロパティのバージョンにメタデータを提供する場合は、シグネチャを使用します。  
  
 通常、このメソッドの戻り値は、依存関係プロパティの識別子を格納することによって、依存関係プロパティを宣言および公開するために使用されます。 依存関係プロパティに対してプロパティシステム[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]を呼び出す場合 (特に、追加する所有者クラスに存在する場合)、この識別子は依存関係プロパティへのアクセスを提供します。 同様の機能を示すには、元の所有者と追加された所有者の両方に同じプロパティ名を使用する必要があります。 を使用して<xref:System.Windows.DependencyProperty> [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A> 型<xref:System.Windows.DependencyProperty.AddOwner%2A>に追加される依存関係プロパティについては、メソッドの戻り値を使用して依存関係プロパティ識別子を定義し、プロパティラッパーを宣言する必要があります。  
  
 上記<xref:System.Windows.DependencyProperty.AddOwner%2A>の方法は、内で[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]宣言されている依存関係プロパティを作成するときに使用します。 たとえば、とは<xref:System.Windows.Controls.Border>両方<xref:System.Windows.Controls.Control>とも`BorderBrush` 、類似した機能を持つ依存関係プロパティを定義します。 <xref:System.Windows.Controls.Control>元の所有<xref:System.Windows.Controls.Border.BorderBrushProperty>者<xref:System.Windows.Controls.Border>と登録されて<xref:System.Windows.DependencyProperty.AddOwner%2A>いる依存関係プロパティの識別子に基づいてを呼び出すことにより、プロパティをプロパティシステムに定義します。 `BorderBrush` その後、 <xref:System.Windows.DependencyProperty> <xref:System.Windows.Controls.Control.BorderBrushProperty> `BorderBrush`戻り値を使用して、追加された所有者のそのプロパティに対して新しい静的フィールド () が確立され、プロパティラッパーも宣言されます。 <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">この依存関係プロパティの所有者として追加する型。</param>
        <param name="typeMetadata">提供される型に存在する依存関係プロパティを修飾するメタデータ。</param>
        <summary>既に登録済みの依存関係プロパティの所有者として別の型を追加します。その際、提供される所有者の型に存在する依存関係プロパティに依存関係プロパティのメタデータを提供します。</summary>
        <returns>依存関係プロパティを識別する元の <see cref="T:System.Windows.DependencyProperty" /> 識別子への参照。 この識別子は、追加するクラスが <see langword="public static readonly" /> フィールドとして公開する必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを使用すると、プロパティシステムは、特定の依存関係プロパティを最初に登録しなかった型の依存関係プロパティを認識できます。  
  
 このメソッドの戻り値は、依存関係プロパティを宣言および公開するために使用されます。これは、特に、追加する所有者クラスに存在するためです。 通常は、元の所有者と追加された所有者の両方に同じプロパティ名を使用して、同様の機能を示す必要があります。 を使用して[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A>型に追加される依存関係プロパティの識別子と新しいプロパティラッパーを公開することをお勧めします。  
  
 上記<xref:System.Windows.DependencyProperty.AddOwner%2A>の方法は、で[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]宣言するときに使用します。 たとえば、とは<xref:System.Windows.Controls.Border>両方<xref:System.Windows.Controls.Control>とも`BorderBrush` 、類似した機能を持つ依存関係プロパティを定義します。 <xref:System.Windows.Controls.Control>元の所有<xref:System.Windows.Controls.Border.BorderBrushProperty>者<xref:System.Windows.Controls.Border>と登録されて<xref:System.Windows.DependencyProperty.AddOwner%2A>いる依存関係プロパティの識別子でを呼び出すことによって、プロパティをプロパティシステムに定義します。 `BorderBrush` その後、 <xref:System.Windows.DependencyProperty> <xref:System.Windows.Controls.Control.BorderBrushProperty> `BorderBrush`戻り値を使用して、追加された所有者のプロパティに静的フィールド () を確立し、プロパティラッパーも宣言します。 <xref:System.Windows.DependencyProperty.AddOwner%2A>  
  
 など<xref:System.Windows.DependencyObject.GetValue%2A>の操作では、追加された所有者の依存関係プロパティ識別子を使用する必要があります。 ただし、異なるメタデータを持つ所有者として追加されたクラスの型またはインスタンスに関係する型固有の操作では、元の (追加された所有者ではない) 依存関係プロパティの識別子がで指定されている場合でも、期待どおりの結果が返されます。<xref:System.Windows.DependencyObject.GetValue%2A> や<xref:System.Windows.DependencyProperty.GetMetadata%2A>などのメソッドの呼び出し。 追加された所有者のメタデータは<xref:System.Windows.DependencyProperty.AddOwner%2A> 、呼び出し自体によってこれらされ、必ずしも [所有者クラス識別子の追加] フィールドによって排他的に参照されるわけではありません。 ただし、を使用して[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] <xref:System.Windows.DependencyProperty.AddOwner%2A>型に追加された依存関係プロパティの識別子と新しいプロパティラッパーを公開することをお勧めします。これに失敗すると、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]との間に不一致が生じます。[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]プロパティの表現。  
  
 指定されたメタデータは、基本所有者に存在する依存関係プロパティのプロパティメタデータとマージされます。 元の基本メタデータで指定されたすべての特性が保持されます。 新しいメタデータで特に変更された特性だけが、基本メタデータの特性を上書きします。 などの一部の特性<xref:System.Windows.PropertyMetadata.DefaultValue%2A>は、新しいメタデータで指定されている場合に置き換えられます。 などの他の<xref:System.Windows.PropertyChangedCallback>は、結合されます。 最終的には、マージ動作は、オーバーライドに使用されているプロパティメタデータ型に依存するため、ここで説明する動作は、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依存関係プロパティで使用される既存のプロパティメタデータクラスに対して行われます。 詳細については、「[依存関係プロパティのメタ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)データ」および「[フレームワークプロパティメタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定のメタデータを取得します。</summary>
        <value>依存関係プロパティの既定のメタデータ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のメタデータは、その特定のオブジェクトまたは明示的<xref:System.Windows.DependencyProperty.Register%2A>なまたは<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>呼び出しによって代替メタデータが指定されていない派生型のオブジェクトで使用できるプロパティメタデータです。  
  
 元の所有者が、依存関係プロパティ<xref:System.Windows.DependencyProperty.Register%2A>を確立した最初の呼び出しにメタデータを適用し<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>た場合、そのメタデータはとして返されます。  
  
 元<xref:System.Windows.DependencyProperty.Register%2A>の呼び出しでメタデータが適用されていない場合は、 <xref:System.Windows.DependencyProperty.Register%2A>呼び出し内から既定のメタデータが生成さ<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>れ、この値がとして返されます。  
  
 に既定のメタデータを関連付ける<xref:System.Windows.DependencyProperty>主な目的は、 <xref:System.Windows.DependencyObject>または派生型のこのプロパティに既定値を指定することです。  
  
 非添付プロパティの場合、このプロパティによって返されるメタデータ型は、プロパティ<xref:System.Windows.PropertyMetadata>が最初に派生メタデータ型に登録されている場合でも、型の派生型にキャストできません。 最初に登録されたメタデータを元のメタデータ型を含め<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>て、最初に登録したメタデータが必要な場合は、代わりにを呼び出し、元の登録型をパラメーターとして渡します。  
  
 添付プロパティの場合、このプロパティによって返されるメタデータの型は、元<xref:System.Windows.DependencyProperty.RegisterAttached%2A>の登録メソッドに指定されている型と一致します。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyProperty" /> のハッシュ コードを返します。</summary>
        <returns>この <see cref="T:System.Windows.DependencyProperty" /> のハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティシステムは独自の一意の識別子<xref:System.Windows.DependencyProperty.GlobalIndex%2A>を使用し、そのプロパティの値はに<xref:System.Windows.DependencyProperty.GetHashCode%2A>よって返されます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>特定の型のメタデータが存在する場合、この依存関係プロパティに関連付けられているメタデータを返します。 依存関係プロパティが最初に登録された型、その後で依存関係プロパティが追加された型、または継承を通じて依存関係プロパティが取得され、そのメタデータが明確にオーバーライドされた型を指定できます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">依存関係プロパティのメタデータを取得する対象の特定の型。</param>
        <summary>指定した既存の型に存在する場合の、この依存関係プロパティのメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型として使用する型またはオブジェクト参照のいずれかを指定する必要があります。これは、また<xref:System.Windows.DependencyProperty.AddOwner%2A>は<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しによって、依存関係プロパティのメタデータが型に存在するために変更されるためです。  
  
   
  
## Examples  
 次の例では、型に基づいて依存関係プロパティのメタデータを取得します。 型は、 `typeof`演算子を使用して取得されます。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">メタデータの取得元となる依存関係プロパティの型固有のバージョンを確認するために型をチェックするときの、対象となる依存関係オブジェクト。</param>
        <summary>この依存関係プロパティのメタデータが指定したオブジェクト インスタンスに存在する場合に、このメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された依存関係プロパティのメタデータは、またはの呼び出しに<xref:System.Windows.DependencyProperty.AddOwner%2A>よって、プロパティメタデータが存在する場合には<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>変更できないため、型またはオブジェクト参照のいずれかを指定する必要があります。各種.  
  
 インスタンスに基づいてプロパティメタデータを要求する場合は、その型を内部で評価できるようにインスタンスを渡すだけです。 依存関係プロパティのメタデータは、インスタンスごとに異なります。任意の型プロパティの組み合わせに対して常に一貫しています。  
  
   
  
## Examples  
 次の例では、特定<xref:System.Windows.DependencyObject>のインスタンスに基づいて依存関係プロパティのメタデータを取得します。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">依存関係プロパティ メタデータの取得元となる依存関係オブジェクト型を記録する特定のオブジェクト。</param>
        <summary>指定した型に存在する場合の、この依存関係プロパティのメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 指定された依存関係プロパティのメタデータは、またはの呼び出しに<xref:System.Windows.DependencyProperty.AddOwner%2A>よって、プロパティメタデータが存在する場合には<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>変更できないため、型またはオブジェクト参照のいずれかを指定する必要があります。各種.  
  
   
  
## Examples  
 次の例では、に<xref:System.Windows.DependencyObjectType>基づいて依存関係プロパティのメタデータを取得します。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティを一意に識別する内部的に生成された値を取得します。</summary>
        <value>一意の数値識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値は整数であり、グローバル一意識別子 (GUID) ではありません。 一般に、このインデックス値の使用は必須ではなく、すべての依存関係プロパティのテーブルへのインデックスアクセスはありません。 依存関係プロパティは、その識別子フィールドによって参照される必要があります。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A>は、を0から始まる配列インデックスとして使用<xref:System.Windows.DependencyProperty.GlobalIndex%2A>するデータ構造に高速にアクセスするために、内部的に使用されます。 同様の使用方法には、デザイナーまたはツールのアプリケーションが含まれる場合があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">チェックする値。</param>
        <summary>指定した値がこの依存関係プロパティの型で受け入れ可能かどうかを、依存関係プロパティの最初の登録で指定されたプロパティの型と照合することによって判断します。</summary>
        <returns>指定した値が登録済みのプロパティ型であるか、または受け入れ可能な派生型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値`null`が参照型の依存関係プロパティ、または<xref:System.Nullable%601>依存関係プロパティの有効な型であり、この`true`ような場合はを返します。 依存関係プロパティが参照<xref:System.Nullable%601>でも型でもない場合、は例外を発生させるのではなく、 <xref:System.Windows.DependencyProperty.IsValidType%2A> null 値に対してを返し`false`ます。  
  
   
  
## Examples  
 次の例で<xref:System.Windows.DependencyProperty.IsValidType%2A>は、依存関係プロパティ<xref:System.Windows.DependencyObject.SetValue%2A>でを呼び出す前に、をチェックとして使用します。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">チェックする値。</param>
        <summary>指定した値がプロパティの型で受け入れ可能かどうかを基本型チェックによって判断します。さらに、その型の有効値の範囲内にこの値があるかどうかを判断することもあります。</summary>
        <returns>値が受け入れ可能で、適切な型または派生型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの場合は、依存関係プロパティの登録で指定されたを<xref:System.Windows.ValidateValueCallback>使用して、その型の許容範囲の値を指定できます。  
  
 このメソッドは<xref:System.Windows.DependencyProperty.IsValidType%2A> 、を内部で呼び出します。 問題の依存関係プロパティにがない<xref:System.Windows.ValidateValueCallback>場合、このメソッドを呼び出すことは、 <xref:System.Windows.DependencyProperty.IsValidType%2A>実際にはを呼び出した場合と同じです。 依存関係プロパティにがあり<xref:System.Windows.ValidateValueCallback> <xref:System.Windows.DependencyProperty.IsValidType%2A> 、がを返し`true`た場合、返される値はコールバックに実装されます。  
  
 Null 値は参照型の依存関係プロパティ、または<xref:System.Nullable%601>依存関係プロパティの有効な値であり、このような場合にはを返し`true`ます。 依存関係プロパティが参照<xref:System.Nullable%601>でも型でもない場合、は例外を発生させるのではなく、 <xref:System.Windows.DependencyProperty.IsValidType%2A> null 値に対してを返し`false`ます。  
  
   
  
## Examples  
 次の例で<xref:System.Windows.DependencyProperty.IsValidValue%2A>は、依存関係プロパティ<xref:System.Windows.DependencyObject.SetValue%2A>でを呼び出す前に、をチェックとして使用します。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの名前を取得します。</summary>
        <value>プロパティの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、依存関係プロパティの`name`登録時にパラメーターとして指定された名前を取得します。 この名前は不変であり、また`null`は空の文字列にすることはできません。 同じ所有者の種類で重複する名前の登録は許可されていません。重複したを登録しようとすると、例外がスローされます。  
  
> [!IMPORTANT]
>  依存<xref:System.Windows.DependencyProperty.Name%2A>関係プロパティのは、依存関係プロパティの識別子の名前とサフィックス "property" を一致させる規則に従う必要があります。 詳細については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、 <xref:System.Windows.DependencyProperty.Name%2A>依存関係プロパティ識別子のさまざまな特性 (を含む) に対してクエリを行います。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型のインスタンスに存在する場合の代替メタデータをこの依存関係プロパティに提供します。この代替メタデータは、依存関係プロパティの最初の登録時に指定したメタデータの代わりに使用されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">この依存関係プロパティが継承され、指定した代替メタデータが適用される型。</param>
        <param name="typeMetadata">オーバーライドする型の依存関係プロパティに適用するメタデータ。</param>
        <summary>指定した型のインスタンスに存在する場合の代替メタデータをこの依存関係プロパティに提供し、基本型から継承されたときにこの依存関係プロパティに存在していたメタデータをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティのメタデータは、プロパティシステムが依存関係プロパティを使用する前にオーバーライドする必要があります。 これは、依存関係プロパティを登録するクラスを使用して、特定のインスタンスが作成された時刻に相当します。 の呼び出しは、このメソッドの`forType`パラメーターとして自身を提供する型の静的コンストラクター内、または同様のインスタンス化によってのみ実行されます。 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 所有者の型のインスタンスが存在した後にメタデータを変更しようとしても、例外は発生しませんが、プロパティシステムの動作が矛盾します。  
  
 このメソッドでは、特定の派生クラスに対するメタデータのオーバーライドが確立された後、この同じ派生クラスでメタデータをオーバーライドしようとすると、例外が発生します。  
  
 指定されたメタデータは、基本所有者に存在する依存関係プロパティのプロパティメタデータとマージされます。 元の基本メタデータで指定されたすべての特性が保持されます。新しいメタデータで特に変更された特性だけが、基本メタデータの特性を上書きします。 などの一部の<xref:System.Windows.PropertyMetadata.DefaultValue%2A>特性は、新しいメタデータで指定されている場合に置き換えられます。 などの他の<xref:System.Windows.PropertyChangedCallback>は、結合されます。 最終的には、マージ動作は、オーバーライドに使用されているプロパティメタデータ型に依存するため、ここで説明する動作は、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依存関係プロパティで使用される既存のプロパティメタデータクラスに対して行われます。 詳細については、「[依存関係プロパティのメタ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)データ」および「[フレームワークプロパティメタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">読み取り専用の依存関係プロパティでメタデータをオーバーライドしようとしました (このシグネチャを使用してこの操作を行うことはできません)。</exception>
        <exception cref="T:System.ArgumentException">指定した型に存在する場合のメタデータが、この依存関係プロパティに対して既に確立されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">この依存関係プロパティが継承され、指定した代替メタデータが適用される型。</param>
        <param name="typeMetadata">オーバーライドする型の依存関係プロパティに適用するメタデータ。</param>
        <param name="key">読み取り専用の依存関係プロパティのアクセス キー。</param>
        <summary>指定した型のインスタンスに存在する場合に代替メタデータを読み取り専用の依存関係プロパティに提供し、依存関係プロパティの最初の登録時に指定したメタデータをオーバーライドします。 例外の発生を防ぐために、読み取り専用の依存関係プロパティに <see cref="T:System.Windows.DependencyPropertyKey" /> を渡す必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このシグネチャは、読み取り専用の依存関係プロパティ識別子 (<xref:System.Windows.DependencyPropertyKey>) メソッドの基になる実装を提供します。 読み取り/書き込み依存関係プロパティのメタデータをオーバーライドする<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>場合は、を使用します。  
  
 依存関係プロパティのメタデータは、プロパティシステムが依存関係プロパティを使用する前にオーバーライドする必要があります。 これは、依存関係プロパティを登録するクラスに対して特定のオブジェクトが作成された時刻に相当します。 の呼び出しは、このメソッドの`forType`パラメーターとして自身を提供する型の静的コンストラクター内、または同様のインスタンス化によってのみ実行されます。 <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> 所有者の型のインスタンスが存在した後にメタデータを変更しようとしても、例外は発生しませんが、プロパティシステムの動作が矛盾します。  
  
 このメソッドでは、特定の派生クラスに対するメタデータのオーバーライドが確立された後、この同じ派生クラスでメタデータをオーバーライドしようとすると、例外が発生します。  
  
 指定されたメタデータは、基本所有者に存在する依存関係プロパティのプロパティメタデータとマージされます。 元の基本メタデータで指定されたすべての特性が保持されます。新しいメタデータで特に変更された特性だけが、基本メタデータの特性を上書きします。 などの一部の<xref:System.Windows.PropertyMetadata.DefaultValue%2A>特性は、新しいメタデータで指定されている場合に置き換えられます。 などの他の<xref:System.Windows.PropertyChangedCallback>は、結合されます。 マージ動作は、オーバーライドに使用されているプロパティメタデータ型によって異なります。 詳細については、「[依存関係プロパティのメタ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)データ」および「[フレームワークプロパティメタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティをプロパティ システムに登録したオブジェクト、または自身をプロパティの所有者として追加したオブジェクトの型を取得します。</summary>
        <value>プロパティを登録したオブジェクト、または自身をプロパティの所有者として追加したオブジェクトの型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値は、プロパティの登録時に指定されました。 所有者<xref:System.Windows.DependencyProperty>は、 <xref:System.Windows.DependencyProperty.Register%2A>呼び出しから生成された識別子の場合は元の登録型、 <xref:System.Windows.DependencyProperty.AddOwner%2A>呼び出しから生成された<xref:System.Windows.DependencyProperty>識別子の場合は自身を所有者として追加した型のいずれかになります。  
  
 指定<xref:System.Windows.DependencyProperty.OwnerType%2A>さ<xref:System.Windows.DependencyProperty>れたのは不変であり`null` 、有効<xref:System.Windows.DependencyProperty>なにはできません。  
  
   
  
## Examples  
 次の例では、依存関係プロパティの識別子`dp`に基づいて所有者の種類を取得し、その同じ識別子の所有者の型でメタデータを取得します。 この操作は、実際に<xref:System.Windows.DependencyProperty.DefaultMetadata%2A> `dp`はを取得するのと同じです。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値の型を取得します。</summary>
        <value>プロパティ値の <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、 `propertyType`パラメーターを使用して、元のプロパティの登録によって宣言されたプロパティの値の型を報告します。 <xref:System.Windows.DependencyProperty.Name%2A>と同様に、依存関係プロパティのプロパティ型は登録後に変更できません。  
  
   
  
## Examples  
 次の例では、 <xref:System.Windows.DependencyProperty.PropertyType%2A>依存関係プロパティ識別子のさまざまな特性 (を含む) に対してクエリを行います。 の<xref:System.Windows.DependencyProperty.PropertyType%2A>型名の文字列は、返さ<xref:System.Type>れたから取得されます。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyProperty" /> インスタンスによって識別される依存関係プロパティが読み取り専用の依存関係プロパティかどうかを示す値を取得します。</summary>
        <value>依存関係プロパティが読み取り専用の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取り専用の依存関係プロパティは、 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> <xref:System.Windows.DependencyProperty.Register%2A>メソッドではなくメソッドを呼び出すことによって、プロパティシステム内に登録されます。 添付プロパティは、読み取り専用として登録することもできます。「 <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>」を参照してください。  
  
 読み取り専用の依存関係プロパティに<xref:System.Windows.DependencyPropertyKey>は、メタデータ<xref:System.Windows.DependencyProperty>のオーバーライドや値の設定などのメタデータ操作を実行するために、識別子ではなく識別子を指定する必要があります。 または識別子を公開する<xref:System.Windows.DependencyProperty>別[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]のを<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>呼び出して識別子のコレクションを取得した場合<xref:System.Windows.DependencyProperty.ReadOnly%2A>は、を呼び出す<xref:System.Windows.DependencyObject.SetValue%2A>前に<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>値を確認してください。入力パラメーターとしての依存関係プロパティ識別子。識別子が表す依存関係プロパティが読み取り専用でないことを確認します。 の<xref:System.Windows.DependencyProperty.ReadOnly%2A>値が`true`依存関係プロパティにある場合、その依存関係<xref:System.Windows.DependencyProperty>プロパティの<xref:System.Windows.DependencyPropertyKey>識別子への参照を、メタデータから、または識別子から取得するためのプログラム的な方法はありません。は、読み取り専用の依存関係プロパティに対して<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>を呼び出すために、静的フィールドとして使用できる必要があります。  
  
 カスタム依存関係プロパティを作成し、読み取り専用として登録する場合は、 [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]ラッパープロパティの get アクセサーのみを定義する必要があります。 それ以外の場合は、バッキング依存関係プロパティへのアクセスと比較して、クラスにプロパティラッパーの混乱したオブジェクトモデルが含まれます。 詳細については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」または「読み取り専用の[依存関係プロパティ](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティのフィールドから既定のメタデータと依存関係プロパティの識別子プロパティを取得し、情報を使用してテーブルに "メタデータブラウザー" を実装します。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依存プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。 名前は、所有者型の登録名前空間内で一意である必要があります。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録する所有者型。</param>
        <summary>プロパティ名、プロパティ型、所有者型を指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ名、プロパティの型、所有者の型、プロパティ メタデータを指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるコールバックへの参照。</param>
        <summary>プロパティ名、プロパティ型、所有者型、プロパティ メタデータ、およびプロパティの値検証コールバックを指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
   
  
## Examples  
 次の例では、検証コールバックを含む依存関係プロパティを登録します (コールバック定義は表示されません<xref:System.Windows.ValidateValueCallback>。コールバック定義の詳細については、「」を参照してください)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>添付プロパティをプロパティ システムに登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録する所有者型。</param>
        <summary>プロパティ名、プロパティ型、および所有者型を指定して、添付プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティは、によっ[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]て定義されるプロパティの概念です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティを依存関係プロパティとして実装します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティは依存関係プロパティであるため、レポートレイアウト特性などの操作の一般的なプロパティシステムで使用できるメタデータを適用できます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
   
  
## Examples  
 次の例では、この<xref:System.Windows.DependencyProperty.RegisterAttached%2A>シグネチャを使用して、抽象クラスに添付プロパティを登録します。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。 ここには、既定値などの特性を含めることができます。</param>
        <summary>プロパティ名、プロパティの型、所有者の型、およびプロパティ メタデータを指定して、アタッチされるプロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティは、によっ[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]て定義されるプロパティの概念です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティを依存関係プロパティとして実装します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティは依存関係プロパティであるため、レポートレイアウト特性などの操作の一般的なプロパティシステムで使用できるメタデータを適用できます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 の代わりに依存関係プロパティをに<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登録する特定のシナリオの1つは、プロパティ値の<xref:System.Windows.DependencyProperty.Register%2A>継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサー <xref:System.Windows.DependencyProperty.RegisterAttached%2A>をクラスで定義する場合でも、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータ<xref:System.Windows.DependencyProperty.RegisterAttached%2A>で指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>するプロパティを登録するには、常にを使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。 ここには、既定値などの特性を含めることができます。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および値の検証コールバックを指定して、添付プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティは、によっ[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]て定義されるプロパティの概念です。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティを依存関係プロパティとして実装します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティは依存関係プロパティであるため、レポートレイアウト特性などの操作の一般的なプロパティシステムで使用できるメタデータを適用できます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 の代わりに依存関係プロパティをに<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登録する特定のシナリオの1つは、プロパティ値の<xref:System.Windows.DependencyProperty.Register%2A>継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサー <xref:System.Windows.DependencyProperty.RegisterAttached%2A>をクラスで定義する場合でも、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータ<xref:System.Windows.DependencyProperty.RegisterAttached%2A>で指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>するプロパティを登録するには、常にを使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、この<xref:System.Windows.DependencyProperty.RegisterAttached%2A>シグネチャを使用して、抽象クラスに添付プロパティを登録します。 この添付プロパティは列挙型のプロパティであり、登録は検証コールバックを追加して、指定された値が列挙体の値であることを確認します。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み取り専用添付プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ型、所有者型、およびプロパティ メタデータを指定して、読み取り専用の添付プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要がある依存関係プロパティのキー。これは後で依存関係プロパティの参照に使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは型<xref:System.Windows.DependencyPropertyKey> <xref:System.Windows.DependencyProperty.RegisterAttached%2A>を返しますが、は<xref:System.Windows.DependencyProperty>型を返します。 通常、読み取り専用プロパティを表すキーは公開されません。これは、を呼び出す<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>ことで、キーを使用して依存関係プロパティの値を設定できるためです。 クラスの<xref:System.Windows.DependencyPropertyKey>設計は要件に影響を与えますが、通常は、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみにアクセスと可視性を制限することをお勧めします。 また、の<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>値をクラスの`public static readonly`フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 添付プロパティの主要なシナリオはで[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]使用されるため、読み取り専用の添付プロパティはまれなシナリオです。 パブリック setter を使用しない場合、添付プロパティを構文[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]で設定することはできません。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 依存関係プロパティを添付として登録するための特定のシナリオの1つは、プロパティ値の継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサー <xref:System.Windows.DependencyProperty.RegisterAttached%2A>をクラスで定義する場合でも、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータ<xref:System.Windows.DependencyProperty.RegisterAttached%2A>で指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>するプロパティを登録するには、常にを使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるユーザー作成のコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを指定して、読み取り専用の添付プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用され、次いで依存関係プロパティの参照に使用される、依存関係プロパティのキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは型<xref:System.Windows.DependencyPropertyKey> <xref:System.Windows.DependencyProperty.RegisterAttached%2A>を返しますが、は<xref:System.Windows.DependencyProperty>型を返します。 通常、型<xref:System.Windows.DependencyProperty>を表すキー。 通常、読み取り専用プロパティを表すキーは公開されません。これは、を呼び出す<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>ことで、キーを使用して依存関係プロパティの値を設定できるためです。 クラスの<xref:System.Windows.DependencyPropertyKey>設計は要件に影響を与えますが、通常は、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみにアクセスと可視性を制限することをお勧めします。 また、の<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>値をクラスの`public static readonly`フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 添付プロパティの主要なシナリオはで[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]使用されるため、読み取り専用の添付プロパティはまれなシナリオです。 パブリック setter を使用しない場合、添付プロパティを構文[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]で設定することはできません。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>値を継承する依存関係プロパティに RegisterAttached を使用する  
 の代わりに依存関係プロパティを添付として登録<xref:System.Windows.DependencyProperty.Register%2A>する特定のシナリオの1つは、プロパティ値の継承をサポートすることです。 依存関係プロパティを公開するプロパティラッパーアクセサー <xref:System.Windows.DependencyProperty.RegisterAttached%2A>をクラスで定義する場合でも、Get * および Set * 静的メソッドを公開して true をアタッチする予定がない場合でも、値を継承する依存関係プロパティを登録する必要があります。プロパティサポートアクセサー。   プロパティ値の継承は非添付依存関係プロパティに対して機能するように見えますが、ランタイムツリー内の特定の要素境界を通じて非添付プロパティの継承動作は未定義です。 プロパティをアタッチ済みとして登録すると、添付プロパティがプロパティシステムにグローバルプロパティとして適用され、プロパティ値の継承が要素ツリー内のすべての境界にわたって機能するようになります。 メタデータ<xref:System.Windows.DependencyProperty.RegisterAttached%2A>で指定<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>するプロパティを登録するには、常にを使用します。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み取り専用の依存関係プロパティとして、依存関係プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータを指定して、読み取り専用の依存関係プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用され、次いで依存関係プロパティの参照に使用される、依存関係プロパティのキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは型<xref:System.Windows.DependencyPropertyKey> <xref:System.Windows.DependencyProperty.RegisterAttached%2A>を返しますが、は<xref:System.Windows.DependencyProperty>型を返します。 通常、読み取り専用プロパティを表すキーは公開されません。これは、を呼び出す<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>ことで、キーを使用して依存関係プロパティの値を設定できるためです。 クラスの<xref:System.Windows.DependencyPropertyKey>設計は要件に影響を与えますが、通常は、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみにアクセスと可視性を制限することをお勧めします。 また、の<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>値をクラスの`public static readonly`フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 読み取り専用の依存関係プロパティは、既存[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]のとカスタマイズのシナリオにおいて非常に一般的なシナリオです。他の[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]機能では、そのプロパティがによって設定されることを意図していない場合でも依存関係プロパティが必要になる可能性があるためです。元. 読み取り専用の依存関係プロパティの値は、スタイルの依存関係プロパティ<xref:System.Windows.Trigger>でのベースなど、依存関係プロパティを受け取る他のプロパティシステム操作の基準として使用できます。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
   
  
## Examples  
 次の例では`AquariumSize` 、依存関係プロパティを読み取り専用として登録します。 この例で`AquariumSizeKey`は、(アセンブリ内の他のクラスがメタデータをオーバーライドできるように) 内部キーとしてを定義し、 `AquariumSizeProperty`そのキーに基づいて依存関係プロパティ識別子をとして公開します。 また、get アクセサーのみを使用`AquariumSize`して、のラッパーが作成されます。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるユーザー作成のコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを指定して、読み取り専用の依存関係プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要がある依存関係プロパティのキー。これは後で依存関係プロパティの参照に使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは型<xref:System.Windows.DependencyPropertyKey> <xref:System.Windows.DependencyProperty.RegisterAttached%2A>を返しますが、は<xref:System.Windows.DependencyProperty>型を返します。 通常、読み取り専用プロパティを表すキーは公開されません。これは、を呼び出す<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>ことで、キーを使用して依存関係プロパティの値を設定できるためです。 クラスの<xref:System.Windows.DependencyPropertyKey>設計は要件に影響を与えますが、通常は、クラスまたはアプリケーションロジックの一部としてその依存関係プロパティを設定するために必要なコード部分のみにアクセスと可視性を制限することをお勧めします。 また、の<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>値をクラスの`public static readonly`フィールドとして公開することによって、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することもお勧めします。  
  
 読み取り専用の依存関係プロパティは、非常に一般的なシナリオです。 読み取り専用の依存関係プロパティの値は、スタイルの依存関係プロパティ<xref:System.Windows.Trigger>でのベースなど、依存関係プロパティを受け取る他のプロパティシステム操作の基準として使用できます。  
  
 依存関係プロパティの登録の詳細につい<xref:System.Windows.DependencyProperty>ては、「」を参照してください。  
  
 読み取り専用の依存関係プロパティでの検証は、重要度が低い場合があります。 キーに指定した非パブリックアクセスレベルにより、任意の無効な入力の可能性が減少します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>依存関係プロパティの文字列表現を返します。</summary>
        <returns>依存関係プロパティの文字列表現。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装は、 <xref:System.Windows.DependencyProperty.Name%2A>プロパティ値を返します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティは存在するが、その値がプロパティ システムによって設定されていないことを示すために、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティ システムが <see langword="null" /> の代わりに使用する静的な値を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue>は、 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]プロパティシステムが要求さ<xref:System.Windows.DependencyProperty>れた値を特定できない場合に使用される sentinel 値です。 <xref:System.Windows.DependencyProperty.UnsetValue>は`null`、有効なプロパティ値`null`であり、有効な (および頻繁に使用される) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>可能性があるので、ではなく使用されます。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>はから返さ<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>れません。 インスタンスの依存<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>関係プロパティに対してを呼び出すと、次のいずれかが適用されます。 <xref:System.Windows.DependencyObject>  
  
-   依存関係プロパティには、メタデータに既定値が設定されており、その値が返されます。 この値はから<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>取得できます。  
  
-   他の値がプロパティシステムによって設定されており、既定値が関連していません。 詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。  
  
 のの<xref:System.Windows.PropertyMetadata.DefaultValue%2A> <xref:System.Windows.DependencyProperty.UnsetValue>設定は、特に許可されていません。  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType>要求<xref:System.Windows.DependencyProperty.UnsetValue>されたプロパティがローカルに設定されていない場合は、を返します。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue>は、 <xref:System.Windows.CoerceValueCallback>の戻り値として使用される場合に特別な意味を持ちます。 詳細については、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
 データベースにバインドする場合、はと<xref:System.Windows.DependencyProperty.UnsetValue> <xref:System.DBNull.Value>等価でないことに注意してください。これは、 <xref:System.DBNull.Value>が true null と等しいかどうかに似ています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値検証コールバックを取得します。</summary>
        <value>依存関係プロパティを最初に登録するときに <paramref name="validateValueCallback" /> パラメーターで指定した、この依存関係プロパティの値検証コールバック。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティには`null` 、検証コールバックが登録されていないすべての依存関係プロパティのが含まれます。  
  
 検証値のコールバックは静的な意味で動作する必要<xref:System.Windows.ValidateValueCallback>があります。で適用される検証では、指定された値が特定のインスタンスに対して有効かどうかを判断できません。 コールバックは、依存関係プロパティを持つすべてのオブジェクトが、指定された値を有効なものとして受け入れるかどうかを判断するだけです。 特定のインスタンスの他の依存関係プロパティの値を知ることに依存する検証を実行する必要が<xref:System.Windows.CoerceValueCallback>ある場合は、代わりにを使用します。 は<xref:System.Windows.CoerceValueCallback> 、依存関係プロパティの識別子内で直接ではなく、依存関係プロパティのメタデータの一部として登録されます。 詳細については、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>
