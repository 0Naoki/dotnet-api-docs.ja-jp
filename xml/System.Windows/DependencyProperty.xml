<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="48e189814c9d38e818a9d416a18db9a92e096f66" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48623038" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>スタイル設定、データ バインディング、アニメーション、および継承などの方法によって設定できるプロパティを表します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A<xref:System.Windows.DependencyProperty>で次の機能をサポートしている[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   スタイルのプロパティを設定できます。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
-   プロパティは、データ バインドを通じて設定できます。 データ バインディングの依存関係プロパティの詳細については、次を参照してください。[方法: 2 つのコントロールのプロパティをバインド](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)します。  
  
-   動的リソース参照では、プロパティを設定できます。 詳細については、「[XAML リソース](~/docs/framework/wpf/advanced/xaml-resources.md)」を参照してください。  
  
-   プロパティは、要素ツリーの親要素からその値を自動的に継承できます。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
-   プロパティをアニメーション化することができます。 詳しくは、「 [アニメーションの概要](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)」をご覧ください。  
  
-   プロパティは、プロパティの以前の値が変更されましたが、プロパティの値を強制的に変換できる場合に報告できます。 詳しくは、「[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)」を参照してください。  
  
-   プロパティに情報を報告する[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]プロパティ値を変更してビジュアル要素を再構成するには、レイアウト システムを必要する必要があるかどうかなど、します。  
  
-   プロパティでのサポートの受信、[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]します。  プロパティの編集など、**プロパティ**ウィンドウ。  
  
 依存関係プロパティの詳細については、次を参照してください。[依存関係プロパティの概要](~/docs/framework/wpf/advanced/dependency-properties-overview.md)します。 上記の一覧で、機能をサポートするカスタム型のプロパティをする場合は、依存関係プロパティを作成する必要があります。  カスタム依存関係プロパティを作成する方法については、次を参照してください。[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)します。  
  
 添付プロパティは、任意のオブジェクトを添付プロパティを定義する型情報を報告できるようにするプロパティです。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]、任意の型から継承する<xref:System.Windows.DependencyObject>プロパティを定義する型から継承する型かどうかに関係なく、添付プロパティを使用することができます。 添付プロパティの機能である、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]言語。  添付プロパティを設定する[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]を使用して、 *ownerType*.*propertyName*構文。 添付プロパティの例は、<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>プロパティ。 かどうかは、すべてで使用できるプロパティを作成する<xref:System.Windows.DependencyObject>型の場合は、添付プロパティを作成する必要があります。 添付プロパティをそれらを作成する方法などの詳細についてを参照してください。[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)します。  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>XAML 値  
 `dependencyPropertyName`  
 指定する文字列、<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>の必要な依存関係プロパティ。 これは、前に、XML 名前空間プレフィックス プロパティが既定の XML 名前空間にない場合 (詳細については、次を参照してください[XAML 名前空間および WPF XAML のマッピングの Namespace](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。)。  
  
 `ownerType`.`dependencyPropertyName`  
 ドット (.)、依存関係プロパティの所有者の種類を指定する文字列、<xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>します。 `ownerType` XML 名前空間プレフィックスによっても前ことができます。 この使用状況は遅延バインディングのスタイルとテンプレート、ために、コンテキストを解析するため、依存関係プロパティの所有者を指定する必要がありますを特定、`TargetType`が不明です。 詳しくは、「 [スタイルとテンプレート](~/docs/framework/wpf/controls/styling-and-templating.md)」をご覧ください。  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 ドット (.)、添付プロパティ名では、添付プロパティの所有者を指定する文字列。 `attachedPropertyOwnerType` XML 名前空間プレフィックスによっても前ことができます。  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>既に登録済みの依存関係プロパティの所有者として、ある型に別の型を追加します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">この依存関係プロパティの所有者として追加する型。</param>
        <summary>登録済みの依存関係プロパティの所有者として、別の型を追加します。</summary>
        <returns>依存関係プロパティを識別する元の <see cref="T:System.Windows.DependencyProperty" /> 識別子への参照。 この識別子は、追加元クラスにより、<see langword="public static readonly" /> フィールドとして公開される必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、その特定の依存関係プロパティを最初に登録していない型に依存関係プロパティを認識する、プロパティ システムを使用します。  
  
 通常、<xref:System.Windows.DependencyProperty.AddOwner%2A>依存関係プロパティは、既にマネージ クラスの継承を通じてその依存関係プロパティを公開するクラスを追加するために使用 (クラスの継承は、派生クラスによって継承するラッパー プロパティになると、それに伴って依存関係プロパティへのアクセスの一般的なメンバー テーブル既に) できます。 <xref:System.Windows.DependencyProperty.AddOwner%2A> その依存関係プロパティを最初に登録していない型に依存関係プロパティを認識する、プロパティ システムを有効にします。  
  
 メタデータを指定するのには、この署名することはできません。  このメソッドを使用すると、メタデータが新しい自動的に生成<xref:System.Windows.DependencyProperty>とその所有者の種類。 自動生成されたメタデータは、このプロパティが定義されている基本型のすべてからマージされたメタデータの結果です。 マージされたメタデータが使用できない場合は、プロパティの既定のメタデータが使用されます。 使用して、プロパティが登録されている場合、<xref:System.Windows.DependencyProperty.RegisterAttached%2A>メソッド、既定のメタデータはときに作成されるメタデータと同じ<xref:System.Windows.DependencyProperty.RegisterAttached%2A>が呼び出されました。 それ以外の場合、<xref:System.Windows.PropertyMetadata>オブジェクトを作成すると、<xref:System.Windows.PropertyMetadata.DefaultValue%2A>プロパティがプロパティの型の既定値を他のすべてのプロパティの設定、<xref:System.Windows.PropertyMetadata>に設定されている`null`します。 使用して、<xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>署名が指定された型に追加されると、依存関係プロパティのバージョンのメタデータを提供したい場合。  
  
 このメソッドの戻り値は通常を宣言し、依存関係プロパティの識別子を格納することにより、依存関係プロパティを公開に使用されます。 プロパティ システムを呼び出そうとする場合、識別子は、依存関係プロパティへのアクセスを提供します。 [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] 、依存関係プロパティに対して特にこれが存在して、追加の所有者クラスにします。 元の所有者と追加された所有者の両方に同じプロパティ名を同様の機能を示すために使用する必要があります。 使用する必要があります、<xref:System.Windows.DependencyProperty>の値を返す、<xref:System.Windows.DependencyProperty.AddOwner%2A>依存関係プロパティの識別子を定義し、宣言メソッド[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]を使用して型に追加される依存関係プロパティのプロパティ ラッパー<xref:System.Windows.DependencyProperty.AddOwner%2A>します。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>内で宣言されている依存関係プロパティを作成するときに、前述の推奨される手法が使用される[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]します。 たとえば、両方<xref:System.Windows.Controls.Border>と<xref:System.Windows.Controls.Control>定義、`BorderBrush`依存関係プロパティは、同様の機能があります。 <xref:System.Windows.Controls.Control> 定義の`BorderBrush`プロパティを呼び出すことによって、プロパティ システム<xref:System.Windows.DependencyProperty.AddOwner%2A>元の所有者に基づく<xref:System.Windows.Controls.Border>、登録されていると<xref:System.Windows.Controls.Border.BorderBrushProperty>依存関係プロパティ識別子。 <xref:System.Windows.DependencyProperty.AddOwner%2A>戻り値の値が新しい静的を確立するために使用し、<xref:System.Windows.DependencyProperty>フィールド (<xref:System.Windows.Controls.Control.BorderBrushProperty>) に追加された所有者では、そのプロパティの`BorderBrush`プロパティ ラッパーも宣言されています。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">この依存関係プロパティの所有者として追加する型。</param>
        <param name="typeMetadata">提供される型に存在する依存関係プロパティを修飾するメタデータ。</param>
        <summary>既に登録済みの依存関係プロパティの所有者として別の型を追加します。その際、提供される所有者の型に存在する依存関係プロパティに依存関係プロパティのメタデータを提供します。</summary>
        <returns>依存関係プロパティを識別する元の <see cref="T:System.Windows.DependencyProperty" /> 識別子への参照。 この識別子は、追加元クラスにより、<see langword="public static readonly" /> フィールドとして公開される必要があります。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、その特定の依存関係プロパティを最初に登録していない型に依存関係プロパティを認識する、プロパティ システムを使用します。  
  
 このメソッドの戻り値は、所有者の追加のクラスには存在するために特にもを宣言し、依存関係プロパティが公開されます。 一般に、元の所有者と追加された所有者の両方に同じプロパティ名を使用して、同様の機能を示す必要があります。 新しいも、識別子を公開することをお勧めは[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]を使用して型に追加される依存関係プロパティのプロパティ ラッパー<xref:System.Windows.DependencyProperty.AddOwner%2A>します。  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A>作成するときに、前述の推奨される手法が使用される[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]内で宣言された[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]します。 たとえば、両方<xref:System.Windows.Controls.Border>と<xref:System.Windows.Controls.Control>定義、`BorderBrush`依存関係プロパティは、同様の機能があります。 <xref:System.Windows.Controls.Control> 定義の`BorderBrush`プロパティを呼び出すことによって、プロパティ システム<xref:System.Windows.DependencyProperty.AddOwner%2A>元の所有者に<xref:System.Windows.Controls.Border>、登録されていると<xref:System.Windows.Controls.Border.BorderBrushProperty>依存関係プロパティ識別子。 <xref:System.Windows.DependencyProperty.AddOwner%2A>戻り値の値は、静的なを確立するために使用し、<xref:System.Windows.DependencyProperty>フィールド (<xref:System.Windows.Controls.Control.BorderBrushProperty>) に追加された所有者では、そのプロパティの`BorderBrush`プロパティ ラッパーも宣言されています。  
  
 追加した所有者の依存関係プロパティ識別子をなど操作に使用する必要があります<xref:System.Windows.DependencyObject.GetValue%2A>します。 ただし、種類、またはさまざまなメタデータで所有者があるように追加されたクラスのインスタンスに関連する型固有の操作を返すいても、期待どおりの結果、元の (いない、追加した所有者の) で依存関係プロパティ識別子が指定されました。などのメソッドを呼び出し<xref:System.Windows.DependencyObject.GetValue%2A>または<xref:System.Windows.DependencyProperty.GetMetadata%2A>します。 によって追加された所有者のメタデータを永続的なものは、<xref:System.Windows.DependencyProperty.AddOwner%2A>所有者クラス識別子フィールドの追加によって排他的参照必ずしもそれ自体を呼び出します。 それにもかかわらずも、新しい識別子を公開することをお勧めは[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]を使用して型に追加される依存関係プロパティのプロパティ ラッパー<xref:System.Windows.DependencyProperty.AddOwner%2A>これに失敗の間に不一致が作成されるため、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]と[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] 、プロパティの表現。  
  
 指定したメタデータは、基本の所有者に存在する依存関係プロパティのプロパティのメタデータに統合されます。 元の基本メタデータで指定されたすべての特性が保持されます。 基本のメタデータの特性は、新しいメタデータに変更された具体的には特性のみが上書きされます。 いくつかの特性など<xref:System.Windows.PropertyMetadata.DefaultValue%2A>、新しいメタデータで指定されている場合は置き換えられます。 他のユーザーなど<xref:System.Windows.PropertyChangedCallback>、結合されます。 最終的には、マージ動作によって異なりますので、ここで説明されている動作で使用される既存のプロパティのメタデータ クラス用のオーバーライドで使用されているプロパティのメタデータ型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依存関係プロパティ。 詳細については、次を参照してください。[依存関係プロパティ メタデータ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)と[フレームワーク プロパティ メタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの既定のメタデータを取得します。</summary>
        <value>依存関係プロパティの既定のメタデータ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定のメタデータは、代替メタデータが指定されていませんが、明示的な特定のオブジェクトまたは派生型のオブジェクトに提供されるプロパティのメタデータ<xref:System.Windows.DependencyProperty.Register%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>呼び出します。  
  
 元の所有者では、最初にメタデータが適用される場合<xref:System.Windows.DependencyProperty.Register%2A>としてそのメタデータが返されます、依存関係プロパティを確立されている呼び出し<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>します。  
  
 元のメタデータが適用されていない場合<xref:System.Windows.DependencyProperty.Register%2A>内から既定のメタデータを生成しを呼び出す、<xref:System.Windows.DependencyProperty.Register%2A>として呼び出しと、この値が返されます、<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>します。  
  
 関連付けられている既定のメタデータの主な目的、<xref:System.Windows.DependencyProperty>いずれかでこのプロパティの既定値を指定することが<xref:System.Windows.DependencyObject>または派生型。  
  
 派生型に非添付プロパティは、このプロパティによって返されるメタデータの型をキャストできません<xref:System.Windows.PropertyMetadata>派生メタデータ型のプロパティが最初に登録された場合でも、入力します。 元のメタデータの可能性がある派生型を含む最初に登録されているメタデータを実行する場合に、呼び出す<xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29>をパラメーターとして代わりに、入力元の登録を渡します。  
  
 添付プロパティは、このプロパティによって返されるメタデータの型が元の指定された型を一致<xref:System.Windows.DependencyProperty.RegisterAttached%2A>登録メソッド。  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyProperty" /> のハッシュ コードを返します。</summary>
        <returns>この <see cref="T:System.Windows.DependencyProperty" /> のハッシュ コード。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ システムは、独自の一意の識別子を使用して<xref:System.Windows.DependencyProperty.GlobalIndex%2A>、そのプロパティの値がによって返されると<xref:System.Windows.DependencyProperty.GetHashCode%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>特定の型のメタデータが存在する場合、この依存関係プロパティに関連付けられているメタデータを返します。 依存関係プロパティが最初に登録された型、その後で依存関係プロパティが追加された型、または継承を通じて依存関係プロパティが取得され、そのメタデータが明確にオーバーライドされた型を指定できます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">依存関係プロパティのメタデータを取得する対象の特定の型。</param>
        <summary>指定した既存の型に存在する場合の、この依存関係プロパティのメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 型、または型の型が必要な元の登録のいずれかからメタデータが異なるので、使用するオブジェクト参照を指定する<xref:System.Windows.DependencyProperty.AddOwner%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>の呼び出しを型に存在する依存関係プロパティのメタデータを変更します。  
  
   
  
## Examples  
 次の例では、その型に基づいて依存関係プロパティのメタデータを取得します。 使用して、型を取得、`typeof`演算子。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">メタデータの取得元となる依存関係プロパティの型固有のバージョンを確認するために型をチェックするときの、対象となる依存関係オブジェクト。</param>
        <summary>この依存関係プロパティのメタデータが指定したオブジェクト インスタンスに存在する場合に、このメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 または型のオブジェクト参照が、指定するために必要な元の登録のいずれかから、指定された依存関係プロパティのメタデータが異なるので<xref:System.Windows.DependencyProperty.AddOwner%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>に存在するプロパティのメタデータを絞り込むことができますを呼び出し、入力します。  
  
 インスタンスに基づくプロパティのメタデータを要求するときにその型を内部的に評価できるように、インスタンスを渡しているにすぎません。 依存関係プロパティ メタデータがインスタンスごとに異なるされません。任意の型のプロパティの組み合わせの一貫性が常にあります。  
  
   
  
## Examples  
 次の例では、特定に基づいて依存関係プロパティのメタデータを取得する<xref:System.Windows.DependencyObject>インスタンス。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">依存関係プロパティ メタデータの取得元となる依存関係オブジェクト型を記録する特定のオブジェクト。</param>
        <summary>指定した型に存在する場合の、この依存関係プロパティのメタデータを返します。</summary>
        <returns>プロパティ メタデータ オブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 または型のオブジェクト参照が、指定するために必要な元の登録のいずれかから、指定された依存関係プロパティのメタデータが異なるので<xref:System.Windows.DependencyProperty.AddOwner%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>に存在するプロパティのメタデータを絞り込むことができますを呼び出し、入力します。  
  
   
  
## Examples  
 次の例に基づく依存関係プロパティのメタデータを取得します。 その<xref:System.Windows.DependencyObjectType>します。  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティを一意に識別する内部的に生成された値を取得します。</summary>
        <value>一意の数値識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値は、整数、グローバル一意識別子 (GUID) ありません。 一般に、このインデックスの値を使用する必要はありませんし、すべての依存関係プロパティのテーブルにインデックスへのアクセスはありません。 依存関係プロパティが代わりに、識別子フィールドで参照されている必要があります。  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> 使用するデータ構造へのアクセス速度を内部的に使用されます、<xref:System.Windows.DependencyProperty.GlobalIndex%2A>として、配列の 0 から始まるインデックス。 アプリケーションの設計者またはツールのような使用状況があります。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">確認する値。</param>
        <summary>指定した値がこの依存関係プロパティの型で受け入れ可能かどうかを、依存関係プロパティの最初の登録で指定されたプロパティの型と照合することによって判断します。</summary>
        <returns>指定した値が登録済みのプロパティ型であるか、または受け入れ可能な派生型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値`null`または参照型の依存関係プロパティの有効な型には、 <xref:System.Nullable%601> 、依存関係プロパティを返す`true`ような場合。 依存関係プロパティのどちらの参照がある場合も、<xref:System.Nullable%601>型、<xref:System.Windows.DependencyProperty.IsValidType%2A>が返されます`false`例外を発生ではなく null 値。  
  
   
  
## Examples  
 次の例では<xref:System.Windows.DependencyProperty.IsValidType%2A>チェックを呼び出す前として<xref:System.Windows.DependencyObject.SetValue%2A>依存関係プロパティ。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">確認する値。</param>
        <summary>指定した値がプロパティの型で受け入れ可能かどうかを基本型チェックによって判断します。さらに、その型の有効値の範囲内にこの値があるかどうかを判断することもあります。</summary>
        <returns>値が受け入れ可能で、適切な型または派生型である場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 を通じて依存関係プロパティの場合は、その型の値の許容の範囲を指定できます、<xref:System.Windows.ValidateValueCallback>依存関係プロパティの登録で提供されています。  
  
 このメソッドを呼び出す<xref:System.Windows.DependencyProperty.IsValidType%2A>内部的にします。 対象の依存関係プロパティがにない場合<xref:System.Windows.ValidateValueCallback>を呼び出すことと事実上同じではこのメソッドを呼び出す<xref:System.Windows.DependencyProperty.IsValidType%2A>します。 依存関係プロパティが設定されている場合、 <xref:System.Windows.ValidateValueCallback>、場合<xref:System.Windows.DependencyProperty.IsValidType%2A>が返される`true`コールバックで実装された、値が返されます。  
  
 Null 値は、参照型の依存関係プロパティの有効な値の<xref:System.Nullable%601>、依存関係プロパティを返す`true`ような場合。 依存関係プロパティのどちらの参照がある場合も、<xref:System.Nullable%601>型、<xref:System.Windows.DependencyProperty.IsValidType%2A>が返されます`false`例外を発生ではなく null 値。  
  
   
  
## Examples  
 次の例では<xref:System.Windows.DependencyProperty.IsValidValue%2A>チェックを呼び出す前として<xref:System.Windows.DependencyObject.SetValue%2A>依存関係プロパティ。  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの名前を取得します。</summary>
        <value>プロパティの名前。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティで指定された名前を取得する、`name`依存関係プロパティの登録時にパラメーター。 この名前は変更できないとすることはできません`null`または空の文字列。 同じ所有者型で重複する名前登録では、許可されていないと、重複を登録しようとしたときに例外がスローされます。  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A>プロパティの依存関係の"Property"というサフィックスを差し引いたその依存関係プロパティ識別子の名前と一致する規則に従う必要があります。 詳細については、「[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)」を参照してください。  
  
   
  
## Examples  
 次の例のクエリの依存関係プロパティ識別子では、さまざまな特性など、<xref:System.Windows.DependencyProperty.Name%2A>します。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定した型のインスタンスに存在する場合の代替メタデータをこの依存関係プロパティに提供します。この代替メタデータは、依存関係プロパティの最初の登録時に指定したメタデータの代わりに使用されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">この依存関係プロパティが継承され、指定した代替メタデータが適用される型。</param>
        <param name="typeMetadata">オーバーライドする型の依存関係プロパティに適用するメタデータ。</param>
        <summary>指定した型のインスタンスに存在する場合の代替メタデータをこの依存関係プロパティに提供し、基本型から継承されたときにこの依存関係プロパティに存在していたメタデータをオーバーライドします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティ システムは、依存関係プロパティを使用する前に、依存関係プロパティ メタデータをオーバーライドする必要があります。 これは、特定のインスタンスは、依存関係プロパティを登録するクラスを使用して作成された時間に相当します。 呼び出す<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>として自体を提供する型の静的コンス トラクター内でのみ実行する必要があります、`forType`またはのようなインスタンス化で、このメソッドのパラメーター。 インスタンス所有者の種類の存在にメタデータを変更しようとしてください。 例外は発生しませんが、プロパティ システムに一貫性のない動作が発生します。  
  
 このメソッドを使用して特定の派生クラスのオーバーライドのメタデータが確立されると、この同じ派生クラスのメタデータをオーバーライドしようで例外が発生します。  
  
 指定したメタデータは、基本の所有者に存在する依存関係プロパティのプロパティのメタデータに統合されます。 元の基本メタデータで指定されたすべての特性が保持されます。基本のメタデータの特性は、新しいメタデータに変更された具体的には特性のみが上書きされます。 いくつかの特性など<xref:System.Windows.PropertyMetadata.DefaultValue%2A>新しいメタデータで指定されている場合は置き換えられます。 他のユーザーなど<xref:System.Windows.PropertyChangedCallback>、結合されます。 最終的には、マージ動作によって異なりますので、ここで説明されている動作で使用される既存のプロパティのメタデータ クラス用のオーバーライドで使用されているプロパティのメタデータ型[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]依存関係プロパティ。 詳細については、次を参照してください。[依存関係プロパティ メタデータ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)と[フレームワーク プロパティ メタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)します。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">読み取り専用の依存関係プロパティでメタデータをオーバーライドしようとしました (このシグネチャを使用してこの操作を行うことはできません)。</exception>
        <exception cref="T:System.ArgumentException">指定した型に存在する場合のメタデータが、この依存関係プロパティに対して既に確立されています。</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">この依存関係プロパティが継承され、指定した代替メタデータが適用される型。</param>
        <param name="typeMetadata">オーバーライドする型の依存関係プロパティに適用するメタデータ。</param>
        <param name="key">読み取り専用の依存関係プロパティのアクセス キー。</param>
        <summary>指定した型のインスタンスに存在する場合に代替メタデータを読み取り専用の依存関係プロパティに提供し、依存関係プロパティの最初の登録時に指定したメタデータをオーバーライドします。 例外の発生を防ぐために、読み取り専用の依存関係プロパティの <see cref="T:System.Windows.DependencyPropertyKey" /> を渡す必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この署名は、読み取り専用の依存関係プロパティの識別子の基になる実装を提供します (<xref:System.Windows.DependencyPropertyKey>) メソッドです。 読み取り/書き込み依存関係プロパティのメタデータをオーバーライドする場合は、使用<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>します。  
  
 プロパティ システムは、依存関係プロパティを使用する前に、依存関係プロパティ メタデータをオーバーライドする必要があります。 これは、依存関係プロパティを登録するクラスの特定のオブジェクトが作成される時間に相当します。 呼び出す<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>として自体を提供する型の静的コンス トラクター内でのみ実行する必要があります、`forType`またはのようなインスタンス化で、このメソッドのパラメーター。 インスタンス所有者の種類の存在にメタデータを変更しようとしてください。 例外は発生しませんが、プロパティ システムに一貫性のない動作が発生します。  
  
 このメソッドを使用して特定の派生クラスのオーバーライドのメタデータが確立されると、この同じ派生クラスのメタデータをオーバーライドしようで例外が発生します。  
  
 指定したメタデータは、基本の所有者に存在する依存関係プロパティのプロパティのメタデータに統合されます。 元の基本メタデータで指定されたすべての特性が保持されます。基本のメタデータの特性は、新しいメタデータに変更された具体的には特性のみが上書きされます。 いくつかの特性など<xref:System.Windows.PropertyMetadata.DefaultValue%2A>新しいメタデータで指定されている場合は置き換えられます。 他のユーザーなど<xref:System.Windows.PropertyChangedCallback>、結合されます。 マージ動作は、オーバーライドで使用されているプロパティのメタデータの種類によって異なります。 詳細については、次を参照してください。[依存関係プロパティ メタデータ](~/docs/framework/wpf/advanced/dependency-property-metadata.md)と[フレームワーク プロパティ メタデータ](~/docs/framework/wpf/advanced/framework-property-metadata.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティをプロパティ システムに登録したオブジェクト、または自身をプロパティの所有者として追加したオブジェクトの型を取得します。</summary>
        <value>プロパティを登録したオブジェクト、または自身をプロパティの所有者として追加したオブジェクトの型。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値は、プロパティの登録時に指定されました。 所有者は型であるか、元登録の場合、<xref:System.Windows.DependencyProperty>から生成された識別子を<xref:System.Windows.DependencyProperty.Register%2A>呼び出し、または自身の場合の所有者として追加する型、<xref:System.Windows.DependencyProperty>から生成された識別子を<xref:System.Windows.DependencyProperty.AddOwner%2A>を呼び出します。  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> 、特定の<xref:System.Windows.DependencyProperty>は変更できないとすることはできません`null`で有効な<xref:System.Windows.DependencyProperty>します。  
  
   
  
## Examples  
 次の例では、依存関係プロパティ識別子に基づく、所有者型を取得する`dp`、し、その同じ識別子、所有者型でメタデータを取得します。 この操作は実際に<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>で`dp`します。  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値の型を取得します。</summary>
        <value>プロパティ値の <see cref="T:System.Type" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを元のプロパティの登録によって宣言されたプロパティの値の型を報告する、`propertyType`パラメーター。 ような<xref:System.Windows.DependencyProperty.Name%2A>、登録した後は、依存関係プロパティのプロパティの型は変更できません。  
  
   
  
## Examples  
 次の例のクエリの依存関係プロパティ識別子では、さまざまな特性など、<xref:System.Windows.DependencyProperty.PropertyType%2A>します。 型名の文字列、<xref:System.Windows.DependencyProperty.PropertyType%2A>は返された<xref:System.Type>します。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.DependencyProperty" /> インスタンスによって識別される依存関係プロパティが読み取り専用の依存関係プロパティかどうかを示す値を取得します。</summary>
        <value>依存関係プロパティが読み取り専用の場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 読み取り専用の依存関係プロパティは、呼び出すことによって、プロパティ システムに登録されて、<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>メソッドではなく、<xref:System.Windows.DependencyProperty.Register%2A>メソッド。 添付プロパティを読み取り専用として登録することもできます。参照してください<xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>します。  
  
 読み取り専用の依存関係プロパティが必要な<xref:System.Windows.DependencyPropertyKey>識別子ではなく<xref:System.Windows.DependencyProperty>メタデータをオーバーライドまたは値の設定などのメタデータの操作を実行する識別子。 コレクションを取得した場合は<xref:System.Windows.DependencyProperty>を呼び出すことによって識別子<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>別または[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]識別子、チェックを公開する、<xref:System.Windows.DependencyProperty.ReadOnly%2A>呼び出しを試みる前に値<xref:System.Windows.DependencyObject.SetValue%2A>または<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>を使用します。識別子を表す依存関係プロパティが読み取り専用ではないことを確認する、入力パラメーターとして依存関係プロパティ識別子。 場合の値<xref:System.Windows.DependencyProperty.ReadOnly%2A>は`true`依存関係プロパティをプログラムでの参照を取得する方法はありません、<xref:System.Windows.DependencyPropertyKey>メタデータからまたはその依存関係プロパティの識別子、<xref:System.Windows.DependencyProperty>識別子。 識別子。呼び出すために、静的フィールドとして使用可能である必要があります<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>に対する読み取り専用の依存関係プロパティ。  
  
 カスタム依存関係プロパティを作成して読み取り専用として登録するの get アクセサーのみを定義する必要があります、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]ラッパー プロパティ。 それ以外の場合、クラスは、バックアップの依存関係プロパティへのアクセスと比較してプロパティのラッパーの混乱を招くオブジェクト モデルがあります。 詳細については、次を参照してください。[カスタム依存関係プロパティ](~/docs/framework/wpf/advanced/custom-dependency-properties.md)または[読み取り専用依存関係プロパティ](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)します。  
  
   
  
## Examples  
 次の例では、さまざまな依存関係プロパティのフィールドから、既定のメタデータと依存関係プロパティの識別子のプロパティを取得し、情報を使用して、「メタデータ ブラウザー」を実装するためにテーブルを作成します。  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>依存プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。 名前は、所有者型の登録名前空間内で一意である必要があります。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録する所有者型。</param>
        <summary>プロパティ名、プロパティ型、所有者型を指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する必要がある依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ名、プロパティの型、所有者の型、プロパティ メタデータを指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する必要がある依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるコールバックへの参照。</param>
        <summary>プロパティ名、プロパティ型、所有者型、プロパティ メタデータ、およびプロパティの値検証コールバックを指定して、依存関係プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する必要がある依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
   
  
## Examples  
 次の例では、依存関係プロパティを検証コールバックを登録します (コールバック定義は表示されません。 コールバック定義の詳細については、「 <xref:System.Windows.ValidateValueCallback>)。  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>添付プロパティをプロパティ システムに登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録する所有者型。</param>
        <summary>プロパティ名、プロパティ型、および所有者型を指定して、添付プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する必要がある依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティによって定義されたプロパティの概念は、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 依存関係プロパティとして添付プロパティを実装します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティは依存関係プロパティ、レポートのレイアウト特性などの操作の [全般] プロパティ システムで使用できるメタデータが適用されることができます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
   
  
## Examples  
 次の例では、これを使用して抽象クラスで添付プロパティを登録します。<xref:System.Windows.DependencyProperty.RegisterAttached%2A>署名します。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。 ここには、既定値などの特性を含めることができます。</param>
        <summary>プロパティ名、プロパティの型、所有者の型、およびプロパティ メタデータを指定して、アタッチされるプロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する必要がある依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティによって定義されたプロパティの概念は、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 依存関係プロパティとして添付プロパティを実装します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティは依存関係プロパティ、レポートのレイアウト特性などの操作の [全般] プロパティ システムで使用できるメタデータが適用されることができます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>RegisterAttached を使用して、依存関係プロパティの値の継承  
 1 つのシナリオでの依存関係プロパティを登録するため<xref:System.Windows.DependencyProperty.RegisterAttached%2A>の代わりに<xref:System.Windows.DependencyProperty.Register%2A>プロパティ値の継承をサポートすることです。 依存関係プロパティの値の継承を登録する必要があります<xref:System.Windows.DependencyProperty.RegisterAttached%2A>しないを提供する静的メソッドを Get * とセット * を公開する true にアタッチされている場合でも、クラス、依存関係プロパティを公開するプロパティのラッパーのアクセサーを定義する場合でもプロパティのサポートのアクセサー。   プロパティ値の継承は、非添付依存関係プロパティに見える場合があります、ランタイム ツリー内の要素の特定の境界を介する非添付プロパティの継承動作は定義されていません。 効果的に接続されている場合は、プロパティを登録して、添付プロパティをグローバル プロパティは、プロパティ システムを要素ツリー内のすべての境界を越えてプロパティ値の継承が動作することを保証します。 常に使用する<xref:System.Windows.DependencyProperty.RegisterAttached%2A>に指定したプロパティを登録する<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータにします。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。 ここには、既定値などの特性を含めることができます。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および値の検証コールバックを指定して、添付プロパティを登録します。</summary>
        <returns>クラス内の <see langword="public static readonly" /> フィールドの値を設定するために使用する必要がある依存関係プロパティ識別子。 この識別子は、後で依存関係プロパティを参照する際に使用されます。たとえば、依存関係プロパティの値をプログラムで設定したり、メタデータを取得したりする操作で使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 添付プロパティによって定義されたプロパティの概念は、[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] 依存関係プロパティとして添付プロパティを実装します。 [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]添付プロパティは依存関係プロパティ、レポートのレイアウト特性などの操作の [全般] プロパティ システムで使用できるメタデータが適用されることができます。 詳細については、「[添付プロパティの概要](~/docs/framework/wpf/advanced/attached-properties-overview.md)」を参照してください。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>RegisterAttached を使用して、依存関係プロパティの値の継承  
 1 つのシナリオでの依存関係プロパティを登録するため<xref:System.Windows.DependencyProperty.RegisterAttached%2A>の代わりに<xref:System.Windows.DependencyProperty.Register%2A>プロパティ値の継承をサポートすることです。 依存関係プロパティの値の継承を登録する必要があります<xref:System.Windows.DependencyProperty.RegisterAttached%2A>しないを提供する静的メソッドを Get * とセット * を公開する true にアタッチされている場合でも、クラス、依存関係プロパティを公開するプロパティのラッパーのアクセサーを定義する場合でもプロパティのサポートのアクセサー。   プロパティ値の継承は、非添付依存関係プロパティに見える場合があります、ランタイム ツリー内の要素の特定の境界を介する非添付プロパティの継承動作は定義されていません。 効果的に接続されている場合は、プロパティを登録して、添付プロパティをグローバル プロパティは、プロパティ システムを要素ツリー内のすべての境界を越えてプロパティ値の継承が動作することを保証します。 常に使用する<xref:System.Windows.DependencyProperty.RegisterAttached%2A>に指定したプロパティを登録する<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータにします。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、これを使用して抽象クラスで添付プロパティを登録します。<xref:System.Windows.DependencyProperty.RegisterAttached%2A>署名します。 この添付プロパティは列挙型プロパティ、および登録が指定された値が列挙体の値であることを確認する検証コールバックを追加します。  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み取り専用添付プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ型、所有者型、およびプロパティ メタデータを指定して、読み取り専用の添付プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要がある依存関係プロパティのキー。これは後で依存関係プロパティの参照に使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、型を返します<xref:System.Windows.DependencyPropertyKey>であるのに対し<xref:System.Windows.DependencyProperty.RegisterAttached%2A>型を返します<xref:System.Windows.DependencyProperty>します。 通常、読み取り専用プロパティを表すキーが行われないパブリックで呼び出すことによって、依存関係プロパティの値を設定するキーを使用できるため<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>します。 クラスのデザインは、要件に影響を与えるが、アクセスし、いずれかの可視性を制限する推奨<xref:System.Windows.DependencyPropertyKey>クラスまたはアプリケーション ロジックの一部としてその依存関係プロパティを設定するために必要なコードの部分のみにします。 値を公開することで、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することをお勧めも<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>として、`public static readonly`フィールド、クラスにします。  
  
 読み取り専用の添付プロパティは、添付プロパティの主なシナリオがでの使用のために、まれなシナリオ[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。 パブリック セッターを持たない添付プロパティを設定することはできません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]構文。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>RegisterAttached を使用して、依存関係プロパティの値の継承  
 プロパティ値の継承をサポートするためには、1 つのシナリオとして、依存関係プロパティを登録するためです。 依存関係プロパティの値の継承を登録する必要があります<xref:System.Windows.DependencyProperty.RegisterAttached%2A>しないを提供する静的メソッドを Get * とセット * を公開する true にアタッチされている場合でも、クラス、依存関係プロパティを公開するプロパティのラッパーのアクセサーを定義する場合でもプロパティのサポートのアクセサー。   プロパティ値の継承は、非添付依存関係プロパティに見える場合があります、ランタイム ツリー内の要素の特定の境界を介する非添付プロパティの継承動作は定義されていません。 効果的に接続されている場合は、プロパティを登録して、添付プロパティをグローバル プロパティは、プロパティ システムを要素ツリー内のすべての境界を越えてプロパティ値の継承が動作することを保証します。 常に使用する<xref:System.Windows.DependencyProperty.RegisterAttached%2A>に指定したプロパティを登録する<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータにします。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="defaultMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるユーザー作成のコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを指定して、読み取り専用の添付プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用され、次いで依存関係プロパティの参照に使用される、依存関係プロパティのキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、型を返します<xref:System.Windows.DependencyPropertyKey>であるのに対し<xref:System.Windows.DependencyProperty.RegisterAttached%2A>型を返します<xref:System.Windows.DependencyProperty>します。 型を表すキーでは通常、<xref:System.Windows.DependencyProperty>します。 通常、読み取り専用プロパティを表すキーが行われないパブリックで呼び出すことによって、依存関係プロパティの値を設定するキーを使用できるため<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>します。 クラスのデザインは、要件に影響を与えるが、アクセスし、いずれかの可視性を制限する推奨<xref:System.Windows.DependencyPropertyKey>クラスまたはアプリケーション ロジックの一部としてその依存関係プロパティを設定するために必要なコードの部分のみにします。 値を公開することで、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することをお勧めも<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>として、`public static readonly`フィールド、クラスにします。  
  
 読み取り専用の添付プロパティは、添付プロパティの主なシナリオがでの使用のために、まれなシナリオ[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。 パブリック セッターを持たない添付プロパティを設定することはできません[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]構文。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>RegisterAttached を使用して、依存関係プロパティの値の継承  
 代わりに接続されている場合は、依存関係プロパティを登録するための 1 つの特定シナリオ<xref:System.Windows.DependencyProperty.Register%2A>プロパティ値の継承をサポートすることです。 依存関係プロパティの値の継承を登録する必要があります<xref:System.Windows.DependencyProperty.RegisterAttached%2A>しないを提供する静的メソッドを Get * とセット * を公開する true にアタッチされている場合でも、クラス、依存関係プロパティを公開するプロパティのラッパーのアクセサーを定義する場合でもプロパティのサポートのアクセサー。   プロパティ値の継承は、非添付依存関係プロパティに見える場合があります、ランタイム ツリー内の要素の特定の境界を介する非添付プロパティの継承動作は定義されていません。 効果的に接続されている場合は、プロパティを登録して、添付プロパティをグローバル プロパティは、プロパティ システムを要素ツリー内のすべての境界を越えてプロパティ値の継承が動作することを保証します。 常に使用する<xref:System.Windows.DependencyProperty.RegisterAttached%2A>に指定したプロパティを登録する<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータにします。 詳細については、「[プロパティ値の継承](~/docs/framework/wpf/advanced/property-value-inheritance.md)」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>読み取り専用の依存関係プロパティとして、依存関係プロパティを登録します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータを指定して、読み取り専用の依存関係プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用され、次いで依存関係プロパティの参照に使用される、依存関係プロパティのキー。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、型を返します<xref:System.Windows.DependencyPropertyKey>であるのに対し<xref:System.Windows.DependencyProperty.RegisterAttached%2A>型を返します<xref:System.Windows.DependencyProperty>します。 通常、読み取り専用プロパティを表すキーが行われないパブリックで呼び出すことによって、依存関係プロパティの値を設定するキーを使用できるため<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>します。 クラスのデザインは、要件に影響を与えるが、アクセスし、いずれかの可視性を制限する推奨<xref:System.Windows.DependencyPropertyKey>クラスまたはアプリケーション ロジックの一部としてその依存関係プロパティを設定するために必要なコードの部分のみにします。 値を公開することで、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することをお勧めも<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>として、`public static readonly`フィールド、クラスにします。  
  
 読み取り専用の依存関係プロパティは、非常に典型的なシナリオ両方既存[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]とカスタマイズのシナリオのため、他の[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]場合でも、そのプロパティをによって設定する必要はありませんは、機能に依存関係プロパティが必要な可能性があります呼び出し元。 に基づいてなどの依存関係プロパティを取得するその他のプロパティ システム操作の基礎として読み取り専用の依存関係プロパティの値を使用する、<xref:System.Windows.Trigger>スタイル内で、依存関係プロパティ。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
   
  
## Examples  
 次の例では、登録、`AquariumSize`読み取り専用の依存関係プロパティ。 例では、定義`AquariumSizeKey`(アセンブリになったため、他のクラスは、メタデータをオーバーライドできます) 内部のキーと公開としては、そのキーに基づいて依存関係プロパティの識別子として`AquariumSizeProperty`します。 ラッパーを作成することも、 `AquariumSize`、get アクセサーのみを使用します。  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">登録する依存関係プロパティの名前。</param>
        <param name="propertyType">プロパティの型。</param>
        <param name="ownerType">依存関係プロパティを登録している所有者の型。</param>
        <param name="typeMetadata">依存関係プロパティのプロパティ メタデータ。</param>
        <param name="validateValueCallback">通常の型検証に加えて、依存関係プロパティ値のカスタム検証を実行する必要があるユーザー作成のコールバックへの参照。</param>
        <summary>プロパティ型、所有者型、プロパティ メタデータ、および検証コールバックを指定して、読み取り専用の依存関係プロパティを登録します。</summary>
        <returns>クラスの静的な読み取り専用フィールドの値を設定するために使用する必要がある依存関係プロパティのキー。これは後で依存関係プロパティの参照に使用されます。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、型を返します<xref:System.Windows.DependencyPropertyKey>であるのに対し<xref:System.Windows.DependencyProperty.RegisterAttached%2A>型を返します<xref:System.Windows.DependencyProperty>します。 通常、読み取り専用プロパティを表すキーが行われないパブリックで呼び出すことによって、依存関係プロパティの値を設定するキーを使用できるため<xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>します。 クラスのデザインは、要件に影響を与えるが、アクセスし、いずれかの可視性を制限する推奨<xref:System.Windows.DependencyPropertyKey>クラスまたはアプリケーション ロジックの一部としてその依存関係プロパティを設定するために必要なコードの部分のみにします。 値を公開することで、読み取り専用の依存関係プロパティの依存関係プロパティ識別子を公開することをお勧めも<xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType>として、`public static readonly`フィールド、クラスにします。  
  
 読み取り専用の依存関係プロパティは、非常に典型的なシナリオです。 に基づいてなどの依存関係プロパティを取得するその他のプロパティ システム操作の基礎として読み取り専用の依存関係プロパティの値を使用する、<xref:System.Windows.Trigger>スタイル内で、依存関係プロパティ。  
  
 依存関係プロパティの登録の詳細については、次を参照してください。<xref:System.Windows.DependencyProperty>します。  
  
 読み取り専用の依存関係プロパティの検証は、重要度の低い可能性があります。 キーの指定した非パブリック アクセス レベルは、任意の無効な入力の可能性を減らします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>依存関係プロパティの文字列表現を返します。</summary>
        <returns>依存関係プロパティの文字列表現。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この実装を返します、<xref:System.Windows.DependencyProperty.Name%2A>プロパティの値。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>プロパティは存在するが、その値がプロパティ システムによって設定されていないことを示すために、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] プロパティ システムが <see langword="null" /> の代わりに使用する静的な値を指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> シナリオに使用される sentinel 値は、場所、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]プロパティ システムは、要求を決定できません<xref:System.Windows.DependencyProperty>値。 <xref:System.Windows.DependencyProperty.UnsetValue> 使用がなく`null`ため、 `null` 、有効なプロパティ値だけでなく、有効な可能性があります (および頻繁に使用される)<xref:System.Windows.PropertyMetadata.DefaultValue%2A>します。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> うちは返されません<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>します。 呼び出すと<xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>の依存関係プロパティで、<xref:System.Windows.DependencyObject>インスタンスを次のいずれかに該当。  
  
-   依存関係プロパティ メタデータで確立された既定値があるし、その値が返されます。 この値を決める要因<xref:System.Windows.DependencyProperty.DefaultMetadata%2A>します。  
  
-   その他の値が、プロパティ システムによって確立されているし、既定値は関連性がなくなった。 詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。  
  
 設定、<xref:System.Windows.PropertyMetadata.DefaultValue%2A>の<xref:System.Windows.DependencyProperty.UnsetValue>は具体的には許可されません。  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> 返します<xref:System.Windows.DependencyProperty.UnsetValue>ときに要求されたプロパティが設定されていないローカルです。  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> 戻り値として使用する場合の特別な意味を持つ、<xref:System.Windows.CoerceValueCallback>します。 詳細については、次を参照してください。[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)です。  
  
 データベースにバインドしている場合ことに注意<xref:System.Windows.DependencyProperty.UnsetValue>と等価でない<xref:System.DBNull.Value>、方法と同様の方法で<xref:System.DBNull.Value>true null と等価ではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>依存関係プロパティの値検証コールバックを取得します。</summary>
        <value>依存関係プロパティを最初に登録するときに <paramref name="validateValueCallback" /> パラメーターで指定した、この依存関係プロパティの値検証コールバック。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが格納されます`null`依存関係プロパティに登録済みの検証コールバックがありません。  
  
 コールバックが静的な意味で動作する必要があります値を検証します。 検証を使用して適用、<xref:System.Windows.ValidateValueCallback>指定された値は、特定のインスタンスに対して有効かどうかを判断することはできません。 コールバックを依存関係プロパティを持つすべてのオブジェクトが必要がありますまたは有効なものとして指定された値を許容しないようにするかどうかのみを確認できます。 使用して、特定のインスタンスには、その他の依存関係プロパティの値を知ることに依存している検証を実行する必要がある場合、<xref:System.Windows.CoerceValueCallback>代わりにします。 <xref:System.Windows.CoerceValueCallback>依存関係プロパティ識別子内で直接ではなく、依存関係プロパティのメタデータの一環として登録します。 詳細については、次を参照してください。[依存関係プロパティのコールバックと検証](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>