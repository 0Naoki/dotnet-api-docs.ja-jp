<Type Name="UIElement" FullName="System.Windows.UIElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="145d585974489663334666a2d0796729df867253" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56373704" /></Metadata><TypeSignature Language="C#" Value="public class UIElement : System.Windows.Media.Visual, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi UIElement extends System.Windows.Media.Visual implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.UIElement" />
  <TypeSignature Language="VB.NET" Value="Public Class UIElement&#xA;Inherits Visual&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class UIElement : System::Windows::Media::Visual, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type UIElement = class&#xA;    inherit Visual&#xA;    interface IAnimatable&#xA;    interface IInputElement" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Visual</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.UidProperty("Uid")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><see cref="T:System.Windows.UIElement" /> は、Windows Presentation Foundation (WPF) の要素および基本表示特性における WPF コア レベル実装構築の基底クラスです。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement> 要素のレイアウト特性、および表示、要素とその子の動作要素のレイアウトに影響を与えることができますが、派生クラス仮想メソッドがオーバーライドできる公開開始点を提供します。  
  
 多くの入力や要素の動作に重点を置いて一般でも定義されて、<xref:System.Windows.UIElement>クラス。 これには、キーボード、マウスおよびスタイラス入力、および関連するステータスのプロパティのイベントが含まれます。 ルーティング イベントは、これらのイベントの多くはあり、多くの入力に関連するイベントのバブルを両方のルーティング イベントのトンネリング バージョンとバージョン。 これらのペアになっているイベントは、通常、コントロールの作成者に最も関心のあるイベントです。  
  
 <xref:System.Windows.UIElement> 含まれています[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]に関連した、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]イベント モデルでは、指定した発生可能なメソッドを含む要素インスタンスに基づいているイベントをルーティングします。  
  
 アーキテクチャの観点から<xref:System.Windows.UIElement>にウィンドウ ハンドルとほぼ同等と見なす[!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]プログラミング、または内の要素[!INCLUDE[TLA#tla_dhtml](~/includes/tlasharptla-dhtml-md.md)]プログラミングします。 <xref:System.Windows.UIElement> WPF コア レベルでの基本要素です。  
  
 A<xref:System.Windows.UIElement>で具体的には定義されている次の機能を備えて、<xref:System.Windows.UIElement>クラス。  
  
-   子要素としてレンダリングできます (<xref:System.Windows.UIElement>から派生した<xref:System.Windows.Media.Visual>、高レベルのグラフィックス クラス)  
  
-   サイズし、の使用可能な子要素を配置するために使用するロジックが含まれています、 <xref:System.Windows.UIElement> (レイアウト システムによって解釈される) 場合  
  
-   (コントロールに、ルーティングやコマンドのルーティング イベントの処理を使用して入力の送信先を取得するを含む) ユーザー入力に応答できます。  
  
-   要素の論理ツリー内のルートを経由するルーティング イベントを発生させることができます。  
  
-   アニメーション システムの一部の機能をサポートしています  
  
 <xref:System.Windows.FrameworkElement> WPF フレームワーク レベルの実装クラスに基づく<xref:System.Windows.UIElement>、WPF フレームワーク レベルの特定の操作を追加します。 <xref:System.Windows.FrameworkElement> 追加し、次の機能を定義します。  
  
-   その他のフレームワーク固有のレイアウト特性  
  
-   レポートのプロパティを豊富なメタデータのサポート  
  
-   特定のクラスに固有の実装の基本クラスとその添付プロパティを入力または添付イベント  
  
-   スタイルのサポート  
  
-   さらにアニメーションのサポート  
  
 クラスは、関連する別<xref:System.Windows.ContentElement>します。 <xref:System.Windows.ContentElement>クラスを実装する多数のと同じメンバー <xref:System.Windows.UIElement>; これら 2 つのクラス間の差が、意図したものでは、全体的なコンテンツ モデルに配置する必要があります。 A<xref:System.Windows.UIElement>派生クラスは通常比較的固定コンテンツ モデルが、どのような要素は、マークアップ内の子要素を使用できますの制限があることを意味を定義します。 より制限の少ないの子コンテンツを取るための容量がある可能性があります、<xref:System.Windows.UIElement>容量が指定されたコンテンツのプロパティで通常集中管理されているものの、します。 A<xref:System.Windows.ContentElement>派生クラスは通常フロー形式のドキュメントなどのシナリオをサポートするために、コンテンツに関する制限の厳しいです。  
  
> [!IMPORTANT]
>  <xref:System.Windows.UIElement.Visibility%2A> 状態では、すべての入力をその要素の処理に影響します。 表示されていない要素は、ヒット テストに参加していないと、上にマウスが境界の要素がある場合でも、入力イベントを受け取りません場合に表示されていた。  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UIElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UIElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.UIElement" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実際の型は、新しいインスタンスを作成する<xref:System.Windows.UIElement>アプリケーション コードでは一般的ではないため、<xref:System.Windows.UIElement>基本要素です。 参照してください[基本要素の概要](~/docs/framework/wpf/advanced/base-elements-overview.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法でハンドラーの実装で考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントへのアクセス パターン。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="uIElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドルするルーティング イベントの識別子。</param>
        <param name="handler">ハンドラーの実装に対する参照。</param>
        <param name="handledEventsToo">イベント データ内でルーティング イベントが処理済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するには <see langword="true" />。ルーティング イベントが既に処理済みとしてマークされている場合はハンドラーを呼び出さないという既定の条件を使用してハンドラーを登録する場合は <see langword="false" />。  
  
既定値は、<see langword="false" /> です。  
  
ルーティング イベントの再処理を機械的に要求しないでください。</param>
        <summary>指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。 イベント ルート上の別の要素により既にハンドル済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 複雑な作業は、実用的な方法で低レベルの入力イベントを処理します。 多くのコントロールは、特定のイベントが処理済みとしてマークされてし、別のより直感的なイベントに置き換えの動作を実装します。 一般に、これを行うための設計上の意図がある場合を処理済みとして、コントロールは、プラットフォームの入力イベントをマークだけです。 特定のシナリオでこれらの設計意図、特定の入力イベントの処理が必要とは限りません。 その登録するこのようなシナリオがハンドラーを`handledEventsToo`として`true`が適切です。 実行しないでこの日常的にします。 処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベント処理ロジックが複雑になります。 ハンドラーのロジックが多くの場合は、パフォーマンスの低下を参照してください可能性があります。 既に特定のコントロールがアプリケーション ロジックで処理するイベントを処理している開発プロセス中に検出する場所の場合の処理済みイベントのハンドラーをアタッチの使用を予約する必要があります。  
  
 クラスの特定のイベントとコントロールの組み合わせの動作を処理を回避するための別の手法では、代わりにそのイベントのプレビューを使用します。 たとえば場合、<xref:System.Windows.UIElement.MouseLeftButtonDown>処理済みとしてマークは、クラス処理によってありますのハンドラーを追加する<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>代わりにします。  
  
 例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。 ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。 そのため、この動作では次の方法でハンドラーの実装で考慮する必要があります副作用がある可能性がありますを検討してください。  
  
 通常の"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントへのアクセス パターン。  
  
   
  
## Examples  
 次の例で呼び出されるハンドラーを実装する、<xref:System.Windows.FrameworkElement.Initialized>イベントを使用して、ページ上の名前付きの要素のいずれかに定義されたハンドラーをアタッチするページで`handledEventsToo``true`します。 このハンドラー、経路上の別の要素が共有イベント データ、ルートでその処理要素に到達する前に処理済みとしてマークされている場合でも呼び出されます。  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">ハンドラーの追加先のイベント ルート。</param>
        <param name="e">ハンドラーを追加するために使用されるイベント データ。 このメソッドは、イベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティを使用してハンドラーを作成します。</param>
        <summary>現在の <see cref="T:System.Windows.EventRoute" /> イベント ハンドラー コレクションのハンドラーを、指定した <see cref="T:System.Windows.UIElement" /> に追加します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、コンテンツ ホスト要素で使用できます (を実装するか、<xref:System.Windows.IContentHost>またはご存知ない方) の子要素のハンドラーを追加する、<xref:System.Windows.EventRoute>します。 通常、これは必要ありません<xref:System.Windows.UIElement>ハンドラーが完了した論理ツリーで見つかったすべての要素に対して自動的に追加します。 ただし、場合によってはで、<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>が混在しているルートに追加するテンプレートの必要性の取得元の要素の介在するテンプレートのツリー内。 両方<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>このメソッドのバージョンをサポートします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.UIElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグアンドドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ドラッグ アンド ドロップ操作が既定では、有効でないと、設定した意図的に有効にする必要があります<xref:System.Windows.UIElement.AllowDrop%2A>に`true`します。 この基本の設定を超えたドラッグ アンド ドロップの動作は完全に特定の実装とによって定義されていない<xref:System.Windows.UIElement>またはその他の基本要素クラス。 たとえば、特定のコントロール<xref:System.Windows.Controls.RichTextBox>既定の動作を持っています。 ドラッグ アンド ドロップの詳細については、次を参照してください。[ドラッグ アンド ドロップの概要](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)します。  
  
 <xref:System.Windows.FrameworkElement> その実装では、この依存関係プロパティのメタデータをオーバーライドします。 具体的には、<xref:System.Windows.FrameworkElement>プロパティ値の継承を有効にするには、このプロパティの指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータ内)。 その他の値のない子要素がある場合にプロパティ値の継承をこのコンテキストで意味<xref:System.Windows.UIElement.AllowDrop%2A>ローカル値または最も近い親要素の値が割り当てられます (ここでも、いずれかの既定のスタイルでこの値、スタイルを使用して割り当てる値、またはローカル値)、プロパティ システムによってすべての以前に割り当てられていない子要素に対する親要素から値が割り当てられます。 実際にはつまり、ルート要素でドロップ操作を許可するかどうかを指定することができます、として割り当てられている値は、特にされているすべての子要素に反映されます`false`します。  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.AllowDropProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次のマークアップ例のセット、<xref:System.Windows.UIElement.AllowDrop%2A>プロパティ`true`で属性を使用して、<xref:System.Windows.Controls.TextBox>集計のオプションを有効にするプロパティを関連するその他の設定ほか、<xref:System.Windows.Controls.TextBox>複数行テキストのデータ オブジェクトの対象となる場合をドラッグします。 サンプル全体については、次を参照してください。[削除ファイル サンプルを読み込む](https://msdn.microsoft.com/library/be90d645-dd61-4f53-93bb-87902d086ef7)します。  
  
 [!code-xaml[DragDrop_DropOpenTextFile#UIElementAllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/DragDrop_DropOpenTextFile/CS/window1.xaml#uielementallowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.AllowDrop" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドはシールされているため、オーバーライドできません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="uIElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティの識別子。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用します。 既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティからアニメーションを削除するには、としては、そのプロパティの識別子を指定`dp`指定`clock`として`null`します。 アニメーションが削除され、その基本値にアニメーション化されたプロパティを設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 クロックに割り当てられているその他のアニメーションを実行し続けます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Windows.Shapes.Rectangle> `myAnimatedRectangle`を呼び出すことによって適用されるタイミングを特定のアニメーションが<xref:System.Windows.UIElement.ApplyAnimationClock%2A>します。  
  
 [!code-csharp[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/ClockControllerSpeedRatioExample.cs#uielementapplyanimationclock)]
 [!code-vb[timingbehaviors_procedural_snip#UIElementApplyAnimationClock](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/clockcontrollerspeedratioexample.vb#uielementapplyanimationclock)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="uIElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">アニメーション化するプロパティ。</param>
        <param name="clock">アニメーションをコントロールして宣言するアニメーション クロック。</param>
        <param name="handoffBehavior">列挙体の値。 既定値は <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> で、既存のアニメーションを停止して新しいアニメーションに置き換えます。</param>
        <summary>この要素の指定した依存関係プロパティにアニメーションを適用し、プロパティでアニメーションが既に適用されているときに行われる処理を指定する機能も提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティからアニメーションを削除するには、としては、そのプロパティの識別子を指定`dp`指定`clock`として`null`します。 アニメーションが削除され、その基本値にアニメーション化されたプロパティを設定します。 ただし、最初に関連付けられているアニメーション クロックは停止されません。 クロックに割り当てられているその他のアニメーションを実行し続けます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.UIElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素にキャプチャされているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素にキャプチャされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.UIElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.UIElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素上で押されているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素上で押されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.UIElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されているかどうかを示す値を取得します。</summary>
        <value>少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Arrange">
      <MemberSignature Language="C#" Value="public void Arrange (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Arrange(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Arrange (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Arrange(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="member this.Arrange : System.Windows.Rect -&gt; unit" Usage="uIElement.Arrange finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">親が子要素に対して計算する最終的なサイズ。<see cref="T:System.Windows.Rect" /> のインスタンスを指定します。</param>
        <summary>子要素を配置し、<see cref="T:System.Windows.UIElement" /> のサイズを決定します。 親要素はそれぞれの <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> 実装 (または WPF フレームワーク レベルの同等実装) からこのメソッドを呼び出し、レイアウトを再帰的に更新します。 このメソッドは、レイアウト更新の 2 番目のパスを構成します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 シナリオでは、の動作を派生する WPF フレームワーク レベル要素の<xref:System.Windows.UIElement.Arrange%2A>しないで (とことはできません、シャドウする場合を除き、) を変更します。 代わりに、オーバーライドする必要があります、<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>クラスで実装します。 <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>によって内部的に実装が呼び出される<xref:System.Windows.UIElement.Arrange%2A>既定の WPF フレームワーク レベルのレイアウトの操作の一部として。 <xref:System.Windows.UIElement.ArrangeCore%2A>実装を呼び出す必要がありますも<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>子要素がある場合、各子要素。  
  
 シナリオでは、動作を派生する WPF コア レベルの要素の<xref:System.Windows.UIElement.Arrange%2A>しないで (とことはできません、シャドウする場合を除き、) を変更します。 オーバーライドする代わりに、<xref:System.Windows.UIElement.ArrangeCore%2A>クラスにします。 <xref:System.Windows.UIElement.ArrangeCore%2A>によって内部的に実装が呼び出される<xref:System.Windows.UIElement.Arrange%2A>既定の WPF フレームワーク レベルのレイアウトの操作の一部として。 ただし、これは前提 WPF フレームワーク レベルのレイアウトとそうでない多くの場合、具体的には、WPF コア レベルからの要素を派生する場合、レイアウト システムを使用している、<xref:System.Windows.UIElement>基本要素クラス。 <xref:System.Windows.UIElement.ArrangeCore%2A>実装を呼び出す必要がありますも<xref:System.Windows.UIElement.Arrange%2A>子要素がある場合、各子要素。 WPF コア レベルのシナリオは、使用しないことを意味に注意してください、<xref:System.Windows.FrameworkElement>ために、派生クラスで<xref:System.Windows.FrameworkElement>シール<xref:System.Windows.FrameworkElement.ArrangeCore%2A>します。  
  
 WPF フレームワーク レベルのレイアウトの配置の計算[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]から成る、<xref:System.Windows.UIElement.Measure%2A>を呼び出すと、<xref:System.Windows.UIElement.Arrange%2A>を呼び出します。 中に、<xref:System.Windows.UIElement.Measure%2A>呼び出し、レイアウト システムは、指定されたを使用して要素のサイズ要件を決定します。 <xref:System.Windows.Size> (`availableSize`) 引数。 中に、<xref:System.Windows.UIElement.Arrange%2A>呼び出し、レイアウト システムは、サイズを終了し、要素の位置の境界ボックス。  詳細については、「[Layout](~/docs/framework/wpf/advanced/layout.md)」 (レイアウト) を参照してください。  
  
 `availableSize` 0 から無限大に任意の数を指定できます。 最小値を返す要素をレイアウトする<xref:System.Windows.Size>を通じて必要な`availableSize`パラメーター。  
  
 常に受信レイアウトが初めてインスタンス化されたときに、<xref:System.Windows.UIElement.Measure%2A>前に呼び出す<xref:System.Windows.UIElement.Arrange%2A>します。 ただし、最初のレイアウト パスの後に受け取る場合があります、<xref:System.Windows.UIElement.Arrange%2A>せずに呼び出す、 <xref:System.Windows.UIElement.Measure%2A>; 場合のみに影響を与えるプロパティ<xref:System.Windows.UIElement.Arrange%2A>(配置) などが変更された親を受け取ったとき、または、<xref:System.Windows.UIElement.Arrange%2A>せず、 <xref:System.Windows.UIElement.Measure%2A>. A<xref:System.Windows.UIElement.Measure%2A>呼び出しが自動的に無効になり、<xref:System.Windows.UIElement.Arrange%2A>呼び出します。  
  
 レイアウトの更新は、通常、非同期的に (はレイアウト システムによって決定されます) で発生します。 要素が要素のサイズ設定に影響を与えるプロパティの変更をすぐに反映されない可能性があります (など<xref:System.Windows.FrameworkElement.Width%2A>)。  
  
> [!NOTE]
>  使用してレイアウトの更新を強制することができます、<xref:System.Windows.UIElement.UpdateLayout%2A>メソッドです。 ただし、この関数を呼び出すことが推奨されていません、通常必要はありませんし、パフォーマンスの低下が発生することができます。 多くの状況で呼び出すことが<xref:System.Windows.UIElement.UpdateLayout%2A>適切な場合があります、更新プログラムがレイアウト システムに処理する既に可能性があります。 レイアウト システムは、パッケージの一部としてすべての必要な更新プログラムを最適化できる方法でレイアウトの変更を処理できます。  
  
 レイアウト システムは 2 つの異なるキューのいずれか、無効なレイアウトの<xref:System.Windows.UIElement.Measure%2A>とに 1 つずつ<xref:System.Windows.UIElement.Arrange%2A>します。 レイアウトのキューは、ビジュアル ツリー内の要素の順序に基づいて並べ替えられます。 要素ツリーの上位には、親の変更を繰り返すことによって、冗長なレイアウトを回避するために、キューの上部にあるがします。 重複するエントリは自動的に、キューから削除しが既に有効である要素も、キューから自動的に削除します。  
  
 レイアウトを更新するときに、<xref:System.Windows.UIElement.Measure%2A>キューが最初に、空に続けて、<xref:System.Windows.UIElement.Arrange%2A>キュー。 内の要素、<xref:System.Windows.UIElement.Arrange%2A>内の要素がある場合、キューは配置しない、<xref:System.Windows.UIElement.Measure%2A>キュー。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected virtual void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberSignature Language="F#" Value="abstract member ArrangeCore : System.Windows.Rect -&gt; unit&#xA;override this.ArrangeCore : System.Windows.Rect -&gt; unit" Usage="uIElement.ArrangeCore finalRect" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">親の末尾の領域。親の要素は要素自体と子を配置するために使用します。</param>
        <summary>WPF コア レベルの配置レイアウト定義のテンプレートを定義します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  このメソッドのオーバーライドは適切な場合にのみ WPF コア レベルで派生して、WPF フレームワーク レベルのレイアウト システムを使用していないと<xref:System.Windows.FrameworkElement>ために、派生クラスで<xref:System.Windows.FrameworkElement>シール<xref:System.Windows.FrameworkElement.ArrangeCore%2A>します。 クラスに固有のレイアウトをオーバーライドする適切なメソッドでは、動作は、配置、WPF フレームワーク レベルのレイアウト システムを使用している場合<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>します。  
  
   
  
## Examples  
 <xref:System.Windows.UIElement.ArrangeCore%2A> 実装は、サイズを返すには、基本の実装を呼び出す必要がありますを呼び出して、<xref:System.Windows.UIElement.Arrange%2A>各表示されている子要素のメソッドおよびこれらによって返されるサイズを調整<xref:System.Windows.UIElement.Arrange%2A>サイズが基本の実装の呼び出し。 ロジックの調整の側面を<xref:System.Windows.UIElement.ArrangeCore%2A>要素のレイアウト特性に応じて、実装が異なる場合があります。 次のサンプル テンプレートで`VisualChildren`仮想的なプロパティですそのコンテンツを列挙するため、要素を定義する。<xref:System.Windows.UIElement>コンテンツのコレクションを一切定義しませんレベルでは、WPF フレームワーク レベルのアーキテクチャが特定のコントロールまたはコントロールの基底クラスなどの派生要素にコンテンツの動作を延期します。  
  
 [!code-csharp[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementarrangeoverride)]
 [!code-vb[CorePseudocode#UIElementArrangeOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementarrangeoverride)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>WPF コア レベルで要素を開発している場合、これをオーバーライドする必要があります、WPF コア レベルの要素を一意に提供するメソッドがレイアウトの動作を配置または適切なレイアウトを要素の子要素について決定します。 上書きをそれらの子要素は定義済みのパターンから認識されないなどの場合に必要な場合があります、<see cref="T:System.Windows.Controls.ItemCollection" />します。  
  
親要素は、クラス固有を呼び出す必要があります<see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />各子要素に対してそれ以外の場合、子要素は表示されません。</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="uIElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</param>
        <param name="animation">開始するアニメーションのタイムライン。</param>
        <summary>この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされます非アニメーションの開始時点より前の最初のフレームがレンダリングされるときにアニメーション化します。  
  
 場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`、現在のアニメーションを削除し、プロパティの現在の値が保持されています。  
  
 場合、全体`animation`値は`null`、すべてのアニメーションがプロパティから削除、およびプロパティ値をその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 そのタイムラインに割り当てられているその他のアニメーションを実行し続けます。  
  
   
  
## Examples  
 次の例は、アニメーションを作成し、割り当てを呼び出して<xref:System.Windows.UIElement.BeginAnimation%2A>を開始します。  
  
 [!code-csharp[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#beginanimation)]
 [!code-vb[timingbehaviors_procedural_snip#BeginAnimation](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#beginanimation)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="uIElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</param>
        <param name="animation">適用されるアニメーションのタイムライン。</param>
        <param name="handoffBehavior">プロパティ値に既に影響している現在の (実行中の) アニメーションと新しいアニメーションが対話する方法を指定する列挙値。</param>
        <summary>この要素のアニメーション化対象のプロパティを指定して、特定のアニメーションを開始します。プロパティの既存のアニメーションが実行中である場合の動作も指定できます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされます非アニメーションの開始時点より前の最初のフレームがレンダリングされるときにアニメーション化します。  
  
 場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`、現在のアニメーションを削除し、プロパティの現在の値が保持されています。  
  
 場合、全体`animation`値は`null`、すべてのアニメーションがプロパティから削除、およびプロパティ値をその基本値に戻ります。 ただし、最初に関連付けられているアニメーション タイムラインは停止されません。 そのタイムラインに割り当てられているその他のアニメーションを実行し続けます。  
  
   
  
## Examples  
 次の例では、リソースの呼び出しから既存のアニメーションを取得するハンドラーを実装する<xref:System.Windows.UIElement.BeginAnimation%2A>とハンドオフ動作を指定します。  
  
 [!code-csharp[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/csharp/VS_Snippets_Wpf/BrushesIntroduction/CSharp/SampleViewer.xaml.cs#beginanimationhandoff)]
 [!code-vb[BrushesIntroduction#BeginAnimationHandoff](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BrushesIntroduction/visualbasic/sampleviewer.xaml.vb#beginanimationhandoff)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffect BitmapEffect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffect BitmapEffect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffect" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffect As BitmapEffect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffect ^ BitmapEffect { System::Windows::Media::Effects::BitmapEffect ^ get(); void set(System::Windows::Media::Effects::BitmapEffect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffect : System.Windows.Media.Effects.BitmapEffect with get, set" Usage="System.Windows.UIElement.BitmapEffect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に描画された内容に直接適用するビットマップ効果を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>適用するビットマップ効果。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Effects.BitmapEffect> そのため、抽象型は、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]使用状況の実装の派生クラスを必要と<xref:System.Windows.Media.Effects.BitmapEffect>など<xref:System.Windows.Media.Effects.OuterGlowBitmapEffect>します。 派生したクラスが実装されている 1 つはシーケンシャルを使用すると、1 つ以上を指定するコレクション型<xref:System.Windows.Media.Effects.BitmapEffect>、入れ子になったタグ構文を使用します。  
  
 既存のクラスの派生しない<xref:System.Windows.Media.Effects.BitmapEffect>型コンバーターをサポートしているため、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]このプロパティを使用する構文は、プロパティ要素構文では一般にします。  
  
<a name="dependencyPropertyInfo_BitmapEffect"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.BitmapEffectProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、ビットマップ効果を使用して<xref:System.Windows.Media.Effects.BlurBitmapEffect>します。  
  
 [!code-csharp[EffectsGallery_snip#CodeBehindBlurCodeBehindExampleInline](~/samples/snippets/csharp/VS_Snippets_Wpf/EffectsGallery_snip/CSharp/blurcodebehindexample.xaml.cs#codebehindblurcodebehindexampleinline)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInput">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.BitmapEffectInput BitmapEffectInput" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.BitmapEffectInput" />
      <MemberSignature Language="VB.NET" Value="Public Property BitmapEffectInput As BitmapEffectInput" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::BitmapEffectInput ^ BitmapEffectInput { System::Windows::Media::Effects::BitmapEffectInput ^ get(); void set(System::Windows::Media::Effects::BitmapEffectInput ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BitmapEffectInput : System.Windows.Media.Effects.BitmapEffectInput with get, set" Usage="System.Windows.UIElement.BitmapEffectInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-3.0">
          <AttributeName>System.Obsolete("BitmapEffects are deprecated and no longer function.  Consider using Effects where appropriate instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.Obsolete("Avoid using BitmapEffects as they have very poor performance characteristics.  They will be deprecated in a future version.  Consider using the UIElement.Effect property and ShaderEffects where appropriate instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.BitmapEffectInput</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に描画された内容に直接適用するビットマップ効果用の入力ソースを取得または設定します。  これは依存関係プロパティです。</summary>
        <value>ビットマップ効果のソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_BitmapEffectInput"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.BitmapEffectInputProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectInputProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectInputProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectInputProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapEffectInputProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapEffectInputProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapEffectInputProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.BitmapEffectInputProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.BitmapEffectInput" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BitmapEffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BitmapEffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BitmapEffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.BitmapEffectProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BitmapEffectProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BitmapEffectProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable BitmapEffectProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.BitmapEffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.BitmapEffect" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheMode">
      <MemberSignature Language="C#" Value="public System.Windows.Media.CacheMode CacheMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.CacheMode CacheMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CacheMode" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheMode As CacheMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::CacheMode ^ CacheMode { System::Windows::Media::CacheMode ^ get(); void set(System::Windows::Media::CacheMode ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CacheMode : System.Windows.Media.CacheMode with get, set" Usage="System.Windows.UIElement.CacheMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CacheMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.UIElement" /> のキャッシュされた表現を取得または設定します。</summary>
        <value><see cref="T:System.Windows.Media.CacheMode" /> のキャッシュされた表現を保持する <see cref="T:System.Windows.UIElement" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 設定、<xref:System.Windows.UIElement.CacheMode%2A>プロパティを表示するために時間がかかるがコンテンツのパフォーマンスを向上させる必要がある場合。 詳細については、「<xref:System.Windows.Media.BitmapCache>」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Media3D.Viewport2DVisual3D.CacheMode" />
        <altmember cref="T:System.Windows.Media.BitmapCache" />
        <altmember cref="T:System.Windows.Media.BitmapCacheBrush" />
      </Docs>
    </Member>
    <Member MemberName="CacheModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CacheModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CacheModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.CacheModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CacheModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CacheModeProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable CacheModeProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.CacheModeProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.CacheMode" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="uIElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にマウスをキャプチャするように強制することを試みます。</summary>
        <returns>マウスが正常にキャプチャされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キャプチャするには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.UIElement.IsEnabled%2A>は`true`を呼び出す前に<xref:System.Windows.UIElement.CaptureMouse%2A>します。  
  
 呼び出す場合<xref:System.Windows.UIElement.CaptureMouse%2A>返します`true`、し<xref:System.Windows.UIElement.IsMouseCaptured%2A>も`true`します。  
  
 呼び出す場合<xref:System.Windows.UIElement.CaptureMouse%2A>返します`true`、<xref:System.Windows.UIElement.GotMouseCapture>と<xref:System.Windows.UIElement.IsMouseCapturedChanged>イベントが発生するで<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>要素としてデータを報告するイベントの場所、<xref:System.Windows.UIElement.CaptureMouse%2A>メソッドが呼び出されます。 キャプチャを強制する場合は、既存のキャプチャのキャプチャに関連する、マウスでドラッグ アンド ドロップで特に干渉可能性があります。  
  
 すべての要素からマウスのキャプチャをクリアするには、呼び出し<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>で、`element`として指定されたパラメーター`null`します。  
  
   
  
## Examples  
 次の例では、1 組のマウスをキャプチャする (およびキャプチャ解除) するマウスや入力のキーの組み合わせのハンドラーを実装し、3 D モデルを表示するための特別なマウス モードを有効にします。  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="uIElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にスタイラスをキャプチャするように強制することを試みます。</summary>
        <returns>スタイラスが正常にキャプチャされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の実装を常に基になる既定のスタイラス デバイスに基づいて`true`します。 ただし、入力システムのデバイスの実装を提供する、入力デバイスを拡張する場合に、異なる結果を返す可能性のある代替のスタイラス デバイス実装で、システムを作成することです。  
  
 スタイラスをキャプチャする要素は、その境界の外側にスタイラスがある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このメソッドを呼び出す呼び出しと基になるは静的<xref:System.Windows.Input.Stylus>メソッド<xref:System.Windows.Input.Stylus.Capture%2A>します。 実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。  
  
 キャプチャするには、要素を有効にする必要があります。 確認するかどうか<xref:System.Windows.UIElement.IsEnabled%2A>は`true`を呼び出す前に返す<xref:System.Windows.UIElement.CaptureStylus%2A>。  
  
 呼び出す場合<xref:System.Windows.UIElement.CaptureStylus%2A>返します`true`、<xref:System.Windows.UIElement.IsStylusCaptured%2A>も`true`します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">キャプチャの対象となるデバイス。</param>
        <summary>この要素にタッチをキャプチャするように強制することを試みます。</summary>
        <returns>指定したタッチがこの要素にキャプチャされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.CaptureTouch%2A> 戻ります`false`場合、<xref:System.Windows.Input.TouchDevice>別の要素にキャプチャされています。  
  
 場合<xref:System.Windows.UIElement.CaptureTouch%2A>返します`true`、<xref:System.Windows.UIElement.GotTouchCapture>イベントが発生します。  
  
 この要素から 1 つのタッチのキャプチャをリリースするには、使用、<xref:System.Windows.UIElement.ReleaseTouchCapture%2A>メソッドを解放するタッチ デバイスを指定します。 この要素からすべてのタッチをリリースするには、使用、<xref:System.Windows.UIElement.ReleaseAllTouchCaptures%2A>メソッド。  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> は <see langword="null" />です。</exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="Clip">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Geometry Clip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Geometry Clip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Clip" />
      <MemberSignature Language="VB.NET" Value="Public Property Clip As Geometry" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Geometry ^ Clip { System::Windows::Media::Geometry ^ get(); void set(System::Windows::Media::Geometry ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Clip : System.Windows.Media.Geometry with get, set" Usage="System.Windows.UIElement.Clip" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素内容の輪郭の定義に使用するジオメトリを取得または設定します。  これは依存関係プロパティです。</summary>
        <value>クリッピング領域のサイズ設定に使用するジオメトリ。 既定値は null <see cref="T:System.Windows.Media.Geometry" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ジオメトリの外の要素は、レンダリングされたレイアウトで視覚的にクリップされます。 ジオメトリを四角形にする必要はありません。  
  
<a name="dependencyPropertyInfo_Clip"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ClipProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 この例は、フレームワーク要素を定義する方法を示します<xref:System.Windows.UIElement.Clip%2A>リージョン。 クリップを定義するには、使用、 <xref:System.Windows.Media.Geometry> (たとえば、<xref:System.Windows.Media.EllipseGeometry>要素の設定に<xref:System.Windows.UIElement.Clip%2A>プロパティ。 ジオメトリの領域内にある、領域のみが表示されます。  
  
 次の例は、<xref:System.Windows.Controls.Image>要素が定義されているクリップ領域がないです。 クリップ領域が定義されていないため、イメージ全体が表示されます。  
  
 [!code-xaml[ClipPathExample#2](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#2)]  
  
 ![クリップ領域を適用する前にオブジェクト](~/add/media/mil-task-clip-region-noclip.png "クリップ領域を適用する前にオブジェクト")  
クリップ地域のないイメージ  
  
 次の例と同一のイメージが作成された、定義済みのクリップ領域がある点が異なります。 領域内にあるイメージの一部のみ、<xref:System.Windows.Media.EllipseGeometry>が表示されます。  
  
 [!code-xaml[ClipPathExample#4](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#4)]  
  
 ![クリップされたオブジェクト](~/add/media/mil-task-clip-region-ellispe.PNG "クリップされたオブジェクト")  
楕円のクリップ領域を持つイメージ  
  
 次の例は、フレームワーク要素のアニメーション化する方法を示しています。<xref:System.Windows.UIElement.Clip%2A>リージョン。 この例で、<xref:System.Windows.Media.EllipseGeometry>楕円のクリップ領域を定義するために使用する<xref:System.Windows.Controls.Image>要素。 A<xref:System.Windows.Media.Animation.PointAnimation>楕円ジオメトリのアニメーション化<xref:System.Windows.Media.EllipseGeometry.Center%2A>プロパティから (0, 0) に (200, 150)。 アニメーションは、イメージが読み込まれると、無期限に繰り返す後に再生を開始します。  
  
 [!code-xaml[ClipPathExample#5](~/samples/snippets/csharp/VS_Snippets_Wpf/ClipPathExample/CS/ClipExample.xaml#5)]  
  
 完全なサンプルは、次を参照してください。、[クリップ領域のサンプル](https://msdn.microsoft.com/library/83043a0b-f824-445f-9675-103280c5ca67)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="ClipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClipProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClipProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.ClipProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Clip" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClipToBounds">
      <MemberSignature Language="C#" Value="public bool ClipToBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ClipToBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.ClipToBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property ClipToBounds As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ClipToBounds { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ClipToBounds : bool with get, set" Usage="System.Windows.UIElement.ClipToBounds" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親要素のサイズに合わせるために、この要素の内容 (またはこの要素の子要素の内容) を切り取るかどうかを示す値を取得または設定します。   これは依存関係プロパティです。</summary>
        <value>コンテンツをクリップする必要がある場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 子要素、<xref:System.Windows.UIElement.ClipToBounds%2A>レイアウトの動作に親要素の幅と高さをによってかどうか決定が中にさまざまな効果を持つ<xref:System.Windows.FrameworkElement.Height%2A>  /  <xref:System.Windows.FrameworkElement.Width%2A>または<xref:System.Windows.FrameworkElement.MaxHeight%2A>  /  <xref:System.Windows.FrameworkElement.MaxWidth%2A>. <xref:System.Windows.FrameworkElement.MaxHeight%2A> / <xref:System.Windows.FrameworkElement.MaxWidth%2A> 親要素が常に守られての値に関係なく<xref:System.Windows.UIElement.ClipToBounds%2A>効果的なクリッピングはこれらの最大値に基づいて、コンテンツをクリップは常にします。 親の<xref:System.Windows.FrameworkElement.Height%2A>  /  <xref:System.Windows.FrameworkElement.Width%2A>設定は、コンテンツをクリップされず<xref:System.Windows.UIElement.ClipToBounds%2A>は`false`、コンテンツの場合にクリップされますが、<xref:System.Windows.UIElement.ClipToBounds%2A>は`true`します。  
  
 その既定値に注意してください。`false`に実装されている一般的な動作は、、<xref:System.Windows.UIElement>クラス。 任意の要素から派生した可能性があります<xref:System.Windows.UIElement>このプロパティの既定値がそのインスタンス内の依存関係プロパティ メタデータをオーバーライドする`true`代わりにします。 いくつかの既存の派生クラスでは、このメタデータをオーバーライドまたは依存関係プロパティの既定値を調整します。  
  
 <xref:System.Windows.Controls.InkCanvas>、 <xref:System.Windows.Controls.InkPresenter>、および<xref:System.Windows.Controls.Primitives.Popup>を既定値を上書き各`true`します。  
  
 <xref:System.Windows.FrameworkElement> この依存関係プロパティのメタデータをオーバーライドします。 具体的には、<xref:System.Windows.FrameworkElement>プロパティ値の継承を有効にするには、このプロパティの指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータ内)。 その他の値のない子要素がある場合にプロパティ値の継承をこのコンテキストで意味<xref:System.Windows.UIElement.ClipToBounds%2A>ローカル値または最も近い親要素の値が割り当てられます (ここでも、いずれかの既定のスタイルでこの値、スタイルを使用して割り当てる値、またはローカル値)、プロパティ システムによってすべての未使用の子要素に対する親要素から値が割り当てられます。 実際にはつまり、ルート要素での境界にクリップを許可するかどうかを指定することができます、として割り当てられている値は、特にされているすべての子要素に反映されます`false`します。  
  
<a name="dependencyPropertyInfo_ClipToBounds"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ClipToBoundsProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Clip" />
      </Docs>
    </Member>
    <Member MemberName="ClipToBoundsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ClipToBoundsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ClipToBoundsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ClipToBoundsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ClipToBoundsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable ClipToBoundsProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.ClipToBoundsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.ClipToBounds" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.UIElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクションを取得します。 <see cref="T:System.Windows.Input.CommandBinding" /> は、この要素のコマンド処理を有効にし、コマンド、コマンドのイベント、およびこの要素によってアタッチされるハンドラーの間の関連を宣言します。</summary>
        <value>すべての <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 もう 1 つの一般的な方法を設定する、<xref:System.Windows.UIElement.CommandBindings%2A>コレクションは、使用する<xref:System.Windows.Input.CommandManager>メソッド プログラムを使用します。  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  
  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a>XAML 値  
 *oneOrMoreCommandBindings*  
 1 つまたは複数<xref:System.Windows.Input.CommandBinding>要素。 これらの必要がありますが、<xref:System.Windows.Input.CommandBinding.Command%2A>属性、既知のコマンドに設定され、に対して属性が設定、<xref:System.Windows.Input.CommandBinding.CanExecute>と<xref:System.Windows.Input.CommandBinding.Executed>ハンドラーの実装。 詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。  
  
   
  
## Examples  
 次の例では、追加、<xref:System.Windows.Input.CommandBinding>マークアップを使用してウィンドウにします。 なお[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]、<xref:System.Windows.Input.CommandBindingCollection>マークアップには、要素として宣言されていないコレクション オブジェクトが、このプロパティは、型によって推論され、1 つ以上を持つプロパティ要素の値を設定する<xref:System.Windows.Input.CommandBinding>要素。  
  
 [!code-xaml[commandWithHandler#CommandHandlerCommandBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/commandWithHandler/CSharp/Window1.xaml#commandhandlercommandbinding)]  
  
 詳細については、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]のコレクションの構文を参照してください[XAML 構文の詳細](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)します。  
  
 次の例は、基本的に同じコードで実行します。  
  
 [!code-csharp[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandHandlerProcedural/CSharp/Window1.xaml.cs#commandhandlerbindinginit)]
 [!code-vb[CommandHandlerProcedural#CommandHandlerBindingInit](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandHandlerProcedural/visualbasic/window1.xaml.vb#commandhandlerbindinginit)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="DesiredSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size DesiredSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size DesiredSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.DesiredSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DesiredSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size DesiredSize { System::Windows::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DesiredSize : System.Windows.Size" Usage="System.Windows.UIElement.DesiredSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト処理の測定パスの実行中に、この要素が計算したサイズを取得します。</summary>
        <value>計算されたサイズ。これが、配置パスの目的のサイズになります。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 場合、このプロパティによって返される値は有効な測定値にのみがの値、<xref:System.Windows.UIElement.IsMeasureValid%2A>プロパティは`true`します。  
  
 <xref:System.Windows.UIElement.DesiredSize%2A> などのレイアウト動作を実装するときに測定要因の 1 つオーバーライドと、通常、チェック<xref:System.Windows.FrameworkElement.ArrangeOverride%2A>、 <xref:System.Windows.FrameworkElement.MeasureOverride%2A>、または<xref:System.Windows.UIElement.OnRender%2A>(で、<xref:System.Windows.UIElement.OnRender%2A>場合、チェックする可能性があります<xref:System.Windows.UIElement.RenderSize%2A>代わりに、これによって異なりますが、実装の場合)。 シナリオによっては、<xref:System.Windows.UIElement.DesiredSize%2A>可能性がありますが完全に順守されます、実装ロジック、制約の<xref:System.Windows.UIElement.DesiredSize%2A>が適用され、このような制約は、親要素または子要素のいずれかの他の特性も変更可能性があります。 たとえば、スクロール可能なリージョンをサポートしています (ただし、選択をスクロール可能なリージョンを既に有効にする WPF フレームワーク レベルのコントロールから派生) をコントロールで使用可能なサイズと比較<xref:System.Windows.UIElement.DesiredSize%2A>します。 コントロールのスクロール バーを有効になっている内部の状態を設定し、でした、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]そのコントロール。 または、<xref:System.Windows.UIElement.DesiredSize%2A>危険性がある特定のシナリオでも無視されます。  
  
   
  
## Examples  
 次の例は<xref:System.Windows.UIElement.DesiredSize%2A>の一部として、<xref:System.Windows.FrameworkElement.MeasureOverride%2A>実装します。 通知方法<xref:System.Windows.UIElement.Measure%2A>を取得するには、直前に呼び出されますが<xref:System.Windows.UIElement.DesiredSize%2A>します。 これによりを<xref:System.Windows.UIElement.DesiredSize%2A>正当な値を保持します。  
  
 [!code-cpp[PlotPanel#2](~/samples/snippets/cpp/VS_Snippets_Wpf/PlotPanel/CPP/PlotPanel.cpp#2)]
 [!code-csharp[PlotPanel#2](~/samples/snippets/csharp/VS_Snippets_Wpf/PlotPanel/CSharp/PlotPanel.cs#2)]
 [!code-vb[PlotPanel#2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PlotPanel/VisualBasic/PlotPanel.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.DragEnter?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.DragEnter>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.DragEnterEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewDragEnter>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.DragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.DragLeave?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.DragLeave>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.DragLeaveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.DragDrop.PreviewDragLeave>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.DragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、要素の境界でドラッグを開始した場合でも発生します。 ドラッグが境界の外側を開始し、このイベントは発生しても、内部で、移動だけでなく<xref:System.Windows.UIElement.DragEnter>およびプレビュー イベントに関連します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.DragOver?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.DragOver>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.DragOverEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.DragDrop.PreviewDragOver>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.DragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.Drop?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.Drop>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.DropEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewDrop>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.Drop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Effect">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Effects.Effect Effect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Effects.Effect Effect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Effect" />
      <MemberSignature Language="VB.NET" Value="Public Property Effect As Effect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Effects::Effect ^ Effect { System::Windows::Media::Effects::Effect ^ get(); void set(System::Windows::Media::Effects::Effect ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Effect : System.Windows.Media.Effects.Effect with get, set" Usage="System.Windows.UIElement.Effect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Effects.Effect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.UIElement" /> に適用するビットマップ効果を取得または設定します。 これは依存関係プロパティです。</summary>
        <value>ビットマップ効果を表す <see cref="T:System.Windows.Media.Effects.Effect" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 使用して、<xref:System.Windows.UIElement.Effect%2A>するビットマップ効果を適用するプロパティを<xref:System.Windows.UIElement>します。  
  
<a name="dependencyPropertyInfo_Effect"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.EffectProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の XAML は、カスタムを割り当てる方法を示しています。<xref:System.Windows.Media.Effects.ShaderEffect>を、<xref:System.Windows.UIElement.Effect%2A>プロパティ。  
  
 [!code-xaml[System.Windows.Media.Effects.ShaderEffect#1000](~/samples/snippets/csharp/VS_Snippets_Wpf/System.Windows.Media.Effects.ShaderEffect/CS/Window1.xaml#1000)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Media.Effects.Effect" />
        <altmember cref="T:System.Windows.Media.Effects.ShaderEffect" />
      </Docs>
    </Member>
    <Member MemberName="EffectProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty EffectProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty EffectProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.EffectProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EffectProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ EffectProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable EffectProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.EffectProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Effect" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="uIElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素にフォーカスを設定することを試みます。</summary>
        <returns>この要素にキーボード フォーカスと論理フォーカスの両方が設定された場合は <see langword="true" />。論理フォーカスのみが設定された場合、またはこのメソッドの呼び出しによってフォーカスの変更が強制されない場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスを<xref:System.Windows.UIElement.Focusable%2A>と<xref:System.Windows.UIElement.IsEnabled%2A>は両方とも必要`true`します。  
  
 要素がフォーカスを設定し、有効な場合でも、`Focus`プレビュー イベントが特定のツリーで処理され、(たとえば、複合コントロール) でその要素にフォーカスができない可能性があります。
このような場合は、このメソッドが返されます`false`します。
 
 一般に、フォーカスは、2 つの異なる概念によって制御します。 キーボード フォーカスと論理フォーカスします。 これら 2 つの概念が常に同じでないです。 詳細については、次を参照してください。[フォーカスの概要](~/docs/framework/wpf/advanced/focus-overview.md)と[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。
 
 呼び出す場合<xref:System.Windows.UIElement.Focus%2A>返します`true`、<xref:System.Windows.UIElement.IsKeyboardFocused%2A>と<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>も`true`します。  
  
 関連するプロパティが既にがない場合`true`を呼び出すとき、 <xref:System.Windows.UIElement.Focus%2A>、1 つ以上の次のイベントは、次の順序で発生します: <xref:System.Windows.UIElement.PreviewLostKeyboardFocus>、 <xref:System.Windows.UIElement.PreviewGotKeyboardFocus> (ソースの新しいフォーカス ターゲット)、 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged>、 <xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>、<xref:System.Windows.UIElement.LostKeyboardFocus>、 <xref:System.Windows.UIElement.GotKeyboardFocus> (ソースは新しいフォーカス対象です)。  
  
 この呼び出しを正常に行うためには、以前フォーカスがあることに、アプリケーションで他の要素が必要です。  
  
   
  
## Examples  
 次の例では、フォーカスを設定、<xref:System.Windows.Controls.TextBox>によって参照される<xref:System.Windows.FrameworkElement.Name%2A>、し、内のカーソルの位置を調整、<xref:System.Windows.Controls.TextBox>します。  
  
 [!code-csharp[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/TextBox_CursorToEnd/CSharp/Window1.xaml.cs#uielementfocus)]
 [!code-vb[TextBox_CursorToEnd#UIElementFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextBox_CursorToEnd/VisualBasic/Window1.xaml.vb#uielementfocus)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.UIElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>要素がフォーカス可能な場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスがある要素のみでは、キーボード入力を受け取ります。  
  
 <xref:System.Windows.UIElement.Focusable%2A> [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]何が実際には、依存関係プロパティのプロパティ アクセサー。 この特定の依存関係プロパティでは、その見かけ上の「既定」値をコントロールに特にの派生型の要素のクラスに異なる方法で設定がよくあります。 これは、2 つの方法のいずれかでよく発生します。  
  
-   依存関係プロパティが特定の派生クラスによって継承されますが、派生したクラスのオーバーライドを依存関係プロパティのメタデータとプロパティの既定値を変更します。  
  
-   スタイルまたはテンプレートは、異なる方法でその依存関係プロパティの値を設定する要素に適用されます。  
  
 などの明らかな「既定」の<xref:System.Windows.UIElement.Focusable%2A>の<xref:System.Windows.Controls.Button>コントロールである`true`場合でも、<xref:System.Windows.Controls.Button>継承<xref:System.Windows.UIElement.Focusable%2A>として、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]プロパティから直接<xref:System.Windows.UIElement>します。 これは、値のメタデータを適用するため、<xref:System.Windows.UIElement.Focusable%2A>の静的コンス トラクター内で依存関係プロパティのオーバーライドされた、<xref:System.Windows.Controls.Control>基底クラスで、間に配置される<xref:System.Windows.Controls.Button>と<xref:System.Windows.UIElement>クラス階層です。  
  
 継承するときに<xref:System.Windows.Controls.Control>またはその派生クラスでは、<xref:System.Windows.Controls.Control>にするには、このプロパティの既定値を再定義`true`します。  
  
 継承するときに<xref:System.Windows.Controls.Label>(これは、<xref:System.Windows.Controls.Control>クラスの派生)、既定値がもう一度再定義する`false`。  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.FocusableProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次のコード例は、特定のカスタム コントロールを設定するためのコントロール テンプレートを示しています。 <xref:System.Windows.UIElement.Focusable%2A> `false`テンプレート内の要素のいずれかにします。  
  
 [!code-xaml[RichTextBox_NoScrollViewer#_ControlTemplate](~/samples/snippets/csharp/VS_Snippets_Wpf/RichTextBox_NoScrollViewer/CS/window1.xaml#_controltemplate)]
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>派生する場合<see cref="T:System.Windows.UIElement" />直接 (からではなく、 <see cref="T:System.Windows.Controls.Control" />)、要素にフォーカスを設定できる、既定では、要素はできないためフォーカスを設定するかどうかを検討してください。 要素にフォーカスを設定できる場合は、次のように、型の静的コンス トラクター内でこのプロパティのメタデータをオーバーライドします。 
[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)] [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)] 
場所<paramref name="myElement" />のメタデータ値をオーバーライドする型のクラス名にする必要があります。</para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Focusable" /> プロパティの値が変更された場合に発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Focusable" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="uIElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">照合する対象の依存関係プロパティ。</param>
        <summary>この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化される値は無視されます。</summary>
        <returns>指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 プロパティのアニメーションが添付されていない場合、<xref:System.Windows.UIElement.GetAnimationBaseValue%2A>を戻り値は常に、<xref:System.Windows.DependencyObject.GetValue%2A>値を返します。 添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始を含む値を派生しと停止の値は無視され、プロパティの値はその他のすべての可能な入力に基づいて決定されます。 詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。  
  
   
  
## Examples  
 次の例では、アニメーションの基本値を報告するハンドラーを実装する<xref:System.Windows.FrameworkElement.Width%2A>プロパティを<xref:System.Windows.Controls.Button>、トランス フォームの基本値とします。  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalue)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalue)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberSignature Language="F#" Value="abstract member GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry&#xA;override this.GetLayoutClip : System.Windows.Size -&gt; System.Windows.Media.Geometry" Usage="uIElement.GetLayoutClip layoutSlotSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">要素によって提供される使用可能なサイズ。</param>
        <summary><see cref="P:System.Windows.UIElement.ClipToBounds" /> が <see langword="true" /> に設定される場合にクリップされる領域を表す代替クリッピング ジオメトリを返します。</summary>
        <returns>潜在的なクリッピング ジオメトリ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定の実装は、正当な値を返しますが、使用しない、`layoutSlotSize`パラメーター計算を行います。 値を使用する代わりに<xref:System.Windows.UIElement.RenderSize%2A>します。  
  
 このメソッドはオーバーライドが大幅にすぐに派生して<xref:System.Windows.FrameworkElement>クラス、および<xref:System.Windows.FrameworkElement>上書きには、一般的な WPF フレームワーク レベル要素のより高度な動作が生成されます。 詳細については、「<xref:System.Windows.FrameworkElement.GetLayoutClip%2A?displayProperty=nameWithType>」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="uIElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>派生クラスでオーバーライドされると、ビジュアル親が存在しない場合に、この要素の代替[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] の親を返します。</summary>
        <returns>報告する代替の親接続を派生クラスの実装が持つ場合のオブジェクト。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの既定の仮想実装`null`します。 <xref:System.Windows.FrameworkElement> 現実の実装を提供します。  
  
 別の親が場所要素代替親構造体を作成、イベントがルーティングされるように、ビジュアル ツリーに標準の親では、ルーティングの標準的なパターンから逸脱した方法での場合、イベントのルーティングに使用またはの下、ルーティング方法をプレビューします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.GiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。 ドラッグ アンド ドロップ操作が、プロセス、視覚的なフィードバックが促進されます。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.GiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.GiveFeedback>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.GiveFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewGiveFeedback>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.GiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスがメソッド呼び出しを使用して強制意図的には、直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 このシナリオでキーボード フォーカスのままであると、要素を<xref:System.Windows.UIElement.Focus%2A>メソッドが呼び出されますも論理フォーカスを取得します。  
  
 このイベントをより正確に解釈するは、発生する状況の値、<xref:System.Windows.UIElement.IsFocused%2A>からルート内の要素のプロパティが変更された`false`に`true`。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを取得、実際の要素を決定するためにイベント データ。  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.GotFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnGotFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.GotFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.IsKeyboardFocusedChanged> 要素のフォーカスの状態を保持するプロパティで状態の変更を追跡するようなイベント<xref:System.Windows.UIElement.GotKeyboardFocus>多くの同じ状況でイベントが発生します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を決定するためにイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.GotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.GotKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.GotKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がマウスをキャプチャは、境界外にマウス ポインターがあってもマウス入力を受け取ります。 マウスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、は、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされました。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>マウスが、実際の要素を決定するデータのキャプチャ、イベント。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.GotMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.GotMouseCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.GotMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnGotMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.GotMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラスをキャプチャしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がスタイラスをキャプチャするときは、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまで、キャプチャを保持します。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>実際のキャプチャを持つ要素を決定するためにイベント データ。  
  
 このイベントは、このクラスで添付イベントのエイリアスを作成できるように<xref:System.Windows.UIElement.GotStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.GotStylusCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.GotStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnGotStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.GotStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがこの要素にキャプチャされると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.GotTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnGotTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.GotTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.UIElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にアニメーション化されたプロパティがあるかどうかを示す値を取得します。</summary>
        <value>プロパティのいずれかに添付されたアニメーションをこの要素が持つ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを返します`true`(ロック、常に実行されている) のアニメーションの永続的な場合、または特定のタイムラインのアニメーション。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasEffectiveKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual bool HasEffectiveKeyboardFocus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasEffectiveKeyboardFocus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property HasEffectiveKeyboardFocus As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property bool HasEffectiveKeyboardFocus { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasEffectiveKeyboardFocus : bool" Usage="System.Windows.UIElement.HasEffectiveKeyboardFocus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.UIElement" /> にフォーカスがあるかどうかを示す値を取得します。</summary>
        <value><see cref="T:System.Windows.UIElement" /> にフォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 サブクラスは、要素にキーボード フォーカスがあるときに指定するには、このプロパティをオーバーライドできます。  これは、ときに便利です、<xref:System.Windows.UIElement>キーボード フォーカスを設定できる要素を含む要素にフォーカスがあるレポートを必要とします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="HitTestCore">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> を実装して、基本要素のヒット テスト動作を提供します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.GeometryHitTestResult HitTestCore (System.Windows.Media.GeometryHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.GeometryHitTestResult HitTestCore(class System.Windows.Media.GeometryHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As GeometryHitTestParameters) As GeometryHitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::GeometryHitTestResult ^ HitTestCore(System::Windows::Media::GeometryHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.GeometryHitTestParameters -&gt; System.Windows.Media.GeometryHitTestResult" Usage="uIElement.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.GeometryHitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.GeometryHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">実行するヒット テストについて、初期ヒット ポイントも含めて、記述します。</param>
        <summary><see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.GeometryHitTestParameters)" /> を実装して、要素のヒット テストの基本動作を提供します (<see cref="T:System.Windows.Media.GeometryHitTestResult" /> を返します)。</summary>
        <returns>評価されたジオメトリを含むテスト結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元の仮想メソッドを参照してください。<xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType>についてはさらにこのメソッドをオーバーライドする派生クラス。 いくつかの特定のコントロール (<xref:System.Windows.Controls.TextBlock>など) は個別の実装は、この 1 つをオーバーライドします。  
  
 このメソッドは、アプリケーション コードから呼び出すためのものではありません。 このメソッドは、(マウス ポインターが要素上がなど) かどうかは、入力システムのさまざまな側面によって公開される内部のヒット テスト動作をサポートします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTestCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.HitTestResult HitTestCore (System.Windows.Media.PointHitTestParameters hitTestParameters);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.HitTestResult HitTestCore(class System.Windows.Media.PointHitTestParameters hitTestParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.HitTestCore(System.Windows.Media.PointHitTestParameters)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function HitTestCore (hitTestParameters As PointHitTestParameters) As HitTestResult" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::HitTestResult ^ HitTestCore(System::Windows::Media::PointHitTestParameters ^ hitTestParameters);" />
      <MemberSignature Language="F#" Value="override this.HitTestCore : System.Windows.Media.PointHitTestParameters -&gt; System.Windows.Media.HitTestResult" Usage="uIElement.HitTestCore hitTestParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.HitTestResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hitTestParameters" Type="System.Windows.Media.PointHitTestParameters" />
      </Parameters>
      <Docs>
        <param name="hitTestParameters">実行するヒット テストについて、初期ヒット ポイントも含めて、記述します。</param>
        <summary><see cref="M:System.Windows.Media.Visual.HitTestCore(System.Windows.Media.PointHitTestParameters)" /> を実装して、要素のヒット テストの基本動作を提供します (<see cref="T:System.Windows.Media.HitTestResult" /> を返します)。</summary>
        <returns>評価されたポイントを含む、テストの結果。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 元の仮想メソッドを参照してください。<xref:System.Windows.Media.Visual.HitTestCore%2A?displayProperty=nameWithType>についてはさらにこのメソッドをオーバーライドする派生クラス。 注意いくつかの特定のコントロール (<xref:System.Windows.Controls.TextBlock>など) をオーバーライド、個別の実装には<xref:System.Windows.UIElement.HitTestCore%2A>で定義されている<xref:System.Windows.UIElement>。  
  
 このメソッドは、アプリケーション コードから呼び出すためのものではありません。 このメソッドは、(マウス ポインターが要素上がなど) かどうかは、入力システムのさまざまな側面によって公開される内部のヒット テスト動作をサポートします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.UIElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられている入力バインドのコレクションを取得します。</summary>
        <value>入力バインディングのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 入力バインディングでは、入力デバイスにコマンドのバインドをサポートします。 たとえば、<xref:System.Windows.Input.MouseBinding>実装は、マウス デバイスに特定のプロパティを含むバインドを入力します。  
  
 入力バインディングのコレクション型に関連すると、インスタンスで宣言されている入力バインドの両方が含まれます。  
  
 関連するプロパティ、 <xref:System.Windows.UIElement.CommandBindings%2A>、コマンド バインディングのコレクションを保持します。 これは、プロセスはコマンドの処理 - 既知のコマンドに関連付けられているアクションの下、次のレベルを表しているという点で入力バインディングとは異なります。  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  
  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a>XAML 値  
 *oneOrMoreInputBindings*  
 1 つまたは複数<xref:System.Windows.Input.InputBinding>要素 (通常、<xref:System.Windows.Input.KeyBinding>または<xref:System.Windows.Input.MouseBinding>派生クラス)。 これらの各が必要です、<xref:System.Windows.Input.InputBinding.Command%2A>と<xref:System.Windows.Input.InputBinding.Gesture%2A>属性に設定します。  
  
   
  
## Examples  
 次の例でこのプロパティを設定します、 <xref:System.Windows.Window>、1 つ<xref:System.Windows.Input.KeyBinding>します。  
  
 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewXAMLKeyBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewxamlkeybinding)]  
  
 詳細については、[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]のコレクションの構文を参照してください[XAML 構文の詳細](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandBinding" />
      </Docs>
    </Member>
    <Member MemberName="InputHitTest">
      <MemberSignature Language="C#" Value="public System.Windows.IInputElement InputHitTest (System.Windows.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.IInputElement InputHitTest(valuetype System.Windows.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InputHitTest(System.Windows.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::IInputElement ^ InputHitTest(System::Windows::Point point);" />
      <MemberSignature Language="F#" Value="member this.InputHitTest : System.Windows.Point -&gt; System.Windows.IInputElement" Usage="uIElement.InputHitTest point" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.IInputElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
      </Parameters>
      <Docs>
        <param name="point">この要素内のオフセット座標。</param>
        <summary>現在の要素の原点からの指定した相対座標にある、現在の要素内の入力要素を返します。</summary>
        <returns>指定した位置にある子要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IInputElement> その型は両方の共通のインターフェイスであるために、戻り値の型として返される<xref:System.Windows.UIElement>と<xref:System.Windows.ContentElement>します。 戻り値の型を適切にキャストまたはの特定のメンバーで定義されているインターフェイスのインスタンスを使用することができますし、<xref:System.Windows.IInputElement>インターフェイス。  
  
 このメソッドは、通常、アプリケーション コードからは呼び出されません。 このメソッドを呼び出すことでは、適切なは、大量の低レベルの入力機能が既に存在する、マウス デバイスのロジックを再作成などを再実装する場合のみ。  
  
 <xref:System.Windows.IContentHost> コントラクト、<xref:System.Windows.IContentHost.InputHitTest%2A>メソッドを同じシグネチャを明示的に実装するためにいくつかの要素を選択します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateArrange">
      <MemberSignature Language="C#" Value="public void InvalidateArrange ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateArrange() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateArrange" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateArrange ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateArrange();" />
      <MemberSignature Language="F#" Value="member this.InvalidateArrange : unit -&gt; unit" Usage="uIElement.InvalidateArrange " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素の配置状態 (レイアウト) を無効にします。 無効にした後、要素のレイアウトが更新されます。更新は、<see cref="M:System.Windows.UIElement.UpdateLayout" /> によって強制されない限り非同期に行われます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しを頻繁に<xref:System.Windows.UIElement.InvalidateArrange%2A>またはに特に<xref:System.Windows.UIElement.UpdateLayout%2A>パフォーマンスに大きな影響を及ぼします。 したがって、他の後続の呼び出しの正確なレイアウト状態が絶対に必要な場合を除き、このメソッドを呼び出す[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]コードにします。 高度なシナリオを呼び出すことがあります<xref:System.Windows.UIElement.InvalidateArrange%2A>を作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback> on ではない依存関係プロパティの<xref:System.Windows.Freezable>または<xref:System.Windows.FrameworkElement>派生クラスで、引き続き変更時にレイアウトの配置パスに影響を与えます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateMeasure">
      <MemberSignature Language="C#" Value="public void InvalidateMeasure ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateMeasure() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateMeasure ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateMeasure();" />
      <MemberSignature Language="F#" Value="member this.InvalidateMeasure : unit -&gt; unit" Usage="uIElement.InvalidateMeasure " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素の測定状態 (レイアウト) を無効にします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 呼び出しでこのメソッドを呼び出す<xref:System.Windows.UIElement.InvalidateArrange%2A>内部的を呼び出す必要はありません<xref:System.Windows.UIElement.InvalidateMeasure%2A>と<xref:System.Windows.UIElement.InvalidateArrange%2A>を連続しています。 無効化、後に、要素は、レイアウト更新しない限り、非同期的に行われますは<xref:System.Windows.UIElement.UpdateLayout%2A>を強制的に同期レイアウトの変更と呼びます。  
  
 WPF フレームワーク レベルのレイアウト システムは、要素のビジュアル ツリー内の変更の処理を行い、レイアウト システムと同等の必要な場合に、このメソッドを呼び出して最も一般的なレイアウトの無効化の場合。 直接操作、要素ツリーのまたは類似したシナリオを高度な完全なレイアウトの実装を作成する場合にのみ、このメソッドを呼び出す必要があります。 このような 1 つの高度なシナリオは、作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback> on ではない依存関係プロパティを<xref:System.Windows.Freezable>または<xref:System.Windows.FrameworkElement>派生クラスで、引き続き変更時にレイアウトの測定パスに影響を与えます。  
  
 呼び出しを頻繁に<xref:System.Windows.UIElement.InvalidateMeasure%2A>またはに特に<xref:System.Windows.UIElement.UpdateLayout%2A>パフォーマンスに大きな影響を及ぼします。 したがって、他の後続の呼び出しの正確なレイアウト状態が絶対に必要な場合を除き、このメソッドを呼び出す[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]コードにします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvalidateVisual">
      <MemberSignature Language="C#" Value="public void InvalidateVisual ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateVisual() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.InvalidateVisual" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateVisual ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateVisual();" />
      <MemberSignature Language="F#" Value="member this.InvalidateVisual : unit -&gt; unit" Usage="uIElement.InvalidateVisual " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>要素の描画を無効にして、新しい完全なレイアウト パスを強制します。 レイアウト サイクルが完了した後に、<see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" /> が呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドを呼び出す<xref:System.Windows.UIElement.InvalidateArrange%2A>内部的にします。  
  
 一般に、このメソッドは、アプリケーション コードからは呼び出されません。 WPF フレームワーク レベルのレイアウト システムは、要素のビジュアル ツリー内の変更の処理と同等の必要な場合に、このメソッドを呼び出すことは既にします。 このメソッドの呼び出しは、高度なシナリオに対してのみ必要です。 このような 1 つの高度なシナリオは、作成するかどうかは、 <xref:System.Windows.PropertyChangedCallback> on ではない依存関係プロパティを<xref:System.Windows.Freezable>または<xref:System.Windows.FrameworkElement>派生クラスで、引き続き変更時に、レイアウトに影響を与えます。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
      </Docs>
    </Member>
    <Member MemberName="IsArrangeValid">
      <MemberSignature Language="C#" Value="public bool IsArrangeValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArrangeValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsArrangeValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArrangeValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArrangeValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArrangeValid : bool" Usage="System.Windows.UIElement.IsArrangeValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のレイアウトにおける子要素の計算済みのサイズと位置が有効かどうかを示す値を取得します。</summary>
        <value>レイアウトのサイズと位置が有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 配置を呼び出すことによって無効化を強制する<xref:System.Windows.UIElement.InvalidateArrange%2A>この要素 (またはその親) にします。 これは、フラグのタイミングで、レイアウト システムを決定します再合成のレイアウト。 または、イミディ エイトへの呼び出しを<xref:System.Windows.UIElement.UpdateLayout%2A>できても、これは、それ以上の無効化が保留しないことが確実である場合にのみ実行してありますが、(があるパフォーマンスに影響を不必要に強制更新プログラムの数が多い)。  
  
 <xref:System.Windows.UIElement.IsArrangeValid%2A> ことはできません`true`しない限り、<xref:System.Windows.UIElement.IsMeasureValid%2A>も`true`(レイアウト プロセスで配置することはできません有効な測定を有効になって初めてなし)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.InvalidateArrange" />
        <altmember cref="P:System.Windows.UIElement.IsMeasureValid" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.UIElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] で有効かどうかを示す値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>要素が有効な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティがクラス固有の実装によって影響を受けることに注意してください<xref:System.Windows.UIElement.IsEnabledCore%2A>で多くの場合、実行時に、特定の要素。 そのため、ここで示されている既定値がありますいない有効です。 たとえば、<xref:System.Windows.Controls.Primitives.ScrollBar>なります<xref:System.Windows.UIElement.IsEnabled%2A>`false`スクロール バーをサポートする必要がないと判断されたときにします。 この値を設定しようとしても可能性があるとオーバーライドされますによって返される値<xref:System.Windows.UIElement.IsEnabledCore%2A>します。  
  
 無効な要素は、ヒット テストやフォーカスに参加していないと、そのため、入力イベントのソースはできません。  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsEnabledProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、ことを示しています、ハンドラーを 1 つのボタンの実行が設定されている場合<xref:System.Windows.UIElement.IsEnabled%2A>`false`もう 1 つの名前付きのボタンで`b1`します。  
  
 [!code-csharp[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/CSharp/default.xaml.cs#handler)]
 [!code-vb[RoutedEventAddRemoveHandler#Handler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventAddRemoveHandler/VisualBasic/default.xaml.vb#handler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsEnabled" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.UIElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>派生クラス内で <see cref="P:System.Windows.UIElement.IsEnabled" /> の戻り値になる値を取得します。</summary>
        <value>要素が有効な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このプロパティの既定の実装では、値をキャッシュしもこの要素の親要素が有効になっているかどうかを計算します。 (子要素は実用的で効果的に有効にできません、親が有効でない場合[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)])。この実装をオーバーライドすることを選択する場合、この動作を保持する基本実装を呼び出すことをことを確認します。  
  
<see cref="T:System.Windows.Controls.Primitives.ScrollBar" />クラスは、このプロパティの既存のオーバーライド実装を提供します。 この上書きは、コンテンツ表示領域内のコンテンツが利用可能な領域を超えるかどうかを判断します。 コンテンツ領域を超えると、スクロール バーの部分が有効になっています。 それ以外の場合、スクロール バーは有効になっていません。</para></block>
        <altmember cref="E:System.Windows.UIElement.IsEnabledChanged" />
        <altmember cref="P:System.Windows.UIElement.IsEnabled" />
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.UIElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に論理フォーカスがあるかどうかを判断する値を取得します。  これは依存関係プロパティです。</summary>
        <value>この要素に論理フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 論理フォーカスは、アプリケーションは、メニューの内容と、アプリケーションの残りの部分の間など、複数のフォーカス区分がキーボード フォーカスと異なる場合があります。 このシナリオでアプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるのみ、ただし、他のフォーカス区分の特定の要素には論理フォーカスが保持可能性がありますもします。 論理フォーカスの詳細については、次を参照してください。[フォーカスの概要](~/docs/framework/wpf/advanced/focus-overview.md)します。  
  
 (これは読み取り専用)、このプロパティを設定してフォーカスを設定しないでください。 このプロパティの一般的な使用がの依存関係プロパティとして使用するには、<xref:System.Windows.Setter>または<xref:System.Windows.EventTrigger>します。 プログラムでフォーカスを設定するには、呼び出す<xref:System.Windows.UIElement.Focus%2A>します。 ユーザーによる操作や管理の実装は、マウス キャプチャの動作を含む可能性によって、フォーカスを設定もできます。  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、フォーカスがある場合は、コントロールの背景を変更するコード ハンドラーです。  
  
 [!code-csharp[PopupSimple#IsFocused](~/samples/snippets/csharp/VS_Snippets_Wpf/PopupSimple/CSharp/Window1.xaml.cs#isfocused)]  
  
 これと同じ効果を実現するために別の一般的な方法は、配置、<xref:System.Windows.Trigger>で、<xref:System.Windows.Style>コントロールのこのアプローチが分離コードを含む特定のイベントの処理は必要ありませんし、デザイナーに対話型とグラフィカルな性質を大きい値へのアクセスを許可[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]します。 例については、「[方法: 外縁にグロー効果を生み出す](https://msdn.microsoft.com/library/a2ccf19a-d0dc-4e3c-88e3-95d7f7d765b1)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisible">
      <MemberSignature Language="C#" Value="public bool IsHitTestVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHitTestVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsHitTestVisible" />
      <MemberSignature Language="VB.NET" Value="Public Property IsHitTestVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHitTestVisible { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisible : bool with get, set" Usage="System.Windows.UIElement.IsHitTestVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が、表示される内容のある部分からのヒット テストの結果として返されるかどうかを宣言する値を取得または設定します。 これは依存関係プロパティです。</summary>
        <value>少なくとも 1 つの点からヒット テストの結果としてこの要素が返される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は <see langword="true" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの有効な値は、論理ツリーのヒット テスト可能な要素の相対位置が反映されます。 たとえば、要素が子要素の場合にある要素のないヒット テストの表示、子のプロパティの有効な値のまま`false`場合でも、その値をローカルに設定しようとしています。 このためは設定しないことが重要<xref:System.Windows.UIElement.IsHitTestVisible%2A>に`false`複合コントロールで任意の入力を必要またはそのコントロールのヒット テストしない場合を除き、します。 ヒット テストについて詳しくは、「[ビジュアル層でのヒット テスト](~/docs/framework/wpf/graphics-multimedia/hit-testing-in-the-visual-layer.md)」をご覧ください。  
  
<a name="dependencyPropertyInfo_IsHitTestVisible"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsHitTestVisibleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsHitTestVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsHitTestVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsHitTestVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsHitTestVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsHitTestVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 依存関係プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHitTestVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsHitTestVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsHitTestVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsHitTestVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsHitTestVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsHitTestVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsHitTestVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsHitTestVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.UIElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)] などの入力方式システムがこの要素への入力の処理に対して有効になっているかどうかを示す値を取得します。</summary>
        <value>入力方式がアクティブである場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 基礎となる添付プロパティの既定値は <see langword="true;" /> ですが、この値は実行時の入力方式の実際の状態の影響を受けます。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティが添付プロパティによって返される値を返します<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>現在有効な入力方法 (キーボード、音声、およびその他の入力デバイス)。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.UIElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスがあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>この要素にキーボード フォーカスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスに関連するイベントは、このプロパティの値への変更を伴うことができます。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>一般的に使用されるクラスのイベント ハンドラー内で他の入力関連のイベントでは、インスタンスの要素が既に、キーボード フォーカスとマウスを決定するイベントとキーボード イベントが発生すると組み合わせてかを判断します。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsKeyboardFocusedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
        <altmember cref="E:System.Windows.UIElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.UIElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>キーボード フォーカスがその要素またはそのビジュアル ツリーの子要素内の任意の場所にあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>キーボード フォーカスがその要素またはその子要素にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの値の変更が通常発生させる、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>イベント、派生クラスがオーバーライドされない限り<xref:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged%2A>イベントを抑制します。  
  
 このプロパティを直接設定しないでください、呼び出すことによって要素にフォーカスを設定することができますが、 <xref:System.Windows.UIElement.Focus%2A>、か行うことによって、<xref:System.Windows.UIElement.MoveFocus%2A>要求。 このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。  
  
 <xref:System.Windows.UIElement.IsKeyboardFocused%2A> <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>は通常クラス イベント ハンドラー内での使用その他の入力に関連するイベントのインスタンス要素は既に、キーボード フォーカスとマウスを決定するイベントとキーボード イベントが発生すると組み合わせてかを判断します。  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsKeyboardFocusWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabled">
      <MemberSignature Language="C#" Value="public bool IsManipulationEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsManipulationEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsManipulationEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsManipulationEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsManipulationEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsManipulationEnabled : bool with get, set" Usage="System.Windows.UIElement.IsManipulationEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.UIElement" /> で操作イベントが有効かどうかを示す値を取得または設定します。</summary>
        <value>この <see cref="T:System.Windows.UIElement" /> で操作イベントが有効な場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティをする場合は true に設定、<xref:System.Windows.UIElement>を受信する、 <xref:System.Windows.UIElement.ManipulationStarting>、 <xref:System.Windows.UIElement.ManipulationStarted>、 <xref:System.Windows.UIElement.ManipulationDelta>、 <xref:System.Windows.UIElement.ManipulationInertiaStarting>、<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>と<xref:System.Windows.UIElement.ManipulationCompleted>イベント。 操作の詳細については、次を参照してください。、[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
   
  
## Examples  
 次の例では、赤い四角形を持つアプリケーションを作成します。  <xref:System.Windows.UIElement.IsManipulationEnabled%2A>四角形のプロパティが true に設定され、アプリケーションのウィンドウをサブスクライブする、 <xref:System.Windows.UIElement.ManipulationStarting>、 <xref:System.Windows.UIElement.ManipulationDelta>、および<xref:System.Windows.UIElement.ManipulationInertiaStarting>イベント。 この例の例では[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
 [!code-xaml[BasicManipulation#UI](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml#ui)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsManipulationEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsManipulationEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsManipulationEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsManipulationEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsManipulationEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsManipulationEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsManipulationEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsManipulationEnabled" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMeasureValid">
      <MemberSignature Language="C#" Value="public bool IsMeasureValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMeasureValid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMeasureValid" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMeasureValid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMeasureValid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMeasureValid : bool" Usage="System.Windows.UIElement.IsMeasureValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>レイアウト測定パスから返された現在のサイズが有効かどうかを示す値を取得します。</summary>
        <value>レイアウトの測定パスから有効な現在値が返された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 測定と配置を呼び出すことによって無効化を強制する<xref:System.Windows.UIElement.InvalidateMeasure%2A>でこの要素 (または、ビジュアル ツリーの任意の親要素)。 レイアウト システムによる決定時に発生しているこの再構成のレイアウト、非同期的には指定します。 またはへの直接呼び出しを行うことができます<xref:System.Windows.UIElement.UpdateLayout%2A>します。 だけに呼び出す必要がありますが、する<xref:System.Windows.UIElement.UpdateLayout%2A>かどうかそれ以上の無効化が保留しないこと可能性があります (強制不必要に更新プログラムの数が多いはパフォーマンスの結果になります)。  
  
 場合<xref:System.Windows.UIElement.IsMeasureValid%2A>は`false`、<xref:System.Windows.UIElement.IsArrangeValid%2A>必要もあります`false`(レイアウト プロセスの強制のロジックで配置することはできません有効な測定を有効になって初めてなし)。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.UIElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にマウスがキャプチャされるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>要素にマウス キャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス キャプチャの状態は、インプロセス ドラッグ アンド ドロップ操作に関連しています。  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsMouseCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、マウスの状態のキャプチャを有効または無効、マウスが要素の既にキャプチャされているかどうかに基づいて。  
  
 マウスのキャプチャが他の場所でその要素にマウスのキャプチャが設定されています。 要素にマウスのキャプチャがある場合に、呼び出すことによってクリアされます<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>null 入力します。  
  
 [!code-csharp[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseSnippetSample/CSharp/Window1.xaml.cs#ismousecaptured)]
 [!code-vb[MouseSnippetSample#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseSnippetSample/visualbasic/window1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsMouseCaptured" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.UIElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはビジュアル ツリー内の子要素がマウスのキャプチャを保持するかどうかを決定する値を取得します。 これは依存関係プロパティです。</summary>
        <value>この要素または格納されている要素がマウス キャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsMouseCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.UIElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" /> の値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.UIElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>マウス ポインターがヒット テストと同じ要素の結果上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なり<xref:System.Windows.UIElement.IsMouseOver%2A>、このプロパティはのみ`true`はヒット テストのリテラル要素の上でマウス ポインターがかどうか。 代わりに子要素の上にマウス ポインターが、具体的には、要素のより深いテンプレートおよび複合の一部である要素をこのプロパティになります`false`します。 コントロールが合成する方法がわかっていない限り、(たとえば、このプロパティ テンプレートで使用する、カスタム コントロールを定義するコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいない作成はほとんどのシナリオを使用して、<xref:System.Windows.UIElement.IsMouseOver%2A>代わりにします。  
  
 この要素によって、マウスがキャプチャされていて、このプロパティは`true`のキャプチャ時に、このプロパティを返し続けます`true`までマウス キャプチャが失われ、その境界上にポインターがありません。  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsMouseDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.UIElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素 (ビジュアル ツリー内の子要素を含む) の上にあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>マウス ポインターが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 通常、コントロールは複合ことなど、すべてのコントロール (ビジュアル ツリー) 内のさまざまな要素が格納しているコントロールのマウスの状態が報告されます。 たとえば、<xref:System.Windows.Controls.ListBox>スタイルのコントロールがレポートされます<xref:System.Windows.UIElement.IsMouseOver%2A>として`true`の geometry 上にマウスが任意の場所である場合も含めて<xref:System.Windows.Controls.ListBoxItem>します。  
  
 類似の"IsMouseOverChanged"イベントが存在しないがいくつかの類似イベントの操作を行います。 たとえば、処理<xref:System.Windows.UIElement.MouseEnter>、 <xref:System.Windows.UIElement.MouseMove>、および<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>します。  
  
 この要素がマウスをキャプチャする場合は、このプロパティの値`true`マウス キャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。  
  
 一部のコントロールは、意図的に、マウスに直接関係しない特定の操作上にマウス ポインターをキャプチャします。 これにより、<xref:System.Windows.UIElement.IsMouseOver%2A>される`true`マウスが移動したように見えていない場合でもです。  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsMouseOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、このプロパティを参照のプロパティの型として、<xref:System.Windows.Trigger>の一部である、 \<Style.Triggers > ブロックします。 マウスがコントロールの上にある場合は、コントロールのテキストが青色になり、カーソルが手の形になります。  
  
 [!code-xaml[ListViewChkBox#Trigger](~/samples/snippets/csharp/VS_Snippets_Wpf/ListViewChkBox/CS/window1.xaml#trigger)]   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsMouseOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.UIElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素によってスタイラスがキャプチャされるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>要素にスタイラスのキャプチャがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsStylusCapturedProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsStylusCaptured" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.UIElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素、または要素の境界とそのビジュアル ツリー内の要素がスタイラス キャプチャを保持するかどうかを示す値を取得します。 これは依存関係プロパティです。</summary>
        <value>この要素または格納されている要素がスタイラスのキャプチャを持つ場合は、<see langword="true" />。それ以外の場合は、<see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Windows Vista でタッチ入力のサポート](https://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)と[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsStylusCaptureWithinProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.CaptureStylus" />
        <altmember cref="P:System.Windows.UIElement.IsStylusCaptured" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.UIElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>スタイラス ポインターがヒット テストの結果と同じ要素上にある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なり<xref:System.Windows.UIElement.IsStylusOver%2A>、このプロパティはのみ`true`要素の上にスタイラスがある場合。 スタイラスの代わりに子要素または要素のより深い複合 (ビジュアル ツリー) の一部である要素を場合、このプロパティになります`false`します。  
  
 コントロールが合成する方法がわかっていない限り、(たとえば、このプロパティ テンプレートで使用する、カスタム コントロールを定義するコントロールの)、このプロパティは、予期しない結果を返す可能性があります。 コントロールをいない作成はほとんどのシナリオを使用して、<xref:System.Windows.UIElement.IsStylusOver%2A>代わりにします。  
  
 この要素がスタイラス キャプチャされ、このプロパティが`true`のキャプチャ時に、このプロパティの値`true`までスタイラスのキャプチャが失われ、その境界上にスタイラスがありません。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsStylusDirectlyOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.UIElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスのカーソルがこの要素 (子ビジュアル要素を含む) の上にあるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>スタイラスのカーソルが要素またはその子要素の上にある場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 既定値は、<see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素にスタイラスのキャプチャがある場合は、このプロパティは返す引き続き`true`スタイラスのキャプチャが失われ、ポインターがその範囲外までです。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsStylusOverProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsStylusOver" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Windows.UIElement.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] に表示されるかどうかを示す値を取得します。  これは依存関係プロパティです。</summary>
        <value>要素が表示される場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 決定、<xref:System.Windows.UIElement.IsVisible%2A>値はレイアウトのすべての要因が考慮されます。 これに対し、 <xref:System.Windows.UIElement.Visibility%2A>、表示または非表示に要素をプログラムで作成するという意図は、設定可能なプロパティのみを示します。  
  
 要素を<xref:System.Windows.UIElement.IsVisible%2A>は`false`いない入力イベント (またはコマンド) に参加、しないメジャーのいずれかに影響を与えるまたは配置レイアウトのパスがフォーカスを設定できる、タブの順序でないおよびヒット テストでは報告されません。 これに対して、要素、<xref:System.Windows.UIElement.IsEnabled%2A>は`false`イベントとコマンド、およびヒット テストには参加してこれにフォーカスを設定できます。  
  
<a name="dependencyPropertyInfo_IsVisible"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.IsVisibleProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsVisibleChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.IsVisibleChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsVisibleChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsVisibleChanged;" />
      <MemberSignature Language="F#" Value="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsVisibleChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の <see cref="P:System.Windows.UIElement.IsVisible" /> プロパティの値が変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 値以外の理由、レイアウト システムによって、要素がレンダリングされない場合、このイベントは発生しませんが、<xref:System.Windows.UIElement.IsVisible%2A>プロパティ。 たとえば、要素は、関連付けられている visual があります。  
  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisibleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsVisibleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsVisibleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.IsVisibleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsVisibleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsVisibleProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsVisibleProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.IsVisibleProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.IsVisible" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーの処理は、コマンドを実行し、テキストの合成などその他のプラットフォーム機能と対話します。 <xref:System.Windows.UIElement.KeyDown>イベントは、下位レベルのテキストの入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、ため、一部のコントロールがあるコントロールの複合またはテキストの高度なバージョンを提供するクラスの処理の入力処理および関連するイベントです。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.KeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.KeyDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.KeyDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewKeyDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.KeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.UIElement.KeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.KeyUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.KeyUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewKeyUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.KeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler LayoutUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LayoutUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LayoutUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LayoutUpdated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LayoutUpdated;" />
      <MemberSignature Language="F#" Value="member this.LayoutUpdated : EventHandler " Usage="member this.LayoutUpdated : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>現在の <see cref="T:System.Windows.Threading.Dispatcher" /> に関連付けられた各種ビジュアル要素のレイアウトが変更されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 レイアウトの更新は、プロパティの変更、ウィンドウのサイズ変更、または明示的なユーザーの要求の結果として発生します。  
  
 このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素が論理フォーカスを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。 ここでは、キーボード フォーカスのままですが、および要素の位置を<xref:System.Windows.UIElement.Focus%2A>メソッドが呼び出されますも論理フォーカスを取得します。  
  
 このイベントをより正確に解釈がその it 発生する状況の値、<xref:System.Windows.UIElement.IsFocused%2A>からルート内の要素のプロパティが変更される`true`に`false`します。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを取得、実際の要素を決定するためにイベント データ。  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.LostFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.RoutedEventHandler>|  
  
-   対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnLostFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.LostFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを失っている実際の要素を決定するためにイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.LostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.LostKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.LostKeyboardFocusEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がマウス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がマウスをキャプチャは、ポインターがその境界の外側にある場合でも、マウス入力を受け取ります。 マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>キャプチャを失った実際の要素を決定するためにイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.LostMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.LostMouseCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.LostMouseCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnLostMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.LostMouseCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がスタイラス キャプチャを失ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素がスタイラスをキャプチャするときは、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。 スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。  
  
 このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを失っている実際の要素を決定するためにイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.LostStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.LostStylusCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.LostStylusCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnLostStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.LostStylusCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がタッチのキャプチャを失うと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.LostTouchCaptureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnLostTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.LostTouchCapture" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; ManipulationBoundaryFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationBoundaryFeedback As EventHandler(Of ManipulationBoundaryFeedbackEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^&gt; ^ ManipulationBoundaryFeedback;" />
      <MemberSignature Language="F#" Value="member this.ManipulationBoundaryFeedback : EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; " Usage="member this.ManipulationBoundaryFeedback : System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationBoundaryFeedbackEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作中に境界に到達したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_ManipulationBoundaryFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationBoundaryFeedbackEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationBoundaryFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationBoundaryFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationBoundaryFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationBoundaryFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationBoundaryFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompleted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationCompletedEventArgs&gt; ManipulationCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationCompleted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationCompleted As EventHandler(Of ManipulationCompletedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationCompletedEventArgs ^&gt; ^ ManipulationCompleted;" />
      <MemberSignature Language="F#" Value="member this.ManipulationCompleted : EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; " Usage="member this.ManipulationCompleted : System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationCompletedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.UIElement" /> オブジェクトの操作および慣性による処理が完了すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントを使用すると、完了時に、操作に関する情報を取得します。  たとえば、使用することができます、<xref:System.Windows.Input.ManipulationCompletedEventArgs.TotalManipulation%2A?displayProperty=nameWithType>総量操作の位置を決定するプロパティを変更します。  
  
 操作の詳細については、次を参照してください。、[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
<a name="routedEventInfo_ManipulationCompleted"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ManipulationCompletedEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationCompletedEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationCompletedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationCompletedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationCompletedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationCompletedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationCompletedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationCompletedEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationCompletedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.ManipulationCompleted" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDelta">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationDeltaEventArgs&gt; ManipulationDelta" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationDelta" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationDelta As EventHandler(Of ManipulationDeltaEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationDeltaEventArgs ^&gt; ^ ManipulationDelta;" />
      <MemberSignature Language="F#" Value="member this.ManipulationDelta : EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; " Usage="member this.ManipulationDelta : System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationDeltaEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作中に入力デバイスが位置を変更したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationDelta>イベントには複数回が発生したときに、ユーザーがドラッグした本の指画面上で、操作中に、もう一度慣性による処理が発生したとき。  使用することができます、<xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A>慣性による処理中に、イベントが発生しているかどうかを確認するプロパティ。  
  
 要素で<xref:System.Windows.UIElement.ManipulationDelta>イベント発生イベントが発生したときに何らかの方法では影響しません。  操作される要素にロジックを提供する必要があります。  <xref:System.Windows.Input.ManipulationDeltaEventArgs.CumulativeManipulation%2A>と<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>のプロパティの型は<xref:System.Windows.Input.ManipulationDelta>操作の位置を変更する方法についてのデータが含まれ、移動、サイズ変更、またはオブジェクトの回転として解釈されます。  操作される要素には、その情報を適用します。  
  
 操作の詳細については、次を参照してください。、[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
<a name="routedEventInfo_ManipulationDelta"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ManipulationDeltaEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationDeltaEventArgs>。|  
  
   
  
## Examples  
 次の例は、イベント ハンドラーを<xref:System.Windows.UIElement.ManipulationDelta>イベント。 この例では、<xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>プロパティを移動、サイズ変更、および回転を<xref:System.Windows.Shapes.Rectangle>します。  また、例を確認するかどうか、<xref:System.Windows.UIElement.ManipulationDelta>慣性と四角形は、ウィンドウの端をタッチするかどうかの中にイベントが発生しました。  そのような場合に該当する場合、アプリケーションは、四角形のアプリケーションの可視領域を離れることを防ぐために操作を停止します。 この例の例では[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
 [!code-csharp[BasicManipulation#ManipulationDelta](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationdelta)]
 [!code-vb[BasicManipulation#ManipulationDelta](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationdelta)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationDeltaEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationDeltaEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationDeltaEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationDeltaEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationDeltaEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationDeltaEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationDeltaEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.ManipulationDelta" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; ManipulationInertiaStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationInertiaStarting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationInertiaStarting As EventHandler(Of ManipulationInertiaStartingEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationInertiaStartingEventArgs ^&gt; ^ ManipulationInertiaStarting;" />
      <MemberSignature Language="F#" Value="member this.ManipulationInertiaStarting : EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; " Usage="member this.ManipulationInertiaStarting : System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationInertiaStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力デバイスが操作中に <see cref="T:System.Windows.UIElement" /> オブジェクトとの接続を失い、慣性による処理が開始されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationInertiaStarting>イベントは、ユーザーが操作中にすべての画面から指を離したときに発生します。 たとえば、ユーザーを「スロー」、 <xref:System.Windows.UIElement> 、サーフェイスの間で、ユーザーが影響を及ぼす、<xref:System.Windows.UIElement>アクションを開始する短い距離では、画面上で指を移動し、離します、<xref:System.Windows.UIElement>します。 慣性が開始要素を離したときに、<xref:System.Windows.UIElement.ManipulationInertiaStarting>イベントが発生します。  <xref:System.Windows.UIElement>の受信を継続<xref:System.Windows.UIElement.ManipulationDelta>要素で慣性による処理が行われていることを通知するイベントです。  
  
 このイベントを使用すると、慣性の動作を指定します。  たとえば、慣性が開始されるときに使用される初期速度を設定できます。  必要な減速を設定するか、目的の配置を設定して慣性による処理の量を指定することもできます。  これらの値 (平行移動、拡大縮小、または回転) 操作の種類ごとに個別に設定できます。  詳細については、「<xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>」を参照してください。  
  
 操作の詳細については、次を参照してください。、[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
<a name="routedEventInfo_ManipulationInertiaStarting"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ManipulationInertiaStartingEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationInertiaStartingEventArgs>。|  
  
   
  
## Examples  
 次の例は、<xref:System.Windows.UIElement.ManipulationInertiaStarting>イベント ハンドラーおよび平行移動、拡大縮小、および慣性による処理中に使用される回転に必要な減速を設定します。 この例の例では[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
 [!code-csharp[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationinertiastarting)]
 [!code-vb[BasicManipulation#ManipulationInertiaStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationinertiastarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationInertiaStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationInertiaStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationInertiaStartingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationInertiaStartingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationInertiaStartingEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationInertiaStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarted">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartedEventArgs&gt; ManipulationStarted" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarted" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationStarted As EventHandler(Of ManipulationStartedEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationStartedEventArgs ^&gt; ^ ManipulationStarted;" />
      <MemberSignature Language="F#" Value="member this.ManipulationStarted : EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; " Usage="member this.ManipulationStarted : System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartedEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力デバイスで <see cref="T:System.Windows.UIElement" /> オブジェクトの操作を開始すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationStarted>イベントが発生した後、<xref:System.Windows.UIElement.ManipulationStarting>イベント。  使用して、次を行うことができます、 <xref:System.Windows.Input.ManipulationStartedEventArgs>:  
  
-   使用して、操作の位置が関連している要素を取得、<xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationContainer%2A>プロパティ。  
  
-   使用して、操作の始点を取得、<xref:System.Windows.Input.ManipulationStartedEventArgs.ManipulationOrigin%2A>プロパティ。  
  
-   呼び出して、操作をキャンセル、<xref:System.Windows.Input.ManipulationStartedEventArgs.Complete%2A>メソッド。  
  
 操作の詳細については、次を参照してください。、[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
<a name="routedEventInfo_ManipulationStarted"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ManipulationStartedEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationStartedEventArgs>。|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationStartedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationStartedEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationStartedEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationStartedEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.ManipulationStarted" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStarting">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.ManipulationStartingEventArgs&gt; ManipulationStarting" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.ManipulationStarting" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ManipulationStarting As EventHandler(Of ManipulationStartingEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::ManipulationStartingEventArgs ^&gt; ^ ManipulationStarting;" />
      <MemberSignature Language="F#" Value="member this.ManipulationStarting : EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; " Usage="member this.ManipulationStarting : System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.ManipulationStartingEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>操作プロセッサを初めて作成するときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.ManipulationStarting>イベントを持つ要素で発生する、<xref:System.Windows.UIElement.IsManipulationEnabled%2A>プロパティに設定`true`にユーザーの指が。 既定では、後続の操作イベントを持つ要素を基準とした操作の位置を報告<xref:System.Windows.UIElement.IsManipulationEnabled%2A>設定`true`します。  設定を位置は別の要素を基準としたことを指定することができます、<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>プロパティ。 たとえば、要素の親に対する相対的な操作を行うことができます。  
  
 イベント ハンドラーでは、次を実行することもできます<xref:System.Windows.UIElement.ManipulationStarting>:。  
  
-   ユーザーが 1 つ以上の指を設定して、操作を実行する必要があるかどうかを指定、<xref:System.Windows.Input.ManipulationStartingEventArgs.IsSingleTouchEnabled%2A?displayProperty=nameWithType>プロパティ。  
  
-   設定操作の種類が有効になっているかを指定、<xref:System.Windows.Input.ManipulationStartingEventArgs.Mode%2A?displayProperty=nameWithType>プロパティを<xref:System.Windows.Input.ManipulationModes>列挙体。  
  
-   1 本指による回転の中心を設定して指定、<xref:System.Windows.Input.ManipulationStartingEventArgs.Pivot%2A?displayProperty=nameWithType>プロパティ。  
  
-   呼び出して、操作をキャンセル、<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A?displayProperty=nameWithType>メソッド。  
  
 操作の詳細については、次を参照してください。、[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  操作に応答するアプリケーションの例は、次を参照してください。[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
<a name="routedEventInfo_ManipulationStarting"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.ManipulationStartingEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.ManipulationStartingEventArgs>。|  
  
   
  
## Examples  
 次の例では、イベントのイベント ハンドラー、<xref:System.Windows.UIElement.ManipulationStarting>イベントとセット、<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>操作の座標は親要素に対する相対的なように操作イベントを受信する親要素にします。  この例の例では[チュートリアル。初めてのタッチ アプリケーションを作成する](~/docs/framework/wpf/advanced/walkthrough-creating-your-first-touch-application.md)します。  
  
 [!code-csharp[BasicManipulation#ManipulationStarting](~/samples/snippets/csharp/VS_Snippets_Wpf/basicmanipulation/csharp/mainwindow.xaml.cs#manipulationstarting)]
 [!code-vb[BasicManipulation#ManipulationStarting](~/samples/snippets/visualbasic/VS_Snippets_Wpf/basicmanipulation/visualbasic/mainwindow.xaml.vb#manipulationstarting)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ManipulationStartingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ManipulationStartingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ManipulationStartingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ManipulationStartingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ManipulationStartingEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable ManipulationStartingEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.ManipulationStartingEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.ManipulationStarting" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Measure">
      <MemberSignature Language="C#" Value="public void Measure (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Measure(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.Measure(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Measure (availableSize As Size)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Measure(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="member this.Measure : System.Windows.Size -&gt; unit" Usage="uIElement.Measure availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">親要素が子要素を割り当てることができる使用可能な領域。 子要素は使用可能な空間よりも大きな空間を要求できます。現在の要素のコンテンツ モデルでスクロールが可能な場合、指定されたサイズに対応できる可能性があります。</param>
        <summary><see cref="T:System.Windows.UIElement" /> の <see cref="P:System.Windows.UIElement.DesiredSize" /> を更新します。 親要素は、独自の <see cref="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" /> 実装からこのメソッドを呼び出し、レイアウトを再帰的に更新します。 このメソッドの呼び出しは、レイアウト更新の最初のパス (「メジャー」パス) となります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 レイアウトの配置での計算[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で構成を<xref:System.Windows.UIElement.Measure%2A>を呼び出すと<xref:System.Windows.UIElement.Arrange%2A>呼び出します。 中に、<xref:System.Windows.UIElement.Measure%2A>呼び出し、要素を使用してそのサイズ要件を決定する、`availableSize`入力します。 中に、<xref:System.Windows.UIElement.Arrange%2A>要素のサイズの呼び出しを終了します。  
  
 `availableSize` 任意の数を無制限に 0 を指定できます。 要素のレイアウトに参加しているが、最小値を返す必要があります<xref:System.Windows.Size>の必要な指定された`availableSize`します。  
  
 常に受信レイアウトが初めてインスタンス化されたときに、<xref:System.Windows.UIElement.Measure%2A>前に呼び出す<xref:System.Windows.UIElement.Arrange%2A>します。 ただし、最初のレイアウト パスの後に受け取る場合があります、<xref:System.Windows.UIElement.Arrange%2A>せずに呼び出す、 <xref:System.Windows.UIElement.Measure%2A>; 場合のみに影響を与えるプロパティ<xref:System.Windows.UIElement.Arrange%2A>(配置) などが変更された親を受け取ったとき、または、<xref:System.Windows.UIElement.Arrange%2A>せず、 <xref:System.Windows.UIElement.Measure%2A>. A<xref:System.Windows.UIElement.Measure%2A>呼び出しが自動的に無効になり、<xref:System.Windows.UIElement.Arrange%2A>呼び出します。  
  
 レイアウトの更新は、あらゆるレイアウトの変更をメイン スレッドが待機していないように、非同期的に発生します。 分離コードのプロパティ値のチェックを使用して要素のクエリを実行しても、そのサイズやレイアウトの特性と対話するプロパティの変更がすぐに反映可能性がありますされません (、<xref:System.Windows.FrameworkElement.Width%2A>プロパティなど)。  
  
> [!NOTE]
>  使用してレイアウトの更新を強制することができます、<xref:System.Windows.UIElement.UpdateLayout%2A>メソッド。 ただし、このメソッドを呼び出すことは通常必要はありません、パフォーマンスの低下が発生することができます。  
  
 レイアウト システムは 2 つの異なるキューのいずれか、無効なレイアウトの<xref:System.Windows.UIElement.Measure%2A>とに 1 つずつ<xref:System.Windows.UIElement.Arrange%2A>します。 レイアウトのキューはレイアウトを実行する要素のビジュアル ツリー内の要素の順序に基づいて並べ替えられますツリーの上位の要素では、親の変更を繰り返すことによって、冗長なレイアウトを回避するために、キューの上部にあります。 重複するエントリは自動的に、キューから削除し、レイアウト検証は既に要素も、キューから自動的に削除します。  
  
 レイアウトを更新するときに、<xref:System.Windows.UIElement.Measure%2A>キューが最初に、空に続けて、<xref:System.Windows.UIElement.Arrange%2A>キュー。 内の要素、<xref:System.Windows.UIElement.Arrange%2A>内の要素がある場合、キューは配置しない、<xref:System.Windows.UIElement.Measure%2A>キュー。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberSignature Language="F#" Value="abstract member MeasureCore : System.Windows.Size -&gt; System.Windows.Size&#xA;override this.MeasureCore : System.Windows.Size -&gt; System.Windows.Size" Usage="uIElement.MeasureCore availableSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">親要素が子に割り当てることができる、使用可能なサイズ。</param>
        <summary>派生クラスでオーバーライドされると、子要素のコンテンツのサイズも考慮して、この要素のサイズを適切に設定するための測定ロジックを提供します。</summary>
        <returns>レイアウト内のこの要素の必要なサイズ。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素を派生する方が一般的です<xref:System.Windows.FrameworkElement>なく<xref:System.Windows.UIElement>します。 派生する場合<xref:System.Windows.FrameworkElement>、注意のオーバーライドを<xref:System.Windows.UIElement.MeasureCore%2A>で<xref:System.Windows.FrameworkElement>シール、<xref:System.Windows.UIElement.MeasureCore%2A>メソッド。 のみをオーバーライドするため、<xref:System.Windows.UIElement.MeasureCore%2A>から派生する場合は、レイアウトの測定の特性を変更するための手段として<xref:System.Windows.UIElement>が含まれていない、継承によって<xref:System.Windows.FrameworkElement>します。 これがある場合、独自の実装をビルドしようとする場合、[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]コア レベル。 派生する場合はそれ<xref:System.Windows.FrameworkElement>、メジャーの動作の実装のテンプレートは、<xref:System.Windows.FrameworkElement>の実装。<xref:System.Windows.FrameworkElement.MeasureOverride%2A>します。  
  
 子要素を持つ親要素で呼び出す必要があります<xref:System.Windows.UIElement.Measure%2A>それぞれの子では、それ以外の場合これらの子要素はいないサイズまたは配置されはレイアウトから効果的に表示されません。  
  
   
  
## Examples  
 一般的なオーバーライド<xref:System.Windows.UIElement.MeasureCore%2A>おおよそこのパターンに従います (という組み込みのコレクションがない`VisualChildren`;`VisualChildren`要素を保持任意の子コレクションを表すプレース ホルダーです)。  
  
 [!code-csharp[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementmeasureoverride)]
 [!code-vb[CorePseudocode#UIElementMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementmeasureoverride)]  
  
-   呼び出す必要があります<xref:System.Windows.UIElement.Measure%2A>で各子要素。  
  
-   一般に、実装が間測定情報をキャッシュする、<xref:System.Windows.UIElement.MeasureCore%2A>と<xref:System.Windows.UIElement.ArrangeCore%2A>メソッドの呼び出しで同じ要素。  
  
-   基本実装を呼び出す<xref:System.Windows.UIElement.MeasureCore%2A>は必要ありませんが、適切なは、基本の実装が必要なレイアウト機能を提供する場合があります。  
  
-   呼び出す<xref:System.Windows.UIElement.Measure%2A>の子要素渡す必要があります同じであるか`availableSize`親、または領域のサブセットの場合は、レイアウトの種類に応じて、親要素をサポートしています。 たとえば、要素に固有の枠線または埋め込み、スクロール バー、またはカスタム コントロールの領域を削除するでしょう。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>実装は、指定された値を処理できる必要があります<paramref name="availableSize" />有限です。 無限の値は、要求の制約がないことを示します。 および Measure の再帰呼び出しからの親要素の測定の選択を効果的に延期します。  
  
実装は、指定された値を検討できます<paramref name="availableSize" />ソフト制約にします。 子要素は、アプリケーション コードの他の側面が親要素の現在の実際のサイズを決定できる場合でもより大きなサイズの場合を指定可能性があります。 大きなサイズの要求は、親要素がコンテンツの表示領域内のコンテンツのスクロールをサポートできるかどうか、子要素をクエリすることを示す規則です。</para></block>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.MouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.MouseDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.MouseDown>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.UIElement.MouseLeftButtonDown>または<xref:System.Windows.UIElement.MouseRightButtonDown>に対応する 2 つの標準のマウス ボタンのいずれかのキーを押します。 <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。 「解説」を参照してください。<xref:System.Windows.UIElement.MouseLeftButtonDown>または<xref:System.Windows.UIElement.MouseRightButtonDown>します。  
  
> [!IMPORTANT]
>  一部のコントロールは、固有のクラスのマウス ボタンのイベント処理があります。 左マウス ボタンを押すイベントは、クラス、コントロールの処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。 イベントが処理済みマークされると、その要素にアタッチされている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー UI ツリーのルートに向かうバブルの方向に要素にアタッチされているが通常も発生します。  
  
 前の重要なに記載されている問題を解決でき、それでも<xref:System.Windows.UIElement.MouseDown>をこれらのソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、<xref:System.Windows.UIElement.PreviewMouseDown>イベントで、コントロールによって処理済みとしてマークされていません。 これは、プレビュー イベントであるため、ルートがルートをトンネリングをコントロールに注意してください。  
  
-   コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.UIElement.AddHandler%2A>とルーティング イベントのデータの処理としてマークされている場合でも、イベントをリッスンするハンドラーの有効な署名オプションを選択します。  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewMouseDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseEnter> 直接イベント ルーティング方法の処理を使用します。 ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。 ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.MouseEnter>マウス ポインターがこのイベントの詳細、要素の境界内に入る時点を追跡しますが文字どおり報告された、<xref:System.Windows.UIElement.IsMouseOver%2A>からプロパティ値が変更された`false`に`true`この要素にします。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.MouseEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.MouseEnter>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 A <xref:System.Windows.Controls.Button> (またはその<xref:System.Windows.Controls.Primitives.ButtonBase>派生クラス) のネイティブの処理が、<xref:System.Windows.UIElement.KeyDown>ボタンにフォーカスがあり、スペース バーが押されたときにイベント。 ネイティブの処理が発生、 <xref:System.Windows.Controls.Primitives.ButtonBase.Click>  ボタンが、ソースとしてイベントもマウス ポインターが移動には表示されない場合でも、マウスをキャプチャします。 マウスのキャプチャの結果として、<xref:System.Windows.UIElement.MouseEnter>イベントがソースとしてボタンも発生します。 一般に、要素がマウスをキャプチャし、<xref:System.Windows.UIElement.MouseEnter>が発生しただけでなく<xref:System.Windows.UIElement.GotMouseCapture>およびその他のコントロールに固有のイベント可能性があります。  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>マウス ポインターがこの要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeave> 直接イベント ルーティング方法の処理を使用します。 ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。 ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.MouseLeave>マウスが離れるときに、要素では、このイベントの詳細は、トラックが文字どおり報告された、<xref:System.Windows.UIElement.IsMouseOver%2A>からプロパティ値が変更された`true`に`false`この要素。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.MouseLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.MouseLeave>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.MouseLeftButtonDown>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。 これは、可能性がありますが含まれていますクラス ハンドラーが生成されたイベントにはなど<xref:System.Windows.Controls.Control.MouseDoubleClick>します。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
> [!IMPORTANT]
>  一部のコントロール クラスには、固有のクラスのマウス ボタンのイベント処理があります。 左マウス ボタンを押すイベントは、クラス、コントロールの処理が最も可能性の高いイベントです。 多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。 イベントが処理済みマークされると、その要素にアタッチされている他のインスタンス ハンドラーは通常は発生しません。 その他のクラスまたはインスタンス ハンドラー UI ツリーのルートに向かうバブルの方向に要素にアタッチされているが通常も発生します。  
  
 前の重要なに記載されている問題を解決でき、それでも<xref:System.Windows.UIElement.MouseLeftButtonDown>をこれらのソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベントをマウスの左ボタンのイベント。  
  
-   ハンドラーのアタッチ、<xref:System.Windows.UIElement.PreviewMouseDown>イベントで、コントロールによって処理済みとしてマークされていません。 これは、プレビュー イベントであるため、ルートがルートをトンネリングをコントロールに注意してください。  
  
-   コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.UIElement.AddHandler%2A>とルーティング イベントのデータの処理としてマークされている場合でも、イベントをリッスンするハンドラーの有効な署名オプションを選択します。  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.MouseLeftButtonUp>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.MouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.MouseMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewMouseMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.MouseRightButtonDown>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。 これは、可能性がありますが含まれていますクラス ハンドラーが生成されたイベントにはなど<xref:System.Windows.Controls.Control.MouseDoubleClick>します。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
 右側のボタンのマウス イベントは、アプリケーションのシナリオでネイティブ処理を頻繁にあります。 たとえば、マウスの右ボタンを押したままは、コンテキスト メニューを表示することがあります。 参照してください[ContextMenu の概要](~/docs/framework/wpf/controls/contextmenu-overview.md)します。  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリーを通じてバブル ルーティングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.MouseRightButtonUp>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.MouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.MouseUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.MouseUp>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.UIElement.MouseLeftButtonUp>または<xref:System.Windows.UIElement.MouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのリリースに対応します。 <xref:System.Windows.UIElement.MouseLeftButtonUp> <xref:System.Windows.UIElement.MouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。 「解説」を参照してください。<xref:System.Windows.UIElement.MouseLeftButtonUp>または<xref:System.Windows.UIElement.MouseRightButtonUp>します。  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewMouseUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスおよびマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、発生した場合、<xref:System.Windows.UIElement.MouseWheel>フォーカスがあるか、キャプチャした要素からのイベント、マウス ポインター実際にもあります別の要素。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.MouseWheel>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.MouseWheel>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.MouseWheelEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewMouseWheel>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.MouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="uIElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">既存のタブ オーダーを検査するモード、または視覚的な移動方向を示すプロパティを含む検査要求。</param>
        <summary>この要素から別の要素へのフォーカスの移動を試みます。 フォーカスの移動方向は、ガイドラインの方向によって指定され、この要素のビジュアル親の編成内で解釈されます。</summary>
        <returns>要求した検査が実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドの戻り値を確認してください。 戻り値`false`コントロールの複合で定義されているタブ ストップの検査が実行され、検査要求を要求をラップしていないかどうかに返される可能性があります。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnAccessKey">
      <MemberSignature Language="C#" Value="protected virtual void OnAccessKey (System.Windows.Input.AccessKeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAccessKey(class System.Windows.Input.AccessKeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnAccessKey(System.Windows.Input.AccessKeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAccessKey (e As AccessKeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAccessKey(System::Windows::Input::AccessKeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit&#xA;override this.OnAccessKey : System.Windows.Input.AccessKeyEventArgs -&gt; unit" Usage="uIElement.OnAccessKey e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.AccessKeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">アクセス キー イベントのイベント データ。 イベント データは、呼び出されたキーを報告し、これらのイベントの送信を制御する <see cref="T:System.Windows.Input.AccessKeyManager" /> オブジェクトが、このアクセス キーの呼び出しを他の要素にも送信したかどうかを示します。</param>
        <summary>この要素に対して有効なアクセス キーが呼び出されたときのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 実際のアクセス キー イベントではありません、<xref:System.Windows.UIElement>クラス、またはその他のハンドラーをアタッチすることができますか。 専任マネージャー クラスを使用して、イベントが発生した代わりに、 <xref:System.Windows.Input.AccessKeyManager>、後に入力モデル全体に適用されるアクセス キーを検索するすべての入力を処理します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このメソッドの既定の実装<see cref="T:System.Windows.UIElement" />キーボード フォーカスをこの要素のセット (呼び出して<see cref="M:System.Windows.UIElement.Focus" />)。 実装は、ユーザー補助のシナリオで期待される動作のために、フォーカスを設定できるいる場合、この動作を永続化する必要があります。 基本の実装では、渡されたイベント データで何も行いません、他のイベントは発生しません同様に、フォーカスを設定します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnChildDesiredSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChildDesiredSizeChanged (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChildDesiredSizeChanged(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChildDesiredSizeChanged (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChildDesiredSizeChanged(System::Windows::UIElement ^ child);" />
      <MemberSignature Language="F#" Value="abstract member OnChildDesiredSizeChanged : System.Windows.UIElement -&gt; unit&#xA;override this.OnChildDesiredSizeChanged : System.Windows.UIElement -&gt; unit" Usage="uIElement.OnChildDesiredSizeChanged child" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">サイズが変更される子要素。</param>
        <summary>子要素のサイズが変更されるときのレイアウト動作をサポートします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは通常、アプリケーション コードで呼び出されません。 公開されるため、クラスで、その派生型の要素が無効な可能性がありますレイアウト状態を確認します。 クラスは、子要素をサイズ変更に基づくレイアウト パスの処理時間を最小限に抑えるの最適化を試みるも可能性があります。 例を実装する要素のクラスを派生する<xref:System.Windows.UIElement.OnChildDesiredSizeChanged%2A>は、<xref:System.Windows.Controls.Grid>コントロール。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />メソッドが呼び出し元の既定の実装<see cref="M:System.Windows.UIElement.InvalidateMeasure" />自体。 一般的な実装になります: 最適化を独自の要素をサポートし、基本通常呼び出す<see cref="M:System.Windows.UIElement.OnChildDesiredSizeChanged(System.Windows.UIElement)" />から少なくとも 1 つのコード分岐 (キャッシュ ロジック、独自のメジャーごとに「ダーティ」状態を示すもの)。  
  
このメソッドはサイズの変更を開始した子自体があった場合、レイアウト処理でのみ呼び出されます。 それ以外の場合、親要素が開始する場合、<see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" />を渡すと、レイアウト システム規則に従って、親が再計算レイアウト既にします。 親要素のサイズ変更に子要素のレイアウトの呼び出しからの戻り値は必要ありませんので、レイアウト システムは子と親の順序のレイアウトを処理します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="uIElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] インフラストラクチャの、クラス固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装を返します。</summary>
        <returns>型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>通常このメソッドの実装は、特定のコンス トラクターを呼び出す<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />実装では、戻り値として返すとします。  
  
すべて<see cref="T:System.Windows.UIElement" />派生クラスは、独自の特定の提供するためにこのメソッドを実装する必要があります<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />を実装する、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]インフラストラクチャ。 このパターンの実装の詳細については、「<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.UIElement.GotFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>提供されたイベント データを使用して、<see cref="E:System.Windows.UIElement.GotFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、仮想は、イベントを発生させる既定の実装。  
  
 これを * メソッドの実装は、イベントを発生させる、およびイベントを発生させる、この同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.UIElement.IsFocused%2A>プロパティ値が変更されます。 <xref:System.Windows.UIElement.OnGotFocus%2A>からその他の実装とは異なる[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で * のみそのイベントのクラス処理を追加する便利な手段を提供するには、実装します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>フォーカス イベントを発生させないする意図とは異なる必要がない限り、実装が、基本実装を呼び出すことを確認します。 それ以外の場合、<see cref="E:System.Windows.UIElement.GotFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザー操作中に発生しません。 要素にフォーカスを設定しない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.UIElement.Focusable" />に<see langword="false" />します。</para></block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
        <altmember cref="E:System.Windows.UIElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>タッチがこの要素にキャプチャされているときに発生する <see cref="E:System.Windows.UIElement.GotTouchCapture" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnGotTouchCapture%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnGotTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.GotTouchCapture>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnGotTouchCapture%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsKeyboardFocusedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsKeyboardFocused%2A>依存関係プロパティの変更。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>同じイベント データ インスタンスをイベントが発生します。 なお、<xref:System.Windows.UIElement.IsKeyboardFocusedChanged>イベントがルーティング イベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素によって <see cref="E:System.Windows.UIElement.IsKeyboardFocusWithinChanged" /> イベントが発生する直前に呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>依存関係プロパティの変更。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>同じイベント データ インスタンスをイベントが発生します。 なお、<xref:System.Windows.UIElement.IsKeyboardFocusWithinChanged>イベントがルーティング イベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsMouseCapturedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsMouseCaptured%2A>依存関係プロパティの値が変化します。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsMouseCapturedChanged>同じイベント データ インスタンスをイベントが発生します。 なお、<xref:System.Windows.UIElement.IsMouseCapturedChanged>イベントは、ルーティング イベントはありません。そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>この仮想メソッドが発生したときの値、<see cref="P:System.Windows.UIElement.IsMouseCaptureWithin" />依存関係プロパティの値が変化します。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<see cref="E:System.Windows.UIElement.IsMouseCaptureWithinChanged" />同じイベント データ インスタンスをイベントが発生します。 イベントがルーティング イベントで; ではないことに注意してください。そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsMouseDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsMouseDirectlyOver%2A>依存関係プロパティの値が変化します。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。 なお、<xref:System.Windows.UIElement.IsMouseDirectlyOverChanged>イベントがルーティング イベントではありません。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsStylusCapturedChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsStylusCaptured%2A>依存関係プロパティの値が変化します。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsStylusCapturedChanged>同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティング イベントではないことを確認します。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsStylusCaptureWithinChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsStylusCaptureWithin%2A>依存関係プロパティの値が変化します。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsStylusCaptureWithinChanged>同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティング イベントではないことを確認します。 そのため、クラス ハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="uIElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.IsStylusDirectlyOverChanged" /> イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この仮想メソッドが発生したときの値、<xref:System.Windows.UIElement.IsStylusDirectlyOver%2A>依存関係プロパティの値が変化します。 仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。 次に、<xref:System.Windows.UIElement.IsStylusDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。 イベントは、ルーティング イベントではないことを確認します。 そのため、クラスのハンドラーで処理されるようにマークすることはできません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーストロークは、専用の入力マネージャーによって処理されます。 その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。 これらの入力システムの機能、イベントを処理し、としてマークする場合<xref:System.Windows.UIElement.OnKeyDown%2A>は呼び出されません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーストロークは、専用の入力マネージャーによって処理されます。 その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。 これらの入力システムの機能、イベントを処理し、としてマークする場合<xref:System.Windows.UIElement.OnKeyUp%2A>は呼び出されません。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。 このイベント データには、<see cref="E:System.Windows.UIElement.LostFocus" /> イベントの識別子が含まれている必要があります。</param>
        <summary>提供されたイベント データを使って、<see cref="E:System.Windows.UIElement.LostFocus" /> ルーティング イベントを発生させます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドは、仮想は、イベントを発生させる既定の実装。  
  
 これを * メソッドの実装は、イベントを発生させる、およびイベントを発生させる、この同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.UIElement.IsFocused%2A>プロパティ値が変更されます。 この実装が異なるその他の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で * のみそのイベントのクラス処理を追加する便利な手段を提供するには、実装します。  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>フォーカス イベントを発生させないする意図とは異なる必要がない限り、実装が、基本実装を呼び出すことを確認します。 それ以外の場合、<see cref="E:System.Windows.UIElement.LostFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザー操作中に発生しません。 要素にフォーカスを設定しない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.UIElement.Focusable" />に<see langword="false" />します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納する <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>この要素がタッチのキャプチャを失ったときに発生する <see cref="E:System.Windows.UIElement.LostTouchCapture" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnLostTouchCapture%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnLostTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.LostTouchCapture>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnLostTouchCapture%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit&#xA;override this.OnManipulationBoundaryFeedback : System.Windows.Input.ManipulationBoundaryFeedbackEventArgs -&gt; unit" Usage="uIElement.OnManipulationBoundaryFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" /> イベントが発生すると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>イベント。 必ず、<xref:System.Windows.UIElement.OnManipulationBoundaryFeedback%2A>を基底クラスのための基本クラスのメソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationCompleted (System.Windows.Input.ManipulationCompletedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationCompleted(class System.Windows.Input.ManipulationCompletedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationCompleted(System.Windows.Input.ManipulationCompletedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationCompleted (e As ManipulationCompletedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationCompleted(System::Windows::Input::ManipulationCompletedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit&#xA;override this.OnManipulationCompleted : System.Windows.Input.ManipulationCompletedEventArgs -&gt; unit" Usage="uIElement.OnManipulationCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationCompletedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationCompleted" /> イベントが発生すると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationCompleted%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnManipulationCompleted%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.ManipulationCompleted>イベント。 必ず、<xref:System.Windows.UIElement.OnManipulationCompleted%2A>を基底クラスのための基本クラスのメソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationDelta">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationDelta (System.Windows.Input.ManipulationDeltaEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationDelta(class System.Windows.Input.ManipulationDeltaEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationDelta(System.Windows.Input.ManipulationDeltaEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationDelta (e As ManipulationDeltaEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationDelta(System::Windows::Input::ManipulationDeltaEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit&#xA;override this.OnManipulationDelta : System.Windows.Input.ManipulationDeltaEventArgs -&gt; unit" Usage="uIElement.OnManipulationDelta e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationDeltaEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationDelta" /> イベントが発生すると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationDelta%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnManipulationDelta%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.ManipulationDelta>イベント。 必ず、<xref:System.Windows.UIElement.OnManipulationDelta%2A>を基底クラスのための基本クラスのメソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationInertiaStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationInertiaStarting (System.Windows.Input.ManipulationInertiaStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationInertiaStarting(class System.Windows.Input.ManipulationInertiaStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationInertiaStarting(System.Windows.Input.ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationInertiaStarting (e As ManipulationInertiaStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationInertiaStarting(System::Windows::Input::ManipulationInertiaStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit&#xA;override this.OnManipulationInertiaStarting : System.Windows.Input.ManipulationInertiaStartingEventArgs -&gt; unit" Usage="uIElement.OnManipulationInertiaStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationInertiaStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationInertiaStarting" /> イベントが発生すると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.ManipulationInertiaStarting>イベント。 必ず、<xref:System.Windows.UIElement.OnManipulationInertiaStarting%2A>を基底クラスのための基本クラスのメソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarted">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarted (System.Windows.Input.ManipulationStartedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarted(class System.Windows.Input.ManipulationStartedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarted(System.Windows.Input.ManipulationStartedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationStarted (e As ManipulationStartedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationStarted(System::Windows::Input::ManipulationStartedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationStarted : System.Windows.Input.ManipulationStartedEventArgs -&gt; unit&#xA;override this.OnManipulationStarted : System.Windows.Input.ManipulationStartedEventArgs -&gt; unit" Usage="uIElement.OnManipulationStarted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベントのデータ。</param>
        <summary><see cref="E:System.Windows.UIElement.ManipulationStarted" /> イベントが発生すると呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationStarted%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnManipulationStarted%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.ManipulationStarted>イベント。 必ず、<xref:System.Windows.UIElement.OnManipulationStarted%2A>を基底クラスのための基本クラスのメソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnManipulationStarting">
      <MemberSignature Language="C#" Value="protected virtual void OnManipulationStarting (System.Windows.Input.ManipulationStartingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnManipulationStarting(class System.Windows.Input.ManipulationStartingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnManipulationStarting(System.Windows.Input.ManipulationStartingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnManipulationStarting (e As ManipulationStartingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnManipulationStarting(System::Windows::Input::ManipulationStartingEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit&#xA;override this.OnManipulationStarting : System.Windows.Input.ManipulationStartingEventArgs -&gt; unit" Usage="uIElement.OnManipulationStarting e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationStartingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.ManipulationStartingEventArgs" />。</param>
        <summary>操作プロセッサを初めて作成するときに発生する <see cref="E:System.Windows.UIElement.ManipulationStarting" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnManipulationStarting%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnManipulationStarting%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.ManipulationStarting>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnManipulationStarting%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。 一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.UIElement.OnMouseDown%2A>は呼び出されません。  
  
 このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.UIElement.MouseLeftButtonDown>と<xref:System.Windows.UIElement.MouseRightButtonDown>します。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。 処理することによって<xref:System.Windows.UIElement.OnMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、直接ルーティング戦略のルーティング イベントです。 一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、直接ルーティング戦略のルーティング イベントです。 一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>この要素上で未処理の <see cref="E:System.Windows.UIElement.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeftButtonDown>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.MouseLeftButtonDown>。 マークすることができますが、<xref:System.Windows.UIElement.MouseLeftButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。 基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>します。 派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A>、派生クラスで、基本実装を呼び出さずにただし、このオーバーライドを無効にします、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseLeftButtonUp>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.MouseLeftButtonUp>。 マークすることができますが、<xref:System.Windows.UIElement.MouseLeftButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnMouseLeftButtonUp%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseRightButtonDown>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.MouseRightButtonDown>。 マークすることができますが、<xref:System.Windows.UIElement.MouseRightButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。 基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>します。 派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.UIElement.OnMouseRightButtonDown%2A>ない; 呼び出し元のベースは、派生クラスでただし、この上書きを無効にしますに含まれる、コントロール上のコンテキスト] メニューの [サービスの<xref:System.Windows.Controls.Control>既定の動作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.MouseRightButtonUp>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。 <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.MouseRightButtonUp>。 マークすることができますが、<xref:System.Windows.UIElement.MouseRightButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnMouseRightButtonUp%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウス ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。 一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.UIElement.OnMouseUp%2A>は呼び出されません。  
  
 このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.UIElement.MouseLeftButtonUp>と<xref:System.Windows.UIElement.MouseRightButtonUp>します。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。 処理することによって<xref:System.Windows.UIElement.OnMouseUp%2A>、クラス処理は、すべての可能なマウスのボタンのアクションを記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="uIElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="uIElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="uIElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="uIElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。 一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>は呼び出されません。  
  
 このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>と<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>します。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。 処理することによって<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>します。 マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。 基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>します。 派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>、派生クラスで、基本実装を呼び出さずにただし、このオーバーライドを無効にします、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの左ボタンが放されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>します。 マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが押されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.MouseRightButtonDown>します。 マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>します。  
  
 または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。 基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。 呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>します。 派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>ない; 呼び出し元のベースは、派生クラスでただし、この上書きを無効にしますに含まれる、コントロール上のコンテキスト] メニューの [サービスの<xref:System.Windows.Controls.Control>既定の動作。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、マウスの右ボタンが離されたことを報告します。</param>
        <summary>未処理の <see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。 <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.UIElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>します。 マークすることができますが、<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。 イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。  
  
 処理の一般的なマウス イベントの既定の実装<xref:System.Windows.UIElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。 このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。 派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>します。 マウスの処理の動作を変更することはできません<xref:System.Windows.UIElement>オーバーライドすることで<xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。 このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。 一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。 これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>は呼び出されません。  
  
 このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>と<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>します。 これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>を受信します。  
  
 このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。 明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。 クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。 処理することによって<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>、クラス処理は、すべての可能なマウスのボタンのアクションを記述することを示すは。 この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。  
  
 各ボタンに固有の直接イベントもに、仮想 * メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。  
  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="uIElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。 プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.UIElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>この要素がタッチで押されたときに発生する <see cref="E:System.Windows.UIElement.PreviewTouchDown" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchDown%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.PreviewTouchDown>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.UIElement.PreviewTouchMove" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchMove%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.PreviewTouchMove>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.UIElement.PreviewTouchUp" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnPreviewTouchUp%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.PreviewTouchUp>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="uIElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="uIElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnRender">
      <MemberSignature Language="C#" Value="protected virtual void OnRender (System.Windows.Media.DrawingContext drawingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRender(class System.Windows.Media.DrawingContext drawingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRender(System::Windows::Media::DrawingContext ^ drawingContext);" />
      <MemberSignature Language="F#" Value="abstract member OnRender : System.Windows.Media.DrawingContext -&gt; unit&#xA;override this.OnRender : System.Windows.Media.DrawingContext -&gt; unit" Usage="uIElement.OnRender drawingContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="drawingContext" Type="System.Windows.Media.DrawingContext" />
      </Parameters>
      <Docs>
        <param name="drawingContext">特定の要素に対する描画命令。 このコンテキストはレイアウト システムに提供されます。</param>
        <summary>派生クラスでオーバーライドされると、レイアウト システムの指示で行われるレンダリング操作に参加します。 この要素に対するレンダリング指示は、このメソッドの呼び出し時に直接使用されるわけではなく、後からレイアウト処理や描画処理で非同期に使用されるときまで保存されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッド既定の実装ではない、<xref:System.Windows.UIElement>クラス。  
  
   
  
## Examples  
 次のコード例では、パネルの派生クラスに対して考えられる実装を示します。  
  
 [!code-csharp[LightWeightCustomPanel#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LightWeightCustomPanel/CSharp/OffsetPanel.cs#1)]
 [!code-vb[LightWeightCustomPanel#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LightWeightCustomPanel/visualbasic/offsetpanel.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><see cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />効果などの装飾のレンダリング要素を (論理ツリーで定義されていない) グラフィカル要素を追加するメソッドをオーバーライドすることができます。 A<see cref="T:System.Windows.Media.DrawingContext" />オブジェクトは、図形、テキスト、画像またはビデオを描画するためのメソッドを提供する引数として渡されます。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnRenderSizeChanged (System.Windows.SizeChangedInfo info);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnRenderSizeChanged (info As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ info);" />
      <MemberSignature Language="F#" Value="abstract member OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit&#xA;override this.OnRenderSizeChanged : System.Windows.SizeChangedInfo -&gt; unit" Usage="uIElement.OnRenderSizeChanged info" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="info">パッケージ化されたパラメーター (<see cref="T:System.Windows.SizeChangedInfo" />)。これには、新旧のサイズと、どのディメンションが実際に変更されたかが含まれます。</param>
        <summary>派生クラスでオーバーライドされると、レイアウト システムの指示で行われるレンダリング操作に参加します。 レイアウトの更新の結果として要素の <see cref="P:System.Windows.UIElement.RenderSize" /> が変化した場合、このメソッドはレイアウトが更新されてからレンダリングが行われるまでの間に呼び出されます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 一般的な WPF フレームワーク レベル要素からオーバーライド実装を使用して<xref:System.Windows.FrameworkElement>します。 <xref:System.Windows.FrameworkElement>実装を無効化、<xref:System.Windows.FrameworkElement.Width%2A>と<xref:System.Windows.FrameworkElement.Height%2A>プロパティとレイアウトを再構築の基礎のハンドル。 オーバーライドする<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>で、<xref:System.Windows.UIElement>レベルことを示します要素の実装は WPF フレームワーク レベルの実装を使用して意図的にないため、要素する必要がありますレイアウト ロジックよりを直接処理、通常記述することで、レイアウト システムを置換します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="uIElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="uIElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。 呼び出すことができます基本前に、または後、特別な処理の要件に応じて。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="uIElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="uIElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="uIElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</param>
        <summary>アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。 このイベントに対するクラス処理を追加するには、このメソッドを実装します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このメソッドには、既定の実装がありません。 継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。  
  
 このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで * メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。 ここで一致するイベントは、ルーティング イベントです。 On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。 そのため、実装では、イベント データのソースのプロパティを確認する必要があります。 ほとんどの場合、イベントが再発生する必要がありますください。  
  
 このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.UIElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。 クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>この要素の内部がタッチで押されたときに発生する <see cref="E:System.Windows.UIElement.TouchDown" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchDown%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.TouchDown>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnTouchDown%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>この要素の境界の外部から内部にタッチが移動したときに発生する <see cref="E:System.Windows.UIElement.TouchEnter" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchEnter%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnTouchEnter%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.TouchEnter>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnTouchEnter%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>タッチがこの <see cref="E:System.Windows.UIElement.TouchLeave" /> の境界の内部から外部に移動したときに発生する <see cref="T:System.Windows.UIElement" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchLeave%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnTouchLeave%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.TouchLeave>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnTouchLeave%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.UIElement.TouchMove" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchMove%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.TouchMove>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnTouchMove%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="uIElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</param>
        <summary>この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.UIElement.TouchUp" /> ルーティング イベントのクラス処理を提供します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.OnTouchUp%2A>メソッドには、既定の実装がありません。 オーバーライド<xref:System.Windows.UIElement.OnTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.UIElement.TouchUp>イベント。 基底クラスの呼び出しを必ず<xref:System.Windows.UIElement.OnTouchUp%2A>を基本クラス メソッドがイベントを受信します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberSignature Language="F#" Value="override this.OnVisualParentChanged : System.Windows.DependencyObject -&gt; unit" Usage="uIElement.OnVisualParentChanged oldParent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">直前の親。 <see cref="T:System.Windows.DependencyObject" /> に直前の親要素がなかった場合は、<see langword="null" /> を指定できます。</param>
        <summary>この <see cref="T:System.Windows.UIElement" /> の親要素によって、基になるビジュアル親に対する変更が報告されると呼び出されます。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>このメソッドをオーバーライドする場合は、常に基本の実装を呼び出します。 既定の基本実装では、逆継承されたプロパティの状態の一部の内部メンテナンスを実行します。 基本の実装の呼び出しに失敗すると、この状態が無効になります。  
  
このメソッドは、<see cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" /> をオーバーライドします。 <see cref="T:System.Windows.FrameworkElement" /> <see cref="T:System.Windows.Window" />オーバーライド両方も、<see cref="T:System.Windows.UIElement" />の実装<see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />、および<see cref="T:System.Windows.Window" />シールすることです。</para></block>
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberSignature Language="F#" Value="member this.Opacity : double with get, set" Usage="System.Windows.UIElement.Opacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="T:System.Windows.UIElement" /> を [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] に表示する際に、その全体に適用される不透明度率を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>不透明度率。 既定の不透明度は 1.0 です。 予期される値は 0 0 ～ 1.0 です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1.0 の既定値は、既定では、この依存関係プロパティの初期のメタデータによって提供される、<xref:System.Windows.UIElement>クラス。 他の派生クラスは、クラス コンス トラクター内からのメタデータをオーバーライドすることでこの既定値を変更可能性がある可能性があります。  
  
 値<xref:System.Windows.UIElement.Opacity%2A>要素が表示されてもいない限り、実際のレイアウトには適用されません (<xref:System.Windows.UIElement.IsVisible%2A>は`true`)。  
  
 <xref:System.Windows.UIElement.Opacity%2A> 適用されます親要素から要素ツリーの下位の子要素が可視の効果の設定は個々 の子要素のプロパティの値に示されている入れ子になったの不透明度。 たとえば、一覧に 50% (0.5) の不透明度があり、ユーザーがそのリスト項目のいずれかが、独自の不透明度が 20% (0.2) に設定は、そのリスト項目の net 表示の不透明度として表示するが 10% (0.1)、リスト項目のプロパティの値が<xref:System.Windows.UIElement.Opacity%2A>プロパティにあります。 照会されたときに、0.2。  
  
 宣言または評価の不透明度が 0 の場合でも、要素はまだ入力イベントと、コマンドに参加しがフォーカスを設定できる可能性があります。 この側面は、役立ちます、たとえばマスクの透明な要素を基になるオブジェクトの不透明度 0 オブジェクト (shape) などを使用できます。 不透明度 0 のオブジェクトは、すべての入力イベントを基になる領域の処理を処理できます。 ただし、`Background`または`Fill`オブジェクトまたは図形の必要があります設定する値になっている場合でも<xref:System.Windows.Media.Brushes.Transparent%2A>、それ以外の場合のヒット テストが有効でないと、イベントを受信しなかった。  
  
<a name="dependencyPropertyInfo_Opacity"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.OpacityProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.OpacityMask" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMask">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Brush OpacityMask { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Brush OpacityMask" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.OpacityMask" />
      <MemberSignature Language="VB.NET" Value="Public Property OpacityMask As Brush" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Brush ^ OpacityMask { System::Windows::Media::Brush ^ get(); void set(System::Windows::Media::Brush ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OpacityMask : System.Windows.Media.Brush with get, set" Usage="System.Windows.UIElement.OpacityMask" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Brush</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画されるコンテンツのアルファ チャネル マスクに適用される <see cref="T:System.Windows.Media.Brush" /> 実装として、不透明マスクを取得または設定します。  これは依存関係プロパティです。</summary>
        <value>不透明マスクに使用するブラシ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティがアルファ チャネル値は、指定されたものを使用してのみ<xref:System.Windows.Media.Brush>します。 他のチャネル、 <xref:System.Windows.Media.Brush>(赤、緑、または青) のコンテンツをレンダリングは無視されます。  
  
 最も一般的な<xref:System.Windows.Media.Brush>この目的は、<xref:System.Windows.Media.ImageBrush>マスク、画像を表示などのさまざまな使用できます。 定義されているいずれかが<xref:System.Windows.Media.Brush>(など<xref:System.Windows.Media.LinearGradientBrush>) ことができます。  
  
 [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]、このプロパティの値の各実装に固有のインライン構文を使用できます、<xref:System.Windows.Media.Brush>抽象クラス。 詳細については、次を参照してください。[純色およびグラデーション概要](~/docs/framework/wpf/graphics-multimedia/painting-with-solid-colors-and-gradients-overview.md)します。  
  
<a name="dependencyPropertyInfo_OpacityMask"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.OpacityMaskProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次のマークアップ例は、<xref:System.Windows.Media.ImageBrush>別に適用される不透明度マスク<xref:System.Windows.Controls.Image>します。  
  
 [!code-xaml[OpacityMasksSnippet#UIElementOpacityMask](~/samples/snippets/csharp/VS_Snippets_Wpf/OpacityMasksSnippet/CS/ImageBrushExample.xaml#uielementopacitymask)]   
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.Opacity" />
      </Docs>
    </Member>
    <Member MemberName="OpacityMaskProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityMaskProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityMaskProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityMaskProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpacityMaskProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OpacityMaskProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpacityMaskProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.OpacityMaskProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.OpacityMask" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpacityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OpacityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OpacityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.OpacityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OpacityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OpacityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable OpacityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.OpacityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Opacity" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistId">
      <MemberSignature Language="C#" Value="public int PersistId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PersistId" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.PersistId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PersistId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PersistId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PersistId : int" Usage="System.Windows.UIElement.PersistId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("PersistId is an obsolete property and may be removed in a future release.  The value of this property is not defined.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素を一意に識別する値を取得します。</summary>
        <value>この要素の一意の識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PersistId%2A> 各要素を一意に識別します。 要素は、同じ<xref:System.Windows.UIElement.PersistId%2A>たびに同じ[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)](バイナリ表現を含む) が読み込まれます。 内部の読み込み、解析およびシリアル化の要件については、この識別子が使用されます。 アプリケーション コードで使用されるものではありません。  
  
 このプロパティはリレーションシップを持たない、<xref:System.Object.GetHashCode%2A>特定のインスタンスの結果。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="uIElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">要求したフォーカス検査の方向。</param>
        <summary>派生クラスでオーバーライドされると、指定したフォーカス検査方向のフォーカスを受け取ることになる要素を返します。実際にはフォーカスはその要素に移動しません。</summary>
        <returns><see cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出された場合にフォーカスを受け取る要素。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このクラスでこのメソッドの既定の実装が完了していないと、常に返します`null`します。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewDragEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewDragEnter>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewDragEnterEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.DragEnter>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewDragEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewDragLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewDragLeave>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewDragLeaveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.DragLeave>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewDragLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewDragOver>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewDragOver>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewDragOverEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.DragOver>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewDragOver" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewDrop>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewDrop>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewDropEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.DragEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.Drop>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewDrop" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作が開始されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewGiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するために、マウス ポインターの外観を変更するドラッグ イベントのソース。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewGiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewGiveFeedback>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewGiveFeedbackEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.GiveFeedback>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキーボード フォーカスが移動したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、ルーティングのトンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を決定するためにイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewGotKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewGotKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.GotKeyboardFocus>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがある状態でキーが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーの処理は、コマンドを実行し、テキストの合成などその他のプラットフォーム機能と対話します。 <xref:System.Windows.UIElement.KeyDown>イベントは、下位レベルのテキストの入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、ため、一部のコントロールがあるコントロールの複合またはテキストの高度なバージョンを提供するクラスの処理の入力処理および関連するイベントです。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewKeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewKeyDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewKeyDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.KeyDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewKeyDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にフォーカスがあるときにキーが離されると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 キーの処理は、コマンドを実行し、テキストの合成などその他のプラットフォーム機能と対話します。 <xref:System.Windows.UIElement.KeyUp>イベントは、下位レベルのテキストの入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。 これは、ため、一部のコントロールがあるコントロールの複合またはテキストの高度なバージョンを提供するクラスの処理の入力処理および関連するイベントです。 詳細については、個々 のコントロールのドキュメントを確認します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewKeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewKeyUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewKeyUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.KeyUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewKeyUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素からキーボード フォーカスが離れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、ルーティングのトンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。 チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを失っている実際の要素を決定するためにイベント データ。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewLostKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewLostKeyboardFocusEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.LostKeyboardFocus>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewMouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewMouseDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.PreviewMouseDown>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>に対応する 2 つの標準のマウス ボタンのいずれかのキーを押します。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> <xref:System.Windows.UIElement.PreviewMouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。 「解説」を参照してください。<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>します。  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.MouseDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリー ルートをトンネリングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。 これは、可能性がありますが含まれていますクラス ハンドラーが生成されたイベントにはなど<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>します。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリー ルートをトンネリングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でマウス ポインターが動かされたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントは、どちらも、要素の境界にマウス ポインターが最初にマウス ポインターが要素の境界内に残っているときに移動したときにもとします。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewMouseMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.MouseMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリー ルートをトンネリングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.PreviewMouseRightButtonDown>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。 これは、可能性がありますが含まれていますクラス ハンドラーが生成されたイベントにはなど<xref:System.Windows.Controls.Control.PreviewMouseDoubleClick>します。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseRightButtonDownEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これは、次の要素ツリー ルートをトンネリングするよう、実際には、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を<xref:System.Windows.UIElement>します。  
  
 このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。  
  
 このイベントのイベント データは、基になるイベントのデータを公開<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。 そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.UIElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。 マークした場合<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>、処理は本質的にマークして<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>経路、さらにすべてのリスナーは自動的に処理およびすべての関連するイベントです。  
  
 概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.UIElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。 イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。 非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.UIElement>します。  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseRightButtonUpEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewMouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewMouseUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 <xref:System.Windows.UIElement.PreviewMouseUp>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>に対応する 2 つの標準のマウス ボタンのいずれかのキーを押します。 <xref:System.Windows.UIElement.PreviewMouseLeftButtonUp> <xref:System.Windows.UIElement.PreviewMouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。 「解説」を参照してください。<xref:System.Windows.UIElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.UIElement.PreviewMouseRightButtonUp>します。  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.MouseUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 フォーカスおよびマウスのキャプチャ、マウス ポインターが; よりも優先します。フォーカスがあるか、キャプチャした要素からこのイベントを受信する場合、マウス ポインター可能性が実際にある別の要素上。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewMouseMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewMouseWheelEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.MouseWheel>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewQueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを宣言します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewQueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewQueryContinueDrag>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewQueryContinueDragEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.QueryContinueDrag>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusButtonDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。 [Windows Vista でタッチ入力のサポート](https://msdn.microsoft.com/library/63f1d71f-03d8-4d83-a174-e3dc7c57bad0)と[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusButtonDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusButtonDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusButtonUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusButtonUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusButtonUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusInAirMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusInAirMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusInAirMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusInRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusInRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusInRange>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素上にあるときにスタイラスが移動すると発生します。 このイベントを発生させるためには、デジタイザーによって検出されている間にスタイラスが移動する必要があります。それ以外の場合には、代わりに <see cref="E:System.Windows.UIElement.PreviewStylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusOutOfRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusOutOfRangeEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusOutOfRange>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スタイラス ジェスチャについては、次を参照してください。<xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusSystemGesture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusSystemGestureEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusSystemGesture>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewStylusDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewStylusUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.StylusUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewStylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.PreviewTextInput>イベントでは、コンポーネントまたはデバイスに依存しない方法でテキスト入力をリッスンするアプリケーション。 キーボードの主要な手段は、 <xref:System.Windows.UIElement.PreviewTextInput>; が、音声認識、手書き入力、およびその他の入力デバイスも<xref:System.Windows.UIElement.PreviewTextInput>します。  
  
 -既定のキーボードまたは入力方式エディター - 経由のいずれかのキーの組み合わせにより、複数のキー イベントは 1 つのテキストの入力イベントを発生可能性があります。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.PreviewTextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.PreviewTextInput>イベントは、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewTextInputEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.TextInput>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewTextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定で、<xref:System.Windows.UIElement.PreviewTouchDown>と<xref:System.Windows.UIElement.TouchDown>指が画面をタッチし、移動するまで、イベントは発生しません。 画面に指を押すと、により、キーを押して移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>します。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、<xref:System.Windows.UIElement.PreviewTouchDown>と<xref:System.Windows.UIElement.TouchDown>、画面に触れると、すぐに発生するイベントの設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティを`false`この要素の。  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewTouchDownEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.TouchDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewTouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewTouchMoveEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.TouchMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewTouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.PreviewTouchUpEvent>|  
|ルーティング方法|トンネリング|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するバブル イベントが<xref:System.Windows.UIElement.TouchUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnPreviewTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.PreviewTouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.QueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.QueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.QueryContinueDrag>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.QueryContinueDragEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewQueryContinueDrag>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.QueryContinueDrag" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>カーソルの表示が要求されると発生します。 このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.QueryCursor>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.QueryCursor>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 このイベントの名前で参照されているカーソルは、必ずしも (挿入ポイントとも呼ばれる) にテキスト カーソルではありません。 代わりに、このコンテキストでのカーソルは、いくつかの可能な入力に関連するデバイスまたは Windows プログラミングの概念に関連する画面上のグラフィカル表示を宣言するオブジェクトです。 そのオブジェクトがによって表される、 <xref:System.Windows.Input.Cursor> wpf クラスです。 WPF 入力システムでは、画面上にマウス ポインターの位置を表す場合は、このカーソルを変更することができます。 定義済みの値を使用することができます、<xref:System.Windows.Input.Cursors>列挙型、または画像ファイルとしてカスタム カーソルを宣言できます。  
  
 リッスン、<xref:System.Windows.UIElement.QueryCursor>イベントは、カーソルの管理のための効率的な手法ではありません。 各要素が、独自のカーソルの動作を定義する代わりに、<xref:System.Windows.FrameworkContentElement.Cursor%2A>と<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>します。 のみに依存しないでください<xref:System.Windows.UIElement.QueryCursor>WPF フレームワーク レベルの基本要素を使用していないかで異常な場合に、カーソルの動作を定義する要素ごとの単位ではニーズに合わないかどうか。 応答でのカーソルの動作の実装の詳細については<xref:System.Windows.UIElement.QueryCursor>を参照してください<xref:System.Windows.Input.QueryCursorEventHandler>します。  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.QueryCursorEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   定義済みの対応するトンネル イベントはありません。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnQueryCursor%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.QueryCursor" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="uIElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">イベント データを格納し、発生するイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</param>
        <summary>特定のルーティング イベントを発生させます。 発生する <see cref="T:System.Windows.RoutedEvent" /> は、提供された <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で識別されます (そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして)。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e`パラメーターは、一般的なルーティング イベントのすべてのデータの基本型として型指定ただし、イベント データは、ために発生するイベントに使用される最も固有のイベント データの種類として指定する必要があります<xref:System.Windows.RoutedEventArgs>派生クラスが含まれて、。特定のイベントが発生したときは、特定の実際のデータ プロパティ。  
  
 <xref:System.Windows.RoutedEventArgs> イベントの状態のプロパティだけではありません。ルーティング イベントを発生させるも識別します。 このイベントの発生パターンと、ルーティング イベントのデータの両方とは異なる[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベントに関連するプロパティを通常だけが含まれるイベントやデータのクラス。  
  
   
  
## Examples  
 次の例では、イベント データを作成するには、イベント識別子をデータに追加およびイベント データのインスタンスを使用して、カスタム ルーティング イベントを発生させます。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="uIElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>キャプチャされているすべてのタッチ デバイスをこの要素から解放します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="uIElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素がマウス キャプチャを保持していた場合、キャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値をチェック<xref:System.Windows.UIElement.IsMouseCaptured%2A>このメソッドを呼び出す前にします。  
  
   
  
## Examples  
 次の例は、並列の指定の例に<xref:System.Windows.UIElement.CaptureMouse%2A>: マウスのキャプチャのリリースまでのマウス ボタンを処理し、マウスの移動を再度有効にします。  
  
 [!code-csharp[CubeAnimation#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[CubeAnimation#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="uIElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素がスタイラス デバイス キャプチャを保持していた場合、キャプチャを解放します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。 値をチェック<xref:System.Windows.UIElement.IsStylusCaptured%2A>このメソッドを呼び出す前にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="uIElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">解放の対象となるデバイス。</param>
        <summary>指定されたタッチ デバイスをこの要素から解放することを試みます。</summary>
        <returns>タッチ デバイスが解放された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> は <see langword="null" />です。</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="uIElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">ハンドラーがアタッチされているルーティング イベントの識別子。</param>
        <param name="handler">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</param>
        <summary>指定したルーティング イベント ハンドラーをこの要素から削除します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これを使用するための最も一般的なシナリオ[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]を実装する場合は、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 「ラッパー」イベントに関連付けられたカスタム ルーティング イベントをハンドラーでの「削除」するロジックを実装するときに具体的には、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]レベル。 これに続く例では、「解説」のセクションでは、このシナリオを示しています。  
  
 このメソッドを呼び出しても何も起こりません、メソッドの呼び出しの入力パラメーターに一致する条件で登録されたハンドラーがない場合。  
  
 複数のイベント ハンドラー ストアが削除される最初のハンドラーにのみ、条件に一致する 1 つのハンドラーがアタッチされます。 この動作は整合[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]の動作、`-=`演算子。  
  
 どちらも`routedEvent`も`handler`あります`null`します。 いずれかの値として提供しようとしています。`null`で例外が発生します。  
  
 このメソッドは無視、`handledEventsToo`場合は、ハンドラーが最初に提供されているパラメーターについては、追加、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>処理済みイベントの処理を有効に署名します。 ハンドラーのいずれかの型が削除されます。  
  
   
  
## Examples  
 次の例では<xref:System.Windows.UIElement.RemoveHandler%2A>イベント ラッパー定義の一部として。  
  
 [!code-csharp[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#addremovehandler)]
 [!code-vb[RoutedEventCustom#AddRemoveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#addremovehandler)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="RenderSize">
      <MemberSignature Language="C#" Value="public System.Windows.Size RenderSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Size RenderSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderSize" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Size RenderSize { System::Windows::Size get(); void set(System::Windows::Size value); };" />
      <MemberSignature Language="F#" Value="member this.RenderSize : System.Windows.Size with get, set" Usage="System.Windows.UIElement.RenderSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の最終的な描画サイズを取得します (または、設定します)。</summary>
        <value>この要素の描画のサイズ。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  このプロパティは、のいずれかを設定しないでください[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]やコードで、WPF フレームワーク レベルのレイアウト システムを使用する場合。 ほぼすべての一般的なアプリケーション シナリオでは、このレイアウト システムを使用します。 レイアウト システムはサイズ設定を考慮せず、<xref:System.Windows.UIElement.RenderSize%2A>プロパティを直接します。 <xref:System.Windows.UIElement.RenderSize%2A>プロパティが特定の WPF コア レベルのサポートなど、一般的なレイアウトのプロトコルを意図的に回避するケースのブリッジを有効にする場合にのみ書き込み可能な宣言されて、<xref:System.Windows.Documents.Adorner>クラス。  
  
 レイアウト システム内で該当するレンダリング サイズの上書きなどを確認するため、このプロパティを使用できます<xref:System.Windows.UIElement.OnRender%2A>または<xref:System.Windows.UIElement.GetLayoutClip%2A>します。  
  
 一般的なシナリオの処理、<xref:System.Windows.FrameworkElement.SizeChanged>クラス ハンドラーでイベントをオーバーライドまたは<xref:System.Windows.UIElement.OnRenderSizeChanged%2A>イベント。  
  
## Examples  
 次の例は、カスタム装飾が使用する方法を示しています、<xref:System.Windows.UIElement.RenderSize%2A>値を作成しの一部として、装飾を定義する四角形の画像のサイズを変更するにはその<xref:System.Windows.UIElement.OnRender%2A>実装します。  
  
 [!code-csharp[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/csharp/VS_Snippets_Wpf/AdornersMiscCode/CSharp/Window1.xaml.cs#uielementdesiredsize)]
 [!code-vb[AdornersMiscCode#UIElementDesiredSize](~/samples/snippets/visualbasic/VS_Snippets_Wpf/AdornersMiscCode/visualbasic/window1.xaml.vb#uielementdesiredsize)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.UpdateLayout" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform RenderTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform RenderTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ RenderTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RenderTransform : System.Windows.Media.Transform with get, set" Usage="System.Windows.UIElement.RenderTransform" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の描画位置に影響する変換情報を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>必要な描画変換の詳細を記述します。 既定値は、<see cref="P:System.Windows.Media.Transform.Identity" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 描画変換はレイアウト サイズを再生成またはサイズの情報を表示できません。 レンダリングの変換は通常アニメーションや要素に一時的な効果を適用するためのものです。 経由で、マウス ポインターを置いたまたはの該当部分に目を描画するために負荷に重点を置いた場合に、要素が拡大表示など、[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]します。  
  
<a name="dependencyPropertyInfo_RenderTransform"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.RenderTransformProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOrigin">
      <MemberSignature Language="C#" Value="public System.Windows.Point RenderTransformOrigin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Point RenderTransformOrigin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.RenderTransformOrigin" />
      <MemberSignature Language="VB.NET" Value="Public Property RenderTransformOrigin As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Point RenderTransformOrigin { System::Windows::Point get(); void set(System::Windows::Point value); };" />
      <MemberSignature Language="F#" Value="member this.RenderTransformOrigin : System.Windows.Point with get, set" Usage="System.Windows.UIElement.RenderTransformOrigin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.RenderTransform" /> によって宣言されるすべての使用可能な表示変換の中心点を、要素の境界からの相対位置で取得または設定します。  これは依存関係プロパティです。</summary>
        <value>描画変換を宣言する値。 既定値は座標が (0, 0) の <see cref="T:System.Windows.Point" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.RenderTransformOrigin%2A> やや非標準の使用、<xref:System.Windows.Point>を内の値を構造体、<xref:System.Windows.Point>の座標システムで絶対位置を表していません。 代わりに、0 から 1 までの値は、各 x、y 軸の現在の要素の範囲の要素として解釈されます。 たとえば、(0.5,0.5) が、要素上で中央揃えにする描画変換を (1, 1) または配置描画変換下部にある要素の右下隅。 <xref:System.Double.NaN> 使用できる値はありません。  
  
 0 と 1 を超える値も受け入れられ、独創的な変換の効果の詳細になります。 たとえば、設定した場合<xref:System.Windows.UIElement.RenderTransformOrigin%2A>(5,5) を適用し、 <xref:System.Windows.Media.RotateTransform>、要素自体の境界の外側にも、回転ポイントになります。 変換には、右下を超える発信される大きな円の周囲の要素をスピンします。 原点は、その親要素内で、どこかに可能性があり、フレームまたはビューから可能性がありますする可能性がある可能性があります。 負の値のポイント値に似ていますが、これらは境界の左上を超えます。  
  
 描画変換がレイアウトには影響しません、および通常はアニメーション化するか、要素に一時的な効果を適用に使用します。  
  
<a name="xamlAttributeUsage_RenderTransformOrigin"></a>   
## <a name="xaml-attribute-usage"></a>XAML 属性の使用方法  
  
```  
<object RenderTransformOrigin="xOrigin, yOrigin"/>  
```  
  
<a name="xamlPropertyElementUsage_RenderTransformOrigin"></a>   
## <a name="xaml-property-element-usage"></a>XAML プロパティ要素の使用  
  
```  
<object>  
  <object.RenderTransformOrigin>  
    <Point X=" xOrigin " Y=" yOrigin "/>  
  </object.RenderTransformOrigin>  
</object>  
```  
  
<a name="xamlValues_RenderTransformOrigin"></a>   
## <a name="xaml-values"></a>XAML 値  
 *xOrigin*  
 左右の余白の係数。 これは通常、0 ~ 1 の値として指定します。 「解説」を参照してください。  
  
 *yOrigin*  
 垂直方向の配信元の係数。 これは通常、0 ~ 1 の値として指定します。 「解説」を参照してください。  
  
<a name="dependencyPropertyInfo_RenderTransformOrigin"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.RenderTransformOriginProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、コード内の要素を作成して、適用、 <xref:System.Windows.UIElement.RenderTransformOrigin%2A>、し、適用、<xref:System.Windows.UIElement.RenderTransform%2A>します。  
  
 [!code-csharp[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/csharp/VS_Snippets_Wpf/transformanimations_snip/CSharp/RotateAboutCenterExample.cs#uielementrendertransformorigin)]
 [!code-vb[transformanimations_snip#UIElementRenderTransformOrigin](~/samples/snippets/visualbasic/VS_Snippets_Wpf/transformanimations_snip/visualbasic/rotateaboutcenterexample.vb#uielementrendertransformorigin)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.RenderTransform" />
      </Docs>
    </Member>
    <Member MemberName="RenderTransformOriginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformOriginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformOriginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RenderTransformOriginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RenderTransformOriginProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RenderTransformOriginProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.RenderTransformOriginProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.RenderTransformOrigin" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty RenderTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty RenderTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.RenderTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RenderTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ RenderTransformProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable RenderTransformProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.RenderTransformProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.RenderTransform" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="uIElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.UIElement.CommandBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.UIElement.CommandBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これにより返されます`true`場合<xref:System.Windows.UIElement.CommandBindings%2A>がローカルに設定します。  
  
 これは、`ShouldSerialize`メソッドが提供されますので、<xref:System.Windows.UIElement.CommandBindings%2A>プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発またはコントロールを組み込む独自に開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>します。  
  
 詳細については、次を参照してください。 [ShouldSerialize メソッドとリセット メソッドによる既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="uIElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.UIElement.InputBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</summary>
        <returns><see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.UIElement.InputBindings" />。それ以外の場合は <see langword="false" />。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 これにより返されます`true`場合<xref:System.Windows.UIElement.InputBindings%2A>がローカルに設定します。  
  
 これは、`ShouldSerialize`メソッドが提供されますので、<xref:System.Windows.UIElement.InputBindings%2A>プロパティには、単純な既定値はありません。 このメソッドは、プロパティが既定値から変更されたかどうかを示します。 デザイナーを開発またはコントロールを組み込む独自に開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>します。  
  
 詳細については、次を参照してください。 [ShouldSerialize メソッドとリセット メソッドによる既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixels">
      <MemberSignature Language="C#" Value="public bool SnapsToDevicePixels { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SnapsToDevicePixels" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberSignature Language="VB.NET" Value="Public Property SnapsToDevicePixels As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SnapsToDevicePixels { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SnapsToDevicePixels : bool with get, set" Usage="System.Windows.UIElement.SnapsToDevicePixels" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素のレンダリングがレンダリング中にデバイスに固有のピクセルの設定を使用するかどうかを決定する値を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>デバイスのピクセルに従って要素を描画する場合は <see langword="true" />、それ以外の場合は <see langword="false" />。 <see cref="T:System.Windows.UIElement" /> で宣言された既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティを設定することができます`true`ピクセルを有効にする、ルート要素でスナップ UI 全体を表示します。 96 よりも大きい値で動作するデバイスの[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]、ピクセル スナップ レンダリングには、単一の実線ポインターの近くのアンチエイリアシング ビジュアル アイテムが最小限に抑えることができます。  
  
 継承するときに<xref:System.Windows.FrameworkElement>可能性のあるすべての派生クラス、または<xref:System.Windows.FrameworkElement>を設定するには、この依存関係プロパティのメタデータをオーバーライド、<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>メタデータ プロパティを`true`します。 サブツリーの最も外側の要素だけを指定する必要があることは、この動作は<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>として`true`、そのサブツリーのすべての子要素は、レポートと<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>として`true`であり、<xref:System.Windows.UIElement.SnapsToDevicePixels%2A>視覚効果を適用します。  
  
<a name="dependencyPropertyInfo_SnapsToDevicePixels"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.SnapsToDevicePixelsProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/dotnet/netframework-3.5/aa970908(v=vs.90)">WPF アプリケーションのピクセル スナップ</related>
      </Docs>
    </Member>
    <Member MemberName="SnapsToDevicePixelsProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SnapsToDevicePixelsProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SnapsToDevicePixelsProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SnapsToDevicePixelsProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable SnapsToDevicePixelsProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.SnapsToDevicePixelsProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.SnapsToDevicePixels" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusButtonDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusButtonDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusButtonDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusButtonDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusButtonUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusButtonUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusButtonUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusButtonUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスがデジタイザーに触れたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusDown" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素の境界内に入ったときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusEnter> 直接イベント ルーティング方法の処理を使用します。 ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。 ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.StylusEnter>スタイラスがこのイベントの詳細、要素の境界内に入る時点を追跡しますが文字どおり報告された、<xref:System.Windows.UIElement.IsStylusOver%2A>からプロパティ値が変更された`false`に`true`この要素。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusEnter>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusInAirMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusInAirMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusInAirMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusInAirMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusInRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusInRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusInRange>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusInRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスが要素の境界内から出たときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.UIElement.StylusLeave> 直接イベント ルーティング方法の処理を使用します。 ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。 ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。  
  
 <xref:System.Windows.UIElement.StylusLeave> 、スタイラスがこのイベントの要素の境界の詳細は時点を追跡しますが文字どおり報告された、<xref:System.Windows.UIElement.IsStylusOver%2A>からプロパティ値が変更された`true`に`false`この要素にします。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusLeave>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>スタイラスがこの要素上を移動すると発生します。 このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。 それ以外の場合は、代わりに <see cref="E:System.Windows.UIElement.StylusInAirMove" /> が発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusMove" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusOutOfRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusOutOfRangeEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusOutOfRange>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusOutOfRange" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusPlugIns">
      <MemberSignature Language="C#" Value="protected System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.StylusPlugIns.StylusPlugInCollection StylusPlugIns" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.StylusPlugIns" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property StylusPlugIns As StylusPlugInCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Windows::Input::StylusPlugIns::StylusPlugInCollection ^ StylusPlugIns { System::Windows::Input::StylusPlugIns::StylusPlugInCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StylusPlugIns : System.Windows.Input.StylusPlugIns.StylusPlugInCollection" Usage="System.Windows.UIElement.StylusPlugIns" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusPlugIns.StylusPlugInCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素に関連付けられているすべてのスタイラス プラグイン (カスタマイズ) オブジェクトのコレクションを取得します。</summary>
        <value>特殊なコレクションである、スタイラス プラグインのコレクション。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコレクションのメンバーを追加するコントロールの例は、<xref:System.Windows.Controls.InkCanvas>します。 <xref:System.Windows.Controls.InkCanvas> 追加、<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>これにより、コレクションのアイテムとして、<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>スタイラス入力との対話し、スタイラス イベント駆動型への応答では、一意のレンダリングを生成します。  
  
 カスタム プラグインを作成する方法については、受信し、スタイラスからの入力を解釈を参照してください。[スタイラスからの入力をインターセプト](~/docs/framework/wpf/advanced/intercepting-input-from-the-stylus.md)します。  
  
   
  
## Examples  
 次の例では、作成、<xref:System.Windows.Input.StylusPlugIns.DynamicRenderer>インスタンスし、それを追加、<xref:System.Windows.UIElement.StylusPlugIns%2A>コントロールを処理するカスタムのインクのコレクション。  
  
 [!code-csharp[StylusPluginSamples#3](~/samples/snippets/csharp/VS_Snippets_Wpf/StylusPluginSamples/CSharp/StylusControl.cs#3)]
 [!code-vb[StylusPluginSamples#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StylusPluginSamples/VisualBasic/StylusControl.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.StylusPlugIns.DynamicRenderer" />
        <altmember cref="T:System.Windows.Controls.InkCanvas" />
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 スタイラス ジェスチャの詳細については、次を参照してください。<xref:System.Windows.Input.SystemGesture>します。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusSystemGesture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusSystemGestureEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusSystemGesture>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusSystemGesture" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.StylusUp>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.StylusUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
 タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。 詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.StylusUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewStylusUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.StylusUp" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  このイベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。 以下の解説を参照してください。  
  
 <xref:System.Windows.UIElement.TextInput>イベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。 たとえば、<xref:System.Windows.Controls.TextBox>複合コントロールは、場所、<xref:System.Windows.UIElement.TextInput>イベントが処理済みとしては、合成内に既にマークされています。 コントロールでは、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があるため、このようにします。 使用する場合<xref:System.Windows.UIElement.PreviewTextInput>、テキスト入力用のハンドラーをアタッチするイベントとしてより良い結果が表示される可能性があります。 この手法では、ほとんどの場合コントロール合成が処理済みとしてこのイベントが既にマークし、ハンドラーがイベント ルート上のイベントを受信するを防ぎますを回避できます。  
  
 <xref:System.Windows.UIElement.TextInput>イベントでは、コンポーネントまたはデバイスに依存しない方法でテキスト入力をリッスンするアプリケーション。 キーボードの主要な手段は、 <xref:System.Windows.UIElement.TextInput>、音声認識、手書き入力、およびその他の入力デバイスにもに上げることができますが、<xref:System.Windows.UIElement.TextInput>します。  
  
 -既定のキーボードまたは入力方式エディター - 経由のいずれかのキーの組み合わせにより、複数のキー イベントは 1 つのテキスト入力イベントを発生可能性があります。  
  
 このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.UIElement.TextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.UIElement>は基本要素として継承されます。 イベント ハンドラーに関連付けられている、<xref:System.Windows.UIElement.TextInput>イベントは、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.TextInputEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewTextInput>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.TextInput" /> ルーティング イベントを識別します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。 これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。 これらの識別子を使用して、クラスのハンドラーを追加できます。  
  
 ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。 ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>指がこの要素の上にある間に、その指で画面に触れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既定で、<xref:System.Windows.UIElement.PreviewTouchDown>と<xref:System.Windows.UIElement.TouchDown>指が画面をタッチし、移動するまで、イベントは発生しません。 画面に指を押すと、により、キーを押して移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>します。 プレス アンド ホールド動作では、マウスの右クリックに相当します。  
  
 発生する、<xref:System.Windows.UIElement.PreviewTouchDown>と<xref:System.Windows.UIElement.TouchDown>、画面に触れると、すぐに発生するイベントの設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティを`false`この要素の。  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.TouchDownEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewTouchDown>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.TouchDown" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがこの要素の境界の外部から内部に移動すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 常に、このイベントが発生しますが、タッチ デバイスがこの要素にキャプチャされるかどうか。  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.TouchEnterEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnTouchEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.TouchEnter" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>この要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているすべてのタッチ デバイスを取得します。</summary>
        <value>この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>この要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.UIElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素またはそのビジュアル ツリー内のいずれかの子要素上にあるすべてのタッチ デバイスを取得します。</summary>
        <value>この要素またはそのビジュアル ツリー内のいずれかの子要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>タッチがこの要素の境界の内部から外部に移動すると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 常に、このイベントが発生しますが、タッチ デバイスがこの要素にキャプチャされるかどうか。  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.TouchLeaveEvent>|  
|ルーティング方法|直接|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   オーバーライド<xref:System.Windows.UIElement.OnTouchLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.TouchLeave" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指を画面上で動かすと発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.TouchMoveEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewTouchMove>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.TouchMove" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.UIElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の上に指があるときに、その指が画面から離れると発生します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a>ルーティングされたイベント情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.TouchUpEvent>|  
|ルーティング方法|バブル|  
|Delegate|<xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。|  
  
-   対応するトンネル イベントは<xref:System.Windows.UIElement.PreviewTouchUp>します。  
  
-   オーバーライド<xref:System.Windows.UIElement.OnTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.UIElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="E:System.Windows.UIElement.TouchUp" /> ルーティング イベントを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TranslatePoint">
      <MemberSignature Language="C#" Value="public System.Windows.Point TranslatePoint (System.Windows.Point point, System.Windows.UIElement relativeTo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Point TranslatePoint(valuetype System.Windows.Point point, class System.Windows.UIElement relativeTo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.TranslatePoint(System.Windows.Point,System.Windows.UIElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Point TranslatePoint(System::Windows::Point point, System::Windows::UIElement ^ relativeTo);" />
      <MemberSignature Language="F#" Value="member this.TranslatePoint : System.Windows.Point * System.Windows.UIElement -&gt; System.Windows.Point" Usage="uIElement.TranslatePoint (point, relativeTo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Windows.Point" />
        <Parameter Name="relativeTo" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="point">この要素に相対的なポイント値。</param>
        <param name="relativeTo">指定したポイントに変換する要素。</param>
        <summary>この要素に相対的なポイントを、指定した要素に対する相対座標に変換します。</summary>
        <returns>元の要素ではなく変換先の要素に相対的なポイント値。</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 渡す`null`の`relativeTo`を許可したり、この要素が属する論理ツリーのルート要素に対する相対的な座標があることを示します。  
  
 このメソッドは、変換に使用ヒット テスト ポイント値。 このメソッドを呼び出すことは、下のレベルの入力を処理する必要がありますコントロールを作成する場合に主に関連します。 既存のコントロールを使用している場合は、完成したコントロールが正しく変換済みのヒット テストの結果を報告する通常想定できます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Uid">
      <MemberSignature Language="C#" Value="public string Uid { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Uid" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Uid" />
      <MemberSignature Language="VB.NET" Value="Public Property Uid As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Uid { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Uid : string with get, set" Usage="System.Windows.UIElement.Uid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の一意の識別子 (ローカライズ用) を設定または取得します。 これは依存関係プロパティです。</summary>
        <value>この要素の一意識別子である文字列。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 取得するデザイナーで使用される、`x:Uid`値 (を参照してください[WPF のグローバリゼーションおよびローカリゼーションの概要](~/docs/framework/wpf/advanced/wpf-globalization-and-localization-overview.md)詳細については)。  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.UidProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/81defade-483b-4a89-b76d-9b25bba34010">X:uid 属性</related>
      </Docs>
    </Member>
    <Member MemberName="UidProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UidProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UidProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.UidProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UidProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UidProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable UidProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.UidProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Uid" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateLayout">
      <MemberSignature Language="C#" Value="public void UpdateLayout ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateLayout() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.UIElement.UpdateLayout" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateLayout ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateLayout();" />
      <MemberSignature Language="F#" Value="member this.UpdateLayout : unit -&gt; unit" Usage="uIElement.UpdateLayout " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>この要素のすべての子ビジュアル要素のレイアウトが正常に更新されるようにします。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 要素は、このメソッドを呼び出すと<xref:System.Windows.UIElement.IsMeasureValid%2A>`false`または<xref:System.Windows.UIElement.IsArrangeValid%2A>`false`要素固有を呼び出す<xref:System.Windows.UIElement.MeasureCore%2A>と<xref:System.Windows.UIElement.ArrangeCore%2A>メソッドで、強制的にレイアウトを更新して、すべての計算されたサイズが検証されます。  
  
 このメソッドを呼び出しても何も起こりませんレイアウトが、変更された場合、またはレイアウトの配置も測定の状態が有効でない場合。 ただし、レイアウトがいずれかの点では有効でない場合、<xref:System.Windows.UIElement.UpdateLayout%2A>呼び出しが全体レイアウトを再実行します。 そのため、呼び出しを避ける必要があります<xref:System.Windows.UIElement.UpdateLayout%2A>要素ツリー内の各増分とマイナー変更後にします。 すべての子要素が有効になるまでのルートに対する変更を遅延させる重み付け戦略を使用して、パフォーマンスや通貨のバランスを取るアルゴリズムを使用して遅延で、レイアウト システムは要素のレイアウトを実行します。 呼び出す必要がありますのみ<xref:System.Windows.UIElement.UpdateLayout%2A>更新されたサイズと位置、どうしても必要なかどうか、およびコントロールとする可能性がありますに支障をレイアウト プロパティに対するすべての変更が完了の後にのみです。  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Visibility">
      <MemberSignature Language="C#" Value="public System.Windows.Visibility Visibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Visibility Visibility" />
      <MemberSignature Language="DocId" Value="P:System.Windows.UIElement.Visibility" />
      <MemberSignature Language="VB.NET" Value="Public Property Visibility As Visibility" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Visibility Visibility { System::Windows::Visibility get(); void set(System::Windows::Visibility value); };" />
      <MemberSignature Language="F#" Value="member this.Visibility : System.Windows.Visibility with get, set" Usage="System.Windows.UIElement.Visibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Visibility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この要素の [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] 可視性を取得または設定します。  これは依存関係プロパティです。</summary>
        <value>列挙体の値。 既定値は <see cref="F:System.Windows.Visibility.Visible" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティの設定の値に影響を与えます<xref:System.Windows.UIElement.IsVisible%2A>が発生する可能性がさらに、<xref:System.Windows.UIElement.IsVisibleChanged>イベント。 ただし、<xref:System.Windows.UIElement.IsVisible%2A>が他の要因に影響を与える、それが含まれる親の可視性の設定のインスタンス。  
  
 要素で<xref:System.Windows.UIElement.Visibility%2A>ない<xref:System.Windows.Visibility.Visible>入力イベント (またはコマンド) に参加していない、レイアウトのメジャーまたは整列パスには影響しません、タブ シーケンス、およびヒット テストでは報告されません。  
  
 継承するときに<xref:System.Windows.Window>またはその派生クラスでは、<xref:System.Windows.Window>にするには、このプロパティの既定値を再定義<xref:System.Windows.Visibility.Collapsed>します。 これは、レイアウトの測定パスを最初に作成された実行されていないの効果<xref:System.Windows.Window>、および<xref:System.Windows.UIElement.RenderSize%2A>(0, 0) を返します。 詳細については、「<xref:System.Windows.Window>」を参照してください。 <xref:System.Windows.Controls.Primitives.Popup> 既定値を再定義することも<xref:System.Windows.Visibility.Collapsed>の結果として得られる同様の動作と<xref:System.Windows.Controls.Primitives.Popup>とその派生クラス。  
  
<a name="dependencyPropertyInfo_Visibility"></a>   
## <a name="dependency-property-information"></a>依存プロパティ情報  
  
|||  
|-|-|  
|識別子フィールドです。|<xref:System.Windows.UIElement.VisibilityProperty>|  
|メタデータのプロパティを設定するには `true`|なし|  
  
   
  
## Examples  
 次の例では、ユーザー インターフェイスで相互に排他的なペアにすることを意図した 2 つの異なる名前付きのボタンを参照するハンドラーを実装します。 ボタンに関連付けられている実際のプログラム ロジックを実行する前に、ボタン自体に設定されて<xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>、ペアの他のボタンに設定されていると<xref:System.Windows.Visibility.Visible?displayProperty=nameWithType>します。  
  
 [!code-csharp[MediaElement_snip#UIElementVisibility](~/samples/snippets/csharp/VS_Snippets_Wpf/MediaElement_snip/CSharp/PlaybackExample.cs#uielementvisibility)]
 [!code-vb[MediaElement_snip#UIElementVisibility](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MediaElement_snip/VB/PlaybackExample.vb#uielementvisibility)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.UIElement.IsVisible" />
        <altmember cref="T:System.Windows.Visibility" />
      </Docs>
    </Member>
    <Member MemberName="VisibilityProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VisibilityProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VisibilityProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.UIElement.VisibilityProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VisibilityProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VisibilityProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable VisibilityProperty : System.Windows.DependencyProperty" Usage="System.Windows.UIElement.VisibilityProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><see cref="P:System.Windows.UIElement.Visibility" /> 依存関係プロパティを識別します。</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>