<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a68320bca7e14d4668f64f0875ce1d09eaddacd9" /><Meta Name="ms.sourcegitcommit" Value="635a1dbdc9cbcf7f7c258ac9ffa0314ed734da90" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="04/10/2019" /><Meta Name="ms.locfileid" Value="59472262" /></Metadata><TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type ContentElement = class&#xA;    inherit DependencyObject&#xA;    interface IInputElement&#xA;    interface IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="78b56-101">コンテンツ要素に WPF コアレベルの基底クラスを提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-101">Provides a WPF core-level base class for content elements.</span></span> <span data-ttu-id="78b56-102">コンテンツ要素は、直感的なマークアップ指向レイアウト モデルと、意図的に単純なオブジェクト モデルを使用し、フロー スタイル プレゼンテーション用に設計されています。</span><span class="sxs-lookup"><span data-stu-id="78b56-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement> <span data-ttu-id="78b56-103">次の一般的なコンテンツの特性を定義します。</span><span class="sxs-lookup"><span data-stu-id="78b56-103">defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="78b56-104">入力:すべて<xref:System.Windows.ContentElement>派生クラスは、キーボード、マウス、ドラッグ アンド ドロップ操作、スタイラス コントロール、およびアクセラレータから基本的な入力のキャプチャのサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="78b56-105">フォーカス:すべて<xref:System.Windows.ContentElement>派生クラスはフォーカスを設定できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="78b56-106">(ただしの既定のフォーカスを設定できる状態、<xref:System.Windows.ContentElement>基底クラスは`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="78b56-107">作成する方法の詳細について、<xref:System.Windows.ContentElement>フォーカスを設定できるを参照してください<xref:System.Windows.ContentElement.Focusable%2A>)。さらに、このクラスが含まれています[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]関連要素の間でフォーカスを移動するを使用することできます。</span><span class="sxs-lookup"><span data-stu-id="78b56-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="78b56-108">イベント:<xref:System.Windows.ContentElement>イベントも含まれる入力、フォーカスに関連する; 状態変更イベントも含まれています。</span><span class="sxs-lookup"><span data-stu-id="78b56-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="78b56-109">多くの場合、<xref:System.Windows.ContentElement>イベントはルーティング イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="78b56-110">場合によっては、ルーティング イベントはトンネルとバブルの両方のルーティング方法、同じ状態または条件への応答で個別のイベントとして発生しますがあります。</span><span class="sxs-lookup"><span data-stu-id="78b56-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="78b56-111">また、<xref:System.Windows.ContentElement>定義[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]ことできます raise の各ルーティング イベントとルーティングを追加またはイベントにハンドラーを削除できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <xref:System.Windows.ContentElement> <span data-ttu-id="78b56-112">多くの共通の共有[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]で<xref:System.Windows.UIElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-112">shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="78b56-113">これらの一般的な[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]共有クラス継承から提供されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="78b56-114">同様の動作と同様の内部実装の一般的な名前付けを共有している[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]各クラス。</span><span class="sxs-lookup"><span data-stu-id="78b56-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="78b56-115">類似性があるため<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>それぞれがある、そのマークアップ オブジェクト モデルの動作についてさまざまな開発者の意図は、基本要素である各クラス。</span><span class="sxs-lookup"><span data-stu-id="78b56-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="78b56-116">具体的には、<xref:System.Windows.UIElement>から下降<xref:System.Windows.Media.Visual>、下位レベルのグラフィックスをレンダリングのサポートを提供する、<xref:System.Windows.ContentElement>合成のウィンドウ内の四角形の領域には<xref:System.Windows.ContentElement>レンダリングを遅延ように概念の詳細についてフロー、折り返しなどのドキュメントのシナリオに共通がより簡単にサポートされています。</span><span class="sxs-lookup"><span data-stu-id="78b56-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="78b56-117">これらの 2 つの関連クラスは、共通のインターフェイスを実装も<xref:System.Windows.IInputElement>と<xref:System.Windows.Media.Animation.IAnimatable>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  

 ## <a name="notes-to-inheritors"></a><span data-ttu-id="78b56-118">継承時の注意</span><span class="sxs-lookup"><span data-stu-id="78b56-118">Notes to inheritors</span></span>

 <span data-ttu-id="78b56-119"><xref:System.Windows.ContentElement>クラスがまだフロー スタイル プレゼンテーション用の完全なコンテンツ要素のすべての側面を定義します。</span><span class="sxs-lookup"><span data-stu-id="78b56-119">The <xref:System.Windows.ContentElement> class does not yet define all aspects of a complete content element for flow-style presentation.</span></span> <xref:System.Windows.FrameworkContentElement> <span data-ttu-id="78b56-120">すぐに派生クラスの<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-120">is an immediately derived class of <xref:System.Windows.ContentElement>.</span></span> <xref:System.Windows.FrameworkContentElement> <span data-ttu-id="78b56-121">レンダリングをサポートする追加のメンバーのより完全なセットが含まれています、<xref:System.Windows.FrameworkContentElement>内でコンテンツのホストと、WPF フレームワーク レベルのレイアウト システムを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-121">includes a more complete set of additional members that support rendering a <xref:System.Windows.FrameworkContentElement> within a content host and using the WPF framework-level layout system.</span></span>

 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-122"><see cref="T:System.Windows.ContentElement" /> クラスの新しいインスタンスを初期化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-122">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78b56-123">指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-123">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="78b56-124">ハンドルするルーティング イベントの識別子。</span><span class="sxs-lookup"><span data-stu-id="78b56-124">An identifier for the routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="78b56-125">ハンドラーの実装に対する参照。</span><span class="sxs-lookup"><span data-stu-id="78b56-125">A reference to the handler implementation.</span></span></param>
        <summary><span data-ttu-id="78b56-126">指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-126">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-127">例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-127">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="78b56-128">ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-128">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="78b56-129">そのため、この動作では次の方法でハンドラーの実装で考慮する必要があります副作用がある可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-129">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="78b56-130">通常の"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントへのアクセス パターン。</span><span class="sxs-lookup"><span data-stu-id="78b56-130">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="78b56-131">処理するルーティング イベントの識別子。</span><span class="sxs-lookup"><span data-stu-id="78b56-131">An identifier for the.routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="78b56-132">ハンドラーの実装に対する参照。</span><span class="sxs-lookup"><span data-stu-id="78b56-132">A reference to the handler implementation.</span></span></param>
        <param name="handledEventsToo"><see langword="true" /> <span data-ttu-id="78b56-133">イベント データ内でルーティング イベントが処理済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するときは 。ルーティング イベントが既に処理済みとしてマークされている場合にハンドラーを呼び出さないという既定の条件を使用してハンドラーを登録するときは <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-133">to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span></span>  
  
<span data-ttu-id="78b56-134">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-134">The default is <see langword="false" />.</span></span>  
  
<span data-ttu-id="78b56-135">ルーティング イベントの再処理を機械的に要求しないでください。</span><span class="sxs-lookup"><span data-stu-id="78b56-135">Do not routinely ask to rehandle a routed event.</span></span></param>
        <summary><span data-ttu-id="78b56-136">指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-136">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span> <span data-ttu-id="78b56-137">イベント ルート上の別の要素により既にハンドル済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-137">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-138">複雑な作業は、実用的な方法で低レベルの入力イベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="78b56-138">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="78b56-139">多くのコントロールは、特定のイベントが処理済みとしてマークされてし、別のより直感的なイベントに置き換えの動作を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-139">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="78b56-140">一般に、これを行うための設計上の意図がある場合を処理済みとして、コントロールは、プラットフォームの入力イベントをマークだけです。</span><span class="sxs-lookup"><span data-stu-id="78b56-140">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="78b56-141">特定のシナリオでこれらの設計意図、特定の入力イベントの処理が必要とは限りません。</span><span class="sxs-lookup"><span data-stu-id="78b56-141">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="78b56-142">その登録するこのようなシナリオがハンドラーを`handledEventsToo`として`true`が適切です。</span><span class="sxs-lookup"><span data-stu-id="78b56-142">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="78b56-143">実行しないでこの日常的にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-143">But you should not do this routinely.</span></span> <span data-ttu-id="78b56-144">処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベント処理ロジックが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="78b56-144">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="78b56-145">ハンドラーのロジックが多くの場合は、パフォーマンスの低下を参照してください可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-145">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="78b56-146">既に特定のコントロールがアプリケーション ロジックで処理するイベントを処理している開発プロセス中に検出する場所の場合の処理済みイベントのハンドラーをアタッチの使用を予約する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-146">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="78b56-147">クラスの特定のイベントとコントロールの組み合わせの動作を処理を回避するための別の手法では、代わりにそのイベントのプレビューを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-147">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="78b56-148">たとえば場合、<xref:System.Windows.ContentElement.MouseLeftButtonDown>処理済みとしてマークは、クラス処理によってありますのハンドラーを追加する<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-148">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="78b56-149">例外を発生させずは、同じイベントに対して同じハンドラーを複数回追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-149">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="78b56-150">ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-150">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="78b56-151">そのため、この動作では次の方法でハンドラーの実装で考慮する必要があります副作用がある可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-151">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="78b56-152">通常の"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントへのアクセス パターン。</span><span class="sxs-lookup"><span data-stu-id="78b56-152">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b56-153">次の例で呼び出されるハンドラーを実装する、<xref:System.Windows.FrameworkElement.Initialized>イベントを使用して、ページ上の名前付きの要素のいずれかに定義されたハンドラーをアタッチするページで`handledEventsToo``true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-153">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="78b56-154">このハンドラー、経路上の別の要素が共有イベント データ、ルートでその処理要素に到達する前に処理済みとしてマークされている場合でも呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-154">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route"><span data-ttu-id="78b56-155">ハンドラーの追加先のイベント ルート。</span><span class="sxs-lookup"><span data-stu-id="78b56-155">The event route that handlers are added to.</span></span></param>
        <param name="e"><span data-ttu-id="78b56-156">ハンドラーを追加するために使用されるイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-156">The event data that is used to add the handlers.</span></span> <span data-ttu-id="78b56-157">このメソッドは、引数の <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティを使用してハンドラーを作成します。</span><span class="sxs-lookup"><span data-stu-id="78b56-157">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span></span></param>
        <summary><span data-ttu-id="78b56-158">現在の <see cref="T:System.Windows.EventRoute" /> イベント ハンドラー コレクションのハンドラーを、指定した <see cref="T:System.Windows.ContentElement" /> に追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-158">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-159">このメソッドを使用して、コンテンツ ホスト要素の (を実装するかどうかに関係なく<xref:System.Windows.IContentHost>) のコンテンツのホストの子要素のハンドラーをホストに追加するには<xref:System.Windows.EventRoute>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-159">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-160">この要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-160">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-161">この要素をドラッグ アンド ドロップ操作のターゲットとして使用できる場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-161">if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-162">既定値は <see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-162">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-163">ドラッグ アンド ドロップ操作が既定では、有効でないと、設定した意図的に有効にする必要があります<xref:System.Windows.ContentElement.AllowDrop%2A>に`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-163">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="78b56-164">この基本の設定を超えたドラッグ アンド ドロップの動作は完全に特定の実装とによって定義されていない<xref:System.Windows.ContentElement>またはその他の基本要素クラス。</span><span class="sxs-lookup"><span data-stu-id="78b56-164">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="78b56-165">たとえば、特定のコントロール<xref:System.Windows.Controls.RichTextBox>、既定の動作は必要は<xref:System.Windows.ContentElement>派生クラスでこのような動作があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-165">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="78b56-166">ドラッグ アンド ドロップの詳細については、次を参照してください。[ドラッグ アンド ドロップの概要](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-166">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <xref:System.Windows.FrameworkContentElement> <span data-ttu-id="78b56-167">その実装では、この依存関係プロパティのメタデータをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="78b56-167">overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="78b56-168">具体的には、<xref:System.Windows.FrameworkContentElement>このプロパティがプロパティ値の継承を使用することを指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータ内)。</span><span class="sxs-lookup"><span data-stu-id="78b56-168">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="78b56-169">その他の値のない子要素がある場合にプロパティ値の継承をこのコンテキストで意味<xref:System.Windows.ContentElement.AllowDrop%2A>ローカル値または最も近い親要素の値が割り当てられます (ここでも、いずれかの既定のスタイルでこの値、スタイルを使用して割り当てる値、またはローカル値)、その親要素から値がプロパティ システムによってすべての未使用の子要素に対する割り当てられます。</span><span class="sxs-lookup"><span data-stu-id="78b56-169">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="78b56-170">つまり、ルート要素でドロップ操作を許可し、すべてに値を反映するかどうかを指定できます<xref:System.Windows.FrameworkContentElement>が具体的には割り当てられていない値の子要素`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-170">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-171">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-171">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-172">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-172">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="78b56-173">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-173">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-174">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-174">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="78b56-175">次の例のセット<xref:System.Windows.ContentElement.AllowDrop%2A>で[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]します。</span><span class="sxs-lookup"><span data-stu-id="78b56-175">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-176"><see cref="P:System.Windows.ContentElement.AllowDrop" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-176">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78b56-177">この要素の指定した依存関係プロパティにアニメーションを適用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-177">Applies an animation to a specified dependency property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="78b56-178">アニメーション化するプロパティの識別子。</span><span class="sxs-lookup"><span data-stu-id="78b56-178">The identifier for the property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="78b56-179">アニメーションをコントロールして宣言するアニメーション クロック。</span><span class="sxs-lookup"><span data-stu-id="78b56-179">The animation clock that controls and declares the animation.</span></span></param>
        <summary><span data-ttu-id="78b56-180">この要素の指定した依存関係プロパティにアニメーションを適用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-180">Applies an animation to a specified dependency property on this element.</span></span> <span data-ttu-id="78b56-181">既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</span><span class="sxs-lookup"><span data-stu-id="78b56-181">Any existing animations are stopped and replaced with the new animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-182">プロパティからアニメーションを削除するには、としては、そのプロパティの識別子を指定`dp`指定`clock`として`null`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-182">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="78b56-183">アニメーションが削除され、その基本値にアニメーション化されたプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-183">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="78b56-184">ただし、最初に関連付けられているアニメーション クロックは停止されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-184">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="78b56-185">クロックに割り当てられているその他のアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="78b56-185">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="78b56-186">アニメーション化するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="78b56-186">The property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="78b56-187">アニメーションをコントロールして宣言するアニメーション クロック。</span><span class="sxs-lookup"><span data-stu-id="78b56-187">The animation clock that controls and declares the animation.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="78b56-188">列挙体の値。</span><span class="sxs-lookup"><span data-stu-id="78b56-188">A value of the enumeration.</span></span> <span data-ttu-id="78b56-189">既定値は <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> で、既存のアニメーションを停止して新しいアニメーションに置き換えます。</span><span class="sxs-lookup"><span data-stu-id="78b56-189">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span></span></param>
        <summary><span data-ttu-id="78b56-190">この要素の指定した依存関係プロパティにアニメーションを適用し、プロパティでアニメーションが既に適用されているときに行われる処理を指定する機能も提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-190">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-191">プロパティからアニメーションを削除するには、としては、そのプロパティの識別子を指定`dp`指定`clock`として`null`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-191">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="78b56-192">アニメーションが削除され、その基本値にアニメーション化されたプロパティを設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-192">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="78b56-193">ただし、最初に関連付けられているアニメーション クロックは停止されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-193">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="78b56-194">クロックに割り当てられているその他のアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="78b56-194">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-195">少なくとも 1 つのタッチがこの要素にキャプチャされているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-195">Gets a value that indicates whether at least one touch is captured to this element.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-196">場合、少なくとも 1 つのタッチがこの要素にキャプチャします。それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-196">if at least one touch is captured to this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-197"><see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-197">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-198">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-198">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-199">場合、少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のすべての子要素にキャプチャします。それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-199">if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-200"><see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-200">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-201">少なくとも 1 つのタッチがこの要素上で押されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-201">Gets a value that indicates whether at least one touch is pressed over this element.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-202">この要素上には少なくとも 1 つのタッチが押された場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-202">if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-203"><see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-203">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-204">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-204">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-205">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のすべての子要素上で押された場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-205">if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-206"><see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-206">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="78b56-207">この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</span><span class="sxs-lookup"><span data-stu-id="78b56-207">Starts an animation for a specified animated property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="78b56-208">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="78b56-208">The property to animate, which is specified as a dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="78b56-209">開始するアニメーションのタイムライン。</span><span class="sxs-lookup"><span data-stu-id="78b56-209">The timeline of the animation to start.</span></span></param>
        <summary><span data-ttu-id="78b56-210">この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</span><span class="sxs-lookup"><span data-stu-id="78b56-210">Starts an animation for a specified animated property on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-211">プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされます非アニメーションの開始時点より前の最初のフレームがレンダリングされるときにアニメーション化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-211">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="78b56-212">場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`、現在のアニメーションを削除し、プロパティの現在の値が保持されています。</span><span class="sxs-lookup"><span data-stu-id="78b56-212">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="78b56-213">場合、全体`animation`値は`null`、すべてのアニメーションがプロパティから削除、およびプロパティ値をその基本値に戻ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-213">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="78b56-214">ただし、最初に関連付けられているアニメーション タイムラインは停止されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-214">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="78b56-215">そのタイムラインに割り当てられているその他のアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="78b56-215">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="78b56-216">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</span><span class="sxs-lookup"><span data-stu-id="78b56-216">The property to animate, which is specified as the dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="78b56-217">適用されるアニメーションのタイムライン。</span><span class="sxs-lookup"><span data-stu-id="78b56-217">The timeline of the animation to be applied.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="78b56-218">プロパティ値に既に影響している現在の (実行中の) アニメーションと新しいアニメーションが対話する方法を指定する列挙値。</span><span class="sxs-lookup"><span data-stu-id="78b56-218">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span></span></param>
        <summary><span data-ttu-id="78b56-219">この要素のアニメーション化対象のプロパティを指定して、特定のアニメーションを開始します。プロパティの既存のアニメーションが実行中である場合の動作も指定できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-219">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-220">プロパティがアニメーション化するかどうかをチェックするときに注意してください、アニメーションが開始されと見なされます非アニメーションの開始時点より前の最初のフレームがレンダリングされるときにアニメーション化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-220">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="78b56-221">場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`、現在のアニメーションを削除し、プロパティの現在の値が保持されています。</span><span class="sxs-lookup"><span data-stu-id="78b56-221">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="78b56-222">場合、全体`animation`値は`null`、すべてのアニメーションがプロパティから削除、およびプロパティ値をその基本値に戻ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-222">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="78b56-223">ただし、最初に関連付けられているアニメーション タイムラインは停止されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-223">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="78b56-224">そのタイムラインに割り当てられているその他のアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="78b56-224">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="contentElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-225">この要素にマウスをキャプチャするように強制することを試みます。</span><span class="sxs-lookup"><span data-stu-id="78b56-225">Attempts to force capture of the mouse to this element.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-226">マウスが正常にキャプチャされた場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-226">if the mouse is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-227">キャプチャするには、要素を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-227">To be captured, an element must be enabled.</span></span> <span data-ttu-id="78b56-228">確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`を呼び出す前に<xref:System.Windows.ContentElement.CaptureMouse%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-228">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="78b56-229">呼び出す場合<xref:System.Windows.ContentElement.CaptureMouse%2A>返します`true`、し<xref:System.Windows.ContentElement.IsMouseCaptured%2A>も`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="78b56-230">呼び出す場合<xref:System.Windows.ContentElement.CaptureMouse%2A>返します`true`、<xref:System.Windows.ContentElement.GotMouseCapture>と<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントが発生するで<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>要素としてデータを報告するイベントの場所、<xref:System.Windows.ContentElement.CaptureMouse%2A>メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-230">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="78b56-231">キャプチャを強制する場合は、既存のキャプチャのキャプチャに関連する、マウスでドラッグ アンド ドロップで特に干渉可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-231">If you force capture, you might interfere with existing captures - especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="78b56-232">すべての要素からマウスのキャプチャをクリアするには、呼び出し<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>で、`element`として指定されたパラメーター`null`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-232">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b56-233">次の例では、マウスをキャプチャまたは要素によって、マウスが既にキャプチャされているかどうかに基づいてキャプチャを解放します。</span><span class="sxs-lookup"><span data-stu-id="78b56-233">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="78b56-234">この例では、見込みのキャプチャ対象の要素はキャストに注意してください、<xref:System.Windows.IInputElement>インターフェイスし、は、最初に呼び出したため、<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>メソッド。</span><span class="sxs-lookup"><span data-stu-id="78b56-234">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="78b56-235">キャスト<xref:System.Windows.IInputElement>がわからないかどうか、要素にキャプチャする、マウスが場合に便利ですが、<xref:System.Windows.UIElement>または<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-235">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="78b56-236">インターフェイスにキャストしてインターフェイス メソッド実装を呼び出すし、呼び出し、適切な型固有ことで内部的には、試用版のいずれかにキャストを必要とせず<xref:System.Windows.UIElement>または<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-236">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="78b56-237">この同じキャスト手法は、その他のメンバーを<xref:System.Windows.IInputElement>多数定義しています、たとえば、入力関連するイベント、およびその他の入力に関連するメソッド。</span><span class="sxs-lookup"><span data-stu-id="78b56-237">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="contentElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-238">この要素にスタイラスをキャプチャするように強制することを試みます。</span><span class="sxs-lookup"><span data-stu-id="78b56-238">Attempts to force capture of the stylus to this element.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-239">スタイラスが正常にキャプチャされた場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-239">if the stylus is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-240">既定の実装を常に基になる既定のスタイラス デバイスに基づいて`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-240">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="78b56-241">ただし、入力システムのデバイスの実装を提供する、入力デバイスを拡張する場合に、異なる結果を返す可能性のある代替のスタイラス デバイス実装で、システムを作成することです。</span><span class="sxs-lookup"><span data-stu-id="78b56-241">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="78b56-242">スタイラスをキャプチャする要素は、その境界の外側にスタイラスがある場合でも、スタイラス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-242">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="78b56-243">スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-243">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="78b56-244">このメソッドを呼び出す呼び出しと基になるは静的<xref:System.Windows.Input.Stylus>メソッド<xref:System.Windows.Input.Stylus.Capture%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-244">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="78b56-245">実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-245">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="78b56-246">キャプチャするには、要素を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-246">To be captured, an element must be enabled.</span></span> <span data-ttu-id="78b56-247">確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`を呼び出す前に返す<xref:System.Windows.ContentElement.CaptureStylus%2A>。</span><span class="sxs-lookup"><span data-stu-id="78b56-247">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="78b56-248">呼び出す場合<xref:System.Windows.ContentElement.CaptureStylus%2A>返します`true`、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>も`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-248">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="78b56-249">キャプチャの対象となるデバイス。</span><span class="sxs-lookup"><span data-stu-id="78b56-249">The device to capture.</span></span></param>
        <summary><span data-ttu-id="78b56-250">この要素にタッチをキャプチャするように強制することを試みます。</span><span class="sxs-lookup"><span data-stu-id="78b56-250">Attempts to force capture of a touch to this element.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-251">指定したタッチがこの要素にキャプチャされる場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-251">if the specified touch is captured to this element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.CaptureTouch%2A> <span data-ttu-id="78b56-252">戻ります`false`場合、<xref:System.Windows.Input.TouchDevice>別の要素にキャプチャされています。</span><span class="sxs-lookup"><span data-stu-id="78b56-252">will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="78b56-253">場合<xref:System.Windows.ContentElement.CaptureTouch%2A>返します`true`、<xref:System.Windows.ContentElement.GotTouchCapture>イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-253">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="78b56-254">この要素から 1 つのタッチのキャプチャをリリースするには、使用、<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>メソッドを解放するタッチ デバイスを指定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-254">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="78b56-255">この要素からすべてのタッチをリリースするには、使用、<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>メソッド。</span><span class="sxs-lookup"><span data-stu-id="78b56-255">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> <span data-ttu-id="78b56-256">は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="78b56-256">is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-257">この要素に関連付けられている <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクションを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-257">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="78b56-258">すべての <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクション。</span><span class="sxs-lookup"><span data-stu-id="78b56-258">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-259">A<xref:System.Windows.Input.CommandBinding>この要素の特定のコマンドのコマンドの処理を有効にし、コマンド、イベント、およびこの要素に関連付けられているハンドラー間のリンケージを宣言します。</span><span class="sxs-lookup"><span data-stu-id="78b56-259">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="78b56-260">もう 1 つの一般的な方法を設定する、<xref:System.Windows.ContentElement.CommandBindings%2A>コレクションは、使用する<xref:System.Windows.Input.CommandManager>メソッド プログラムを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-260">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="78b56-261">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="78b56-261">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="78b56-262">XAML 値</span><span class="sxs-lookup"><span data-stu-id="78b56-262">XAML Values</span></span>  
 *<span data-ttu-id="78b56-263">oneOrMoreCommandBindings</span><span class="sxs-lookup"><span data-stu-id="78b56-263">oneOrMoreCommandBindings</span></span>*  
 <span data-ttu-id="78b56-264">1 つまたは複数<xref:System.Windows.Input.CommandBinding>要素。</span><span class="sxs-lookup"><span data-stu-id="78b56-264">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="78b56-265">これらの必要がありますが、<xref:System.Windows.Input.CommandBinding.Command%2A>属性、既知のコマンドに設定され、に対して属性が設定、<xref:System.Windows.Input.CommandBinding.CanExecute>と<xref:System.Windows.Input.CommandBinding.Executed>ハンドラーの実装。</span><span class="sxs-lookup"><span data-stu-id="78b56-265">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="78b56-266">詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-266">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-267">この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-267">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-268">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-268">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-269">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragEnter>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-269">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-270">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-270">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-271">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-271">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="78b56-272">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-272">Routing strategy</span></span>|<span data-ttu-id="78b56-273">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-273">Bubbling</span></span>|  
|<span data-ttu-id="78b56-274">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-274">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-275">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewDragEnter>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-275">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="78b56-276">オーバーライド<xref:System.Windows.ContentElement.OnDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-276">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-277"><see cref="E:System.Windows.ContentElement.DragEnter" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-277">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-278">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-278">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-279">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-279">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-280">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-280">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-281">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-281">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-282">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-282">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-283">入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-283">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-284">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-284">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-285">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragLeave>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-285">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-286">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-286">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-287">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-287">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="78b56-288">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-288">Routing strategy</span></span>|<span data-ttu-id="78b56-289">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-289">Bubbling</span></span>|  
|<span data-ttu-id="78b56-290">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-290">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-291">対応するトンネル イベントは<xref:System.Windows.DragDrop.PreviewDragLeave>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-291">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="78b56-292">オーバーライド<xref:System.Windows.ContentElement.OnDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-292">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-293"><see cref="E:System.Windows.ContentElement.DragLeave" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-293">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-294">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-294">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-295">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-295">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-296">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-296">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-297">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-297">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-298">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-298">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-299">この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-299">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-300">このイベントは、要素の境界でドラッグを開始した場合でも発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-300">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="78b56-301">ドラッグが境界の外側を開始し、このイベントは発生しても、内部で、移動だけでなく<xref:System.Windows.ContentElement.DragEnter>およびプレビュー イベントに関連します。</span><span class="sxs-lookup"><span data-stu-id="78b56-301">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="78b56-302">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-302">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-303">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragOver>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-303">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-304">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-305">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-305">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="78b56-306">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-306">Routing strategy</span></span>|<span data-ttu-id="78b56-307">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-307">Bubbling</span></span>|  
|<span data-ttu-id="78b56-308">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-308">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-309">対応するトンネル イベントは<xref:System.Windows.DragDrop.PreviewDragOver>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-309">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="78b56-310">オーバーライド<xref:System.Windows.ContentElement.OnDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-310">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-311"><see cref="E:System.Windows.ContentElement.DragOver" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-311">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-312">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-313">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-314">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-315">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-316">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-317">入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-317">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-318">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-318">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-319">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.Drop>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-319">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-320">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-320">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-321">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-321">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="78b56-322">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-322">Routing strategy</span></span>|<span data-ttu-id="78b56-323">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-323">Bubbling</span></span>|  
|<span data-ttu-id="78b56-324">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-324">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-325">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewDrop>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-325">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="78b56-326">オーバーライド<xref:System.Windows.ContentElement.OnDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-326">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-327"><see cref="E:System.Windows.ContentElement.Drop" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-327">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-328">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-328">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-329">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-329">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-330">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-330">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-331">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-331">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-332">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-332">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="contentElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-333">この要素にフォーカスを設定することを試みます。</span><span class="sxs-lookup"><span data-stu-id="78b56-333">Attempts to set focus to this element.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-334">キーボード フォーカスをこの要素に設定できなかった場合は 。このメソッド呼び出しがフォーカスを強制しなかった場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-334">if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-335">フォーカスを<xref:System.Windows.ContentElement.Focusable%2A>と<xref:System.Windows.ContentElement.IsEnabled%2A>は両方とも必要`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-335">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="78b56-336">ほぼすべて<xref:System.Windows.ContentElement>派生クラスでない<xref:System.Windows.ContentElement.Focusable%2A>既定。</span><span class="sxs-lookup"><span data-stu-id="78b56-336">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="78b56-337">要素は、特定のツリー内のフォーカスを設定できる、有効な場合は、イベントの処理が、場合でも、フォーカスを許可しないことによって、プレビューのフォーカス イベントに応答 (複合コントロールなど) ためこのメソッドは`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-337">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="78b56-338">一般にフォーカスが 2 つの異なる概念によって制御されます。 キーボード フォーカスと論理フォーカスは、常に同じではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-338">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="78b56-339">このメソッドは、論理フォーカスを設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-339">This method sets the logical focus.</span></span> <span data-ttu-id="78b56-340">プログラムです。 具体的にキーボード フォーカスを設定する手段はありません。キーボード フォーカスは、ユーザー入力によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-340">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="78b56-341">詳細については、次を参照してください。[フォーカスの概要](~/docs/framework/wpf/advanced/focus-overview.md)と[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-341">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="78b56-342">呼び出す場合<xref:System.Windows.ContentElement.Focus%2A>返します`true`、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>と<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>も`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-342">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="78b56-343">関連するプロパティが既にがない場合`true`を呼び出すとき、 <xref:System.Windows.ContentElement.Focus%2A>、1 つ以上の次のイベントは、次の順序で発生します: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>、 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (ソースの新しいフォーカス ターゲット)、 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>、<xref:System.Windows.ContentElement.LostKeyboardFocus>、 <xref:System.Windows.ContentElement.GotKeyboardFocus> (ソースは新しいフォーカス対象です)。</span><span class="sxs-lookup"><span data-stu-id="78b56-343">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b56-344">次の例では、指定した文書の段落をという名前を検索するページ読み込みイベント ハンドラーは、し、フォーカスを設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-344">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="78b56-345">段落は、既定でフォーカスを設定できません。この特定の段落が適用されるスタイル、スタイルを使用する (非表示)<xref:System.Windows.Setter>フォーカスを設定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-345">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-346">要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-346">Gets or sets a value that indicates whether the element can receive focus.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-347">要素がフォーカスを設定できる場合それ以外の場合<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-347">if the element is focusable; otherwise <see langword="false" />.</span></span> <span data-ttu-id="78b56-348">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-348">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-349">フォーカスがある要素のみでは、キーボード入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-349">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="78b56-350">特定の派生クラスは、派生クラスが既定でフォーカスを設定できるように、この依存関係プロパティのメタデータをオーバーライド可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-350">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="78b56-351">継承するときに<xref:System.Windows.Documents.Hyperlink>またはその派生クラスでは、<xref:System.Windows.Documents.Hyperlink>この依存関係プロパティのメタデータをオーバーライドしするには、このプロパティの既定値を再定義`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-351">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
### <a name="dependency-property-information"></a><span data-ttu-id="78b56-352">依存関係プロパティの情報</span><span class="sxs-lookup"><span data-stu-id="78b56-352">Dependency property information</span></span>
  
|||  
|-|-|  
|<span data-ttu-id="78b56-353">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-353">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="78b56-354">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-354">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-355">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-355">None</span></span>|  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="78b56-356">継承時の注意</span><span class="sxs-lookup"><span data-stu-id="78b56-356">Notes to inheritors</span></span>

<span data-ttu-id="78b56-357">派生させた場合<xref:System.Windows.ContentElement>要素にフォーカスを設定するため、既定ではないことがフォーカスを設定できるかどうかを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-357">When you derive from <xref:System.Windows.ContentElement>, consider whether you want your element to be focusable, because by default it will not be focusable.</span></span> <span data-ttu-id="78b56-358">要素にフォーカスを設定できる場合は、次のように、派生クラスの静的コンス トラクターでは、このプロパティのメタデータをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="78b56-358">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span></span>  

[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
[!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
<span data-ttu-id="78b56-359">場所`myElement`のメタデータ値をオーバーライドする型のクラスの名前です。</span><span class="sxs-lookup"><span data-stu-id="78b56-359">where `myElement` is the class name of the type that you are overriding the metadata value on.</span></span>
  
## Examples  
 <span data-ttu-id="78b56-360">次の例では、スタイルを<xref:System.Windows.Documents.Paragraph>既定でフォーカスを設定できるフォーカスを受け取るときに、視覚的な動作を付け、します。</span><span class="sxs-lookup"><span data-stu-id="78b56-360">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-361"><see cref="P:System.Windows.ContentElement.Focusable" /> プロパティの値が変更された場合に発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-361">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-362">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-362">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-363"><see cref="P:System.Windows.ContentElement.Focusable" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-363">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="contentElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="78b56-364">チェックする対象の依存関係プロパティ。</span><span class="sxs-lookup"><span data-stu-id="78b56-364">The.dependency property to check.</span></span></param>
        <summary><span data-ttu-id="78b56-365">この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化される値は無視されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-365">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span></span></summary>
        <returns><span data-ttu-id="78b56-366">指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</span><span class="sxs-lookup"><span data-stu-id="78b56-366">The property value as if no animations are attached to the specified dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-367">プロパティのアニメーションが添付されていない場合、<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>を戻り値は常に、<xref:System.Windows.DependencyObject.GetValue%2A>値を返します。</span><span class="sxs-lookup"><span data-stu-id="78b56-367">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="78b56-368">添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始を含む値を派生しと停止の値は無視され、プロパティの値はその他のすべての可能な入力に基づいて決定されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-368">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="78b56-369">詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-369">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="contentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-370">派生クラスでオーバーライドされると、ビジュアル親が存在しない場合に、この要素の代替[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] の親を返します。</span><span class="sxs-lookup"><span data-stu-id="78b56-370">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span></span></summary>
        <returns><span data-ttu-id="78b56-371">報告する代替の親接続を派生クラスの実装が持つ場合のオブジェクト。</span><span class="sxs-lookup"><span data-stu-id="78b56-371">An object, if implementation of a derived class has an alternate parent connection to report.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-372">このメソッドの既定の仮想実装`null`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-372">The default virtual implementation of this method returns `null`.</span></span> <xref:System.Windows.FrameworkContentElement> <span data-ttu-id="78b56-373">現実の実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-373">provides a practical implementation.</span></span>  
  
 <span data-ttu-id="78b56-374">別の親が場所要素代替親構造体を作成、イベントがルーティングされるように、ビジュアル ツリーに標準の親では、ルーティングの標準的なパターンから逸脱した方法での場合、イベントのルーティングに使用またはの下、ルーティング方法をプレビューします。</span><span class="sxs-lookup"><span data-stu-id="78b56-374">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-375">入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-375">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-376"><xref:System.Windows.ContentElement.GiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。</span><span class="sxs-lookup"><span data-stu-id="78b56-376">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="78b56-377">ドラッグ アンド ドロップ操作が、プロセス、視覚的なフィードバックが促進されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-377">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="78b56-378">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.GiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-378">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-379">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GiveFeedback>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-379">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-380">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-380">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-381">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-381">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="78b56-382">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-382">Routing strategy</span></span>|<span data-ttu-id="78b56-383">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-383">Bubbling</span></span>|  
|<span data-ttu-id="78b56-384">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-384">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="78b56-385">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewGiveFeedback>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-385">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="78b56-386">オーバーライド<xref:System.Windows.ContentElement.OnGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-386">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-387"><see cref="E:System.Windows.ContentElement.GiveFeedback" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-387">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-388">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-388">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-389">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-389">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-390">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-390">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-391">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-391">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-392">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-392">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-393">この要素が論理フォーカスを取得したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-393">Occurs when this element gets logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-394">フォーカスがメソッド呼び出しを使用して強制意図的には、直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-394">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="78b56-395">このシナリオでキーボード フォーカスのままであると、要素を<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されますも論理フォーカスを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-395">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="78b56-396">このイベントをより正確に解釈するは、発生する状況の値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更された`false`に`true`。</span><span class="sxs-lookup"><span data-stu-id="78b56-396">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="78b56-397">このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-397">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-398">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを取得、実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-398">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-399">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-399">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-400">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-400">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="78b56-401">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-401">Routing strategy</span></span>|<span data-ttu-id="78b56-402">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-402">Bubbling</span></span>|  
|<span data-ttu-id="78b56-403">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-403">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="78b56-404">対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-404">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-405">オーバーライド<xref:System.Windows.ContentElement.OnGotFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-405">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-406"><see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-406">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-407">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-407">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-408">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-408">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-409">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-409">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-410">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-410">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-411">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-411">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-412">この要素にキーボード フォーカスが移動したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-412">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> <span data-ttu-id="78b56-413">要素のフォーカスの状態を保持するプロパティで状態の変更を追跡するようなイベント<xref:System.Windows.ContentElement.GotKeyboardFocus>多くの同じ状況でイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-413">is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="78b56-414">このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-414">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-415">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-415">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="78b56-416">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.GotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-416">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-417">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-417">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-418">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-418">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-419">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-419">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="78b56-420">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-420">Routing strategy</span></span>|<span data-ttu-id="78b56-421">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-421">Bubbling</span></span>|  
|<span data-ttu-id="78b56-422">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-422">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="78b56-423">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-423">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="78b56-424">オーバーライド<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-424">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-425"><see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-425">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-426">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-426">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-427">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-427">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-428">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-428">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-429">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-429">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-430">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-430">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-431">この要素がマウスをキャプチャしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-431">Occurs when this element captures the mouse.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-432">要素がマウスをキャプチャは、境界外にマウス ポインターがあってもマウス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-432">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="78b56-433">マウスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、は、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされました。</span><span class="sxs-lookup"><span data-stu-id="78b56-433">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="78b56-434">このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-434">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-435">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>マウスが、実際の要素を決定するデータのキャプチャ、イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-435">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="78b56-436">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.GotMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-436">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-437">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotMouseCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-437">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-438">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-438">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-439">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-439">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="78b56-440">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-440">Routing strategy</span></span>|<span data-ttu-id="78b56-441">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-441">Bubbling</span></span>|  
|<span data-ttu-id="78b56-442">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-442">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="78b56-443">定義済みの対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-443">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-444">オーバーライド<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-444">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-445"><see cref="E:System.Windows.ContentElement.GotMouseCapture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-445">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-446">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-446">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-447">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-447">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-448">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-448">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-449">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-449">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-450">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-450">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-451">この要素がスタイラスをキャプチャしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-451">Occurs when this element captures the stylus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-452">要素がスタイラスをキャプチャするときは、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-452">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="78b56-453">スタイラスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまで、キャプチャを保持します。</span><span class="sxs-lookup"><span data-stu-id="78b56-453">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="78b56-454">このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-454">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-455">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>実際のキャプチャを持つ要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-455">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="78b56-456">このイベントは、このクラスで添付イベントのエイリアスを作成できるように<xref:System.Windows.ContentElement.GotStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-456">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-457">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotStylusCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-457">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-458">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-458">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-459">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-459">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="78b56-460">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-460">Routing strategy</span></span>|<span data-ttu-id="78b56-461">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-461">Bubbling</span></span>|  
|<span data-ttu-id="78b56-462">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-462">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-463">定義済みの対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-463">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-464">オーバーライド<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-464">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-465"><see cref="E:System.Windows.ContentElement.GotStylusCapture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-465">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-466">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-466">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-467">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-467">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-468">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-468">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-469">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-469">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-470">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-470">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-471">タッチがこの要素にキャプチャされると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-471">Occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-472">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-472">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-473">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-473">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="78b56-474">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-474">Routing strategy</span></span>|<span data-ttu-id="78b56-475">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-475">Bubbling</span></span>|  
|<span data-ttu-id="78b56-476">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-476">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-477">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-477">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-478">オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-478">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-479"><see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-479">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-480">この要素にアニメーション化されたプロパティかあるどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-480">Gets a value that indicates whether this element has any animated properties.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-481">この要素があるアニメーションのプロパティのいずれかに接続されている場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-481">if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-482">このプロパティを返します`true`(ロック、常に実行されている) の永続的なアニメーションのタイムラインを特定のアニメーションか。</span><span class="sxs-lookup"><span data-stu-id="78b56-482">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-483">この要素に関連付けられている入力バインディングのコレクションを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-483">Gets the collection of input bindings that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="78b56-484">入力バインディングのコレクション。</span><span class="sxs-lookup"><span data-stu-id="78b56-484">The collection of input bindings.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-485">入力バインディングでは、入力デバイスにコマンドのバインドをサポートします。</span><span class="sxs-lookup"><span data-stu-id="78b56-485">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="78b56-486">たとえば、<xref:System.Windows.Input.MouseBinding>実装は、マウス デバイスに固有のプロパティを含むバインドを入力します。</span><span class="sxs-lookup"><span data-stu-id="78b56-486">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="78b56-487">入力バインディングのコレクションには、型に関連する両方と、インスタンスで宣言されている入力バインドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="78b56-487">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="78b56-488">関連するプロパティ、 <xref:System.Windows.ContentElement.CommandBindings%2A>、コマンド バインディングのコレクションを保持します。</span><span class="sxs-lookup"><span data-stu-id="78b56-488">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="78b56-489">これらのバインドは、コマンドの処理 - これらの既知のコマンドとクラスに固有のハンドラーに関連付けられているアクションの下、次のレベルを表しているという点で、入力バインディングとは異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-489">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="78b56-490">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="78b56-490">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="78b56-491">XAML 値</span><span class="sxs-lookup"><span data-stu-id="78b56-491">XAML Values</span></span>  
 *<span data-ttu-id="78b56-492">oneOrMoreInputBindings</span><span class="sxs-lookup"><span data-stu-id="78b56-492">oneOrMoreInputBindings</span></span>*  
 <span data-ttu-id="78b56-493">1 つまたは複数<xref:System.Windows.Input.InputBinding>要素 (通常、<xref:System.Windows.Input.KeyBinding>または<xref:System.Windows.Input.MouseBinding>派生クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-493">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="78b56-494">これらの各が必要です、<xref:System.Windows.Input.InputBinding.Command%2A>と<xref:System.Windows.Input.InputBinding.Gesture%2A>属性に設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-494">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-495">この要素が[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] で有効かどうかを示す値を取得または設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-495">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-496">は、要素が有効な場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-496">if the element is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-497">既定値は <see langword="true" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-497">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-498">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-498">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-499">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-499">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="78b56-500">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-500">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-501">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-501">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="78b56-502">次の例を視覚的な代替動作を提供するプロパティの setter を含むスタイルを作成するときに、<xref:System.Windows.Documents.Hyperlink>に設定されている<xref:System.Windows.ContentElement.IsEnabled%2A>`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-502">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-503">この要素の <see cref="P:System.Windows.ContentElement.IsEnabled" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-503">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-504">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-504">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-505">派生クラス内で <see cref="P:System.Windows.ContentElement.IsEnabled" /> の戻り値になる値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-505">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-506">は、要素が有効な場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-506">if the element is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

## <a name="notes-to-inheritors"></a><span data-ttu-id="78b56-507">継承時の注意</span><span class="sxs-lookup"><span data-stu-id="78b56-507">Notes to inheritors</span></span>

<span data-ttu-id="78b56-508">このプロパティの既定の実装では、値をキャッシュしもこの要素の親要素が有効になっているかどうかを計算します。</span><span class="sxs-lookup"><span data-stu-id="78b56-508">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span></span> <span data-ttu-id="78b56-509">親が有効でない場合、実用的なユーザー インターフェイスで、子要素を効率的に有効にできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-509">If the parent is not enabled, the child element cannot be effectively enabled in practical user interface.</span></span> <span data-ttu-id="78b56-510">この実装をオーバーライドすることを選択する場合、この動作を保持する基本実装を呼び出すことをことを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-510">If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-511"><see cref="P:System.Windows.ContentElement.IsEnabled" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-511">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-512">この要素に論理フォーカスがあるかどうかを判断する値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-512">Gets a value that determines whether this element has logical focus.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-513">この要素に論理フォーカスがある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-513">if this element has logical focus; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-514">論理フォーカスは、アプリケーションは、メニューの内容と、アプリケーションの残りの部分の間など、複数のフォーカス区分がキーボード フォーカスと異なる場合があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-514">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="78b56-515">このシナリオでアプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるのみ、ただし、他のフォーカス区分の特定の要素には論理フォーカスが保持可能性がありますもします。</span><span class="sxs-lookup"><span data-stu-id="78b56-515">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="78b56-516">論理フォーカスの詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)と[フォーカスの概要](~/docs/framework/wpf/advanced/focus-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-516">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-517">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-517">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-518">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-518">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="78b56-519">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-519">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-520">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-520">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="78b56-521">次の例では、スタイルを<xref:System.Windows.Documents.Paragraph>既定でフォーカスを設定できるフォーカスを受け取るときに、視覚的な動作を付け、します。</span><span class="sxs-lookup"><span data-stu-id="78b56-521">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-522"><see cref="P:System.Windows.ContentElement.IsFocused" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-522">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-523">[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)] などの入力方法システムが、この要素への入力の処理に対して有効かどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-523">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-524">入力方式がアクティブである場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-524">if an input method is active; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-525">基になる添付プロパティの既定値は<see langword="true" />。 ただし、この値は実行時に入力方式の状態の影響を受けます。</span><span class="sxs-lookup"><span data-stu-id="78b56-525">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-526">このプロパティが添付プロパティによって返される値を返します<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>現在有効な入力方法 (キーボード、音声、およびその他の入力デバイス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-526">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-527">この要素にキーボード フォーカスがあるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-527">Gets a value that indicates whether this element has keyboard focus.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-528">この要素にキーボード フォーカスがある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-528">if this element has keyboard focus; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-529">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-530">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-530">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-531">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-531">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="78b56-532">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-532">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-533">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-533">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-534">この要素の <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-534">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-535">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-535">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-536"><see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-536">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-537">キーボード フォーカスが要素または子要素内にあるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-537">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-538">要素またはその子要素にキーボード フォーカスがある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-538">if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-539">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-539">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-540">このプロパティの値の変更が通常発生させる、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベント、派生クラスがオーバーライドされない限り<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>イベントを抑制します。</span><span class="sxs-lookup"><span data-stu-id="78b56-540">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="78b56-541">このプロパティを直接設定しないでください、呼び出すことによって要素にフォーカスを設定することができますが、 <xref:System.Windows.ContentElement.Focus%2A>、か行うことによって、<xref:System.Windows.ContentElement.MoveFocus%2A>要求。</span><span class="sxs-lookup"><span data-stu-id="78b56-541">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="78b56-542">このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-542">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-543">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-543">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-544">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-544">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="78b56-545">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-545">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-546">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-546">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-547">この要素の <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-547">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-548">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-548">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-549"><see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-549">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-550">マウスがこの要素にキャプチャされているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-550">Gets a value that indicates whether the mouse is captured by this element.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-551">要素がマウス キャプチャを持つ場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-551">if the element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-552">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-552">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-553">マウス キャプチャの状態は、インプロセス ドラッグ アンド ドロップ操作に関連しています。</span><span class="sxs-lookup"><span data-stu-id="78b56-553">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-554">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-554">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-555">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-555">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="78b56-556">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-556">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-557">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-557">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="78b56-558">次の例では、マウスの状態のキャプチャを有効または無効、マウスが要素で既にキャプチャされているかどうかに基づいて。</span><span class="sxs-lookup"><span data-stu-id="78b56-558">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-559">この要素の <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-559">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-560">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-560">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-561"><see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-561">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-562">この要素または要素ツリー内の子要素がマウス キャプチャを保持するかどうかを決定する値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-562">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-563">この要素または格納されている要素がマウス キャプチャを持つ場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-563">if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-564">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-564">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-565">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-565">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-566">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-566">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="78b56-567">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-567">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-568">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-568">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-569">この要素の <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> の値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-569">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-570">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-570">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-571"><see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-571">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-572">マウス ポインターの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-572">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-573">マウス ポインターがヒット テストと同じ要素結果上にある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-573">if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-574">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-574">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-575">異なり<xref:System.Windows.ContentElement.IsMouseOver%2A>、このプロパティはのみ`true`はヒット テストのリテラル要素の上でマウス ポインターがかどうか。</span><span class="sxs-lookup"><span data-stu-id="78b56-575">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element - as it is for a hit test.</span></span> <span data-ttu-id="78b56-576">代わりに子要素の上にマウス ポインターが、具体的には、要素のより深いテンプレートおよび複合の一部である要素をこのプロパティになります`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-576">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="78b56-577">コントロールが合成する方法がわかっていない限り、(たとえば、このプロパティ テンプレートで使用する、カスタム コントロールを定義するコントロールの)、このプロパティは、予期しない結果を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-577">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="78b56-578">コントロールをいない作成はほとんどのシナリオを使用して、<xref:System.Windows.ContentElement.IsMouseOver%2A>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-578">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="78b56-579">この要素によって、マウスがキャプチャされていて、このプロパティは`true`のキャプチャ時に、このプロパティを返し続けます`true`までマウス キャプチャが失われ、その境界上にポインターがありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-579">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-580">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-580">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-581">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-581">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="78b56-582">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-582">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-583">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-583">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-584">この要素の <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-584">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-585">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-585">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-586"><see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-586">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-587">マウス ポインターがこの要素 (子ビジュアル要素またはそのコントロールの複合を含む) 上にあるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-587">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-588">要素またはその子要素の上にマウス ポインターがある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-588">if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-589">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-589">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-590">類似の"IsMouseOverChanged"イベントが存在しないがいくつかの類似イベントの操作を行います。</span><span class="sxs-lookup"><span data-stu-id="78b56-590">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="78b56-591">たとえば、使用することができます<xref:System.Windows.ContentElement.MouseEnter>、 <xref:System.Windows.ContentElement.MouseMove>、および<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-591">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="78b56-592">この要素がマウスをキャプチャする場合は、このプロパティの値`true`マウス キャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。</span><span class="sxs-lookup"><span data-stu-id="78b56-592">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-593">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-593">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-594">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-594">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="78b56-595">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-595">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-596">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-596">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="78b56-597">次の例を視覚的な代替動作を提供するプロパティの setter を含むスタイルを作成するときに、<xref:System.Windows.Documents.Hyperlink>レポート<xref:System.Windows.ContentElement.IsMouseOver%2A>`true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-597">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-598"><see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-598">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-599">スタイラスがこの要素にキャプチャされているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-599">Gets a value that indicates whether the stylus is captured to this element.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-600">要素がスタイラス キャプチャを持つ場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-600">if the element has stylus capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-601">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-601">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-602">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-602">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-603">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-603">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-604">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-604">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-605">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-605">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="78b56-606">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-606">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-607">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-607">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-608">この要素の <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-608">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-609">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-609">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-610"><see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-610">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-611">スタイラスのキャプチャをこの要素 (子要素およびコントロールの複合を含む) が保持するかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-611">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-612">スタイラスのキャプチャがこの要素内に保持されている場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-612">if stylus capture is held within this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-613">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-613">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-614">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-614">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-615">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-615">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-616">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-616">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="78b56-617">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-617">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-618">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-618">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-619">この要素の <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-619">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-620">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-620">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-621"><see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-621">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-622">スタイラスの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-622">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-623">ヒット テストと同じ要素上でスタイラスがある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-623">if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-624">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-624">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-625">異なり<xref:System.Windows.ContentElement.IsStylusOver%2A>、このプロパティはのみ`true`要素の上にスタイラスがある場合。</span><span class="sxs-lookup"><span data-stu-id="78b56-625">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="78b56-626">スタイラスの代わりに子要素または要素のより深い複合の一部である要素を場合、このプロパティになります`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-626">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="78b56-627">コントロールが合成する方法がわかっていない限り、(たとえば、このプロパティ テンプレートで使用する、カスタム コントロールを定義するコントロールの)、このプロパティは、予期しない結果を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-627">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="78b56-628">コントロールをいない作成はほとんどのシナリオを使用して、<xref:System.Windows.ContentElement.IsStylusOver%2A>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-628">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="78b56-629">この要素がスタイラス キャプチャされ、このプロパティが`true`のキャプチャ時に、このプロパティの値`true`までスタイラスのキャプチャが失われ、その境界上にスタイラスがありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-629">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="78b56-630">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-630">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-631">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-631">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-632">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-632">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-633">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-633">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="78b56-634">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-634">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-635">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-635">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-636">この要素の <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> プロパティの値が変更されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-636">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-637">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントのルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-637">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-638"><see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-638">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-639">スタイラスがこの要素 (子ビジュアル要素を含む) 上にあるかどうかを示す値を取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-639">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span></span></summary>
        <value><see langword="true" /> <span data-ttu-id="78b56-640">スタイラスが要素またはその子要素の上にある場合それ以外の場合、<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-640">if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="78b56-641">既定値は、<see langword="false" /> です。</span><span class="sxs-lookup"><span data-stu-id="78b56-641">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-642">この要素にスタイラスのキャプチャがある場合は、このプロパティの値`true`スタイラスのキャプチャが失われ、ポインターがその範囲外までです。</span><span class="sxs-lookup"><span data-stu-id="78b56-642">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="78b56-643">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-644">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-644">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="78b56-645">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="78b56-645">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-646">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-646">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="78b56-647">メタデータのプロパティを設定するには</span><span class="sxs-lookup"><span data-stu-id="78b56-647">Metadata properties set to</span></span> `true`|<span data-ttu-id="78b56-648">なし</span><span class="sxs-lookup"><span data-stu-id="78b56-648">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-649"><see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依存関係プロパティを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-649">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-650">この要素にフォーカスがある状態でキーが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-650">Occurs when a key is pressed while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-651">キーの処理は、コマンドを実行し、テキストの合成などその他のプラットフォーム機能と対話します。</span><span class="sxs-lookup"><span data-stu-id="78b56-651">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="78b56-652"><xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキストの入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-652">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="78b56-653">これは、ため、一部のコントロールがあるコントロールの複合またはテキストの高度なバージョンを提供するクラスの処理の入力処理および関連するイベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-653">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="78b56-654">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.KeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-654">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-655">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.KeyDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-655">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-656">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-656">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-657">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-657">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="78b56-658">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-658">Routing strategy</span></span>|<span data-ttu-id="78b56-659">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-659">Bubbling</span></span>|  
|<span data-ttu-id="78b56-660">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-660">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="78b56-661">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewKeyDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-661">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="78b56-662">オーバーライド<xref:System.Windows.ContentElement.OnKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-662">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-663"><see cref="E:System.Windows.ContentElement.KeyDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-663">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-664">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-664">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-665">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-665">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-666">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-666">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-667">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-667">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-668">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-668">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-669">この要素にフォーカスがあるときにキーが離されると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-669">Occurs when a key is released while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-670">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>添付イベントをこのクラスのように<xref:System.Windows.ContentElement.KeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-670">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-671">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.KeyUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-671">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-672">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-672">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-673">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-673">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="78b56-674">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-674">Routing strategy</span></span>|<span data-ttu-id="78b56-675">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-675">Bubbling</span></span>|  
|<span data-ttu-id="78b56-676">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-676">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="78b56-677">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewKeyUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-677">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="78b56-678">オーバーライド<xref:System.Windows.ContentElement.OnKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-678">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-679"><see cref="E:System.Windows.ContentElement.KeyUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-679">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-680">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-680">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-681">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-681">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-682">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-682">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-683">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-683">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-684">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-684">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-685">この要素が論理フォーカスを失ったときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-685">Occurs when this element loses logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-686">メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-686">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="78b56-687">ここでは、キーボード フォーカスのままですが、および要素の位置を<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されますも論理フォーカスを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-687">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="78b56-688">このイベントをより正確に解釈がその it 発生する状況の値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更される`true`に`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-688">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="78b56-689">このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-689">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-690">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを取得、実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-690">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-691">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-691">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-692">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-692">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="78b56-693">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-693">Routing strategy</span></span>|<span data-ttu-id="78b56-694">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-694">Bubbling</span></span>|  
|<span data-ttu-id="78b56-695">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-695">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="78b56-696">対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-696">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-697">オーバーライド<xref:System.Windows.ContentElement.OnLostFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-697">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-698"><see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-698">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-699">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-699">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-700">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-700">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-701">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-701">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-702">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-702">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-703">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-703">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-704">この要素からキーボード フォーカスが離れたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-704">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-705">このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-705">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-706">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを失っている実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-706">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="78b56-707">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.LostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-707">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-708">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-708">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-709">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-709">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-710">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-710">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="78b56-711">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-711">Routing strategy</span></span>|<span data-ttu-id="78b56-712">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-712">Bubbling</span></span>|  
|<span data-ttu-id="78b56-713">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-713">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="78b56-714">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-714">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="78b56-715">オーバーライド<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-715">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-716"><see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-716">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-717">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-717">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-718">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-718">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-719">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-719">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-720">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-720">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-721">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-721">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-722">この要素がマウス キャプチャを失ったときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-722">Occurs when this element loses mouse capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-723">要素がマウスをキャプチャは、ポインターがその境界の外側にある場合でも、マウス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-723">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="78b56-724">マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-724">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="78b56-725">このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-725">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-726">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>キャプチャを失った実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-726">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="78b56-727">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.LostMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-727">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-728">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostMouseCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-728">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-729">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-729">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-730">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-730">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="78b56-731">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-731">Routing strategy</span></span>|<span data-ttu-id="78b56-732">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-732">Bubbling</span></span>|  
|<span data-ttu-id="78b56-733">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-733">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="78b56-734">定義済みの対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-734">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-735">オーバーライド<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-735">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-736"><see cref="E:System.Windows.ContentElement.LostMouseCapture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-736">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-737">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-737">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-738">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-738">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-739">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-739">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-740">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-740">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-741">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-741">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-742">この要素がスタイラス キャプチャを失ったときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-742">Occurs when this element loses stylus capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-743">要素がスタイラスをキャプチャするときは、ポインターがその境界の外側にある場合でも、スタイラス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="78b56-743">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="78b56-744">スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-744">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="78b56-745">このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-745">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-746">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを失っている実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-746">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="78b56-747">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.LostStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-747">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-748">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostStylusCapture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-748">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-749">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-749">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-750">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-750">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="78b56-751">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-751">Routing strategy</span></span>|<span data-ttu-id="78b56-752">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-752">Bubbling</span></span>|  
|<span data-ttu-id="78b56-753">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-753">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-754">定義済みの対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-754">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-755">オーバーライド<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-755">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-756"><see cref="E:System.Windows.ContentElement.LostStylusCapture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-756">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-757">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-757">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-758">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-758">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-759">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-759">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-760">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-760">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-761">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-761">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-762">この要素がタッチのキャプチャを失うと発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-762">Occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-763">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-763">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-764">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-764">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="78b56-765">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-765">Routing strategy</span></span>|<span data-ttu-id="78b56-766">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-766">Bubbling</span></span>|  
|<span data-ttu-id="78b56-767">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-767">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-768">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-768">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-769">オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-769">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-770"><see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-770">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-771">この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-771">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-772">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.MouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-772">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-773">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-773">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-774"><xref:System.Windows.ContentElement.MouseDown>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>に対応する 2 つの標準のマウス ボタンのいずれかのキーを押します。</span><span class="sxs-lookup"><span data-stu-id="78b56-774">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <xref:System.Windows.ContentElement.MouseLeftButtonDown> <span data-ttu-id="78b56-775"><xref:System.Windows.ContentElement.MouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="78b56-775">and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="78b56-776">「解説」を参照してください。<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-776">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78b56-777">いくつか<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、固有のクラスのマウス ボタンのイベント処理を必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-777">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="78b56-778">左マウス ボタンを押すイベントは、クラス、コントロールの処理が最も可能性の高いイベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-778">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="78b56-779">多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="78b56-779">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="78b56-780">イベントが処理済みマークされると、その要素にアタッチされている他のインスタンス ハンドラーは通常は発生しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-780">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="78b56-781">その他のクラスまたはインスタンス ハンドラー UI ツリーのルートに向かうバブルの方向に要素にアタッチされているが通常も発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-781">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="78b56-782">前の重要なに記載されている問題を解決でき、それでも<xref:System.Windows.ContentElement.MouseDown>をこれらのソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベントをマウスの左ボタンのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-782">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="78b56-783">ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>イベントで、コントロールによって処理済みとしてマークされていません。</span><span class="sxs-lookup"><span data-stu-id="78b56-783">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="78b56-784">これは、プレビュー イベントであるため、ルートがルートをトンネリングをコントロールに注意してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-784">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="78b56-785">コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.ContentElement.AddHandler%2A>とルーティング イベントのデータの処理としてマークされている場合でも、イベントをリッスンするハンドラーの有効な署名オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="78b56-785">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-786">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-786">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-787">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-787">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="78b56-788">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-788">Routing strategy</span></span>|<span data-ttu-id="78b56-789">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-789">Bubbling</span></span>|  
|<span data-ttu-id="78b56-790">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-790">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-791">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewMouseDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-791">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="78b56-792">オーバーライド<xref:System.Windows.ContentElement.OnMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-792">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-793"><see cref="E:System.Windows.ContentElement.MouseDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-793">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-794">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-794">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-795">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-795">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-796">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-796">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-797">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-797">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-798">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-798">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-799">マウス ポインターがこの要素の境界内に入ったときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-799">Occurs when the mouse pointer enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseEnter> <span data-ttu-id="78b56-800">[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-800">is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="78b56-801">ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。</span><span class="sxs-lookup"><span data-stu-id="78b56-801">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="78b56-802">ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-802">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="78b56-803"><xref:System.Windows.ContentElement.MouseEnter>マウス ポインターがこのイベントの詳細、要素の境界内に入る時点を追跡しますが文字どおり報告された、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`false`に`true`この要素にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-803">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="78b56-804">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.MouseEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-804">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-805">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseEnter>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-805">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-806">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-806">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-807">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-807">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="78b56-808">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-808">Routing strategy</span></span>|<span data-ttu-id="78b56-809">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-809">Direct</span></span>|  
|<span data-ttu-id="78b56-810">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-810">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="78b56-811">オーバーライド<xref:System.Windows.ContentElement.OnMouseEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-811">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-812"><see cref="E:System.Windows.ContentElement.MouseEnter" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-812">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-813">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-813">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-814">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-814">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-815">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-815">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-816">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-816">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-817">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-817">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-818">マウス ポインターがこの要素の境界内から出たときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-818">Occurs when the mouse pointer leaves the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.MouseLeave> <span data-ttu-id="78b56-819">[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-819">is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="78b56-820">ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。</span><span class="sxs-lookup"><span data-stu-id="78b56-820">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="78b56-821">ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-821">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="78b56-822"><xref:System.Windows.ContentElement.MouseLeave>マウスが離れるときに、要素では、このイベントの詳細は、トラックが文字どおり報告された、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`true`に`false`この要素。</span><span class="sxs-lookup"><span data-stu-id="78b56-822">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="78b56-823">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.MouseLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-823">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-824">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseLeave>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-824">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-825">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-825">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-826">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-826">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="78b56-827">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-827">Routing strategy</span></span>|<span data-ttu-id="78b56-828">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-828">Direct</span></span>|  
|<span data-ttu-id="78b56-829">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-829">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="78b56-830">オーバーライド<xref:System.Windows.ContentElement.OnMouseLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-830">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-831"><see cref="E:System.Windows.ContentElement.MouseLeave" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-831">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-832">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-832">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-833">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-833">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-834">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-834">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-835">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-835">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-836">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-836">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-837">この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-837">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-838">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリー ルートをバブルに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-838">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-839">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-839">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-840">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-840">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-841">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-841">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-842">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-842">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-843">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-843">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-844">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-844">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="78b56-845">いくつか<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、固有のクラスのマウス ボタンのイベント処理を必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-845">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="78b56-846">左マウス ボタンを押すイベントは、クラス、コントロールの処理が最も可能性の高いイベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-846">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="78b56-847">多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="78b56-847">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="78b56-848">イベントが処理済みマークされると、その要素にアタッチされている他のインスタンス ハンドラーは通常は発生しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-848">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="78b56-849">その他のクラスまたはインスタンス ハンドラー UI ツリーのルートに向かうバブルの方向に要素にアタッチされているが通常も発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-849">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="78b56-850">前の重要なに記載されている問題を解決でき、それでも<xref:System.Windows.ContentElement.MouseLeftButtonDown>をこれらのソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベントをマウスの左ボタンのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-850">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="78b56-851">ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>イベントで、コントロールによって処理済みとしてマークされていません。</span><span class="sxs-lookup"><span data-stu-id="78b56-851">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="78b56-852">これは、プレビュー イベントであるため、ルートがルートをトンネリングをコントロールに注意してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-852">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="78b56-853">コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.ContentElement.AddHandler%2A>とルーティング イベントのデータの処理としてマークされている場合でも、イベントをリッスンするハンドラーの有効な署名オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="78b56-853">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-854">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-854">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-855">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-855">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="78b56-856">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-856">Routing strategy</span></span>|<span data-ttu-id="78b56-857">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-857">Direct</span></span>|  
|<span data-ttu-id="78b56-858">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-858">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-859">オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-859">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-860"><see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-860">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-861">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-861">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-862">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-862">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-863">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-863">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-864">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-864">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-865">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-865">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-866">この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-866">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-867">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリー ルートをバブルに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-867">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-868">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-868">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-869">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-869">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-870">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-870">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-871">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-871">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-872">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-872">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-873">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-873">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-874">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-874">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-875">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-875">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="78b56-876">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-876">Routing strategy</span></span>|<span data-ttu-id="78b56-877">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-877">Direct</span></span>|  
|<span data-ttu-id="78b56-878">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-878">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-879">オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-879">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-880"><see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-880">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-881">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-881">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-882">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-882">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-883">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-883">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-884">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-884">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-885">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-885">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-886">この要素の上でマウス ポインターが動かされたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-886">Occurs when the mouse pointer moves while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-887">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.MouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-887">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-888">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-888">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-889">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-890">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-890">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="78b56-891">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-891">Routing strategy</span></span>|<span data-ttu-id="78b56-892">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-892">Bubbling</span></span>|  
|<span data-ttu-id="78b56-893">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-893">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="78b56-894">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewMouseMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-894">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="78b56-895">オーバーライド<xref:System.Windows.ContentElement.OnMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-895">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-896"><see cref="E:System.Windows.ContentElement.MouseMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-896">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-897">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-897">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-898">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-898">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-899">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-899">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-900">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-900">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-901">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-901">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-902">この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-902">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-903">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリー ルートをバブルに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-903">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-904">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-904">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-905">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-905">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-906">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-906">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-907">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-907">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-908">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-908">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-909">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-909">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-910">右側のボタンのマウス イベントは、アプリケーションのシナリオでネイティブ処理を頻繁にあります。</span><span class="sxs-lookup"><span data-stu-id="78b56-910">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="78b56-911">たとえば、マウスの右ボタンを押したままは、コンテキスト メニューを表示することがあります。</span><span class="sxs-lookup"><span data-stu-id="78b56-911">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="78b56-912">参照してください[ContextMenu の概要](~/docs/framework/wpf/controls/contextmenu-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-912">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-913">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-913">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-914">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-914">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="78b56-915">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-915">Routing strategy</span></span>|<span data-ttu-id="78b56-916">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-916">Direct</span></span>|  
|<span data-ttu-id="78b56-917">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-917">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-918">オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-918">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-919"><see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-919">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-920">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-920">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-921">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-921">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-922">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-922">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-923">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-923">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-924">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-924">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-925">この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-925">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-926">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリー ルートをバブルに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-926">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-927">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-927">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-928">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-928">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-929">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-929">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-930">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-930">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-931">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-931">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-932">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-932">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-933">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-933">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-934">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-934">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="78b56-935">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-935">Routing strategy</span></span>|<span data-ttu-id="78b56-936">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-936">Direct</span></span>|  
|<span data-ttu-id="78b56-937">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-937">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-938">オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-938">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-939"><see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-939">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-940">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-940">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-941">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-941">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-942">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-942">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-943">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-943">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-944">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-944">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-945">この要素の上でいずれかのマウス ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-945">Occurs when any mouse button is released over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-946">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.MouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-946">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-947">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-947">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-948"><xref:System.Windows.ContentElement.MouseUp>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのリリースに対応します。</span><span class="sxs-lookup"><span data-stu-id="78b56-948">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <xref:System.Windows.ContentElement.MouseLeftButtonUp> <span data-ttu-id="78b56-949"><xref:System.Windows.ContentElement.MouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="78b56-949">and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="78b56-950">「解説」を参照してください。<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-950">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-951">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-951">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-952">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-952">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="78b56-953">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-953">Routing strategy</span></span>|<span data-ttu-id="78b56-954">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-954">Bubbling</span></span>|  
|<span data-ttu-id="78b56-955">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-955">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-956">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewMouseUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-956">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="78b56-957">オーバーライド<xref:System.Windows.ContentElement.OnMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-957">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-958"><see cref="E:System.Windows.ContentElement.MouseUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-958">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-959">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-959">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-960">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-960">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-961">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-961">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-962">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-962">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-963">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-963">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-964">この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-964">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-965">フォーカスおよびマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、発生した場合、<xref:System.Windows.ContentElement.MouseWheel>フォーカスがあるか、キャプチャした要素からのイベント、マウス ポインター実際にもあります別の要素。</span><span class="sxs-lookup"><span data-stu-id="78b56-965">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="78b56-966">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.MouseWheel>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-966">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-967">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseWheel>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-967">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-968">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-968">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-969">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-969">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="78b56-970">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-970">Routing strategy</span></span>|<span data-ttu-id="78b56-971">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-971">Bubbling</span></span>|  
|<span data-ttu-id="78b56-972">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-972">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="78b56-973">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewMouseWheel>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-973">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="78b56-974">オーバーライド<xref:System.Windows.ContentElement.OnMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-974">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-975"><see cref="E:System.Windows.ContentElement.MouseWheel" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-975">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-976">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-976">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-977">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-977">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-978">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-978">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-979">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-979">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-980">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-980">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="contentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="78b56-981">既存のタブ オーダーを検査するモード、または視覚的な移動方向を示すプロパティを含む検査要求。</span><span class="sxs-lookup"><span data-stu-id="78b56-981">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span></span></param>
        <summary><span data-ttu-id="78b56-982">この要素から別の要素へのフォーカスの移動を試みます。</span><span class="sxs-lookup"><span data-stu-id="78b56-982">Attempts to move focus from this element to another element.</span></span> <span data-ttu-id="78b56-983">フォーカスの移動方向は、ガイドラインの方向によって指定され、この要素のビジュアル親の編成内で解釈されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-983">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-984">要求した検査が実行された場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-984">if the requested traversal was performed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-985">このメソッドの戻り値を確認してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-985">Make sure you check the return value of this method.</span></span> <span data-ttu-id="78b56-986">戻り値`false`コントロールの複合で定義されているタブ ストップの検査が実行され、検査要求を要求をラップしていないかどうかに返される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-986">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contentElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-987">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] インフラストラクチャの、クラス固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装を返します。</span><span class="sxs-lookup"><span data-stu-id="78b56-987">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span></span></summary>
        <returns><span data-ttu-id="78b56-988">型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</span><span class="sxs-lookup"><span data-stu-id="78b56-988">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="78b56-989">継承時の注意</span><span class="sxs-lookup"><span data-stu-id="78b56-989">Notes to inheritors</span></span>

<span data-ttu-id="78b56-990">通常このメソッドの実装は、特定のコンス トラクターを呼び出す<xref:System.Windows.Automation.Peers.AutomationPeer" />実装では、戻り値として返すとします。</span><span class="sxs-lookup"><span data-stu-id="78b56-990">The implementation of this method is typically to call the constructor of a specific <xref:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span></span>  
  
 <span data-ttu-id="78b56-991">すべて<xref:System.Windows.ContentElement>派生クラスは、独自の特定の提供するためにこのメソッドを実装する必要があります<xref:System.Windows.Automation.Peers.AutomationPeer>WPF インフラストラクチャを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-991">All <xref:System.Windows.ContentElement> derived classes should implement this method in order to provide their own specific <xref:System.Windows.Automation.Peers.AutomationPeer> implementations to the WPF infrastructure.</span></span> <span data-ttu-id="78b56-992">このパターンの実装の詳細については、「<xref:System.Windows.Automation.Peers.AutomationPeer>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-992">For details on implementing this pattern, see <xref:System.Windows.Automation.Peers.AutomationPeer>.</span></span>

 ]]></format>
        </remarks>        
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-993">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-993">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-994">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-994">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-995">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-995">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-996">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-996">This method has no default implementation.</span></span> <span data-ttu-id="78b56-997">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-997">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-998">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-998">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-999">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-999">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1000">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1000">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1001">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1001">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1002">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1002">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1003">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1003">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1004">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1004">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1005">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1005">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1006">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1006">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1007">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1007">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1008">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1008">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1009">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1009">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1010">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1010">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1011">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1011">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1012">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1012">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1013">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1013">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1014">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1014">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1015">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1015">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1016">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1016">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1017">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1017">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1018">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1018">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1019">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1019">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1020">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1020">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1021">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1021">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1022">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1022">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1023">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1023">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1024">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1024">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1025">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1025">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1026">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1026">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1027">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1027">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1028">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1028">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1029">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1029">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1030">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1030">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1031">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1031">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1032">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1032">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1033">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1033">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1034">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1034">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1035">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1035">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1036">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1036">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1037">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1037">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1038">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1038">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1039">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1039">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1040">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1040">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1041">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1041">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1042">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1042">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1043">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1043">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1044">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1044">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1045">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1045">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1046">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1046">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1047">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1047">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1048">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1048">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1049">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1049">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1050">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1050">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1051">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1051">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1052">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1052">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1053">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1053">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="78b56-1054">このイベント データには、<see cref="E:System.Windows.ContentElement.GotFocus" /> イベントの識別子が含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1054">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="78b56-1055">提供されたイベント データを使用して、<see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1055">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1056">このメソッドは、仮想は、イベントを発生させる既定の実装。</span><span class="sxs-lookup"><span data-stu-id="78b56-1056">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="78b56-1057">これを \* メソッドの実装は、イベントを発生させる、およびイベントを発生させる、この同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.ContentElement.IsFocused%2A>プロパティ値が変更されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1057">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="78b56-1058"><xref:System.Windows.ContentElement.OnGotFocus%2A>からその他の実装とは異なる[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で \* のみそのイベントのクラス処理を追加する便利な手段を提供するには、実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1058">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
## <a name="notes-to-inheritors"></a><span data-ttu-id="78b56-1059">継承時の注意</span><span class="sxs-lookup"><span data-stu-id="78b56-1059">Notes to inheritors</span></span>

<span data-ttu-id="78b56-1060">フォーカス イベントを発生させないする意図とは異なる必要がない限り、実装が、基本実装を呼び出すことを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1060">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="78b56-1061">それ以外の場合、<xref:System.Windows.ContentElement.GotFocus>イベントは通常、この要素にフォーカスを設定する一般的なユーザー操作中に発生しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1061">Otherwise, the <xref:System.Windows.ContentElement.GotFocus> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="78b56-1062">要素にフォーカスを設定しない場合は、設定されない要素を防ぐことができます<xref:System.Windows.ContentElement.Focusable>に`false`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1062">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <xref:System.Windows.ContentElement.Focusable> to `false`.</span></span>
<span data-ttu-id="78b56-1063">既定で、<xref:System.Windows.ContentElement.Focusable>フォーカスを設定するための設定<xref:System.Windows.ContentElement.Focusable>意図的にする必要はありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1063">Note that by default a <xref:System.Windows.ContentElement.Focusable> is not focusable, therefore setting <xref:System.Windows.ContentElement.Focusable> deliberately might not be necessary.</span></span>

 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1064">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1064">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1065">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1065">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1066">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1066">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1067">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1067">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1068">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1068">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1069">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1069">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1070">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1070">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1071">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1071">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1072">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1072">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1073">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1073">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1074">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1074">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1075">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1075">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1076">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1076">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1077">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1077">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1078">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1078">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1079">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1079">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1080">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1080">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1081">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1081">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1082">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1082">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1083">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1083">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1084">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1084">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1085">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1085">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1086">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1086">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1087">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1087">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1088">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1088">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1089">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1089">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1090">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1090">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1091">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1091">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1092">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1092">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1093">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1093">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1094">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1094">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1095">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1095">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1096">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1096">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1097">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1097">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1098">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1098">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1099">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1099">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1100">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1100">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1101">タッチがこの要素にキャプチャされているときに発生する <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1101">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1102"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1102">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1103">オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.GotTouchCapture>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1103">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="78b56-1104">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1104">Be sure to call the base class' <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1105">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1105">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1106">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1106">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1107">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1107">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1108">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>依存関係プロパティの変更。</span><span class="sxs-lookup"><span data-stu-id="78b56-1108">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="78b56-1109">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1109">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1110">次に、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1110">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1111">なお、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>イベントがルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1111">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="78b56-1112">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1112">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1113">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1113">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1114">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1114">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1115">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1115">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1116">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1116">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1117">この要素によって <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> イベントが発生する直前に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1117">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span></span> <span data-ttu-id="78b56-1118">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1118">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1119">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1119">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1120">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1120">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1121">次に、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1121">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1122">なお、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベントがルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1122">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="78b56-1123">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1123">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1124">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1124">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1125">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1125">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1126">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1126">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1127">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1127">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1128">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1128">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1129">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1129">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1130">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseCaptured%2A>依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1130">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1131">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1131">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1132">次に、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1132">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1133">なお、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントがルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1133">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="78b56-1134">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1134">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1135">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1135">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1136">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1136">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1137">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1137">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1138">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1138">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1139">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1139">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1140">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1140">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="78b56-1141">この仮想メソッドが発生したときの値、<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1141">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1142">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1142">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1143">次に、<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1143">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1144">イベントがルーティング イベントで; ではないことに注意してください。そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1144">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span></span>  
  
<span data-ttu-id="78b56-1145">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1145">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1146">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1146">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1147">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1147">You may call base either before or after your special handling, depending on your requirements.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1148">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1148">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1149">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1149">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1150">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1150">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1151">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1151">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1152">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1152">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1153">次に、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1153">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1154">なお、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>イベントがルーティング イベントではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1154">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="78b56-1155">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1155">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1156">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1156">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1157">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1157">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1158">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1158">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1159">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1159">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1160">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1160">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1161">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1161">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1162">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1162">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1163">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1163">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1164">次に、<xref:System.Windows.ContentElement.IsStylusCapturedChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1164">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1165">イベントは、ルーティング イベントではないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1165">Notice that the event is not a routed event.</span></span> <span data-ttu-id="78b56-1166">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1166">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1167">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1167">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1168">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1168">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1169">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1169">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1170">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1170">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1171">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1171">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1172">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1172">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1173">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1173">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1174">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1174">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1175">次に、<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1175">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1176">イベントは、ルーティング イベントではないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1176">Notice that the event is not a routed event.</span></span> <span data-ttu-id="78b56-1177">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1177">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1178">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1178">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1179">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1179">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1180">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1180">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1181">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1181">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1182">この要素上で未処理の <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1182">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="78b56-1183">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1183">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1184">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>依存関係プロパティの値が変化します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1184">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="78b56-1185">仮想メソッドでは、最初に発生しますが、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1185">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="78b56-1186">次に、<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1186">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="78b56-1187">イベントは、ルーティング イベントではないことを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1187">Notice that the event is not a routed event.</span></span> <span data-ttu-id="78b56-1188">そのため、クラスのハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1188">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="78b56-1189">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1189">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1190">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1190">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1191">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1191">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1192">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1192">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1193">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1193">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1194">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1194">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1195">キーストロークは、専用の入力マネージャーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1195">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="78b56-1196">その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1196">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="78b56-1197">これらの入力システムの機能、イベントを処理し、としてマークする場合<xref:System.Windows.ContentElement.OnKeyDown%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1197">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="78b56-1198">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1198">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1199">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1199">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1200">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1200">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1201">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1201">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1202">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1202">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1203">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1203">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1204">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1204">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1205">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1205">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1206">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1206">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1207">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1207">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1208">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1208">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1209">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1209">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1210">キーストロークは、専用の入力マネージャーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1210">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="78b56-1211">その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1211">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="78b56-1212">これらの入力システムの機能、イベントを処理し、としてマークする場合<xref:System.Windows.ContentElement.OnKeyUp%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1212">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="78b56-1213">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1213">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1214">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1214">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1215">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1215">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1216">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1216">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1217">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1217">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1218">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1218">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1219">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1219">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1220">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1220">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1221">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1221">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1222">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1222">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="78b56-1223">このイベント データには、<see cref="E:System.Windows.ContentElement.LostFocus" /> イベントの識別子が含まれている必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1223">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="78b56-1224">提供されたイベント データを使って、<see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1224">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1225">このメソッドは、仮想は、イベントを発生させる既定の実装。</span><span class="sxs-lookup"><span data-stu-id="78b56-1225">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="78b56-1226">これを \* メソッドの実装は、イベントを発生させる、およびイベントを発生させる、この同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.ContentElement.IsFocused%2A>プロパティ値が変更されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1226">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="78b56-1227">この実装が異なるその他の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で \* のみそのイベントのクラス処理を追加する便利な手段を提供するには、実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1227">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="78b56-1228">フォーカス イベントを発生させないする意図とは異なる必要がない限り、実装が、基本実装を呼び出すことを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1228">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="78b56-1229">それ以外の場合、<see cref="E:System.Windows.ContentElement.LostFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザー操作中に発生しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1229">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="78b56-1230">要素にフォーカスを設定しない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.ContentElement.Focusable" />に<see langword="false" />します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1230">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1231">イベント データを格納する <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1231">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1232">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1232">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1233">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1233">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1234">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1234">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1235">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1235">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1236">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1236">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1237">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1237">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1238">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1238">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1239">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1239">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1240">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1240">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1241">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1241">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1242">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1242">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1243">イベント データを格納する <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1243">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1244">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1244">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1245">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1245">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1246">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1246">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1247">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1247">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1248">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1248">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1249">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1249">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1250">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1250">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1251">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1251">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1252">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1252">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1253">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1253">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1254">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1254">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1255">イベント データを格納する <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1255">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1256">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1256">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1257">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1257">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1258">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1258">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1259">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1259">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1260">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1260">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1261">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1261">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1262">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1262">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1263">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1263">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1264">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1264">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1265">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1265">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1266">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1266">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1267">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1267">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1268">この要素がタッチのキャプチャを失ったときに発生する <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1268">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1269"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1269">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1270">オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.LostTouchCapture>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1270">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="78b56-1271">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1271">Be sure to call the base class' <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1272">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1272">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1273">このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1273">This event data reports details about the mouse button that was pressed and the handled state.</span></span></param>
        <summary><span data-ttu-id="78b56-1274">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1274">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1275">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1275">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1276">マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1276">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="78b56-1277">一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1277">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="78b56-1278">これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnMouseDown%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1278">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="78b56-1279">このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.ContentElement.MouseLeftButtonDown>と<xref:System.Windows.ContentElement.MouseRightButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1279">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="78b56-1280">これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1280">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="78b56-1281">このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1281">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="78b56-1282">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1282">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="78b56-1283">クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1283">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="78b56-1284">処理することによって<xref:System.Windows.ContentElement.OnMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="78b56-1284">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="78b56-1285">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1285">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="78b56-1286">各ボタンに固有の直接イベントもに、仮想 \* メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1286">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="78b56-1287">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1287">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1288">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1288">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1289">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1289">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1290">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1290">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1291">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1291">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1292">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1292">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1293">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1293">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1294">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1294">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1295">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1295">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1296">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1296">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1297">未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1297">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span></span> <span data-ttu-id="78b56-1298">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1298">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1299">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1299">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1300">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1300">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1301">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1301">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="78b56-1302">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1302">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1303">ここで一致するイベントは、直接ルーティング戦略のルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1303">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="78b56-1304">一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1304">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1305">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1305">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1306">未処理の <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1306">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span></span> <span data-ttu-id="78b56-1307">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1307">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1308">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1308">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1309">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1309">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1310">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1310">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="78b56-1311">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1311">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1312">ここで一致するイベントは、直接ルーティング戦略のルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1312">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="78b56-1313">一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1313">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1314">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1314">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1315">このイベント データは、マウスの左ボタンが押されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1315">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="78b56-1316">この要素上で未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1316">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span></span> <span data-ttu-id="78b56-1317">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1317">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1318"><xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1318">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> <span data-ttu-id="78b56-1319">基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="78b56-1319">is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="78b56-1320">マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1320">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1321">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1321">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1322">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1322">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1323">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1323">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1324">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1324">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1325">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1325">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="78b56-1326">または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1326">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="78b56-1327">基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1327">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="78b56-1328">呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1328">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="78b56-1329">派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>、派生クラスで、基本実装を呼び出さずにただし、このオーバーライドを無効にします、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1329">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1330">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1330">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1331">このイベント データは、マウスの左ボタンが放されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1331">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="78b56-1332">未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1332">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1333">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1333">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1334"><xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1334">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> <span data-ttu-id="78b56-1335">基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseLeftButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="78b56-1335">is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="78b56-1336">マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1336">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1337">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1337">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1338">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1338">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1339">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1339">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1340">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1340">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1341">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1341">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1342">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1342">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1343">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1343">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1344">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1344">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1345">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1345">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1346">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1346">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1347">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1347">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1348">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1348">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1349">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1349">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1350">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1350">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1351">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1351">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1352">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1352">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1353">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1353">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1354">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1354">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1355">このイベント データは、マウスの右ボタンが押されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1355">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="78b56-1356">未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1356">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1357">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1357">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1358"><xref:System.Windows.ContentElement.MouseRightButtonDown>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1358">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> <span data-ttu-id="78b56-1359">基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="78b56-1359">is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="78b56-1360">マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1360">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1361">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1361">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1362">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1362">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1363">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1363">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1364">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1364">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1365">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1365">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="78b56-1366">または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1366">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="78b56-1367">基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1367">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="78b56-1368">呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1368">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="78b56-1369">派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>ない; 呼び出し元のベースは、派生クラスでただし、この上書きを無効にしますに含まれる、コントロール上のコンテキスト] メニューの [サービスの<xref:System.Windows.Controls.Control>既定の動作。</span><span class="sxs-lookup"><span data-stu-id="78b56-1369">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1370">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1370">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1371">このイベント データは、マウスの右ボタンが離されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1371">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="78b56-1372">未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1372">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1373">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1373">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1374"><xref:System.Windows.ContentElement.MouseRightButtonUp>イベントはバブル ルートの移動に見えますが、実際には、間接的な方法で送信されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1374">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> <span data-ttu-id="78b56-1375">基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonUp>。</span><span class="sxs-lookup"><span data-stu-id="78b56-1375">is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="78b56-1376">マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1376">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1377">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1377">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1378">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1378">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1379">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1379">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1380">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1380">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1381">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1381">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1382">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1382">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1383">このイベント データは、マウス ボタンが離されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1383">The event data reports that the mouse button was released.</span></span></param>
        <summary><span data-ttu-id="78b56-1384">未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1384">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1385">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1385">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1386">マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1386">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="78b56-1387">一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1387">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="78b56-1388">これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnMouseUp%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1388">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="78b56-1389">このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.ContentElement.MouseLeftButtonUp>と<xref:System.Windows.ContentElement.MouseRightButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1389">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="78b56-1390">これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1390">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="78b56-1391">このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1391">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="78b56-1392">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1392">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="78b56-1393">クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1393">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="78b56-1394">処理することによって<xref:System.Windows.ContentElement.OnMouseUp%2A>、クラス処理は、すべての可能なマウスのボタンのアクションを記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="78b56-1394">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="78b56-1395">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1395">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="78b56-1396">各ボタンに固有の直接イベントもに、仮想 \* メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1396">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="78b56-1397">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1397">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1398">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1398">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1399">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1399">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1400">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1400">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1401">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1401">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1402">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1402">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1403">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1403">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1404">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1404">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1405">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1405">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1406">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1406">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1407">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1407">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1408">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1408">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1409">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1409">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1410">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1410">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1411">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1411">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1412">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1412">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1413">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1413">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1414">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1414">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1415">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1415">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1416">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1416">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1417">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1417">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1418">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1418">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1419">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1419">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1420">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1420">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1421">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1421">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1422">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1422">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1423">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1423">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1424">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1424">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1425">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1425">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1426">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1426">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1427">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1427">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1428">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1428">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1429">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1429">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1430">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1430">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1431">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1431">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1432">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1432">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1433">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1433">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1434">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1434">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1435">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1435">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1436">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1436">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1437">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1437">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1438">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1438">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1439">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1439">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1440">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1440">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1441">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1441">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1442">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1442">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1443">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1443">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1444">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1444">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1445">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1445">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1446">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1446">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1447">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1447">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1448">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1448">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1449">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1449">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1450">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1450">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1451">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1451">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1452">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1452">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1453">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1453">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1454">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1454">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1455">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1455">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1456">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1456">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1457">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1457">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1458">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1458">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1459">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1459">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1460">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1460">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1461">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1461">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1462">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1462">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1463">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1463">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1464">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1464">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1465">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1465">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1466">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1466">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1467">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1467">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1468">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1468">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1469">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1469">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1470">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1470">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1471">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1471">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1472">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1472">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1473">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1473">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1474">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1474">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1475">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1475">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1476">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1476">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1477">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1477">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1478">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1478">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1479">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1479">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1480">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1480">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1481">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1481">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1482">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1482">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1483">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1483">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1484">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1484">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1485">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1485">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1486">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1486">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1487">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1487">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1488">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1488">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1489">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1489">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1490">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1490">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1491">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1491">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1492">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1492">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1493">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1493">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1494">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1494">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1495">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1495">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1496">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1496">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1497">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1497">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1498">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1498">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1499">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1499">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1500">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1500">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1501">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1501">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1502">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1502">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1503">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1503">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1504">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1504">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1505">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1505">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1506">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1506">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1507">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1507">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1508">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1508">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1509">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1509">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1510">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1510">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1511">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1511">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1512">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1512">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1513">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1513">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1514">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1514">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1515">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1515">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1516">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1516">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1517">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1517">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1518">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1518">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1519">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1519">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1520">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1520">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1521">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1521">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1522">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1522">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1523">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1523">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1524">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1524">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1525">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1525">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1526">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1526">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1527">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1527">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1528">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1528">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1529">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1529">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1530">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1530">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1531">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1531">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1532">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1532">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1533">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1533">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1534">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1534">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1535">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1535">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1536">このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1536">The event data reports that one or more mouse buttons were pressed.</span></span></param>
        <summary><span data-ttu-id="78b56-1537">未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1537">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1538">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1538">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1539">マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1539">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="78b56-1540">一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1540">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="78b56-1541">これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1541">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="78b56-1542">このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>と<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1542">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="78b56-1543">これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1543">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="78b56-1544">このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1544">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="78b56-1545">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1545">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="78b56-1546">クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1546">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="78b56-1547">処理することによって<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="78b56-1547">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="78b56-1548">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1548">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="78b56-1549">各ボタンに固有の直接イベントもに、仮想 \* メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1549">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="78b56-1550">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1550">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1551">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1551">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1552">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1552">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1553">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1553">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1554">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1554">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1555">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1555">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1556">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1556">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1557">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1557">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1558">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1558">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1559">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1559">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1560">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1560">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1561">このイベント データは、マウスの左ボタンが押されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1561">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="78b56-1562">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1562">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1563">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1563">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1564"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1564">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> <span data-ttu-id="78b56-1565">基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1565">is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="78b56-1566">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1566">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1567">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1567">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1568">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1568">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1569">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1569">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1570">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1570">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1571">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1571">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="78b56-1572">または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1572">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="78b56-1573">基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1573">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="78b56-1574">呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1574">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="78b56-1575">派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>、派生クラスで、基本実装を呼び出さずにただし、このオーバーライドを無効にします、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1575">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1576">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1576">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1577">このイベント データは、マウスの左ボタンが放されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1577">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="78b56-1578">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1578">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1579">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1579">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1580"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1580">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> <span data-ttu-id="78b56-1581">基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1581">is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="78b56-1582">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1582">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1583">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1583">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1584">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1584">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1585">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1585">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1586">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1586">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1587">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1587">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1588">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1588">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1589">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1589">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1590">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1590">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1591">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1591">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1592">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1592">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1593">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1593">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1594">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1594">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1595">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1595">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1596">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1596">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1597">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1597">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1598">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1598">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1599">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1599">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1600">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1600">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1601">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1601">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1602">このイベント データは、マウスの右ボタンが押されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1602">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="78b56-1603">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1603">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1604">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1604">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1605"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1605">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> <span data-ttu-id="78b56-1606">基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1606">is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="78b56-1607">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1607">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1608">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1608">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1609">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1609">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1610">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1610">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1611">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1611">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1612">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1612">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="78b56-1613">または、特定のマウスの状態のイベント処理を変更するには、このメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1613">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="78b56-1614">基本の実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1614">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="78b56-1615">呼び出すことも期待する先祖クラスにそのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1615">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="78b56-1616">派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>ない; 呼び出し元のベースは、派生クラスでただし、この上書きを無効にしますに含まれる、コントロール上のコンテキスト] メニューの [サービスの<xref:System.Windows.Controls.Control>既定の動作。</span><span class="sxs-lookup"><span data-stu-id="78b56-1616">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1617">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1617">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1618">このイベント データは、マウスの右ボタンが離されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1618">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="78b56-1619">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1619">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1620">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1620">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1621"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントのトンネリングのルートを移動するが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1621">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> <span data-ttu-id="78b56-1622">基になるイベントに、ルーティング、トンネルとは、<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1622">is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="78b56-1623">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>この要素の目的は、イベントを処理済みの状態はイベント ルート上の他の要素には永続化されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1623">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="78b56-1624">イベントをインスタンスの一般的なハンドラーを防ぐために処理済みとしてマークするただし、(指定しなかったもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1624">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="78b56-1625">処理の一般的なマウス イベントの既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1625">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="78b56-1626">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1626">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="78b56-1627">派生クラスの静的コンス トラクター内の別のクラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1627">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78b56-1628">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1628">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1629">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1629">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="78b56-1630">このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1630">The event data reports that one or more mouse buttons were released.</span></span></param>
        <summary><span data-ttu-id="78b56-1631">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1631">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1632">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1632">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1633">マウス ボタンの動作は、専用の入力マネージャーによって処理もされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1633">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="78b56-1634">一般的なマウス ボタンの操作として公開される前に、入力などのマウス ボタンの動作に依存しており、コマンドのバインド、その他のプログラミング機能は、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1634">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="78b56-1635">これらの入力システム機能のマークがある場合、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1635">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="78b56-1636">このクラス ハンドラーを使用して、イベントを処理済みとしてマークする場合、次のイベントに影響する可能性があります:<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>と<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1636">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="78b56-1637">これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1637">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="78b56-1638">このイベントを処理するクラスで処理済みとしてマークする、サブイベントがも発生します。ただし、これらはイベント データの処理済みの状態を渡します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1638">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="78b56-1639">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1639">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="78b56-1640">クラス ハンドラーも呼び出されませんにこれらのクラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>を使用して署名`handledEventsToo``true`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1640">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="78b56-1641">処理することによって<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>、クラス処理は、すべての可能なマウスのボタンのアクションを記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="78b56-1641">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="78b56-1642">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1642">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="78b56-1643">各ボタンに固有の直接イベントもに、仮想 \* メソッドかどうか、これらのボタンに固有のクラス ハンドラーをオーバーライドするとより適切な可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1643">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="78b56-1644">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1644">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1645">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1645">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1646">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1646">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1647">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1647">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1648">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1648">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1649">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1649">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1650">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1650">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1651">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1651">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1652">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1652">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1653">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1653">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1654">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1654">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1655">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1655">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1656">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1656">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1657">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1657">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1658">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1658">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1659">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1659">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1660">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1660">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1661">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1661">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1662">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1662">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1663">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1663">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1664">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1664">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1665">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1665">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1666">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1666">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1667">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1667">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1668">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1668">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1669">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1669">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1670">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1670">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1671">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1671">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1672">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1672">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1673">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1673">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1674">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1674">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1675">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1675">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1676">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1676">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1677">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1677">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1678">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1678">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1679">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1679">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1680">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1680">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1681">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1681">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1682">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1682">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1683">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1683">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1684">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1684">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1685">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1685">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1686">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1686">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1687">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1687">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1688">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1688">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1689">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1689">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1690">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1690">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1691">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1691">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1692">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1692">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1693">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1693">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1694">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1694">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1695">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1695">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1696">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1696">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1697">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1697">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1698">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1698">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1699">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1699">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1700">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1700">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1701">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1701">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1702">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1702">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1703">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1703">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1704">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1704">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1705">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1705">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1706">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1706">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1707">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1707">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1708">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1708">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1709">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1709">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1710">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1710">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1711">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1711">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1712">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1712">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1713">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1713">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1714">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1714">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1715">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1715">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1716">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1716">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1717">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1717">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1718">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1718">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1719">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1719">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1720">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1720">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1721">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1721">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1722">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1722">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1723">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1723">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1724">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1724">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1725">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1725">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1726">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1726">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1727">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1727">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1728">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1728">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1729">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1729">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1730">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1730">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1731">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1731">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1732">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1732">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1733">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1733">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1734">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1734">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1735">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1735">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1736">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1736">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1737">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1737">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1738">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1738">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1739">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1739">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1740">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1740">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1741">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1741">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1742">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1742">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1743">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1743">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1744">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1744">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1745">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1745">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1746">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1746">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1747">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1747">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1748">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1748">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1749">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1749">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1750">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1750">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1751">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1751">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1752">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1752">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1753">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1753">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1754">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1754">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1755">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1755">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1756">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1756">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1757">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1757">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1758">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1758">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1759">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1759">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1760">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1760">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1761">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1761">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1762">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1762">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1763">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1763">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1764">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1764">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1765">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1765">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1766">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1766">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1767">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1767">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1768">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1768">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1769">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1769">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1770">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1770">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1771">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1771">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1772">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1772">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1773">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1773">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1774">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1774">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1775">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1775">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1776">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1776">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1777">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1777">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1778">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1778">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1779">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1779">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1780">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1780">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1781">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1781">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1782">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1782">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1783">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1783">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1784">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1784">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1785">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1785">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1786">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1786">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1787">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1787">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1788">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1788">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1789">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1789">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1790">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1790">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1791">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1791">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1792">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1792">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1793">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1793">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1794">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1794">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1795">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1795">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1796">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1796">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1797">アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1797">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1798">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1798">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1799">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1799">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1800">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1800">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1801">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1801">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1802">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1802">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1803">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1803">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1804">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1804">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1805">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1805">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1806">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1806">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1807">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1807">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="78b56-1808">プレビュー イベントを具体的には、もう 1 つのシナリオでは、対応するバブル クラス ハンドラーが呼び出されないように処理済みとしてマークします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1808">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1809">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1809">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1810">この要素がタッチで押されたときに発生する <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1810">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1811"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1811">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1812">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchDown>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1812">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="78b56-1813">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1813">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1814">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1814">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1815">タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1815">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1816"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1816">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1817">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchMove>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1817">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="78b56-1818">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1818">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1819">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1819">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1820">この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1820">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1821"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1821">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1822">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchUp>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1822">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="78b56-1823">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1823">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1824">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1824">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1825">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1825">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1826">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1826">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1827">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1827">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1828">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1828">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1829">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1829">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1830">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1830">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1831">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1831">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1832">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1832">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1833">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1833">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1834">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1834">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1835">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1835">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="contentElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1836">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1836">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1837">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1837">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1838">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1838">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1839">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1839">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1840">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1840">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1841">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1841">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1842">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1842">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1843">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1843">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1844">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1844">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1845">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1845">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1846">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1846">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1847">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1847">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1848">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1848">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1849">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1849">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1850">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1850">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1851">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1851">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1852">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1852">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1853">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1853">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1854">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1854">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1855">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1855">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1856">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1856">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1857">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1857">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1858">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1858">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1859">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1859">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1860">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1860">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1861">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1861">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1862">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1862">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1863">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1863">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1864">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1864">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1865">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1865">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1866">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1866">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1867">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1867">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1868">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1868">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1869">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1869">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1870">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1870">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1871">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1871">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1872">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1872">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1873">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1873">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1874">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1874">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1875">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1875">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1876">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1876">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1877">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1877">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1878">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1878">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1879">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1879">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1880">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1880">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1881">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1881">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1882">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1882">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1883">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1883">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1884">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1884">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1885">未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1885">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span></span> <span data-ttu-id="78b56-1886">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1886">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1887">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1887">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1888">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1888">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1889">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1889">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="78b56-1890">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1890">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1891">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1891">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1892">一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1892">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1893">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1893">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1894">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1894">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1895">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1895">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1896">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1896">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1897">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1897">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1898">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1898">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1899">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1899">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1900">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1900">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1901">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1901">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1902">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1902">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1903">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1903">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1904">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1904">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1905">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1905">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1906">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1906">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1907">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1907">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1908">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1908">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1909">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1909">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1910">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1910">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1911">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1911">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1912">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1912">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1913">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1913">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1914">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1914">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1915">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1915">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1916">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1916">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1917">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1917">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1918">未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1918">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span></span> <span data-ttu-id="78b56-1919">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1919">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1920">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1920">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1921">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1921">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="78b56-1922">呼び出すことができます基本前に、または後、特別な処理の要件に応じて。</span><span class="sxs-lookup"><span data-stu-id="78b56-1922">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="78b56-1923">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1923">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1924">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1924">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1925">一般的なインスタンス ハンドラーの場合にも役立ちますが、イベントを処理済みとしてマーク (指定されていないもの`handledEventsToo`) 呼び出されないようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1925">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1926">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1926">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1927">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1927">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1928">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1928">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1929">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1929">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1930">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1930">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1931">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1931">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1932">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1932">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1933">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1933">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1934">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1934">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1935">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1935">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1936">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1936">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1937">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1937">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1938">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1938">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1939">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1939">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1940">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1940">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1941">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1941">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1942">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1942">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1943">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1943">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1944">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1944">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1945">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1945">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1946">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1946">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1947">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1947">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1948">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1948">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1949">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1949">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1950">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1950">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1951">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1951">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1952">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1952">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1953">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1953">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1954">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1954">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1955">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1955">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1956">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1956">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1957">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1957">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1958">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1958">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1959">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1959">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1960">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1960">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1961">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1961">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1962">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1962">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1963">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1963">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1964">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1964">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1965">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1965">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1966">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1966">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1967">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1967">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1968">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1968">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1969">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1969">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1970">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1970">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1971">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1971">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1972">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1972">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1973">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1973">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1974">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1974">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1975">アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1975">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="78b56-1976">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1976">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1977">このメソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1977">This method has no default implementation.</span></span> <span data-ttu-id="78b56-1978">継承の中間クラスには、このメソッドを実装があります、ために、実装の基本実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="78b56-1978">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="78b56-1979">このメソッドの目的は、のような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベント パターンで \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することにより、派生クラスから一致するイベントを処理する手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1979">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="78b56-1980">ここで一致するイベントは、ルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1980">In this case the matching event is a routed event.</span></span> <span data-ttu-id="78b56-1981">On のメソッドの実装パターンは、ルーティング イベント ハンドラーを呼び出すの要素とは限りませんが、子要素によって発生するためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1981">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="78b56-1982">そのため、実装では、イベント データのソースのプロパティを確認する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-1982">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="78b56-1983">ほとんどの場合、イベントが再発生する必要がありますください。</span><span class="sxs-lookup"><span data-stu-id="78b56-1983">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="78b56-1984">このメソッドをオーバーライドすることで、または登録することでクラスのハンドラーを<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上のイベントが受信したときに、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-1984">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="78b56-1985">クラス処理が適切なシナリオの 1 つは、イベント データを操作し、ルーティング イベントを処理済みとしてマークすることです。</span><span class="sxs-lookup"><span data-stu-id="78b56-1985">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1986">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1986">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1987">この要素の内部がタッチで押されたときに発生する <see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1987">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1988"><xref:System.Windows.ContentElement.OnTouchDown%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1988">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1989">オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchDown>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1989">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="78b56-1990">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnTouchDown%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1990">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1991">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1991">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1992">この要素の境界の外部から内部にタッチが移動したときに発生する <see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1992">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1993"><xref:System.Windows.ContentElement.OnTouchEnter%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1993">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1994">オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchEnter>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1994">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="78b56-1995">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnTouchEnter%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1995">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-1996">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-1996">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-1997">この要素の境界の内部から外部にタッチが移動したときに発生する <see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-1997">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-1998"><xref:System.Windows.ContentElement.OnTouchLeave%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-1998">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-1999">オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchLeave>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-1999">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="78b56-2000">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnTouchLeave%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2000">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-2001">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-2001">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-2002">タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2002">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2003"><xref:System.Windows.ContentElement.OnTouchMove%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2003">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-2004">オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchMove>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2004">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="78b56-2005">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnTouchMove%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2005">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-2006">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-2006">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="78b56-2007">この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントのクラス処理を提供します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2007">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2008"><xref:System.Windows.ContentElement.OnTouchUp%2A>メソッドには、既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2008">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="78b56-2009">オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchUp>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2009">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="78b56-2010">基底クラスの呼び出しを必ず<xref:System.Windows.ContentElement.OnTouchUp%2A>を基本クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2010">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="contentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="78b56-2011">要求したフォーカス検査の方向。</span><span class="sxs-lookup"><span data-stu-id="78b56-2011">The direction of the requested focus traversal.</span></span></param>
        <summary><span data-ttu-id="78b56-2012">派生クラスでオーバーライドされると、指定したフォーカス検査方向のフォーカスを受け取ることになる要素を返します。実際にはフォーカスはその要素に移動しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2012">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span></span></summary>
        <returns><span data-ttu-id="78b56-2013"><see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出された場合にフォーカスを受け取る要素。</span><span class="sxs-lookup"><span data-stu-id="78b56-2013">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2014">このクラスでこのメソッドの既定の実装は完了せず、常に返します`null`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2014">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2015">この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2015">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2016">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewDragEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2016">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2017">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragEnter>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2017">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2018">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2018">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2019">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2019">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="78b56-2020">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2020">Routing strategy</span></span>|<span data-ttu-id="78b56-2021">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2021">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2022">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2022">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-2023">対応するバブル イベントが<xref:System.Windows.ContentElement.DragEnter>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2023">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="78b56-2024">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2024">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2025"><see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2025">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2026">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2026">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2027">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2027">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2028">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2028">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2029">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2029">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2030">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2030">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2031">入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2031">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2032">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewDragLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2032">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2033">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragLeave>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2033">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2034">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2034">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2035">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2035">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="78b56-2036">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2036">Routing strategy</span></span>|<span data-ttu-id="78b56-2037">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2037">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2038">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2038">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-2039">対応するバブル イベントが<xref:System.Windows.ContentElement.DragLeave>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2039">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="78b56-2040">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2040">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2041"><see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2041">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2042">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2042">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2043">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2043">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2044">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2044">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2045">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2045">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2046">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2046">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2047">この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2047">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2048">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewDragOver>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2048">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2049">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragOver>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2049">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2050">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2050">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2051">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2051">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="78b56-2052">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2052">Routing strategy</span></span>|<span data-ttu-id="78b56-2053">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2053">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2054">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2054">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-2055">対応するバブル イベントが<xref:System.Windows.ContentElement.DragOver>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2055">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="78b56-2056">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2056">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2057"><see cref="E:System.Windows.ContentElement.PreviewDragOver" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2057">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2058">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2058">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2059">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2059">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2060">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2060">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2061">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2061">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2062">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2062">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2063">入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2063">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2064">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewDrop>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2064">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2065">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDrop>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2065">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2066">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2066">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2067">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2067">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="78b56-2068">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2068">Routing strategy</span></span>|<span data-ttu-id="78b56-2069">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2069">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2070">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2070">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="78b56-2071">対応するバブル イベントが<xref:System.Windows.ContentElement.Drop>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2071">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="78b56-2072">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDrop%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2072">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2073"><see cref="E:System.Windows.ContentElement.PreviewDrop" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2073">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2074">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2074">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2075">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2075">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2076">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2076">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2077">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2077">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2078">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2078">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2079">ドラッグ アンド ドロップ操作が開始されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2079">Occurs when a drag-and-drop operation is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2080"><xref:System.Windows.ContentElement.PreviewGiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するために、マウス ポインターの外観を変更するドラッグ イベントのソース。</span><span class="sxs-lookup"><span data-stu-id="78b56-2080">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="78b56-2081">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewGiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2081">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2082">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewGiveFeedback>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2082">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2083">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2083">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2084">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2084">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="78b56-2085">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2085">Routing strategy</span></span>|<span data-ttu-id="78b56-2086">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2086">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2087">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2087">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="78b56-2088">対応するバブル イベントが<xref:System.Windows.ContentElement.GiveFeedback>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2088">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="78b56-2089">オーバーライド<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2089">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2090"><see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2090">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2091">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2091">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2092">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2092">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2093">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2093">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2094">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2094">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2095">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2095">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2096">この要素にキーボード フォーカスが移動したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2096">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2097">このイベントは、ルーティングのトンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2097">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-2098">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-2098">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="78b56-2099">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2099">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2100">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2100">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2101">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2101">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2102">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2102">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="78b56-2103">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2103">Routing strategy</span></span>|<span data-ttu-id="78b56-2104">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2104">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2105">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2105">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="78b56-2106">対応するバブル イベントが<xref:System.Windows.ContentElement.GotKeyboardFocus>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2106">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="78b56-2107">オーバーライド<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2107">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2108"><see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2108">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2109">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2109">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2110">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2110">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2111">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2111">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2112">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2112">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2113">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2113">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2114">この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2114">Occurs when a key is pressed while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2115">キーの処理は、コマンドを実行し、テキストの合成などその他のプラットフォーム機能と対話します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2115">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="78b56-2116"><xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキストの入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2116">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="78b56-2117">これは、ため、一部のコントロールがあるコントロールの複合またはテキストの高度なバージョンを提供するクラスの処理の入力処理および関連するイベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2117">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="78b56-2118">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewKeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2118">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2119">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewKeyDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2119">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2120">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2120">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2121">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2121">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="78b56-2122">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2122">Routing strategy</span></span>|<span data-ttu-id="78b56-2123">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2123">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2124">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2124">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="78b56-2125">対応するバブル イベントが<xref:System.Windows.ContentElement.KeyDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2125">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2126">オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2126">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2127"><see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2127">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2128">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2128">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2129">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2129">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2130">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2130">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2131">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2131">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2132">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2132">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2133">この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2133">Occurs when a key is released while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2134">キーの処理は、コマンドを実行し、テキストの合成などその他のプラットフォーム機能と対話します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2134">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="78b56-2135"><xref:System.Windows.ContentElement.KeyUp>イベントは、下位レベルのテキストの入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2135">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="78b56-2136">これは、ため、一部のコントロールがあるコントロールの複合またはテキストの高度なバージョンを提供するクラスの処理の入力処理および関連するイベントです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2136">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="78b56-2137">詳細については、個々 のコントロールのドキュメントを確認します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2137">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="78b56-2138">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewKeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2138">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2139">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewKeyUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2139">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2140">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2140">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2141">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2141">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="78b56-2142">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2142">Routing strategy</span></span>|<span data-ttu-id="78b56-2143">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2143">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2144">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2144">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="78b56-2145">対応するバブル イベントが<xref:System.Windows.ContentElement.KeyUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2145">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2146">オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2146">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2147"><see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2147">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2148">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2148">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2149">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2149">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2150">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2150">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2151">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2151">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2152">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2152">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2153">この要素からキーボード フォーカスが離れたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2153">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2154">このイベントは、ルーティングのトンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際にアタッチされている場合、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2154">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="78b56-2155">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを失っている実際の要素を決定するためにイベント データ。</span><span class="sxs-lookup"><span data-stu-id="78b56-2155">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="78b56-2156">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2156">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2157">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2157">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2158">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2158">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2159">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2159">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="78b56-2160">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2160">Routing strategy</span></span>|<span data-ttu-id="78b56-2161">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2161">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2162">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2162">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="78b56-2163">対応するバブル イベントが<xref:System.Windows.ContentElement.LostKeyboardFocus>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2163">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="78b56-2164">オーバーライド<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2164">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2165"><see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2165">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2166">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2166">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2167">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2167">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2168">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2168">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2169">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2169">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2170">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2170">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2171">この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2171">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2172">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewMouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2172">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2173">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2173">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2174"><xref:System.Windows.ContentElement.PreviewMouseDown>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>に対応する 2 つの標準のマウス ボタンのいずれかのキーを押します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2174">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> <span data-ttu-id="78b56-2175"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2175">and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="78b56-2176">「解説」を参照してください。<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2176">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2177">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2177">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2178">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2178">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="78b56-2179">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2179">Routing strategy</span></span>|<span data-ttu-id="78b56-2180">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2180">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2181">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2181">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2182">対応するバブル イベントが<xref:System.Windows.ContentElement.MouseDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2182">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2183">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2183">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2184"><see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2184">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2185">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2185">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2186">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2186">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2187">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2187">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2188">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2188">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2189">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2189">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2190">この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2190">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2191">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリーを通じてトンネリングのルートに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2191">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-2192">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2192">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-2193">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2193">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-2194">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2194">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-2195">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2195">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-2196">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2196">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-2197">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2197">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2198">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2198">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2199">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2199">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="78b56-2200">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2200">Routing strategy</span></span>|<span data-ttu-id="78b56-2201">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2201">Direct</span></span>|  
|<span data-ttu-id="78b56-2202">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2202">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2203">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2203">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2204"><see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2204">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2205">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2205">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2206">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2206">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2207">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2207">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2208">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2208">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2209">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2209">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2210">この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2210">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2211">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリーを通じてトンネリングのルートに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2211">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-2212">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2212">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-2213">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2213">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-2214">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2214">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-2215">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2215">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-2216">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2216">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-2217">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2217">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2218">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2218">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2219">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2219">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="78b56-2220">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2220">Routing strategy</span></span>|<span data-ttu-id="78b56-2221">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2221">Direct</span></span>|  
|<span data-ttu-id="78b56-2222">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2222">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2223">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2223">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2224"><see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2224">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2225">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2225">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2226">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2226">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2227">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2227">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2228">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2228">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2229">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2229">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2230">この要素上でマウス ポインターが動かされたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2230">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2231">このイベントは、どちらも、要素の境界にマウス ポインターが最初にマウス ポインターが要素の境界内に残っているときに移動したときにもとします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2231">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="78b56-2232">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2232">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2233">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2233">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2234">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2234">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2235">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2235">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="78b56-2236">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2236">Routing strategy</span></span>|<span data-ttu-id="78b56-2237">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2237">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2238">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2238">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="78b56-2239">対応するバブル イベントが<xref:System.Windows.ContentElement.MouseMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2239">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2240">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2240">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2241"><see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2241">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2242">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2242">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2243">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2243">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2244">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2244">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2245">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2245">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2246">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2246">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2247">この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2247">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2248">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリーを通じてトンネリングのルートに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2248">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-2249">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2249">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-2250">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2250">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-2251">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2251">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-2252">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2252">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-2253">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2253">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-2254">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2254">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2255">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2255">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2256">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2256">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="78b56-2257">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2257">Routing strategy</span></span>|<span data-ttu-id="78b56-2258">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2258">Direct</span></span>|  
|<span data-ttu-id="78b56-2259">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2259">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2260">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2260">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2261"><see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2261">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2262">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2262">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2263">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2263">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2264">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2264">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2265">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2265">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2266">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2266">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2267">この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2267">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2268">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)要素ツリーを通じてトンネリングのルートに従うよう、直接ルーティング イベントが発生し、それぞれで、要素ツリーに沿って reraised を実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2268">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="78b56-2269">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントのいずれかの<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントをイベント ルート上の各要素によって処理されるは、そのイベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2269">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="78b56-2270">このイベントの引数は、基になる引数を公開<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="78b56-2270">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="78b56-2271">そのイベントがイベント ルート上で処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理するために、イベント リスナーをするためには、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2271">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="78b56-2272">概念的には、このイベントと考える (とその他のマウス ボタンのイベントの<xref:System.Windows.ContentElement>) マウス「サービス」にする (によって提供されるサービスの定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2272">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="78b56-2273">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左、右、上下) を確認する必要がないという利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2273">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="78b56-2274">非標準のボタンの状態のチェックより高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2274">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2275">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2275">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2276">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2276">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="78b56-2277">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2277">Routing strategy</span></span>|<span data-ttu-id="78b56-2278">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2278">Direct</span></span>|  
|<span data-ttu-id="78b56-2279">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2279">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2280">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2280">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2281"><see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2281">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2282">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2282">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2283">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2283">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2284">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2284">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2285">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2285">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2286">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2286">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2287">この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2287">Occurs when any mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2288">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewMouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2288">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2289">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2289">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2290"><xref:System.Windows.ContentElement.PreviewMouseUp>イベントは、多くの場合、いずれかと共に発生<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>に対応する 2 つの標準のマウス ボタンのいずれかのキーを押します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2290">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> <span data-ttu-id="78b56-2291"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベントがイベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2291">and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="78b56-2292">「解説」を参照してください。<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2292">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2293">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2293">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2294">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2294">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="78b56-2295">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2295">Routing strategy</span></span>|<span data-ttu-id="78b56-2296">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2296">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2297">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2297">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2298">対応するバブル イベントが<xref:System.Windows.ContentElement.MouseUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2298">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2299">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2299">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2300"><see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2300">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2301">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2301">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2302">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2302">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2303">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2303">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2304">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2304">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2305">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2305">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2306">この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2306">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2307">フォーカスおよびマウスのキャプチャ、マウス ポインターが; よりも優先します。フォーカスがあるか、キャプチャした要素からこのイベントを受信する場合、マウス ポインター可能性が実際にある別の要素上。</span><span class="sxs-lookup"><span data-stu-id="78b56-2307">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="78b56-2308">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2308">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2309">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2309">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2310">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2310">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2311">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2311">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="78b56-2312">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2312">Routing strategy</span></span>|<span data-ttu-id="78b56-2313">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2313">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2314">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2314">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="78b56-2315">対応するバブル イベントが<xref:System.Windows.ContentElement.MouseWheel>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2315">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="78b56-2316">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2316">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2317"><see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2317">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2318">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2318">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2319">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2319">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2320">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2320">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2321">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2321">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2322">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2322">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2323">ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2323">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2324"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを宣言します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2324">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="78b56-2325">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2325">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2326">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2326">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2327">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2327">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2328">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2328">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="78b56-2329">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2329">Routing strategy</span></span>|<span data-ttu-id="78b56-2330">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2330">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2331">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2331">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="78b56-2332">対応するバブル イベントが<xref:System.Windows.ContentElement.QueryContinueDrag>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2332">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="78b56-2333">オーバーライド<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2333">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2334"><see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2334">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2335">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2335">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2336">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2336">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2337">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2337">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2338">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2338">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2339">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2339">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2340">この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2340">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2341">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2341">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2342">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusButtonDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2342">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2343">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2343">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2344">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2344">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2345">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2345">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2346">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2346">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="78b56-2347">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2347">Routing strategy</span></span>|<span data-ttu-id="78b56-2348">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2348">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2349">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2349">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2350">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2350">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2351">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2351">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2352"><see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2352">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2353">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2353">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2354">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2354">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2355">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2355">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2356">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2356">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2357">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2357">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2358">この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2358">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2359">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2359">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2360">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusButtonUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2360">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2361">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2361">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2362">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2362">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2363">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2363">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2364">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2364">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="78b56-2365">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2365">Routing strategy</span></span>|<span data-ttu-id="78b56-2366">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2366">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2367">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2367">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2368">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2368">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2369">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2369">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2370"><see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2370">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2371">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2371">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2372">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2372">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2373">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2373">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2374">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2374">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2375">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2375">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2376">この要素上でスタイラスがデジタイザーに触れたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2376">Occurs when the stylus touches the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2377">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2377">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2378">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2378">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2379">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2379">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2380">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2380">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2381">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2381">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2382">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2382">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="78b56-2383">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2383">Routing strategy</span></span>|<span data-ttu-id="78b56-2384">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2384">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2385">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2385">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="78b56-2386">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2386">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2387">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2387">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2388"><see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2388">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2389">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2389">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2390">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2390">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2391">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2391">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2392">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2392">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2393">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2393">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2394">デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2394">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2395">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2395">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2396">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusInAirMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2396">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2397">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2397">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2398">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2398">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2399">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2399">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2400">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2400">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="78b56-2401">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2401">Routing strategy</span></span>|<span data-ttu-id="78b56-2402">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2402">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2403">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2403">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2404">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusInAirMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2404">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2405">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2405">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2406"><see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2406">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2407">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2407">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2408">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2408">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2409">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2409">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2410">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2410">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2411">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2411">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2412">この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2412">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2413">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2413">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2414">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusInRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2414">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2415">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2415">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2416">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2416">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2417">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2418">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2418">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="78b56-2419">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2419">Routing strategy</span></span>|<span data-ttu-id="78b56-2420">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2420">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2421">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2421">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2422">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusInRange>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2422">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="78b56-2423">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2423">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2424"><see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2424">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2425">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2425">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2426">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2426">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2427">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2427">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2428">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2428">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2429">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2429">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2430">スタイラスが要素上にあるときにスタイラスが移動すると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2430">Occurs when the stylus moves while over the element.</span></span> <span data-ttu-id="78b56-2431">このイベントを発生させるためには、デジタイザーによって検出されている間にスタイラスが移動する必要があります。それ以外の場合には、代わりに <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> が発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2431">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2432">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2432">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2433">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2433">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2434">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2434">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2435">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2435">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2436">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2437">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2437">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="78b56-2438">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2438">Routing strategy</span></span>|<span data-ttu-id="78b56-2439">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2439">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2440">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2440">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2441">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2441">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2442">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2442">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2443"><see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2443">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2444">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2445">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2446">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2447">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2448">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2449">スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2449">Occurs when the stylus is too far from the digitizer to be detected.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2450">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2450">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2451">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2451">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2452">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2452">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2453">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2453">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2454">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2454">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2455">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2455">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="78b56-2456">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2456">Routing strategy</span></span>|<span data-ttu-id="78b56-2457">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2457">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2458">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2458">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2459">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusOutOfRange>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2459">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="78b56-2460">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2460">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2461"><see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2461">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2462">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2462">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2463">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2463">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2464">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2464">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2465">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2465">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2466">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2466">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2467">ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2467">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2468">スタイラス ジェスチャについては、次を参照してください。<xref:System.Windows.Input.SystemGesture>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2468">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="78b56-2469">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2469">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2470">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2470">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2471">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2471">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2472">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2472">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2473">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2473">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2474">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2474">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="78b56-2475">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2475">Routing strategy</span></span>|<span data-ttu-id="78b56-2476">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2476">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2477">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2477">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="78b56-2478">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusSystemGesture>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2478">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="78b56-2479">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2479">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2480"><see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2480">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2481">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2481">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2482">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2482">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2483">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2483">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2484">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2484">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2485">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2485">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2486">ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2486">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2487">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2487">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2488">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2488">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2489">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2489">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2490">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2490">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2491">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2491">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2492">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2492">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="78b56-2493">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2493">Routing strategy</span></span>|<span data-ttu-id="78b56-2494">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2494">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2495">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2495">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2496">対応するバブル イベントが<xref:System.Windows.ContentElement.StylusUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2496">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2497">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2497">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2498"><see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2498">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2499">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2499">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2500">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2500">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2501">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2501">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2502">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2502">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2503">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2503">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2504">この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2504">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2505"><xref:System.Windows.ContentElement.PreviewTextInput>イベントでは、コンポーネントまたはデバイスに依存しない方法でテキスト入力をリッスンするアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="78b56-2505">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="78b56-2506">キーボードの主要な手段は、 <xref:System.Windows.ContentElement.PreviewTextInput>; が、音声認識、手書き入力、およびその他の入力デバイスも<xref:System.Windows.ContentElement.PreviewTextInput>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2506">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="78b56-2507">-既定のキーボードまたは入力方式エディター - 経由のいずれかのキーの組み合わせにより、複数のキー イベントは 1 つのテキストの入力イベントを発生可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2507">Because of key combinations - either in default keyboards or through input method editors - multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="78b56-2508">このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.PreviewTextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2508">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2509">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewTextInput>イベントは、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2509">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2510">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2510">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2511">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2511">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="78b56-2512">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2512">Routing strategy</span></span>|<span data-ttu-id="78b56-2513">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2513">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2514">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2514">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="78b56-2515">対応するバブル イベントが<xref:System.Windows.ContentElement.TextInput>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2515">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="78b56-2516">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2516">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2517"><see cref="E:System.Windows.ContentElement.PreviewTextInput" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2517">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2518">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2518">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2519">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2519">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2520">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2520">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2521">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2521">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2522">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2522">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2523">指がこの要素の上にある間に、その指で画面に触れると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2523">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2524">既定で、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>指が画面をタッチし、移動するまで、イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2524">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="78b56-2525">画面に指を押すと、により、キーを押して移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2525">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="78b56-2526">プレス アンド ホールド動作では、マウスの右クリックに相当します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2526">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="78b56-2527">発生する、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>、画面に触れると、すぐに発生するイベントの設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティを`false`この要素の。</span><span class="sxs-lookup"><span data-stu-id="78b56-2527">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2528">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2528">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2529">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2529">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="78b56-2530">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2530">Routing strategy</span></span>|<span data-ttu-id="78b56-2531">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2531">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2532">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2532">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2533">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2533">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2534">対応するバブル イベントが<xref:System.Windows.ContentElement.TouchDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2534">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2535">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2535">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2536"><see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2536">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2537">この要素の上に指があるときに、その指を画面上で動かすと発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2537">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2538">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2538">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2539">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2539">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="78b56-2540">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2540">Routing strategy</span></span>|<span data-ttu-id="78b56-2541">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2541">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2542">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2542">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2543">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2543">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2544">対応するバブル イベントが<xref:System.Windows.ContentElement.TouchMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2544">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2545">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2545">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2546"><see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2546">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2547">この要素の上に指があるときに、その指が画面から離れると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2547">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2548">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2548">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2549">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2549">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="78b56-2550">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2550">Routing strategy</span></span>|<span data-ttu-id="78b56-2551">トンネリング</span><span class="sxs-lookup"><span data-stu-id="78b56-2551">Tunneling</span></span>|  
|<span data-ttu-id="78b56-2552">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2552">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2553">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2553">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2554">対応するバブル イベントが<xref:System.Windows.ContentElement.TouchUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2554">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2555">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2555">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2556"><see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2556">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2557">ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2557">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2558"><xref:System.Windows.ContentElement.QueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2558">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="78b56-2559">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.QueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2559">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2560">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.QueryContinueDrag>イベントは、基になるに関連付けられている<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2560">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2561">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2561">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2562">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2562">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="78b56-2563">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2563">Routing strategy</span></span>|<span data-ttu-id="78b56-2564">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2564">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2565">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2565">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="78b56-2566">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2566">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="78b56-2567">オーバーライド<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2567">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2568"><see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2568">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2569">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2569">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2570">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2570">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2571">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2571">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2572">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2572">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2573">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2573">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2574">カーソルの表示が要求されると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2574">Occurs when the cursor is requested to display.</span></span> <span data-ttu-id="78b56-2575">このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2575">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2576">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.QueryCursor>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2576">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2577">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.QueryCursor>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2577">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2578">このイベントの名前で参照されているカーソルは、必ずしも (挿入ポイントとも呼ばれる) にテキスト カーソルではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2578">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="78b56-2579">代わりに、このコンテキストでのカーソルは、いくつかの可能な入力に関連するデバイスまたは Windows プログラミングの概念に関連する画面上のグラフィカル表示を宣言するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2579">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="78b56-2580">そのオブジェクトがによって表される、 <xref:System.Windows.Input.Cursor> wpf クラスです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2580">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="78b56-2581">WPF 入力システムでは、画面上にマウス ポインターの位置を表す場合は、このカーソルを変更することができます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2581">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="78b56-2582">定義済みの値を使用することができます、<xref:System.Windows.Input.Cursors>列挙型、または画像ファイルとしてカスタム カーソルを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2582">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="78b56-2583">リッスン、<xref:System.Windows.ContentElement.QueryCursor>イベントは、カーソルの管理のための効率的な手法ではありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2583">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="78b56-2584">各要素が、独自のカーソルの動作を定義する代わりに、<xref:System.Windows.FrameworkContentElement.Cursor%2A>と<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2584">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="78b56-2585">のみに依存しないでください<xref:System.Windows.ContentElement.QueryCursor>WPF フレームワーク レベルの基本要素を使用していないかで異常な場合に、カーソルの動作を定義する要素ごとの単位ではニーズに合わないかどうか。</span><span class="sxs-lookup"><span data-stu-id="78b56-2585">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="78b56-2586">応答でのカーソルの動作の実装の詳細については<xref:System.Windows.ContentElement.QueryCursor>を参照してください<xref:System.Windows.Input.QueryCursorEventHandler>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2586">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2587">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2587">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2588">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2588">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="78b56-2589">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2589">Routing strategy</span></span>|<span data-ttu-id="78b56-2590">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2590">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2591">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2591">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="78b56-2592">定義済みの対応するトンネル イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2592">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="78b56-2593">オーバーライド<xref:System.Windows.ContentElement.OnQueryCursor%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2593">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2594"><see cref="E:System.Windows.ContentElement.QueryCursor" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2594">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2595">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2595">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2596">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2596">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2597">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2597">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2598">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2598">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2599">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2599">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="78b56-2600">イベント データを格納し、発生するイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-2600">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span></span></param>
        <summary><span data-ttu-id="78b56-2601">特定のルーティング イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2601">Raises a specific routed event.</span></span> <span data-ttu-id="78b56-2602">発生する <see cref="T:System.Windows.RoutedEvent" /> は、提供された <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で識別されます (そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2602">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2603">`e`パラメーターは、一般的なルーティング イベントのすべてのデータの基本型として型指定ただし、イベント データは、ために発生するイベントに使用される最も固有のイベント データの種類として指定する必要があります<xref:System.Windows.RoutedEventArgs>派生クラスが含まれて、。特定のイベントが発生したときは、特定の実際のデータ プロパティ。</span><span class="sxs-lookup"><span data-stu-id="78b56-2603">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <xref:System.Windows.RoutedEventArgs> <span data-ttu-id="78b56-2604">イベントの状態のプロパティだけではありません。ルーティング イベントを発生させるも識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2604">is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="78b56-2605">このイベントの発生パターンと、ルーティング イベントのデータの両方とは異なる[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベントに関連するプロパティを通常だけが含まれるイベントやデータのクラス。</span><span class="sxs-lookup"><span data-stu-id="78b56-2605">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b56-2606">次の例では、イベント データを作成するには、イベント識別子をデータに追加およびイベント データのインスタンスを使用して、カスタム ルーティング イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2606">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="contentElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-2607">キャプチャされているすべてのタッチ デバイスをこの要素から解放します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2607">Releases all captured touch devices from this element.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="contentElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-2608">この要素がマウス キャプチャを保持していた場合、キャプチャを解放します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2608">Releases the mouse capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2609">この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2609">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="78b56-2610">値をチェック<xref:System.Windows.ContentElement.IsMouseCaptured%2A>このメソッドを呼び出す前にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2610">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="78b56-2611">次のハンドラーは、キャプチャまたはマウス ボタンの状態に応じてマウス キャプチャを解放します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2611">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="78b56-2612">例では、代替手段を目的マウス ポインターを移動するよりもその他のキャプチャされたマウスの動きを使用する方法を示しています、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2612">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="contentElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-2613">この要素がスタイラス デバイス キャプチャを保持していた場合、キャプチャを解放します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2613">Releases the stylus device capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2614">この要素がキャプチャを保持していない場合は、このメソッドを呼び出しても効果はありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2614">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="78b56-2615">値をチェック<xref:System.Windows.ContentElement.IsStylusCaptured%2A>このメソッドを呼び出す前にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2615">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="78b56-2616">解放の対象となるデバイス。</span><span class="sxs-lookup"><span data-stu-id="78b56-2616">The device to release.</span></span></param>
        <summary><span data-ttu-id="78b56-2617">指定されたタッチ デバイスをこの要素から解放することを試みます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2617">Attempts to release the specified touch device from this element.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-2618">タッチ デバイスが解放された場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-2618">if the touch device is released; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="touchDevice" /> <span data-ttu-id="78b56-2619">は <see langword="null" />です。</span><span class="sxs-lookup"><span data-stu-id="78b56-2619">is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="78b56-2620">ハンドラーがアタッチされているルーティング イベントの識別子。</span><span class="sxs-lookup"><span data-stu-id="78b56-2620">The identifier of the.routed event for which the handler is attached.</span></span></param>
        <param name="handler"><span data-ttu-id="78b56-2621">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</span><span class="sxs-lookup"><span data-stu-id="78b56-2621">The specific handler implementation to remove from the event handler collection on this element.</span></span></param>
        <summary><span data-ttu-id="78b56-2622">指定したルーティング イベント ハンドラーをこの要素から削除します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2622">Removes the specified routed event handler from this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2623">これを使用するための最も一般的なシナリオ[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]を実装する場合は、 [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] 「ラッパー」イベントに関連付けられたカスタム ルーティング イベントをハンドラーでの「削除」するロジックを実装するときに具体的には、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]レベル。</span><span class="sxs-lookup"><span data-stu-id="78b56-2623">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="78b56-2624">これに続く例では、「解説」のセクションでは、このシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="78b56-2624">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="78b56-2625">このメソッドを呼び出しても何も起こりませんメソッド呼び出しの入力パラメーターと一致する条件で登録されたハンドラーがない場合。</span><span class="sxs-lookup"><span data-stu-id="78b56-2625">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="78b56-2626">複数のイベント ハンドラー ストアが削除される最初のハンドラーにのみ、条件に一致する 1 つのハンドラーがアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2626">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="78b56-2627">この動作は整合[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]の動作、`-=`演算子。</span><span class="sxs-lookup"><span data-stu-id="78b56-2627">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="78b56-2628">どちらも`routedEvent`も`handler`あります`null`します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2628">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="78b56-2629">いずれかの値として提供しようとしています。`null`で例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2629">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="78b56-2630">このメソッドは無視、`handledEventsToo`場合は、ハンドラーが最初に提供されているパラメーターについては、追加、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>処理済みイベントの処理を有効に署名します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2630">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="78b56-2631">ハンドラーのいずれかの型が削除されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2631">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-2632">シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.ContentElement.CommandBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2632">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-2633"><see cref="P:System.Windows.ContentElement.CommandBindings" /> プロパティ値をシリアル化する必要がある場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-2633">if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2634">これにより返されます`true`場合<xref:System.Windows.ContentElement.CommandBindings%2A>がローカルに設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2634">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="78b56-2635">これは、`ShouldSerialize`メソッドが提供されますので、<xref:System.Windows.UIElement.CommandBindings%2A>プロパティには、単純な既定値はありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2635">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="78b56-2636">このメソッドは、プロパティが既定値から変更されたかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2636">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="78b56-2637">デザイナーを開発またはコントロールを組み込む独自に開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2637">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="78b56-2638">詳細については、次を参照してください。 [ShouldSerialize メソッドとリセット メソッドによる既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2638">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="78b56-2639">シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.ContentElement.InputBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2639">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span></span></summary>
        <returns><see langword="true" /> <span data-ttu-id="78b56-2640"><see cref="P:System.Windows.ContentElement.InputBindings" /> プロパティ値をシリアル化する必要がある場合は 。それ以外の場合は <see langword="false" />。</span><span class="sxs-lookup"><span data-stu-id="78b56-2640">if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2641">これにより返されます`true`場合<xref:System.Windows.ContentElement.InputBindings%2A>がローカルに設定します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2641">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="78b56-2642">これは、`ShouldSerialize`メソッドが提供されますので、<xref:System.Windows.UIElement.InputBindings%2A>プロパティには、単純な既定値はありません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2642">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="78b56-2643">このメソッドは、プロパティが既定値から変更されたかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2643">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="78b56-2644">デザイナーを開発またはコントロールを組み込む独自に開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2644">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="78b56-2645">詳細については、次を参照してください。 [ShouldSerialize メソッドとリセット メソッドによる既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2645">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2646">この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2646">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2647">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2647">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2648">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusButtonDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2648">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2649">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2649">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2650">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2650">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2651">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2651">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2652">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2652">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="78b56-2653">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2653">Routing strategy</span></span>|<span data-ttu-id="78b56-2654">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2654">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2655">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2655">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2656">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusButtonDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2656">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2657">オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2657">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2658"><see cref="E:System.Windows.ContentElement.StylusButtonDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2658">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2659">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2659">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2660">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2660">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2661">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2661">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2662">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2662">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2663">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2663">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2664">この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2664">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2665">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2665">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2666">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusButtonUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2666">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2667">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2667">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2668">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2668">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2669">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2669">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2670">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2670">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="78b56-2671">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2671">Routing strategy</span></span>|<span data-ttu-id="78b56-2672">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2672">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2673">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2673">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="78b56-2674">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusButtonUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2674">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2675">オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2675">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2676"><see cref="E:System.Windows.ContentElement.StylusButtonUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2676">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2677">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2677">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2678">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2678">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2679">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2679">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2680">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2680">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2681">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2681">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2682">この要素上でスタイラスがデジタイザーに触れたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2682">Occurs when the stylus touches the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2683">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2683">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2684">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusDown>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2684">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2685">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2685">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2686">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2686">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2687">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2688">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2688">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="78b56-2689">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2689">Routing strategy</span></span>|<span data-ttu-id="78b56-2690">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2690">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2691">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2691">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="78b56-2692">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2692">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2693">オーバーライド<xref:System.Windows.ContentElement.OnStylusDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2693">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2694"><see cref="E:System.Windows.ContentElement.StylusDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2694">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2695">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2696">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2697">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2698">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2699">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2700">スタイラスがこの要素の境界内に入ったときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2700">Occurs when the stylus enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.StylusEnter> <span data-ttu-id="78b56-2701">[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2701">is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="78b56-2702">ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。</span><span class="sxs-lookup"><span data-stu-id="78b56-2702">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="78b56-2703">ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2703">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="78b56-2704"><xref:System.Windows.ContentElement.StylusEnter>スタイラスがこのイベントの詳細、要素の境界内に入る時点を追跡しますが文字どおり報告された、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`false`に`true`この要素。</span><span class="sxs-lookup"><span data-stu-id="78b56-2704">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="78b56-2705">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2705">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2706">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusEnter>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2706">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2707">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2707">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2708">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2708">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2709">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2709">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2710">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2710">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="78b56-2711">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2711">Routing strategy</span></span>|<span data-ttu-id="78b56-2712">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2712">Direct</span></span>|  
|<span data-ttu-id="78b56-2713">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2713">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2714">オーバーライド<xref:System.Windows.ContentElement.OnStylusEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2714">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2715"><see cref="E:System.Windows.ContentElement.StylusEnter" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2715">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2716">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2716">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2717">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2717">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2718">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2718">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2719">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2719">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2720">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2720">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2721">デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2721">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2722">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2722">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2723">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusInAirMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2723">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2724">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2724">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2725">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2725">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2726">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2726">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2727">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2727">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="78b56-2728">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2728">Routing strategy</span></span>|<span data-ttu-id="78b56-2729">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2729">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2730">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2730">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2731">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusInAirMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2731">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2732">オーバーライド<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2732">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2733"><see cref="E:System.Windows.ContentElement.StylusInAirMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2733">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2734">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2734">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2735">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2735">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2736">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2736">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2737">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2737">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2738">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2738">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2739">この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2739">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2740">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2740">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2741">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusInRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2741">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2742">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2742">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2743">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2743">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2744">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2744">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2745">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2745">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="78b56-2746">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2746">Routing strategy</span></span>|<span data-ttu-id="78b56-2747">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2747">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2748">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2748">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2749">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusInRange>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2749">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="78b56-2750">オーバーライド<xref:System.Windows.ContentElement.OnStylusInRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2750">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2751"><see cref="E:System.Windows.ContentElement.StylusInRange" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2751">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2752">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2752">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2753">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2753">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2754">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2754">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2755">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2755">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2756">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2756">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2757">スタイラスが要素の境界内から出たときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2757">Occurs when the stylus leaves the bounds of the element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.ContentElement.StylusLeave> <span data-ttu-id="78b56-2758">[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2758">is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="78b56-2759">ルート; は直接ルーティング イベントは発生しません代わりが処理される同じ要素で発生した場所。</span><span class="sxs-lookup"><span data-stu-id="78b56-2759">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="78b56-2760">ただし、ルーティング イベントの動作、スタイルのイベント トリガーなどの他の側面は有効にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2760">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="78b56-2761"><xref:System.Windows.ContentElement.StylusLeave> 、スタイラスがこのイベントの要素の境界の詳細は時点を追跡しますが文字どおり報告された、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`true`に`false`この要素にします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2761">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="78b56-2762">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2762">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2763">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusLeave>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2763">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2764">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2764">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2765">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2765">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2766">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2766">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2767">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2767">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="78b56-2768">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2768">Routing strategy</span></span>|<span data-ttu-id="78b56-2769">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2769">Direct</span></span>|  
|<span data-ttu-id="78b56-2770">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2770">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2771">オーバーライド<xref:System.Windows.ContentElement.OnStylusLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2771">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2772"><see cref="E:System.Windows.ContentElement.StylusLeave" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2772">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2773">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2773">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2774">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2774">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2775">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2775">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2776">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2776">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2777">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2777">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2778">スタイラスがこの要素上を移動すると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2778">Occurs when the stylus moves over this element.</span></span> <span data-ttu-id="78b56-2779">このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2779">The stylus must move while on the digitizer to raise this event.</span></span> <span data-ttu-id="78b56-2780">それ以外の場合は、代わりに <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> が発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2780">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2781">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2781">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2782">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusMove>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2782">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2783">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2783">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2784">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2784">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2785">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2785">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2786">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2786">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="78b56-2787">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2787">Routing strategy</span></span>|<span data-ttu-id="78b56-2788">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2788">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2789">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2789">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2790">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2790">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2791">オーバーライド<xref:System.Windows.ContentElement.OnStylusMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2791">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2792"><see cref="E:System.Windows.ContentElement.StylusMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2792">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2793">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2793">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2794">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2794">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2795">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2795">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2796">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2796">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2797">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2797">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2798">この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2798">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2799">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2799">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2800">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusOutOfRange>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2800">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2801">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2801">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2802">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2802">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2803">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2803">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2804">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2804">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="78b56-2805">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2805">Routing strategy</span></span>|<span data-ttu-id="78b56-2806">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2806">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2807">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2807">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2808">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2808">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="78b56-2809">オーバーライド<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2809">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2810"><see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2810">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2811">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2811">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2812">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2812">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2813">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2813">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2814">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2814">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2815">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2815">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2816">ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2816">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2817">スタイラス ジェスチャの詳細については、次を参照してください。<xref:System.Windows.Input.SystemGesture>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2817">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="78b56-2818">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2818">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2819">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusSystemGesture>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2819">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2820">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2820">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2821">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2821">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2822">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2822">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2823">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2823">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="78b56-2824">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2824">Routing strategy</span></span>|<span data-ttu-id="78b56-2825">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2825">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2826">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2826">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="78b56-2827">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2827">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="78b56-2828">オーバーライド<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2828">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2829"><see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2829">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2830">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2830">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2831">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2831">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2832">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2832">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2833">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2833">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2834">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2834">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2835">ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2835">Occurs when the user raises the stylus off the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2836">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.StylusUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2836">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2837">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusUp>イベントは、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2837">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="78b56-2838">タッチ、マウス、およびスタイラス入力には、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2838">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="78b56-2839">詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2839">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2840">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2840">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2841">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2841">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="78b56-2842">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2842">Routing strategy</span></span>|<span data-ttu-id="78b56-2843">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2843">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2844">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2844">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="78b56-2845">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewStylusUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2845">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2846">オーバーライド<xref:System.Windows.ContentElement.OnStylusUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2846">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2847"><see cref="E:System.Windows.ContentElement.StylusUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2847">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2848">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2848">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2849">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2849">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2850">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2850">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2851">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2851">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2852">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2852">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2853">この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2853">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="78b56-2854">このイベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2854">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="78b56-2855">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2855">See Remark below.</span></span>  
  
 <span data-ttu-id="78b56-2856"><xref:System.Windows.ContentElement.TextInput>イベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2856">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="78b56-2857">たとえば、<xref:System.Windows.Controls.TextBox>複合コントロールは、場所、<xref:System.Windows.ContentElement.TextInput>イベントが処理済みとしては、合成内に既にマークされています。</span><span class="sxs-lookup"><span data-stu-id="78b56-2857">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="78b56-2858">コントロールでは、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があるため、このようにします。</span><span class="sxs-lookup"><span data-stu-id="78b56-2858">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="78b56-2859">使用する場合<xref:System.Windows.ContentElement.PreviewTextInput>、テキスト入力用のハンドラーをアタッチするイベントとしてより良い結果が表示される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2859">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="78b56-2860">この手法では、ほとんどの場合コントロール合成が処理済みとしてこのイベントが既にマークし、ハンドラーがイベント ルート上のイベントを受信するを防ぎますを回避できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2860">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="78b56-2861"><xref:System.Windows.ContentElement.TextInput>イベントでは、コンポーネントまたはデバイスに依存しない方法でテキスト入力をリッスンするアプリケーション。</span><span class="sxs-lookup"><span data-stu-id="78b56-2861">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="78b56-2862">キーボードの主要な手段は、 <xref:System.Windows.ContentElement.TextInput>、音声認識、手書き入力、およびその他の入力デバイスにもに上げることができますが、<xref:System.Windows.ContentElement.TextInput>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2862">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="78b56-2863">-既定のキーボードまたは入力方式エディター - 経由のいずれかのキーの組み合わせにより、複数のキー イベントは 1 つのテキスト入力イベントを発生可能性があります。</span><span class="sxs-lookup"><span data-stu-id="78b56-2863">Because of key combinations - either in default keyboards or through input method editors - multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="78b56-2864">このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントは、このクラスのように<xref:System.Windows.ContentElement.TextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>は基本要素として継承されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2864">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="78b56-2865">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.TextInput>イベントは、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2865">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2866">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2866">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2867">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2867">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="78b56-2868">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2868">Routing strategy</span></span>|<span data-ttu-id="78b56-2869">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2869">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2870">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2870">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="78b56-2871">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewTextInput>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2871">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="78b56-2872">オーバーライド<xref:System.Windows.ContentElement.OnTextInput%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2872">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2873"><see cref="E:System.Windows.ContentElement.TextInput" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2873">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2874">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2874">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="78b56-2875">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2875">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="78b56-2876">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="78b56-2876">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="78b56-2877">ルーティング イベントの登録方法の詳細については、「<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2877">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="78b56-2878">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、「<xref:System.Windows.EventManager.RegisterClassHandler%2A>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="78b56-2878">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2879">指がこの要素の上にある間に、その指で画面に触れると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2879">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2880">既定で、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>指が画面をタッチし、移動するまで、イベントは発生しません。</span><span class="sxs-lookup"><span data-stu-id="78b56-2880">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="78b56-2881">画面に指を押すと、により、キーを押して移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2881">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="78b56-2882">プレス アンド ホールド動作では、マウスの右クリックに相当します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2882">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="78b56-2883">発生する、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>、画面に触れると、すぐに発生するイベントの設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティを`false`この要素の。</span><span class="sxs-lookup"><span data-stu-id="78b56-2883">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2884">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2884">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2885">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2885">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="78b56-2886">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2886">Routing strategy</span></span>|<span data-ttu-id="78b56-2887">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2887">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2888">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2888">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2889">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2889">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2890">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewTouchDown>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="78b56-2891">オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2891">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2892"><see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2892">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2893">タッチがこの要素の境界の外部から内部に移動すると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2893">Occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="78b56-2894">常に、このイベントが発生しますが、タッチ デバイスがこの UI 要素にキャプチャされるかどうか。</span><span class="sxs-lookup"><span data-stu-id="78b56-2894">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2895">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2895">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2896">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2896">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="78b56-2897">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2897">Routing strategy</span></span>|<span data-ttu-id="78b56-2898">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2898">Direct</span></span>|  
|<span data-ttu-id="78b56-2899">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2899">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2900">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2900">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2901">オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2901">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2902"><see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2902">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2903">この要素にキャプチャされているすべてのタッチ デバイスを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2903">Gets all touch devices that are captured to this element.</span></span></summary>
        <value><span data-ttu-id="78b56-2904">この要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span><span class="sxs-lookup"><span data-stu-id="78b56-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2905">この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているすべてのタッチ デバイスを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2905">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="78b56-2906">この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span><span class="sxs-lookup"><span data-stu-id="78b56-2906">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2907">この要素上にあるすべてのタッチ デバイスを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2907">Gets all touch devices that are over this element.</span></span></summary>
        <value><span data-ttu-id="78b56-2908">この要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span><span class="sxs-lookup"><span data-stu-id="78b56-2908">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2909">この要素またはそのビジュアル ツリー内のいずれかの子要素上にあるすべてのタッチ デバイスを取得します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2909">Gets all touch devices that are over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="78b56-2910">この要素またはそのビジュアル ツリー内のいずれかの子要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span><span class="sxs-lookup"><span data-stu-id="78b56-2910">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2911">タッチがこの要素の境界の内部から外部に移動すると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2911">Occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2912">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2912">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2913">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2913">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="78b56-2914">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2914">Routing strategy</span></span>|<span data-ttu-id="78b56-2915">直接</span><span class="sxs-lookup"><span data-stu-id="78b56-2915">Direct</span></span>|  
|<span data-ttu-id="78b56-2916">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2916">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2917">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2917">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2918">オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2918">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2919"><see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2919">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2920">この要素の上に指があるときに、その指を画面上で動かすと発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2920">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2921">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2921">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2922">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2922">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="78b56-2923">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2923">Routing strategy</span></span>|<span data-ttu-id="78b56-2924">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2924">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2925">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2925">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2926">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2926">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2927">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewTouchMove>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2927">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="78b56-2928">オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2928">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2929"><see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2929">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2930">この要素の上に指があるときに、その指が画面から離れると発生します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2930">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="78b56-2931">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="78b56-2931">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="78b56-2932">識別子フィールドです。</span><span class="sxs-lookup"><span data-stu-id="78b56-2932">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="78b56-2933">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="78b56-2933">Routing strategy</span></span>|<span data-ttu-id="78b56-2934">バブル</span><span class="sxs-lookup"><span data-stu-id="78b56-2934">Bubbling</span></span>|  
|<span data-ttu-id="78b56-2935">Delegate</span><span class="sxs-lookup"><span data-stu-id="78b56-2935">Delegate</span></span>|<xref:System.EventHandler%601> <span data-ttu-id="78b56-2936">(<xref:System.Windows.Input.TouchEventArgs> 型)。</span><span class="sxs-lookup"><span data-stu-id="78b56-2936">of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="78b56-2937">対応するトンネル イベントは<xref:System.Windows.ContentElement.PreviewTouchUp>します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2937">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="78b56-2938">オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2938">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="78b56-2939"><see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントを識別します。</span><span class="sxs-lookup"><span data-stu-id="78b56-2939">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
