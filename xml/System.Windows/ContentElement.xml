<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3ead77d5c5a1444bb78a389f6dd17f78c4fdbd08" />
    <Meta Name="ms.sourcegitcommit" Value="4b4804968da1dfdf71c501075a5b66957b54f2e8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="04/27/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="c3caa-101">コンテンツ要素に WPF コア レベルの基底クラスを提供します。</span>
      <span class="sxs-lookup">
        <span data-stu-id="c3caa-101">Provides a WPF core-level base class for content elements.</span>
      </span>
      <span data-ttu-id="c3caa-102">コンテンツ要素は、直感的なマークアップ指向レイアウト モデルと、意図的に単純なオブジェクト モデルを使用し、フロー スタイル プレゼンテーション用に設計されています。</span>
      <span class="sxs-lookup">
        <span data-stu-id="c3caa-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-103"><xref:System.Windows.ContentElement> 次の一般的なコンテンツの特性を定義します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="c3caa-104">入力: すべて<xref:System.Windows.ContentElement>派生クラスは、キーボード、マウスをドラッグ アンド ドロップの操作、スタイラス コントロール、およびアクセラレータから基本的な入力のキャプチャのサポートを提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="c3caa-105">フォーカス: すべて<xref:System.Windows.ContentElement>派生クラスでは、フォーカスを設定できる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="c3caa-106">(ただしの既定のフォーカス可能な状態、<xref:System.Windows.ContentElement>基底クラスが`false`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="c3caa-107">作成する方法の詳細について、<xref:System.Windows.ContentElement>フォーカスを設定するを参照してください<xref:System.Windows.ContentElement.Focusable%2A>)。さらに、このクラスが含まれています[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]関連要素の間でフォーカスを移動するを使用することできます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="c3caa-108">イベント:<xref:System.Windows.ContentElement>イベントも含まれる入力とフォーカスに関連する以外の状態の変更のイベントも含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="c3caa-109">多くの場合、<xref:System.Windows.ContentElement>イベントは、ルーティングされたイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="c3caa-110">場合によっては、ルーティングされたイベントはトンネリングとバブルの両方のルーティング方法、同じ状態または条件への応答で別々 のイベントとして発生があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="c3caa-111">また、<xref:System.Windows.ContentElement>定義[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]できます raise ルーティングされるイベントを追加したり、イベント ハンドラーを削除します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="c3caa-112"><xref:System.Windows.ContentElement> 多くの共通の共有[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]で<xref:System.Windows.UIElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="c3caa-113">これらの一般的な[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]共有クラスの継承を付属していません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="c3caa-114">しかし一般的な名前付け、同様の動作と同様の内部実装の[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]クラスごとにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="c3caa-115">類似性があるため<xref:System.Windows.ContentElement>と<xref:System.Windows.UIElement>基本、要素である各クラスは、そのマークアップ オブジェクト モデルの動作にさまざまな意図を持つ各がします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="c3caa-116">具体的には、<xref:System.Windows.UIElement>から下降<xref:System.Windows.Media.Visual>、下位のグラフィックのレンダリングのサポートを提供する、<xref:System.Windows.ContentElement>合成のウィンドウ内の四角形の領域に一方<xref:System.Windows.ContentElement>フロー、折り返しが設定など、ドキュメントのシナリオに一般的な概念がより簡単にサポートされているように、レンダリングを延期します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="c3caa-117">これらの 2 つの関連クラスに共通のインターフェイスも実装<xref:System.Windows.IInputElement>と<xref:System.Windows.Media.Animation.IAnimatable>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="c3caa-118">
          <see cref="T:System.Windows.ContentElement" />クラスがまだフロー スタイル プレゼンテーションの完全なコンテンツ要素のすべての側面を定義します。</span>
        <span class="sxs-lookup">
          <span data-stu-id="c3caa-118">The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation.</span>
        </span>
        <span data-ttu-id="c3caa-119">
          <see cref="T:System.Windows.FrameworkContentElement" /> 直後に派生クラスである<see cref="T:System.Windows.ContentElement" />です。</span>
        <span class="sxs-lookup">
          <span data-stu-id="c3caa-119">
            <see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />.</span>
        </span>
        <span data-ttu-id="c3caa-120">
          <see cref="T:System.Windows.FrameworkContentElement" /> レンダリングをサポートするその他のメンバーのより完全なセットが含まれています、<see cref="T:System.Windows.FrameworkContentElement" />コンテンツ ホストと WPF フレームワーク レベルのレイアウト システムを使用します。</span>
        <span class="sxs-lookup">
          <span data-stu-id="c3caa-120">
            <see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-121">
            <see cref="T:System.Windows.ContentElement" /> クラスの新しいインスタンスを初期化します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-121">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-122">指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-122">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="c3caa-123">処理されるルーティング イベントの識別子。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-123">An identifier for the routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="c3caa-124">ハンドラーの実装に対する参照。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-124">A reference to the handler implementation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-125">指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-125">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-126">例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-126">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="c3caa-127">ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-127">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="c3caa-128">そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-128">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="c3caa-129">通常、"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。</span><span class="sxs-lookup"><span data-stu-id="c3caa-129">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="c3caa-130">ハンドルするルーティング イベントの識別子。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-130">An identifier for the.routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="c3caa-131">ハンドラーの実装に対する参照。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-131">A reference to the handler implementation.</span>
          </span>
        </param>
        <param name="handledEventsToo">
          <span data-ttu-id="c3caa-132">イベント データ内でルーティング イベントがハンドル済みとしてマークされている場合でも呼び出されるようにハンドラーを登録するには <see langword="true" />。ルーティング イベントが既にハンドル済みとしてマークされている場合はハンドラーを呼び出ないという既定の条件を使用してハンドラーを登録する場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-132">
              <see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span>
          </span>
          <span data-ttu-id="c3caa-133">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-133">The default is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-134">ルーティング イベントの再処理を機械的に要求しないでください。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-134">Do not routinely ask to rehandle a routed event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-135">指定したルーティング イベントのルーティング イベント ハンドラーを追加します。このハンドラーは、現在の要素のハンドラー コレクションに追加されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-135">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
          <span data-ttu-id="c3caa-136">イベント ルート上の他の要素により既に処理済みとしてマークされているルーティング イベントに対し、指定したハンドラーが呼び出されるようにするには、<paramref name="handledEventsToo" /> を <see langword="true" /> に指定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-136">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-137">複雑なタスクは、実用的な方法で低レベルの入力イベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-137">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="c3caa-138">多くのコントロールと、特定のイベントが処理される、マークされた、別のより直観的なイベントに置き換えの動作を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-138">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="c3caa-139">一般に、これを行うための設計上の意図がある場合を処理済みとして、コントロールは、プラットフォームの入力イベントをマークだけです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-139">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="c3caa-140">特定のシナリオでこれらの設計上の意図できない可能性があります、特定の入力イベントの処理が必要です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-140">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="c3caa-141">これらのシナリオを登録するハンドラーの`handledEventsToo`として`true`が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-141">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="c3caa-142">実行しないでこの日常的にします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-142">But you should not do this routinely.</span></span> <span data-ttu-id="c3caa-143">処理される場合でも、すべてのイベントに応答ハンドラーを呼び出すと、独自のアプリケーション イベントを処理ロジックが複雑になります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-143">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="c3caa-144">ハンドラーのロジックは大きな場合は、パフォーマンスの低下を参照してください可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-144">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="c3caa-145">ここで、検出済みの特定のコントロールは、アプリケーション ロジックで処理するイベントを処理は、開発プロセス中にある場合の処理済みのイベントのハンドラーをアタッチの使用を予約する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-145">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="c3caa-146">クラスの処理を特定のイベントとコントロールの組み合わせの動作を回避するためのもう 1 つの方法では、そのイベントのプレビューの代替手段を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-146">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="c3caa-147">たとえば場合、<xref:System.Windows.ContentElement.MouseLeftButtonDown>処理済みとしてマークは、クラス処理によってことができますのハンドラーを追加する<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-147">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="c3caa-148">例外を発生させず、同じイベントのハンドラーは、同じ複数回を追加することができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-148">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="c3caa-149">ただし、ハンドラーには、イベントを処理するときに複数回が実際に呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-149">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="c3caa-150">そのため、この動作では次の方法で、ハンドラーの実装で考慮するべき副作用がある可能性がありますを検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-150">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="c3caa-151">通常、"add"アクセサーの実装を提供するこのメソッドを使用する、[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]カスタム ルーティング イベントのイベントのアクセス パターン。</span><span class="sxs-lookup"><span data-stu-id="c3caa-151">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-152">次の例で呼び出されるハンドラーを実装する、<xref:System.Windows.FrameworkElement.Initialized>イベントを使用して、ページ上の名前付きの要素のいずれかに定義されているハンドラーをアタッチするページに`handledEventsToo``true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-152">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="c3caa-153">このハンドラー経路上の別の要素が共有イベント データ、ルート上で処理中の要素に到達する前に処理済みとしてマークされている場合でも呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-153">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">
          <span data-ttu-id="c3caa-154">ハンドラーの追加先のイベント ルート。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-154">The event route that handlers are added to.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="c3caa-155">ハンドラーを追加するために使用されるイベント データ。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-155">The event data that is used to add the handlers.</span>
          </span>
          <span data-ttu-id="c3caa-156">このメソッドは、引数の <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティを使用してハンドラーを作成します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-156">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-157">現在の <see cref="T:System.Windows.EventRoute" /> イベント ハンドラー コレクションのハンドラーを、指定した <see cref="T:System.Windows.ContentElement" /> に追加します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-157">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-158">コンテンツ ホスト要素に対してこのメソッドを使用 (実装しているかどうかに関係なく<xref:System.Windows.IContentHost>) をホストに、コンテンツ ホストの子要素のハンドラーを追加するために<xref:System.Windows.EventRoute>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-158">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-159">この要素をドラッグ アンド ドロップ操作の対象として使用できるかどうかを示す値を取得または設定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-159">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-160">この要素をドラッグアンドドロップ操作の対象として使用できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-160">
              <see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-161">既定値は <see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-161">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-162">ドラッグ アンド ドロップ操作が既定では、有効になっていないと設定して意図的に有効にする必要があります<xref:System.Windows.ContentElement.AllowDrop%2A>に`true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-162">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="c3caa-163">この基本的な設定を超えるドラッグ アンド ドロップの動作は完全に特定の実装とで定義されていない<xref:System.Windows.ContentElement>またはその他の要素の基本クラスです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-163">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="c3caa-164">たとえば、特定のコントロール<xref:System.Windows.Controls.RichTextBox>は、既定の動作はありませんが<xref:System.Windows.ContentElement>派生クラスがあるこのような動作です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-164">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="c3caa-165">ドラッグ アンド ドロップの詳細については、次を参照してください。[ドラッグ アンド ドロップの概要](~/docs/framework/wpf/advanced/drag-and-drop-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-165">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="c3caa-166"><xref:System.Windows.FrameworkContentElement> 実装では、この依存関係プロパティのメタデータをオーバーライドします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-166"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="c3caa-167">具体的には、<xref:System.Windows.FrameworkContentElement>このプロパティがプロパティ値の継承を使用することを指定 (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>は`true`メタデータで)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-167">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="c3caa-168">このコンテキストでプロパティ値の継承ことを意味のない他の値を含む子要素がある場合<xref:System.Windows.ContentElement.AllowDrop%2A>プロパティ システムによってすべての未使用の子要素をその親要素から値が割り当てられているし、ローカルの値またはスタイル、この値は割り当てられます (ここでものいずれか既定値、またはローカルの値、スタイル)、最も近い親要素の値を使用して割り当てます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-168">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="c3caa-169">つまり、ルート要素でドロップ操作を許可して、すべてに値を反映するかどうかを指定できる<xref:System.Windows.FrameworkContentElement>が具体的には割り当てられていない値の子要素`false`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-169">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-170">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-170">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-171">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-171">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="c3caa-172">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-172">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-173">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-173">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-174">次の例のセット<xref:System.Windows.ContentElement.AllowDrop%2A>で[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-174">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-175">
            <see cref="P:System.Windows.ContentElement.AllowDrop" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-175">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-176">この要素の指定した依存関係プロパティにアニメーションを適用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-176">Applies an animation to a specified dependency property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="c3caa-177">アニメーション化するプロパティの識別子。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-177">The identifier for the property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="c3caa-178">アニメーションをコントロールして宣言するアニメーション クロック。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-178">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-179">この要素の指定した依存関係プロパティにアニメーションを適用します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-179">Applies an animation to a specified dependency property on this element.</span>
          </span>
          <span data-ttu-id="c3caa-180">既存のアニメーションは停止され、新しいアニメーションに置き換えられます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-180">Any existing animations are stopped and replaced with the new animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-181">アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-181">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="c3caa-182">これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-182">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="c3caa-183">ただし、最初に関連付けられているアニメーション クロックは停止されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-183">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="c3caa-184">その他のクロックに割り当てられているアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-184">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="c3caa-185">アニメーション化するプロパティ。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-185">The property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="c3caa-186">アニメーションをコントロールして宣言するアニメーション クロック。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-186">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="c3caa-187">列挙体の値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-187">A value of the enumeration.</span>
          </span>
          <span data-ttu-id="c3caa-188">既定値は <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> で、既存のアニメーションをすべて停止して、新しいアニメーションで置き換えます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-188">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-189">この要素の指定した依存関係プロパティにアニメーションを適用し、プロパティでアニメーションが既に適用されているときに行われる処理を指定する機能も提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-189">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-190">アニメーションのプロパティからを削除するには、そのプロパティの識別子を指定`dp`指定と`clock`として`null`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-190">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="c3caa-191">これは、アニメーションを切り取ってアニメーションのプロパティがその基本値に設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-191">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="c3caa-192">ただし、最初に関連付けられているアニメーション クロックは停止されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-192">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="c3caa-193">その他のクロックに割り当てられているアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-193">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-194">少なくとも 1 つのタッチがこの要素にキャプチャされているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-194">Gets a value that indicates whether at least one touch is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-195">少なくとも 1 つのタッチがこの要素にキャプチャされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-195">
              <see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-196">
            <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-196">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-197">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-197">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-198">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-198">
              <see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-199">
            <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-199">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-200">少なくとも 1 つのタッチがこの要素上で押されているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-200">Gets a value that indicates whether at least one touch is pressed over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-201">少なくとも 1 つのタッチがこの要素上で押されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-201">
              <see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-202">
            <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-202">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-203">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-203">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-204">少なくとも 1 つのタッチがこの要素またはそのビジュアル ツリー内のいずれかの子要素上で押されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-204">
              <see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-205">
            <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-205">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-206">この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-206">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="c3caa-207">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-207">The property to animate, which is specified as a dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="c3caa-208">開始するアニメーションのタイムライン。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-208">The timeline of the animation to start.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-209">この要素のアニメーション化対象のプロパティを指定して、アニメーションを開始します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-209">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-210">プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-210">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="c3caa-211">場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-211">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="c3caa-212">場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-212">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="c3caa-213">ただし、最初に関連付けられているアニメーション タイムラインは停止されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-213">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="c3caa-214">タイムラインに割り当てられているその他のアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-214">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="c3caa-215">依存関係プロパティの識別子として指定された、アニメーション化するプロパティ。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-215">The property to animate, which is specified as the dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="c3caa-216">適用されるアニメーションのタイムライン。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-216">The timeline of the animation to be applied.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="c3caa-217">プロパティ値に既に影響している現在の (実行中の) アニメーションと新しいアニメーションが対話する方法を指定する列挙値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-217">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-218">この要素のアニメーション化対象のプロパティを指定して、特定のアニメーションを開始します。プロパティの既存のアニメーションが実行中である場合の動作も指定できます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-218">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-219">プロパティをアニメーション化するかどうかをチェックするとしているアニメーションが開始されますと見なされるアニメーションをアニメーション化されていないの開始位置を超える最初のフレームがレンダリングされます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-219">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="c3caa-220">場合、<xref:System.Windows.Media.Animation.Timeline.BeginTime%2A>の`animation`は`null`してから、現在のアニメーションは削除し、プロパティの現在の値が保持されています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-220">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="c3caa-221">場合全体`animation`値は`null`、すべてのアニメーションがプロパティから削除され、プロパティ値がその基本値に戻ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-221">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="c3caa-222">ただし、最初に関連付けられているアニメーション タイムラインは停止されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-222">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="c3caa-223">タイムラインに割り当てられているその他のアニメーションを実行し続けます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-223">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-224">この要素にマウスをキャプチャするように強制することを試みます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-224">Attempts to force capture of the mouse to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-225">マウスが正常にキャプチャされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-225">
              <see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-226">キャプチャするのには、要素を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-226">To be captured, an element must be enabled.</span></span> <span data-ttu-id="c3caa-227">確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`を呼び出す前に<xref:System.Windows.ContentElement.CaptureMouse%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-227">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="c3caa-228">呼び出す場合<xref:System.Windows.ContentElement.CaptureMouse%2A>返します`true`、し<xref:System.Windows.ContentElement.IsMouseCaptured%2A>も`true`します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-228">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="c3caa-229">呼び出す場合<xref:System.Windows.ContentElement.CaptureMouse%2A>を返します`true`、<xref:System.Windows.ContentElement.GotMouseCapture>と<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントが発生すると<xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType>要素としてデータを報告するイベントの場所、<xref:System.Windows.ContentElement.CaptureMouse%2A>メソッドが呼び出されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="c3caa-230">既存のキャプチャと干渉する可能性のキャプチャを強制した場合、特にのマウスでドラッグ アンド ドロップに関連するキャプチャします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-230">If you force capture, you might interfere with existing captures—especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="c3caa-231">すべての要素からマウスのキャプチャをクリアする呼び出し<xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType>で、`element`として指定されたパラメーター`null`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-231">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-232">次の例では、マウスをキャプチャまたは、マウスが要素によって既にキャプチャされているかどうかに基づいて、キャプチャを解放します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-232">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="c3caa-233">見込みのキャプチャ対象の要素がこの例ではキャストことに注意してください、<xref:System.Windows.IInputElement>インターフェイス、および最初に呼び出したはこのため、<xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-233">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c3caa-234">キャストする<xref:System.Windows.IInputElement>手法がないことを確認するかどうか、要素をキャプチャする、マウス場合に便利ですが、<xref:System.Windows.UIElement>または<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-234">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="c3caa-235">インターフェイスにキャストして、インターフェイス メソッド実装を呼び出すし、呼び出し、適切な型固有ことで内部的には、試用版のいずれかにキャストせず<xref:System.Windows.UIElement>または<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-235">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="c3caa-236">これと同じキャスト方法が他のメンバーの動作を<xref:System.Windows.IInputElement>のインスタンスを多数定義、入力に関連するイベント、およびその他の入力に関連するメソッド。</span><span class="sxs-lookup"><span data-stu-id="c3caa-236">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-237">この要素にスタイラスをキャプチャするように強制することを試みます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-237">Attempts to force capture of the stylus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-238">スタイラスが正常にキャプチャされた場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-238">
              <see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-239">既定の実装を常に基になる既定のスタイラス デバイスに基づいて`true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-239">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="c3caa-240">ただし、入力のシステムのデバイスの実装を提供する入力デバイスを拡張する場合は、異なる結果を返す可能性のある代替のスタイラス デバイスの実装と、システムを作成することです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-240">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="c3caa-241">要素がスタイラスをキャプチャ、ときに、スタイラスが境界外にある場合でも、スタイラス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-241">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="c3caa-242">スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-242">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="c3caa-243">このメソッドを呼び出す、基になる静的<xref:System.Windows.Input.Stylus>メソッド<xref:System.Windows.Input.Stylus.Capture%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-243">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="c3caa-244">実際のキャプチャの動作は、アクティブなスタイラス デバイスの実装によって実装されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-244">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="c3caa-245">キャプチャするのには、要素を有効にする必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-245">To be captured, an element must be enabled.</span></span> <span data-ttu-id="c3caa-246">確認するかどうか<xref:System.Windows.ContentElement.IsEnabled%2A>は`true`を呼び出す前に返す<xref:System.Windows.ContentElement.CaptureStylus%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-246">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="c3caa-247">呼び出す場合<xref:System.Windows.ContentElement.CaptureStylus%2A>返します`true`、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>も`true`します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-247">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="c3caa-248">キャプチャの対象となるデバイス。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-248">The device to capture.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-249">この要素にタッチをキャプチャするように強制することを試みます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-249">Attempts to force capture of a touch to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-250">指定したタッチがこの要素にキャプチャされる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-250">
              <see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> 返されます`false`場合、<xref:System.Windows.Input.TouchDevice>別の要素に現在キャプチャされています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="c3caa-252">場合<xref:System.Windows.ContentElement.CaptureTouch%2A>返します`true`、<xref:System.Windows.ContentElement.GotTouchCapture>イベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-252">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="c3caa-253">解放するにはこの要素から 1 つのタッチのキャプチャを使用して、<xref:System.Windows.ContentElement.ReleaseTouchCapture%2A>メソッドを解放する、タッチ デバイスを指定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-253">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="c3caa-254">解放するにはこの要素からすべての調整を使用して、<xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A>メソッドです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-254">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c3caa-255">
            <paramref name="touchDevice" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-255">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-256">この要素に関連付けられている <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクションを取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-256">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-257">すべての <see cref="T:System.Windows.Input.CommandBinding" /> オブジェクトのコレクション。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-257">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-258">A<xref:System.Windows.Input.CommandBinding>この要素の特定のコマンドのコマンドの処理を有効にし、コマンド、そのイベントでは、この要素にアタッチされているハンドラー間のリンケージが宣言されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-258">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="c3caa-259">別の一般的な方法を設定する、<xref:System.Windows.ContentElement.CommandBindings%2A>コレクションは、使用する<xref:System.Windows.Input.CommandManager>メソッド プログラムでします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-259">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="c3caa-260">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="c3caa-260">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="c3caa-261">XAML 値</span><span class="sxs-lookup"><span data-stu-id="c3caa-261">XAML Values</span></span>  
 <span data-ttu-id="c3caa-262">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="c3caa-262">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="c3caa-263">1 つまたは複数<xref:System.Windows.Input.CommandBinding>要素。</span><span class="sxs-lookup"><span data-stu-id="c3caa-263">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="c3caa-264">これらの各が必要、<xref:System.Windows.Input.CommandBinding.Command%2A>既知のコマンドに属性が設定され、に対して属性が設定、<xref:System.Windows.Input.CommandBinding.CanExecute>と<xref:System.Windows.Input.CommandBinding.Executed>ハンドラーの実装です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-264">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="c3caa-265">詳細については、「<xref:System.Windows.Input.CommandBinding>」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-265">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-266">この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-266">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-267">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-267">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-268">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragEnter>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-268">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-269">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-270">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-270">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="c3caa-271">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-271">Routing strategy</span></span>|<span data-ttu-id="c3caa-272">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-272">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-273">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-273">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-274">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewDragEnter>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-274">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="c3caa-275">オーバーライド<xref:System.Windows.ContentElement.OnDragEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-275">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-276">
            <see cref="E:System.Windows.ContentElement.DragEnter" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-276">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-277">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-278">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-279">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-280">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-281">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-282">入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-282">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-283">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-283">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-284">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragLeave>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-284">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-285">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-285">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-286">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-286">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="c3caa-287">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-287">Routing strategy</span></span>|<span data-ttu-id="c3caa-288">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-288">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-289">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-289">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-290">対応するトンネリング イベントが<xref:System.Windows.DragDrop.PreviewDragLeave>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-290">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="c3caa-291">オーバーライド<xref:System.Windows.ContentElement.OnDragLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-291">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-292">
            <see cref="E:System.Windows.ContentElement.DragLeave" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-292">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-293">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-293">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-294">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-294">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-295">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-295">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-296">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-296">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-297">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-297">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-298">この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-298">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-299">このイベントは、要素の境界のドラッグを開始した場合でも発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-299">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="c3caa-300">ドラッグ アンドが境界の外側を開始し、このイベントを発生すると、内側、移動だけでなく<xref:System.Windows.ContentElement.DragEnter>とプレビュー イベントを関連します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-300">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="c3caa-301">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-301">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-302">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.DragOver>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-302">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-303">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-303">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-304">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-304">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="c3caa-305">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-305">Routing strategy</span></span>|<span data-ttu-id="c3caa-306">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-306">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-307">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-307">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-308">対応するトンネリング イベントが<xref:System.Windows.DragDrop.PreviewDragOver>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-308">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="c3caa-309">オーバーライド<xref:System.Windows.ContentElement.OnDragOver%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-309">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-310">
            <see cref="E:System.Windows.ContentElement.DragOver" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-310">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-311">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-311">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-312">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-312">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-313">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-313">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-314">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-314">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-315">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-315">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-316">入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-316">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-317">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-317">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-318">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.Drop>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-318">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-319">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-319">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-320">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-320">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="c3caa-321">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-321">Routing strategy</span></span>|<span data-ttu-id="c3caa-322">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-322">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-323">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-323">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-324">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewDrop>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-324">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="c3caa-325">オーバーライド<xref:System.Windows.ContentElement.OnDrop%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-325">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-326">
            <see cref="E:System.Windows.ContentElement.Drop" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-326">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-327">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-327">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-328">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-328">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-329">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-329">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-330">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-330">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-331">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-331">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-332">この要素にフォーカスを設定することを試みます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-332">Attempts to set focus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-333">キーボード フォーカスをこの要素に設定できなかった場合は <see langword="true" />。このメソッド呼び出しがフォーカスを強制しなかった場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-333">
              <see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-334">フォーカスを<xref:System.Windows.ContentElement.Focusable%2A>と<xref:System.Windows.ContentElement.IsEnabled%2A>両方`true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-334">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="c3caa-335">なおほぼすべて<xref:System.Windows.ContentElement>派生クラスは、<xref:System.Windows.ContentElement.Focusable%2A>既定です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-335">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="c3caa-336">場合でも、要素は、特定のツリー内でフォーカスを設定し、有効なイベント処理が、フォーカスがある、許可しないことによって、プレビューのフォーカス イベントに応答 (複合コントロールなど) ためこのメソッドは`false`します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-336">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="c3caa-337">一般にフォーカスが 2 つの異なる概念によって拘束されます: キーボード フォーカスと論理フォーカスが常に一致しません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-337">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="c3caa-338">このメソッドは、論理フォーカスを設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-338">This method sets the logical focus.</span></span> <span data-ttu-id="c3caa-339">プログラムです。 具体的にキーボード フォーカスを設定する手段はありません。キーボード フォーカスは、ユーザー入力によって決定されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-339">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="c3caa-340">詳細については、次を参照してください。[フォーカス概要](~/docs/framework/wpf/advanced/focus-overview.md)と[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-340">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="c3caa-341">呼び出す場合<xref:System.Windows.ContentElement.Focus%2A>返します`true`、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>と<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>も`true`します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-341">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="c3caa-342">場合は、関連するプロパティは、既に`true`を呼び出すとき、 <xref:System.Windows.ContentElement.Focus%2A>、次の順序で発生するか、次のイベントの 1 つ以上: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>、 <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (ソースは、新しいフォーカス ターゲット)、 <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>、 <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>、 <xref:System.Windows.ContentElement.LostKeyboardFocus>、 <xref:System.Windows.ContentElement.GotKeyboardFocus> (ソースは、新しいフォーカス ターゲット)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-342">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-343">次の例では、文書内の段落をという名前を指定した検出されたページ読み込みイベントのハンドラーは、し、フォーカスを設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-343">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="c3caa-344">段落が既定ではフォーカスを設定できません。この特定の段落が適用されるスタイル (非表示) を使用して、スタイル<xref:System.Windows.Setter>フォーカスを設定できるようにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-344">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-345">要素がフォーカスを得ることができるかどうかを示す値を取得または設定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-345">Gets or sets a value that indicates whether the element can receive focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-346">要素にフォーカスを設定できる場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-346">
              <see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-347">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-347">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-348">フォーカスのある要素のみでは、キーボード入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-348">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="c3caa-349">特定の派生クラスは、派生クラスでは、既定でフォーカスを設定できるように、この依存関係プロパティのメタデータをオーバーライド可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-349">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="c3caa-350">継承<xref:System.Windows.Documents.Hyperlink>またはその派生クラスでは、<xref:System.Windows.Documents.Hyperlink>この依存関係プロパティのメタデータをオーバーライドし、このプロパティの既定値を再定義`true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-350">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-351">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-351">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-352">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-352">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="c3caa-353">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-353">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-354">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-354">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-355">次の例では、スタイルを<xref:System.Windows.Documents.Paragraph>既定でフォーカスを設定できるフォーカスを受け取るときに、視覚的な動作を付け、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-355">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="c3caa-356">派生したときに<see cref="T:System.Windows.ContentElement" />要素にフォーカスを設定すると、既定ではないためフォーカスを設定するかどうかを検討してください。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-356">When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable.</span>
            </span>
            <span data-ttu-id="c3caa-357">要素にフォーカスを設定できる場合は、次のように、派生クラスの静的コンス トラクターでは、このプロパティのメタデータをオーバーライドします。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-357">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span>
            </span>  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 <span data-ttu-id="c3caa-358">ここで<paramref name="myElement" />メタデータ値を上書きするのには、型のクラス名を指定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-358">where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</span></span></para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-359">
            <see cref="P:System.Windows.ContentElement.Focusable" /> プロパティの値が変更された場合に発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-359">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-360">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-360">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-361">
            <see cref="P:System.Windows.ContentElement.Focusable" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-361">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="c3caa-362">確認する依存関係プロパティ。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-362">The.dependency property to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-363">この要素の、指定したプロパティの基本プロパティ値を返します。実行中または停止済みのアニメーションでアニメーション化される値は無視されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-363">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-364">指定した依存関係プロパティにアニメーションが添付されていないような場合のプロパティ値。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-364">The property value as if no animations are attached to the specified dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-365">プロパティのアニメーションが添付されていない場合、<xref:System.Windows.ContentElement.GetAnimationBaseValue%2A>に戻り値は常に、<xref:System.Windows.DependencyObject.GetValue%2A>値を返します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-365">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="c3caa-366">添付されたアニメーションがある場合は、可能なすべてのアニメーションが開始を含む値を派生し、停止の値は無視され、プロパティの値はその他のすべての可能な入力に基づいて決定されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-366">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="c3caa-367">詳細については、「[依存関係プロパティ値の優先順位](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)」を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-367">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-368">派生クラスでオーバーライドされると、ビジュアル親が存在しない場合に、この要素の代替[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] の親を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-368">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-369">報告する代替の親接続を派生クラスの実装が持つ場合のオブジェクト。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-369">An object, if implementation of a derived class has an alternate parent connection to report.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-370">このメソッドの既定の仮想実装`null`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-370">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="c3caa-371"><xref:System.Windows.FrameworkContentElement> 実際の実装を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-371"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="c3caa-372">別の親は、できるように、そのイベントは、標準の親のビジュアル ツリーをルーティングの標準的なパターンから逸脱した方法でルーティングまたはプレビューのルーティング方法で下方向に要素が代替の親構造体を作成する場所の場合、イベントのルーティングに使用されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-372">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-373">入力システムがこの要素を対象とするドラッグ アンド ドロップ イベントを報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-373">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-374"><xref:System.Windows.ContentElement.GiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。</span><span class="sxs-lookup"><span data-stu-id="c3caa-374">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="c3caa-375">視覚的なフィードバックは、ドラッグ アンド ドロップ操作が、プロセスを助けます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-375">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="c3caa-376">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.GiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-376">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-377">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GiveFeedback>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-377">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-378">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-378">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-379">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-379">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="c3caa-380">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-380">Routing strategy</span></span>|<span data-ttu-id="c3caa-381">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-381">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-382">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-382">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="c3caa-383">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewGiveFeedback>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-383">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="c3caa-384">オーバーライド<xref:System.Windows.ContentElement.OnGiveFeedback%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-384">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-385">
            <see cref="E:System.Windows.ContentElement.GiveFeedback" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-385">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-386">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-386">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-387">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-387">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-388">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-388">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-389">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-389">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-390">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-390">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-391">この要素が論理フォーカスを取得したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-391">Occurs when this element gets logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-392">フォーカスがメソッド呼び出しを使用して強制的に意図的には、直前のキーボード フォーカスが別のスコープに存在する場合、論理フォーカスはキーボード フォーカスとは異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-392">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="c3caa-393">ここでは、要素にキーボード フォーカスが残り、このシナリオで場所、<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-393">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="c3caa-394">このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更された`false`に`true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-394">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="c3caa-395">このイベントは、バブル ルーティングを使用するため、フォーカスを受け取る要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-395">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-396">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-396">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-397">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-397">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-398">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-398">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="c3caa-399">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-399">Routing strategy</span></span>|<span data-ttu-id="c3caa-400">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-400">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-401">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-401">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="c3caa-402">対応するトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-402">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-403">オーバーライド<xref:System.Windows.ContentElement.OnGotFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-403">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-404">
            <see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-404">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-405">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-405">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-406">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-406">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-407">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-407">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-408">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-408">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-409">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-409">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-410">この要素にキーボード フォーカスが移動したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-410">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> 類似するイベントです。 要素のフォーカス状態を保持するプロパティで状態の変更を追跡します。<xref:System.Windows.ContentElement.GotKeyboardFocus>イベントは、多くの同じ状況で発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="c3caa-412">このイベントは、バブル ルーティングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-412">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-413">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-413">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="c3caa-414">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.GotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-414">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-415">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-415">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-416">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-417">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-417">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="c3caa-418">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-418">Routing strategy</span></span>|<span data-ttu-id="c3caa-419">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-419">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-420">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-420">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c3caa-421">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-421">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c3caa-422">オーバーライド<xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-422">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-423">
            <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-423">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-424">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-424">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-425">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-425">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-426">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-426">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-427">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-427">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-428">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-428">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-429">この要素がマウスをキャプチャしたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-429">Occurs when this element captures the mouse.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-430">要素がマウスをキャプチャは、境界外にマウス ポインターがあってもマウス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-430">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="c3caa-431">マウスでは、ドラッグ アンド ドロップ操作中にのみがキャプチャ通常され、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャされたままです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-431">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="c3caa-432">このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-432">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-433">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>マウスのある実際の要素を決定するデータのキャプチャのイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-433">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="c3caa-434">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.GotMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-434">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-435">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotMouseCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-435">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-436">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-437">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-437">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="c3caa-438">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-438">Routing strategy</span></span>|<span data-ttu-id="c3caa-439">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-439">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-440">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-440">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c3caa-441">対応する定義済みのトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-441">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-442">オーバーライド<xref:System.Windows.ContentElement.OnGotMouseCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-442">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-443">
            <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-443">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-444">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-445">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-446">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-447">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-448">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-449">この要素がスタイラスをキャプチャしたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-449">Occurs when this element captures the stylus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-450">要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-450">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="c3caa-451">スタイラスは、通常、ドラッグ アンド ドロップ操作中にのみキャプチャし、ドラッグ アンド ドロップ操作の削除アクションが発生するまでにキャプチャを保持します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-451">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="c3caa-452">このイベントは、バブル ルーティングを使用するため、キャプチャを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-452">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-453">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>イベント データを実際のキャプチャを持つ要素を決定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-453">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="c3caa-454">このイベントは、このクラスの添付イベントのエイリアスを作成できるように<xref:System.Windows.ContentElement.GotStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-454">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-455">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.GotStylusCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-455">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-456">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-456">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-457">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-457">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="c3caa-458">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-458">Routing strategy</span></span>|<span data-ttu-id="c3caa-459">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-459">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-460">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-460">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-461">対応する定義済みのトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-461">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-462">オーバーライド<xref:System.Windows.ContentElement.OnGotStylusCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-462">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-463">
            <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-463">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-464">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-464">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-465">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-465">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-466">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-466">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-467">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-467">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-468">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-468">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-469">タッチがこの要素にキャプチャされると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-469">Occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-470">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-470">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-471">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-471">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="c3caa-472">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-472">Routing strategy</span></span>|<span data-ttu-id="c3caa-473">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-473">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-474">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-474">Delegate</span></span>|<span data-ttu-id="c3caa-475"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-475"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-476">オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-476">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-477">
            <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-477">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-478">この要素にアニメーション化されたプロパティかあるどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-478">Gets a value that indicates whether this element has any animated properties.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-479">プロパティのいずれかに添付されたアニメーションをこの要素が持つ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-479">
              <see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-480">このプロパティを返します`true`(ロック、常に実行されている) の永続的なアニメーション用または特定のタイムラインのアニメーションのいずれか。</span><span class="sxs-lookup"><span data-stu-id="c3caa-480">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-481">この要素に関連付けられている入力バインディングのコレクションを取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-481">Gets the collection of input bindings that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-482">入力バインディングのコレクション。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-482">The collection of input bindings.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-483">入力バインディングは、コマンド入力デバイスへのバインディングをサポートします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-483">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="c3caa-484">たとえば、<xref:System.Windows.Input.MouseBinding>入力マウス デバイスに固有のプロパティを含むバインドを実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-484">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="c3caa-485">入力バインディングのコレクションには、型に関連する両方と、インスタンスで宣言されている入力バインドが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-485">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="c3caa-486">関連するプロパティ、<xref:System.Windows.ContentElement.CommandBindings%2A>コマンドのショートカット キーのコレクションを保持します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-486">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="c3caa-487">これらのバインディングは、入力バインドとは異なり、コマンドの処理 - これらの既知のコマンドとクラスに固有のハンドラーに関連付けられているアクションの下の次のレベルを表しています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-487">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="c3caa-488">XAML プロパティ要素の使用</span><span class="sxs-lookup"><span data-stu-id="c3caa-488">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="c3caa-489">XAML 値</span><span class="sxs-lookup"><span data-stu-id="c3caa-489">XAML Values</span></span>  
 <span data-ttu-id="c3caa-490">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="c3caa-490">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="c3caa-491">1 つまたは複数<xref:System.Windows.Input.InputBinding>要素 (通常、<xref:System.Windows.Input.KeyBinding>または<xref:System.Windows.Input.MouseBinding>派生クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-491">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="c3caa-492">これらの各が予期、<xref:System.Windows.Input.InputBinding.Command%2A>と<xref:System.Windows.Input.InputBinding.Gesture%2A>属性に設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-492">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-493">この要素が[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] で有効かどうかを示す値を取得または設定します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-493">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-494">要素が有効な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-494">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-495">既定値は <see langword="true" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-495">The default value is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-496">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-496">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-497">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-497">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="c3caa-498">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-498">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-499">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-499">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-500">次の例をプロパティ set アクセス操作子、代替視覚的な動作を示すを含むスタイルを作成するときに、<xref:System.Windows.Documents.Hyperlink>に設定されている<xref:System.Windows.ContentElement.IsEnabled%2A>`false`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-500">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-501">この要素の <see cref="P:System.Windows.ContentElement.IsEnabled" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-501">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-502">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-502">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-503">派生クラス内で <see cref="P:System.Windows.ContentElement.IsEnabled" /> の戻り値になる値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-503">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-504">要素が有効な場合は <see langword="true" />、それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-504">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="c3caa-505">このプロパティの既定の実装では、値をキャッシュし、またこの要素の親要素が有効になっているかどうかを計算します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-505">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span>
            </span>
            <span data-ttu-id="c3caa-506">(親が有効でない場合、子要素効果的に有効にできません実用的な[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)])。この実装をオーバーライドすることを確認する場合は、この動作を保持する基本実装を呼び出します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-506">(If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-507">
            <see cref="P:System.Windows.ContentElement.IsEnabled" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-507">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-508">この要素に論理フォーカスがあるかどうかを判断する値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-508">Gets a value that determines whether this element has logical focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-509">この要素に論理フォーカスが設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-509">
              <see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-510">アプリケーションは、複数のフォーカス区分をなど、メニューの内容と、アプリケーションの残りの部分の間に、論理フォーカスはキーボード フォーカスと異なる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-510">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="c3caa-511">このシナリオでは、アプリケーションの UI の 1 つの要素にキーボード フォーカスが設定できるだけ、ただし、他のフォーカス区分の特定の要素も保持したまま論理フォーカスします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-511">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="c3caa-512">論理フォーカスの詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)と[フォーカス概要](~/docs/framework/wpf/advanced/focus-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-512">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-513">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-513">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-514">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-514">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="c3caa-515">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-515">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-516">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-516">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-517">次の例では、スタイルを<xref:System.Windows.Documents.Paragraph>既定でフォーカスを設定できるフォーカスを受け取るときに、視覚的な動作を付け、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-517">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-518">
            <see cref="P:System.Windows.ContentElement.IsFocused" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-518">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-519">[!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)] などの入力方法システムが、この要素への入力の処理に対して有効かどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-519">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-520">入力方法がアクティブの場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-520">
              <see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-521">基になる添付プロパティの既定値は<see langword="true" />。 ただし、この値は実行時の入力方式の状態の影響を受けます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-521">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-522">このプロパティが添付プロパティによって返される値を返します<xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType>現在有効な入力メソッド (キーボード、音声、およびその他の入力デバイス) 用です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-522">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-523">この要素にキーボード フォーカスがあるかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-523">Gets a value that indicates whether this element has keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-524">この要素にキーボード フォーカスが設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-524">
              <see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-525">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-525">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-526">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-526">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-527">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-527">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="c3caa-528">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-528">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-529">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-529">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-530">この要素の <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-530">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-531">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-531">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-532">
            <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-532">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-533">キーボード フォーカスが要素または子要素内にあるかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-533">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-534">キーボード フォーカスが要素またはその子要素上に設定されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-534">
              <see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-535">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-535">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-536">このプロパティの値に変更が通常発生させる、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベント、派生クラスがオーバーライドしない限り、<xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A>を抑制する状況イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-536">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="c3caa-537">このプロパティを直接設定しないが、要素にフォーカスを設定するには呼び出すことによって<xref:System.Windows.ContentElement.Focus%2A>、またはすることにより、<xref:System.Windows.ContentElement.MoveFocus%2A>要求します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-537">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="c3caa-538">このプロパティの値を変更するこれらのメソッド呼び出しのいずれかの可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-538">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-539">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-539">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-540">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-540">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="c3caa-541">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-541">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-542">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-542">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-543">この要素の <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-543">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-544">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-544">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-545">
            <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-545">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-546">マウスがこの要素にキャプチャされているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-546">Gets a value that indicates whether the mouse is captured by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-547">要素がマウスのキャプチャを持つ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-547">
              <see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-548">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-548">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-549">マウスのキャプチャ状態は、インプロセスのドラッグ アンド ドロップ操作に関連付けられます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-549">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-550">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-550">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-551">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-551">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="c3caa-552">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-552">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-553">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-553">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-554">次の例マウスのキャプチャ状態を切り替えます、マウスが要素で既にキャプチャされているかどうかに基づいて。</span><span class="sxs-lookup"><span data-stu-id="c3caa-554">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-555">この要素の <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-555">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-556">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-556">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-557">
            <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-557">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-558">この要素または要素ツリー内の子要素がマウス キャプチャを保持するかどうかを決定する値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-558">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-559">この要素または格納されている要素がマウスのキャプチャを持つ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-559">
              <see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-560">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-560">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-561">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-561">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-562">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-562">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="c3caa-563">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-563">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-564">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-564">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-565">この要素の <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> の値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-565">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-566">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-566">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-567">
            <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-567">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-568">マウス ポインターの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-568">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-569">
            <see langword="true" /> マウス ポインターがヒット テストと同じ要素結果の上にある場合それ以外の場合、<see langword="false" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-569">
              <see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-570">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-570">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-571">異なり<xref:System.Windows.ContentElement.IsMouseOver%2A>、のみ、このプロパティは`true`literal 要素上にマウス ポインターが場合などは、ヒット テストのです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-571">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element—as it is for a hit test.</span></span> <span data-ttu-id="c3caa-572">代わりに子要素の上にマウス ポインターが、具体的には要素のより深いテンプレートおよび複合の一部である要素をこのプロパティはするか`false`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-572">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="c3caa-573">コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-573">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="c3caa-574">コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.ContentElement.IsMouseOver%2A>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-574">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="c3caa-575">この要素にマウスがキャプチャされるかどうかと、このプロパティは、`true`のキャプチャ時に、このプロパティを返し続けます`true`までマウスのキャプチャが失われ、その境界上にポインターがありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-575">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-576">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-576">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-577">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-577">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="c3caa-578">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-578">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-579">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-579">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-580">この要素の <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-580">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-581">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-581">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-582">
            <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-582">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-583">マウス ポインターがこの要素 (子ビジュアル要素またはそのコントロールの複合を含む) 上にあるかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-583">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-584">マウス ポインターが要素またはその子要素上に存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-584">
              <see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-585">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-585">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-586">類似しています"IsMouseOverChanged"イベントが存在しないいくつかの類似イベントを行います。</span><span class="sxs-lookup"><span data-stu-id="c3caa-586">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="c3caa-587">たとえば、使用することができます<xref:System.Windows.ContentElement.MouseEnter>、 <xref:System.Windows.ContentElement.MouseMove>、および<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-587">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="c3caa-588">この要素がマウスをキャプチャする場合に、このプロパティが残ります`true`マウスのキャプチャが失われ、マウス ポインターが要素の境界を離れるまでです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-588">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-589">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-589">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-590">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-590">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="c3caa-591">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-591">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-592">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-592">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-593">次の例をプロパティ set アクセス操作子、代替視覚的な動作を示すを含むスタイルを作成するときに、<xref:System.Windows.Documents.Hyperlink>レポート<xref:System.Windows.ContentElement.IsMouseOver%2A>`true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-593">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-594">
            <see cref="P:System.Windows.ContentElement.IsMouseOver" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-594">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-595">この要素にスタイラスがキャプチャされるかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-595">Gets a value that indicates whether the stylus is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-596">要素がスタイラスのキャプチャを持つ場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-596">
              <see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-597">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-597">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-598">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-598">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-599">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-599">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-600">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-600">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-601">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-601">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="c3caa-602">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-602">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-603">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-603">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-604">この要素の <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-604">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-605">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-605">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-606">
            <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-606">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-607">スタイラスのキャプチャをこの要素 (子要素およびコントロールの複合を含む) が保持するかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-607">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-608">スタイラスのキャプチャがこの要素内に保持されている場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-608">
              <see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-609">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-609">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-610">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-610">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-611">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-611">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-612">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-612">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="c3caa-613">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-613">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-614">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-614">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-615">この要素の <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-615">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-616">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-616">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-617">
            <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-617">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-618">スタイラスの位置が、要素の構成を考慮したヒット テストの結果に対応しているかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-618">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-619">ヒット テストと同じ要素上にスタイラスがある場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-619">
              <see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-620">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-620">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-621">異なり<xref:System.Windows.ContentElement.IsStylusOver%2A>、のみ、このプロパティは`true`要素の上にスタイラスがある場合。</span><span class="sxs-lookup"><span data-stu-id="c3caa-621">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="c3caa-622">スタイラスが代わりに子要素上、または要素は要素のより深い複合の一部である場合、このプロパティはなって`false`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-622">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="c3caa-623">コントロールは合成する方法がわかっていなければ (たとえば、プロパティを使用するこのカスタム コントロール テンプレートで定義したコントロールの)、このプロパティは、予期しない結果を返す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-623">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="c3caa-624">コントロールをいないオーサリングは、ほとんどのシナリオを使用して<xref:System.Windows.ContentElement.IsStylusOver%2A>代わりにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-624">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="c3caa-625">この要素がスタイラス キャプチャを持つプロパティは、この場合`true`のキャプチャ時に、このプロパティの値`true`までスタイラスのキャプチャが失われ、その境界上にスタイラスがありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-625">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="c3caa-626">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-626">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-627">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-627">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-628">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-628">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-629">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-629">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="c3caa-630">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-630">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-631">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-631">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-632">この要素の <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> プロパティの値が変更されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-632">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-633">このメンバーは、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-633">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-634">
            <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-634">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-635">スタイラスがこの要素 (子ビジュアル要素を含む) 上にあるかどうかを示す値を取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-635">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-636">スタイラスが要素またはその子要素上に存在する場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-636">
              <see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="c3caa-637">既定値は、<see langword="false" /> です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-637">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-638">この要素にスタイラスのキャプチャがある場合は、このプロパティの値`true`スタイラスのキャプチャが失われ、ポインターがその範囲外になるまでです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-638">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="c3caa-639">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-639">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-640">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-640">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="c3caa-641">依存プロパティ情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-641">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-642">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-642">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="c3caa-643">メタデータ プロパティに設定します。 `true`</span><span class="sxs-lookup"><span data-stu-id="c3caa-643">Metadata properties set to `true`</span></span>|<span data-ttu-id="c3caa-644">なし</span><span class="sxs-lookup"><span data-stu-id="c3caa-644">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-645">
            <see cref="P:System.Windows.ContentElement.IsStylusOver" /> 依存関係プロパティを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-645">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-646">この要素にフォーカスがある状態でキーが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-646">Occurs when a key is pressed while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-647">キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-647">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="c3caa-648"><xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-648">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="c3caa-649">これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-649">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="c3caa-650">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.KeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-650">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-651">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.KeyDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-651">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-652">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-652">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-653">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-653">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="c3caa-654">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-654">Routing strategy</span></span>|<span data-ttu-id="c3caa-655">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-655">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-656">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-656">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c3caa-657">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewKeyDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-657">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-658">オーバーライド<xref:System.Windows.ContentElement.OnKeyDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-658">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-659">
            <see cref="E:System.Windows.ContentElement.KeyDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-659">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-660">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-660">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-661">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-661">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-662">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-662">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-663">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-663">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-664">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-664">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-665">この要素にフォーカスがあるときにキーが離されると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-665">Occurs when a key is released while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-666">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>このクラスのイベントをアタッチできるように<xref:System.Windows.ContentElement.KeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素としては、継承です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-666">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-667">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.KeyUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-667">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-668">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-668">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-669">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-669">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="c3caa-670">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-670">Routing strategy</span></span>|<span data-ttu-id="c3caa-671">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-671">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-672">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-672">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c3caa-673">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewKeyUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-673">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-674">オーバーライド<xref:System.Windows.ContentElement.OnKeyUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-674">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-675">
            <see cref="E:System.Windows.ContentElement.KeyUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-675">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-676">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-676">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-677">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-677">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-678">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-678">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-679">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-679">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-680">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-680">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-681">この要素が論理フォーカスを失ったときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-681">Occurs when this element loses logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-682">メソッド呼び出しを使用して意図的にフォーカスを外しているにもかかわらず、直前のキーボード フォーカスが異なるスコープ内に存在する場合、論理フォーカスはキーボード フォーカスとは異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-682">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="c3caa-683">ここでは、キーボード フォーカスは残りますが、および要素の位置、<xref:System.Windows.ContentElement.Focus%2A>メソッドが呼び出されたが論理フォーカスを取得します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-683">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="c3caa-684">このイベントをより正確に解釈というものが発生したときの値、<xref:System.Windows.ContentElement.IsFocused%2A>からルート内の要素のプロパティが変更される`true`に`false`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-684">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="c3caa-685">このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-685">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-686">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスを得られる実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-686">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-687">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-688">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-688">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="c3caa-689">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-689">Routing strategy</span></span>|<span data-ttu-id="c3caa-690">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-690">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-691">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-691">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="c3caa-692">対応するトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-692">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-693">オーバーライド<xref:System.Windows.ContentElement.OnLostFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-693">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-694">
            <see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-694">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-695">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-696">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-697">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-698">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-699">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-700">この要素からキーボード フォーカスが離れたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-700">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-701">このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-701">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-702">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-702">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="c3caa-703">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.LostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-703">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-704">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-704">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-705">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-705">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-706">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-706">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="c3caa-707">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-707">Routing strategy</span></span>|<span data-ttu-id="c3caa-708">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-708">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-709">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-709">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c3caa-710">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-710">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c3caa-711">オーバーライド<xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-711">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-712">
            <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-712">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-713">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-713">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-714">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-714">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-715">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-715">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-716">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-716">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-717">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-717">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-718">この要素がマウス キャプチャを失ったときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-718">Occurs when this element loses mouse capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-719">要素がマウスをキャプチャは、境界外にポインターがあってもマウス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-719">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="c3caa-720">マウスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-720">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="c3caa-721">このイベントは、バブル ルーティングを使用するため、キャプチャを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-721">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-722">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>キャプチャを失った実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-722">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="c3caa-723">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.LostMouseCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-723">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-724">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostMouseCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-724">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-725">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-725">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-726">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-726">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="c3caa-727">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-727">Routing strategy</span></span>|<span data-ttu-id="c3caa-728">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-728">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-729">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-729">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c3caa-730">対応する定義済みのトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-730">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-731">オーバーライド<xref:System.Windows.ContentElement.OnLostMouseCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-731">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-732">
            <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-732">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-733">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-733">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-734">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-734">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-735">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-735">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-736">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-736">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-737">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-737">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-738">この要素がスタイラス キャプチャを失ったときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-738">Occurs when this element loses stylus capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-739">要素がスタイラスをキャプチャ、ときに、ポインターが境界外にある場合でも、スタイラス入力を受け取ります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-739">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="c3caa-740">スタイラスは通常、ドラッグ アンド ドロップ操作中にのみキャプチャされます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-740">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="c3caa-741">このイベントは、バブル ルーティングを使用するため、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-741">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-742">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-742">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="c3caa-743">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.LostStylusCapture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-743">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-744">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.LostStylusCapture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-744">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-745">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-745">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-746">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-746">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="c3caa-747">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-747">Routing strategy</span></span>|<span data-ttu-id="c3caa-748">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-748">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-749">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-749">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-750">対応する定義済みのトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-750">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-751">オーバーライド<xref:System.Windows.ContentElement.OnLostStylusCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-751">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-752">
            <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-752">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-753">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-753">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-754">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-754">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-755">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-755">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-756">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-756">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-757">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-757">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-758">この要素がタッチのキャプチャを失うと発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-758">Occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-759">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-759">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-760">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-760">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="c3caa-761">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-761">Routing strategy</span></span>|<span data-ttu-id="c3caa-762">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-762">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-763">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-763">Delegate</span></span>|<span data-ttu-id="c3caa-764"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-764"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-765">オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-765">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-766">
            <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-766">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-767">この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-767">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-768">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-768">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-769">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-769">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-770"><xref:System.Windows.ContentElement.MouseDown>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-770">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c3caa-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> <xref:System.Windows.ContentElement.MouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c3caa-772">「解説」を参照してください<xref:System.Windows.ContentElement.MouseLeftButtonDown>または<xref:System.Windows.ContentElement.MouseRightButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-772">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c3caa-773">いくつか<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、本質的なイベントに対するクラス処理マウス ボタンがあります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-773">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="c3caa-774">イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-774">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="c3caa-775">多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-775">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="c3caa-776">イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-776">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="c3caa-777">その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-777">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="c3caa-778">前の「重要」に示されている問題を解決でき、それでも<xref:System.Windows.ContentElement.MouseDown>マウスの左ボタンを押すイベントをこれらソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-778">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="c3caa-779">ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-779">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="c3caa-780">これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-780">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="c3caa-781">コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.ContentElement.AddHandler%2A>ハンドラーにルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-781">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-782">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-782">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-783">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-783">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="c3caa-784">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-784">Routing strategy</span></span>|<span data-ttu-id="c3caa-785">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-785">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-786">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-786">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-787">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-787">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-788">オーバーライド<xref:System.Windows.ContentElement.OnMouseDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-788">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-789">
            <see cref="E:System.Windows.ContentElement.MouseDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-789">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-790">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-790">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-791">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-791">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-792">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-792">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-793">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-793">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-794">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-794">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-795">マウス ポインターがこの要素の境界内に入ったときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-795">Occurs when the mouse pointer enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-796"><xref:System.Windows.ContentElement.MouseEnter> [ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-796"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c3caa-797">ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-797">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c3caa-798">ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。</span><span class="sxs-lookup"><span data-stu-id="c3caa-798">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c3caa-799"><xref:System.Windows.ContentElement.MouseEnter>マウス ポインターがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`false`に`true`この要素上です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-799">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="c3caa-800">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-800">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-801">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseEnter>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-801">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-802">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-802">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-803">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-803">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="c3caa-804">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-804">Routing strategy</span></span>|<span data-ttu-id="c3caa-805">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-805">Direct</span></span>|  
|<span data-ttu-id="c3caa-806">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-806">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c3caa-807">オーバーライド<xref:System.Windows.ContentElement.OnMouseEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-807">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-808">
            <see cref="E:System.Windows.ContentElement.MouseEnter" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-808">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-809">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-809">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-810">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-810">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-811">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-811">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-812">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-812">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-813">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-813">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-814">マウス ポインターがこの要素の境界内から出たときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-814">Occurs when the mouse pointer leaves the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-815"><xref:System.Windows.ContentElement.MouseLeave> [ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-815"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c3caa-816">ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-816">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c3caa-817">ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。</span><span class="sxs-lookup"><span data-stu-id="c3caa-817">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c3caa-818"><xref:System.Windows.ContentElement.MouseLeave>トラック マウスが要素をこのイベントの詳細を報告文字どおり、<xref:System.Windows.ContentElement.IsMouseOver%2A>からプロパティ値が変更された`true`に`false`この要素上です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-818">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="c3caa-819">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-819">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-820">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseLeave>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-820">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-821">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-821">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-822">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-822">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="c3caa-823">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-823">Routing strategy</span></span>|<span data-ttu-id="c3caa-824">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-824">Direct</span></span>|  
|<span data-ttu-id="c3caa-825">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-825">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c3caa-826">オーバーライド<xref:System.Windows.ContentElement.OnMouseLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-826">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-827">
            <see cref="E:System.Windows.ContentElement.MouseLeave" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-827">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-828">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-828">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-829">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-829">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-830">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-830">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-831">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-831">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-832">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-832">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-833">この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-833">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-834">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-834">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-835">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-835">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-836">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-836">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-837">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-837">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-838">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-838">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-839">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-839">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-840">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-840">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c3caa-841">いくつか<xref:System.Windows.ContentElement>をたとえば、コントロールと同様の動作を持つクラスを派生<xref:System.Windows.Documents.Hyperlink>、本質的なイベントに対するクラス処理マウス ボタンがあります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-841">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="c3caa-842">イベントをマウスの左ボタンは、クラス、コントロールで処理が最も可能性の高いイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-842">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="c3caa-843">多くの場合、処理するクラスは、基になるをマーク<xref:System.Windows.Input.Mouse>クラス イベントを処理します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-843">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="c3caa-844">イベントが処理済みとマークされるとその要素に関連付けられている他のインスタンス ハンドラーは通常は発生しません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-844">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="c3caa-845">その他のクラスまたはインスタンス ハンドラー、バブルに向かう方向 UI ツリーのルート内の要素に関連付けられている通常も発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-845">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="c3caa-846">前の「重要」に示されている問題を解決でき、それでも<xref:System.Windows.ContentElement.MouseLeftButtonDown>マウスの左ボタンを押すイベントをこれらソリューションのいずれかを使用して処理するクラスを持つ派生クラスでイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-846">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="c3caa-847">ハンドラーのアタッチ、<xref:System.Windows.ContentElement.PreviewMouseDown>コントロールによって処理済みとしてマークされていないイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-847">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="c3caa-848">これはプレビュー イベントであるため、ルート ルートから始まり、トンネルをコントロールに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-848">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="c3caa-849">コントロールのハンドラーを呼び出すことによって手続き登録<xref:System.Windows.ContentElement.AddHandler%2A>ハンドラーにルーティングされたイベント データの処理済みとしてマークされている場合でも、イベントをリッスンできる署名オプションを選択します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-849">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-850">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-850">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-851">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-851">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="c3caa-852">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-852">Routing strategy</span></span>|<span data-ttu-id="c3caa-853">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-853">Direct</span></span>|  
|<span data-ttu-id="c3caa-854">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-854">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-855">オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-855">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-856">
            <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-856">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-857">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-857">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-858">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-858">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-859">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-859">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-860">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-860">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-861">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-861">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-862">この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-862">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-863">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-863">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-864">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-864">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-865">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-865">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-866">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-866">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-867">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-867">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-868">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-868">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-869">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-869">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-870">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-870">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-871">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-871">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="c3caa-872">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-872">Routing strategy</span></span>|<span data-ttu-id="c3caa-873">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-873">Direct</span></span>|  
|<span data-ttu-id="c3caa-874">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-874">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-875">オーバーライド<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-875">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-876">
            <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-876">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-877">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-877">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-878">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-878">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-879">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-879">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-880">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-880">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-881">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-881">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-882">この要素の上でマウス ポインターが動かされたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-882">Occurs when the mouse pointer moves while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-883">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-883">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-884">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-884">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-885">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-885">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-886">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-886">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="c3caa-887">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-887">Routing strategy</span></span>|<span data-ttu-id="c3caa-888">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-888">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-889">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-889">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c3caa-890">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-891">オーバーライド<xref:System.Windows.ContentElement.OnMouseMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-891">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-892">
            <see cref="E:System.Windows.ContentElement.MouseMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-892">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-893">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-893">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-894">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-894">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-895">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-895">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-896">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-896">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-897">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-897">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-898">この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-898">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-899">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-899">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-900">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-900">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-901">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-901">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-902">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-902">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-903">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-903">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-904">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-904">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-905">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-905">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-906">右ボタンをマウス イベントは、アプリケーション シナリオでネイティブの処理を頻繁にあります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-906">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="c3caa-907">たとえば、マウスの右ボタンを押すは、コンテキスト メニューを表示する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-907">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="c3caa-908">参照してください[ContextMenu 概要](~/docs/framework/wpf/controls/contextmenu-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-908">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-909">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-909">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-910">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-910">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="c3caa-911">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-911">Routing strategy</span></span>|<span data-ttu-id="c3caa-912">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-912">Direct</span></span>|  
|<span data-ttu-id="c3caa-913">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-913">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-914">オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-914">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-915">
            <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-915">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-916">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-916">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-917">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-917">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-918">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-918">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-919">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-919">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-920">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-920">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-921">この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-921">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-922">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてバブルのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-922">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-923">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-923">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-924">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-924">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-925">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-925">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-926">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-926">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-927">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-927">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-928">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-928">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-929">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-929">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-930">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-930">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="c3caa-931">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-931">Routing strategy</span></span>|<span data-ttu-id="c3caa-932">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-932">Direct</span></span>|  
|<span data-ttu-id="c3caa-933">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-933">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-934">オーバーライド<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-934">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-935">
            <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-935">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-936">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-936">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-937">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-937">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-938">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-938">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-939">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-939">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-940">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-940">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-941">この要素の上でいずれかのマウス ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-941">Occurs when any mouse button is released over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-942">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-942">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-943">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-943">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-944"><xref:System.Windows.ContentElement.MouseUp>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのリリースに対応します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-944">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c3caa-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> <xref:System.Windows.ContentElement.MouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c3caa-946">「解説」を参照してください<xref:System.Windows.ContentElement.MouseLeftButtonUp>または<xref:System.Windows.ContentElement.MouseRightButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-946">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-947">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-947">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-948">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-948">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="c3caa-949">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-949">Routing strategy</span></span>|<span data-ttu-id="c3caa-950">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-950">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-951">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-951">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-952">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-952">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-953">オーバーライド<xref:System.Windows.ContentElement.OnMouseUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-953">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-954">
            <see cref="E:System.Windows.ContentElement.MouseUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-954">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-955">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-955">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-956">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-956">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-957">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-957">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-958">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-958">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-959">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-959">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-960">この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-960">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-961">フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。そのため、表示された場合、<xref:System.Windows.ContentElement.MouseWheel>対象を絞ったまたはキャプチャした要素からのイベント、マウス ポインター可能性があります実際には別の要素上です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-961">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="c3caa-962">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.MouseWheel>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-962">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-963">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.MouseWheel>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-963">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-964">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-964">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-965">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-965">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="c3caa-966">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-966">Routing strategy</span></span>|<span data-ttu-id="c3caa-967">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-967">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-968">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-968">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="c3caa-969">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewMouseWheel>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-969">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="c3caa-970">オーバーライド<xref:System.Windows.ContentElement.OnMouseWheel%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-970">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-971">
            <see cref="E:System.Windows.ContentElement.MouseWheel" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-971">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-972">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-972">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-973">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-973">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-974">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-974">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-975">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-975">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-976">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-976">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="c3caa-977">既存のタブ オーダーを検査するモード、または視覚的な移動方向を示すプロパティを含む検査要求。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-977">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-978">この要素から別の要素へのフォーカスの移動を試みます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-978">Attempts to move focus from this element to another element.</span>
          </span>
          <span data-ttu-id="c3caa-979">フォーカスの移動方向は、ガイドラインの方向によって指定され、この要素のビジュアル親の編成内で解釈されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-979">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-980">要求した検査が実行された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-980">
              <see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-981">このメソッドの戻り値を確認してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-981">Make sure you check the return value of this method.</span></span> <span data-ttu-id="c3caa-982">戻り値の`false`コントロールの構成で定義されているタブ ストップの検査を実行し、走査の各要求はラップを要求していないかどうかに返される可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-982">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-983">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] インフラストラクチャの、クラス固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-983">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-984">型固有の <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> 実装。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-984">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="c3caa-985">このメソッドの実装は、通常、特定のコンス トラクターを呼び出す<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />実装し、戻り値として返します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-985">The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span>
            </span>
            <span data-ttu-id="c3caa-986">すべて<see cref="T:System.Windows.ContentElement" />派生クラスは、独自の固有の仕様を提供するためにこのメソッドを実装する必要があります<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />を実装する、[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]インフラストラクチャです。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-986">All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
            </span>
            <span data-ttu-id="c3caa-987">このパターンの実装の詳細については、「<see cref="T:System.Windows.Automation.Peers.AutomationPeer" />です。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-987">For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-988">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-988">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-989">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-989">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-990">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-990">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-991">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-991">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-992">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-992">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-993">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-993">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-994">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-994">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-995">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-995">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-996">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-996">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-997">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-997">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-998">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-998">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-999">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-999">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1000">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1000">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1001">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1001">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1002">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1002">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1003">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1003">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1004">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1004">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1005">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1005">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1006">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1006">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1007">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1007">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1008">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1008">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1009">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1009">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1010">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1010">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1011">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1011">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1012">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1012">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1013">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1013">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1014">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1014">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1015">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1015">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1016">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1016">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1017">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1017">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1018">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1018">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1019">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1019">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1020">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1020">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1021">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1021">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1022">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1022">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1023">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1023">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1024">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1024">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1025">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.DragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1025">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1026">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1026">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1027">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1027">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1028">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1028">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1029">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1029">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1030">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1030">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1031">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1031">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1032">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1032">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1033">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1033">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1034">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1034">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1035">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1035">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1036">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1036">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1037">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.GiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1037">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1038">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1038">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1039">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1039">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1040">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1040">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1041">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1041">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1042">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1042">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1043">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1043">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1044">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1044">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1045">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1045">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1046">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1046">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1047">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1047">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1048">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1048">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="c3caa-1049">このイベント データは、<see cref="E:System.Windows.ContentElement.GotFocus" /> イベントの識別子を含む必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1049">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1050">提供されたイベント データを使用して、<see cref="E:System.Windows.ContentElement.GotFocus" /> ルーティング イベントを発生させます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1050">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1051">このメソッドは、仮想がイベントを発生させる既定の実装です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1051">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="c3caa-1052">これで \* メソッドの実装は、イベントを発生させるためのものし、イベントを発生させるこの同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.ContentElement.IsFocused%2A>プロパティ値が変更されました。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1052">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="c3caa-1053"><xref:System.Windows.ContentElement.OnGotFocus%2A>実装が異なるその他の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で \* だけそのイベントに対するクラス処理を追加する便利な手段を提供する実装。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1053">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="c3caa-1054">意図的および例外いないフォーカス イベントを発生させることを確認する必要がない限り、実装は基本実装を呼び出します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1054">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="c3caa-1055">それ以外の場合、<see cref="E:System.Windows.ContentElement.GotFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザーの操作中に発生しません。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1055">Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="c3caa-1056">要素にフォーカスを設定する予定がない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.ContentElement.Focusable" />に<see langword="false" />です。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1056">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
            <span data-ttu-id="c3caa-1057">既定では、ことに注意してください。、<see cref="P:System.Windows.ContentElement.Focusable" />フォーカスを設定するための設定<see cref="P:System.Windows.ContentElement.Focusable" />意図的には必要ありません。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1057">Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1058">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1058">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1059">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1059">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1060">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1060">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1061">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1061">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1062">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1062">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1063">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1063">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1064">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1064">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1065">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1065">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1066">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1066">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1067">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1067">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1068">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1068">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1069">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1069">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1070">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1070">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1071">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1071">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1072">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1072">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1073">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1073">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1074">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1074">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1075">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1075">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1076">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1076">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1077">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1077">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1078">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1078">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1079">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1079">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1080">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1080">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1081">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1081">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1082">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1082">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1083">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1083">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1084">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1084">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1085">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1085">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1086">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1086">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1087">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1087">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1088">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1088">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1089">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1089">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1090">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1090">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1091">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1091">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1092">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1092">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1093">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1093">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1094">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1094">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1095">タッチがこの要素にキャプチャされているときに発生する <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1095">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1096"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1096">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1097">オーバーライド<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.GotTouchCapture>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1097">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="c3caa-1098">必ず、基本クラスの<xref:System.Windows.ContentElement.OnGotTouchCapture%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1098">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1099">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1099">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1100">未処理の <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1100">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1101">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1101">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1102">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocused%2A>依存関係プロパティの変更。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1102">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="c3caa-1103">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1103">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1104">続いて、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1104">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1105">注意して、<xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1105">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="c3caa-1106">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1106">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1107">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1107">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1108">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1108">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1109">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1109">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1110">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1110">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1111">この要素が <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> イベントを発生させる直前に呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1111">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span>
          </span>
          <span data-ttu-id="c3caa-1112">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1112">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1113">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A>依存関係プロパティの値が変更します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1113">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="c3caa-1114">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1114">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1115">続いて、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1115">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1116">注意して、<xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1116">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="c3caa-1117">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1117">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1118">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1118">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1119">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1119">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1120">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1120">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1121">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1121">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1122">未処理の <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1122">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1123">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1123">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1124">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseCaptured%2A>依存関係プロパティの値が変更します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1124">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="c3caa-1125">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1125">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1126">続いて、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1126">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1127">注意して、<xref:System.Windows.ContentElement.IsMouseCapturedChanged>イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1127">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="c3caa-1128">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1128">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1129">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1129">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1130">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1130">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1131">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1131">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1132">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1132">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1133">未処理の <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1133">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1134">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1134">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="c3caa-1135">この仮想メソッドが発生したときの値、<see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />依存関係プロパティの値が変更します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1135">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span>
            </span>
            <span data-ttu-id="c3caa-1136">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1136">The virtual method is raised first and can manipulate the event data as necessary.</span>
            </span>
            <span data-ttu-id="c3caa-1137">続いて、<see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />同じイベント データ インスタンスをイベントが発生します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1137">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span>
            </span>
            <span data-ttu-id="c3caa-1138">イベントが; ルーティングされたイベントではないことに注意してください。そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1138">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span>
            </span>
            <span data-ttu-id="c3caa-1139">このメソッドには、既定の実装ではありません。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1139">This method has no default implementation.</span>
            </span>
            <span data-ttu-id="c3caa-1140">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1140">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span>
            </span>
            <span data-ttu-id="c3caa-1141">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1141">You may call base either before or after your special handling, depending on your requirements.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1142">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1142">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1143">未処理の <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1143">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1144">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1144">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1145">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A>依存関係プロパティの値が変更します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1145">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="c3caa-1146">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1146">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1147">続いて、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1147">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1148">注意して、<xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>イベントは、ルーティングされたイベントではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1148">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="c3caa-1149">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1149">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1150">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1150">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1151">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1151">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1152">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1152">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1153">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1153">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1154">未処理の <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1154">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1155">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1155">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1156">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptured%2A>依存関係プロパティの値が変更します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1156">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="c3caa-1157">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1157">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1158">続いて、<xref:System.Windows.ContentElement.IsStylusCapturedChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1158">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1159">イベントがルーティングされたイベントではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1159">Notice that the event is not a routed event.</span></span> <span data-ttu-id="c3caa-1160">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1160">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1161">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1161">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1162">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1162">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1163">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1163">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1164">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1164">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1165">未処理の <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1165">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1166">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1166">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1167">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A>依存関係プロパティの値が変更します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1167">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="c3caa-1168">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1168">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1169">続いて、<xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1169">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1170">イベントがルーティングされたイベントではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1170">Notice that the event is not a routed event.</span></span> <span data-ttu-id="c3caa-1171">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1171">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1172">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1172">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1173">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1173">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1174">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1174">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1175">イベント データを格納している <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1175">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1176">未処理の <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> イベントがこの要素で発生すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1176">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1177">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1177">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1178">この仮想メソッドが発生したときの値、<xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A>依存関係プロパティの値が変更します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1178">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="c3caa-1179">仮想メソッドは、最初に発生し、必要に応じて、イベント データを操作できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1179">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="c3caa-1180">続いて、<xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged>同じイベント データ インスタンスをイベントが発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1180">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="c3caa-1181">イベントがルーティングされたイベントではないことに注意してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1181">Notice that the event is not a routed event.</span></span> <span data-ttu-id="c3caa-1182">そのため、クラス ハンドラーで処理されるようにマークすることはできません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1182">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="c3caa-1183">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1183">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1184">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1184">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1185">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1185">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1186">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1186">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1187">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1187">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1188">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1188">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1189">キーボード操作は、専用の入力マネージャーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1189">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="c3caa-1190">その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1190">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="c3caa-1191">システムの機能、イベントを処理し、としてマークするような入力する場合<xref:System.Windows.ContentElement.OnKeyDown%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1191">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1192">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1192">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1193">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1193">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1194">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1194">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1195">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1195">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1196">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1196">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1197">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1197">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1198">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1198">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1199">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1199">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1200">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1200">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1201">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1201">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1202">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1202">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1203">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1203">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1204">キーボード操作は、専用の入力マネージャーによって処理されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1204">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="c3caa-1205">その他のプログラミングに依存する機能キーストローク、たとえば、入力とコマンドのバインドは、一般的なキーストロークとして公開される前にキーストロークを処理する可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1205">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="c3caa-1206">システムの機能、イベントを処理し、としてマークするような入力する場合<xref:System.Windows.ContentElement.OnKeyUp%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1206">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1207">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1207">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1208">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1208">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1209">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1209">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1210">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1210">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1211">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1211">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1212">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1212">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1213">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1213">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1214">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1214">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1215">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1215">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1216">イベント データを格納している <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1216">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="c3caa-1217">このイベント データは、<see cref="E:System.Windows.ContentElement.LostFocus" /> イベントの識別子を含む必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1217">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1218">提供されたイベント データを使って、<see cref="E:System.Windows.ContentElement.LostFocus" /> ルーティング イベントを発生させます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1218">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1219">このメソッドは、仮想がイベントを発生させる既定の実装です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1219">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="c3caa-1220">これで \* メソッドの実装は、イベントを発生させるためのものし、イベントを発生させるこの同じメソッドの実装が内部的に呼び出されるときに、<xref:System.Windows.ContentElement.IsFocused%2A>プロパティ値が変更されました。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1220">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="c3caa-1221">この実装が異なるその他の[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]で \* だけそのイベントに対するクラス処理を追加する便利な手段を提供する実装。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1221">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="c3caa-1222">意図的および例外いないフォーカス イベントを発生させることを確認する必要がない限り、実装は基本実装を呼び出します。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1222">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="c3caa-1223">それ以外の場合、<see cref="E:System.Windows.ContentElement.LostFocus" />イベントは通常、この要素にフォーカスを設定する一般的なユーザーの操作中に発生しません。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1223">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="c3caa-1224">要素にフォーカスを設定する予定がない場合は、設定されない要素を防ぐことができます<see cref="P:System.Windows.ContentElement.Focusable" />に<see langword="false" />です。</span>
            <span class="sxs-lookup">
              <span data-stu-id="c3caa-1224">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1225">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1225">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1226">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1226">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1227">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1227">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1228">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1228">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1229">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1229">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1230">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1230">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1231">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1231">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1232">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1232">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1233">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1233">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1234">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1234">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1235">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1235">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1236">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1236">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1237">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1237">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1238">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1238">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1239">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1239">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1240">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1240">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1241">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1241">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1242">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1242">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1243">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1243">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1244">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1244">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1245">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1245">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1246">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1246">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1247">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1247">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1248">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1248">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1249">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1249">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1250">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1250">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1251">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1251">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1252">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1252">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1253">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1253">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1254">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1254">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1255">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1255">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1256">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1256">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1257">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1257">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1258">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1258">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1259">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1259">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1260">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1260">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1261">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1261">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1262">この要素がタッチのキャプチャを失ったときに発生する <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1262">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1263"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1263">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1264">オーバーライド<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.LostTouchCapture>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1264">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="c3caa-1265">必ず、基本クラスの<xref:System.Windows.ContentElement.OnLostTouchCapture%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1265">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1266">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1266">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1267">このイベント データは、押されたマウス ボタンおよび処理済み状態に関する詳細を報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1267">This event data reports details about the mouse button that was pressed and the handled state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1268">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1268">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1269">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1269">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1270">マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1270">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c3caa-1271">その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1271">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c3caa-1272">これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnMouseDown%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1272">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1273">可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.MouseLeftButtonDown>と<xref:System.Windows.ContentElement.MouseRightButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1273">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="c3caa-1274">これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1274">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c3caa-1275">このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1275">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c3caa-1276">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1276">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c3caa-1277">クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1277">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c3caa-1278">処理することにより<xref:System.Windows.ContentElement.OnMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1278">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="c3caa-1279">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1279">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c3caa-1280">各ボタンに固有の直接イベントもに、仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1280">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c3caa-1281">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1281">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1282">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1282">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1283">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1283">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1284">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1284">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1285">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1285">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1286">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1286">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1287">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1287">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1288">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1288">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1289">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1289">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1290">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1290">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1291">未処理の <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1291">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1292">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1292">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1293">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1293">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1294">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1294">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1295">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1295">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c3caa-1296">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1296">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1297">ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1297">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="c3caa-1298">標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1298">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1299">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1299">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1300">未処理の <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1300">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1301">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1301">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1302">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1302">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1303">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1303">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1304">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1304">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c3caa-1305">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1305">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1306">ここでは、照合イベントは、直接ルーティング戦略のルーティング イベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1306">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="c3caa-1307">標準的なインスタンス ハンドラーでも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1307">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1308">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1308">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1309">このイベント データは、マウスの左ボタンが押されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1309">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1310">この要素上で未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> ルーティング イベントが発生したときに呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1310">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span>
          </span>
          <span data-ttu-id="c3caa-1311">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1311">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1312"><xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1312">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseLeftButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="c3caa-1314">マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1314">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1315">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1315">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1316">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1316">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1317">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1317">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1318">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1318">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1319">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1319">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c3caa-1320">代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1320">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c3caa-1321">基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1321">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c3caa-1322">呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1322">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="c3caa-1323">派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>、基本実装を呼び出さずに、派生クラスでただし、この上書きを無効に、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1323">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1324">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1324">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1325">このイベント データは、マウスの左ボタンが放されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1325">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1326">未処理の <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1326">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1327">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1327">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1328"><xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1328">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseLeftButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="c3caa-1330">マークすることができますが、<xref:System.Windows.ContentElement.MouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1330">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1331">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1331">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1332">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1332">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1333">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1333">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1334">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1334">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1335">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1335">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1336">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1336">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1337">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1337">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1338">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1338">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1339">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1339">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1340">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1340">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1341">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1341">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1342">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1342">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1343">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1343">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1344">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1344">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1345">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1345">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1346">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1346">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1347">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1347">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1348">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1348">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1349">このイベント データは、マウスの右ボタンが押されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1349">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1350">未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1350">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1351">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1351">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1352"><xref:System.Windows.ContentElement.MouseRightButtonDown>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1352">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="c3caa-1354">マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1354">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1355">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1355">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1356">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1356">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1357">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1357">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1358">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1358">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1359">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1359">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c3caa-1360">代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1360">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c3caa-1361">基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1361">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c3caa-1362">呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1362">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="c3caa-1363">派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>; 呼び出し元の基本せず、派生クラスでただし、この上書きが無効になります、コンテキスト メニュー上のサービス、コントロールに含まれるの<xref:System.Windows.Controls.Control>既定の動作です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1363">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1364">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1364">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1365">このイベント データは、マウスの右ボタンが離されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1365">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1366">未処理の <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1366">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1367">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1367">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1368"><xref:System.Windows.ContentElement.MouseRightButtonUp>イベントをバブルの経路を通るが表示されますが、間接的な方法で実際に移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1368">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> 基になるイベントはバブル ルーティング、および各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="c3caa-1370">マークすることができますが、<xref:System.Windows.ContentElement.MouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1370">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1371">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1371">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1372">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1372">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1373">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1373">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1374">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1374">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1375">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1375">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1376">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1376">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1377">このイベント データは、マウス ボタンが離されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1377">The event data reports that the mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1378">未処理の <see cref="E:System.Windows.Input.Mouse.MouseUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1378">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1379">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1379">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1380">マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1380">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c3caa-1381">その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1381">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c3caa-1382">これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnMouseUp%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1382">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1383">可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.MouseLeftButtonUp>と<xref:System.Windows.ContentElement.MouseRightButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1383">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="c3caa-1384">これらのイベントのいずれかが受信側の要素に対して生成されるときに<xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1384">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c3caa-1385">このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1385">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c3caa-1386">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1386">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c3caa-1387">クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1387">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c3caa-1388">処理することにより<xref:System.Windows.ContentElement.OnMouseUp%2A>操作をすべての可能なマウス ボタンをクラス処理を記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1388">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="c3caa-1389">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1389">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c3caa-1390">各ボタンに固有の直接イベントもに、仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1390">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c3caa-1391">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1391">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1392">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1392">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1393">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1393">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1394">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1394">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1395">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1395">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1396">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1396">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1397">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1397">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1398">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1398">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1399">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1399">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1400">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1400">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1401">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1401">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1402">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1402">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1403">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1403">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1404">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1404">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1405">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1405">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1406">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1406">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1407">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1407">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1408">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1408">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1409">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1409">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1410">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1410">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1411">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1411">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1412">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1412">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1413">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1413">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1414">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1414">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1415">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1415">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1416">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1416">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1417">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1417">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1418">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1418">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1419">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1419">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1420">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1420">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1421">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1421">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1422">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1422">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1423">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1423">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1424">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1424">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1425">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1425">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1426">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1426">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1427">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1427">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1428">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1428">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1429">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1429">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1430">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1430">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1431">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1431">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1432">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1432">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1433">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1433">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1434">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1434">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1435">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1435">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1436">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1436">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1437">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1437">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1438">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1438">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1439">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1439">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1440">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1440">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1441">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1441">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1442">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1442">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1443">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1443">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1444">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1444">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1445">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1445">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1446">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1446">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1447">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1447">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1448">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1448">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1449">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1449">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1450">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1450">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1451">イベント データを格納している <see cref="T:System.Windows.DragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1451">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1452">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewDrop" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1452">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1453">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1453">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1454">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1454">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1455">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1455">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1456">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1456">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1457">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1457">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1458">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1458">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1459">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1459">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1460">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1460">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1461">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1461">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1462">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1462">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1463">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1463">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1464">イベント データを格納している <see cref="T:System.Windows.GiveFeedbackEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1464">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1465">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1465">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1466">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1466">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1467">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1467">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1468">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1468">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1469">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1469">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1470">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1471">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1471">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1472">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1472">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1473">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1473">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1474">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1474">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1475">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1475">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1476">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1476">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1477">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1477">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1478">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1478">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1479">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1479">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1480">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1480">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1481">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1481">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1482">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1482">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1483">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1483">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1484">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1484">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1485">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1485">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1486">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1486">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1487">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1487">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1488">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1488">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1489">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1489">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1490">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1490">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1491">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1491">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1492">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1492">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1493">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1493">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1494">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1494">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1495">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1495">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1496">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1496">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1497">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1497">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1498">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1498">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1499">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1499">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1500">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1500">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1501">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1501">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1502">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1502">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1503">イベント データを格納している <see cref="T:System.Windows.Input.KeyEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1503">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1504">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1504">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1505">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1505">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1506">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1506">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1507">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1507">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1508">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1508">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1509">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1509">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1510">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1510">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1511">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1511">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1512">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1512">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1513">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1513">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1514">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1514">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1515">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1515">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1516">イベント データを格納している <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1516">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1517">アタッチされた未処理の <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1517">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1518">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1518">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1519">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1519">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1520">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1520">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1521">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1521">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1522">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1523">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1523">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1524">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1524">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1525">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1525">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1526">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1526">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1527">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1527">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1528">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1528">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1529">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1529">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1530">このイベント データは、1 つ以上のマウス ボタンが押されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1530">The event data reports that one or more mouse buttons were pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1531">未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> 添付ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1531">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1532">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1532">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1533">マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1533">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c3caa-1534">その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1534">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c3caa-1535">これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1535">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1536">可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>と<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1536">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="c3caa-1537">これらのイベントのいずれかは、受信側の要素で発生する可能性がありますと<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1537">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c3caa-1538">このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1538">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c3caa-1539">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1539">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c3caa-1540">クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1540">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c3caa-1541">処理することにより<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>処理の速度のすべての可能なマウス ボタンをクラス処理を記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1541">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="c3caa-1542">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1542">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c3caa-1543">各ボタンに固有の直接イベントもに、仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1543">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c3caa-1544">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1544">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1545">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1545">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1546">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1546">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1547">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1547">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1548">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1548">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1549">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1549">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1550">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1550">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1551">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1551">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1552">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1552">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1553">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1553">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1554">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1554">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1555">このイベント データは、マウスの左ボタンが押されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1555">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1556">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1556">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1557">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1557">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1558"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1558">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="c3caa-1560">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1560">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1561">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1561">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1562">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1562">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1563">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1563">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1564">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1564">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1565">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1565">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c3caa-1566">代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1566">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c3caa-1567">基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1567">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c3caa-1568">呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1568">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="c3caa-1569">派生するなど、<xref:System.Windows.Controls.Button>オーバーライドと<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>、基本実装を呼び出さずに、派生クラスでただし、この上書きを無効に、<xref:System.Windows.Controls.Primitives.ButtonBase.Click>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1569">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1570">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1570">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1571">このイベント データは、マウスの左ボタンが放されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1571">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1572">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1572">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1573">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1573">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1574"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1574">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="c3caa-1576">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1576">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1577">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1577">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1578">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1578">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1579">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1579">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1580">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1580">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1581">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1581">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1582">イベント データを格納している <see cref="T:System.Windows.Input.MouseEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1582">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1583">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1583">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1584">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1584">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1585">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1585">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1586">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1586">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1587">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1587">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1588">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1588">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1589">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1589">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1590">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1590">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1591">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1591">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1592">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1592">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1593">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1593">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1594">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1594">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1595">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1595">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1596">このイベント データは、マウスの右ボタンが押されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1596">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1597">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1597">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1598">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1598">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1599"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1599">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> 基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.MouseRightButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="c3caa-1601">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1601">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1602">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1602">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1603">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1603">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1604">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1604">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1605">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1605">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1606">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1606">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="c3caa-1607">代わりに、特定のマウスの状態のイベント処理を変更するためにこのメソッドをオーバーライドすることができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1607">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="c3caa-1608">基本実装を呼び出すを選択するかどうかは、シナリオによって異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1608">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="c3caa-1609">呼び出すも期待する先祖のクラスでは、そのマウス イベントの既定の入力処理を無効に呼び出しに失敗<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1609">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="c3caa-1610">派生するなど、<xref:System.Windows.Controls.Control>オーバーライドと<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>; 呼び出し元の基本せず、派生クラスでただし、この上書きが無効になります、コンテキスト メニュー上のサービス、コントロールに含まれるの<xref:System.Windows.Controls.Control>既定の動作です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1610">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1611">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1611">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1612">このイベント データは、マウスの右ボタンが離されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1612">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1613">未処理の <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1613">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1614">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1614">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1615"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントは、トンネリングのルートで伝送に見えますが、実際には、間接的な方法で移動します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1615">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="c3caa-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> 基になるイベントをルーティングすると、トンネルおよび各<xref:System.Windows.ContentElement>ルートが直接ルーティング イベントを発生させると同じ処理を使用、イベントに沿った<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="c3caa-1617">マークすることができますが、<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>イベントをこの要素の目的の処理、処理済みの状態はイベント ルート上の他の要素は永続化されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1617">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="c3caa-1618">イベントを全般インスタンス ハンドラーを防ぐために処理済みとしてマークするただし、(を指定しなかったもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1618">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1619">一般的なマウスのイベント処理の既定の実装<xref:System.Windows.ContentElement>リッスン<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>適切なローカル イベントに変換します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1619">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="c3caa-1620">このロジックをオーバーライドする場合は、派生クラスを作成する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1620">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="c3caa-1621">派生クラスの静的コンス トラクター内の代替クラス ハンドラーを登録<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1621">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c3caa-1622">マウスの処理の動作を変更することはできません<xref:System.Windows.ContentElement>オーバーライドすることで<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1622">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1623">イベント データを格納している <see cref="T:System.Windows.Input.MouseButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1623">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="c3caa-1624">このイベント データは、1 つ以上のマウス ボタンが離されたことを報告します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1624">The event data reports that one or more mouse buttons were released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1625">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1625">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1626">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1626">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1627">マウス ボタンの動作は、専用の入力マネージャーによっても処理されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1627">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="c3caa-1628">その他のプログラミング機能の入力など、マウス ボタンの動作に依存し、バインディングのコマンドは、一般的なマウス ボタンの操作として公開される前に、アクションのハンドラーを呼び出す可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1628">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="c3caa-1629">これらの入力システム機能マーク場合、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベントを処理するには、<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>は呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1629">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="c3caa-1630">可能性のある、次のイベントに影響するイベントを処理済みとしてマークをこのクラスのハンドラーを使用する場合:<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>と<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1630">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="c3caa-1631">これらのイベントのいずれかが受信側の要素に対して生成されるときに<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>を受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1631">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="c3caa-1632">このイベントを処理するクラスで処理済みのマークを付けた場合サブイベントも発生します。ただし、イベント データの処理済みの状態を通過するとします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1632">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="c3caa-1633">明示的に使用する場合を除き、サブイベントのインスタンス ハンドラーが呼び出されませんクラス処理でイベントを処理すると場合、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>で`handledEventsToo``true`ハンドラーをアタッチするためにします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1633">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="c3caa-1634">クラス ハンドラーも呼び出されないと、クラス ハンドラーが登録されていない限り、<xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>による署名`handledEventsToo``true`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1634">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="c3caa-1635">処理することにより<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>操作をすべての可能なマウス ボタンをクラス処理を記述することを示すは。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1635">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="c3caa-1636">この動作が望ましくない可能性があります。そのため、この仮想メソッドを使用してイベントを処理済みとしてマークする場合は、注意を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1636">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="c3caa-1637">各ボタンに固有の直接イベントもに、仮想 \* メソッドです。かどうかこれらのボタンに固有のクラスのハンドラーをオーバーライドする場合がありますより適切な検討してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1637">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="c3caa-1638">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1638">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1639">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1639">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1640">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1640">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1641">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1641">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1642">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1642">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1643">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1643">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1644">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1644">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1645">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1645">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1646">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1646">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1647">イベント データを格納している <see cref="T:System.Windows.Input.MouseWheelEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1647">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1648">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1648">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1649">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1649">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1650">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1650">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1651">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1651">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1652">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1652">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1653">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1653">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1654">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1654">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1655">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1655">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1656">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1656">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1657">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1657">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1658">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1658">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1659">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1659">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1660">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1660">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1661">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1661">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1662">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1662">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1663">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1663">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1664">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1664">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1665">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1665">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1666">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1666">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1667">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1667">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1668">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1668">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1669">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1669">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1670">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1670">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1671">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1671">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1672">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1672">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1673">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1673">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1674">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1674">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1675">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1675">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1676">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1676">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1677">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1677">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1678">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1678">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1679">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1679">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1680">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1680">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1681">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1681">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1682">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1682">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1683">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1683">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1684">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1684">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1685">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1685">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1686">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1686">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1687">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1687">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1688">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1688">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1689">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1689">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1690">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1690">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1691">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1691">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1692">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1692">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1693">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1693">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1694">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1694">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1695">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1695">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1696">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1696">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1697">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1697">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1698">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1698">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1699">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1699">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1700">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1700">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1701">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1701">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1702">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1702">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1703">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1703">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1704">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1704">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1705">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1705">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1706">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1706">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1707">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1707">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1708">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1708">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1709">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1709">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1710">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1710">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1711">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1711">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1712">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1712">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1713">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1713">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1714">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1714">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1715">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1715">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1716">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1716">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1717">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1717">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1718">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1718">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1719">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1719">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1720">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1720">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1721">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1721">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1722">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1722">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1723">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1723">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1724">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1724">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1725">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1725">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1726">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1726">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1727">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1727">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1728">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1728">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1729">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1729">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1730">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1730">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1731">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1731">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1732">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1732">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1733">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1733">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1734">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1734">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1735">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1735">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1736">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1736">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1737">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1737">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1738">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1738">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1739">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1739">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1740">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1740">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1741">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1741">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1742">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1742">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1743">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1743">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1744">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1744">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1745">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1745">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1746">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1746">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1747">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1747">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1748">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1748">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1749">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1749">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1750">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1750">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1751">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1751">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1752">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1752">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1753">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1753">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1754">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1754">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1755">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1755">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1756">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1756">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1757">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1757">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1758">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1758">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1759">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1759">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1760">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1760">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1761">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1761">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1762">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1762">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1763">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1763">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1764">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1764">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1765">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1765">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1766">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1766">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1767">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1767">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1768">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1768">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1769">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1769">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1770">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1770">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1771">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1771">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1772">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1772">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1773">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1773">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1774">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1774">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1775">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1775">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1776">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1776">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1777">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1777">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1778">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1778">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1779">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1779">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1780">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1780">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1781">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1781">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1782">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1782">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1783">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1783">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1784">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1784">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1785">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1785">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1786">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1786">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1787">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1787">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1788">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1788">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1789">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1789">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1790">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1790">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1791">アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1791">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1792">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1792">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1793">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1793">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1794">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1794">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1795">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1795">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1796">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1796">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1797">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1797">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1798">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1798">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1799">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1799">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1800">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1800">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1801">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1801">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="c3caa-1802">プレビュー イベントを具体的には、もう 1 つのシナリオでは、マークして処理されるように、一致するバブル クラス ハンドラーは呼び出されません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1802">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1803">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1803">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1804">この要素がタッチで押されたときに発生する <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1804">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1805"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1805">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1806">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchDown>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1806">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="c3caa-1807">必ず、基本クラスの<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1807">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1808">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1808">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1809">タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1809">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1810"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1810">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1811">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchMove>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1811">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="c3caa-1812">必ず、基本クラスの<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1812">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1813">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1813">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1814">この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1814">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1815"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1815">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1816">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.PreviewTouchUp>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1816">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="c3caa-1817">必ず、基本クラスの<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1817">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1818">イベント データを格納している <see cref="T:System.Windows.QueryContinueDragEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1818">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1819">アタッチされた未処理の <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1819">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1820">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1820">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1821">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1821">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1822">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1822">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1823">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1823">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1824">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1824">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1825">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1825">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1826">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1826">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1827">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1827">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1828">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1828">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1829">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1829">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1830">イベント データを格納している <see cref="T:System.Windows.Input.QueryCursorEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1830">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1831">アタッチされた未処理の <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1831">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1832">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1832">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1833">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1833">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1834">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1834">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1835">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1835">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1836">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1836">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1837">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1837">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1838">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1838">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1839">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1839">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1840">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1840">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1841">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1841">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1842">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1842">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1843">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1843">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1844">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1844">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1845">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1845">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1846">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1846">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1847">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1847">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1848">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1848">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1849">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1849">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1850">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1850">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1851">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1851">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1852">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1852">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1853">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1853">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1854">イベント データを格納している <see cref="T:System.Windows.Input.StylusButtonEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1854">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1855">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1855">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1856">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1856">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1857">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1857">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1858">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1858">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1859">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1859">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1860">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1860">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1861">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1861">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1862">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1862">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1863">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1863">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1864">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1864">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1865">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1865">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1866">イベント データを格納している <see cref="T:System.Windows.Input.StylusDownEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1866">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1867">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusDown" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1867">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1868">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1868">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1869">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1869">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1870">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1870">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1871">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1871">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1872">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1872">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1873">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1873">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1874">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1874">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1875">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1875">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1876">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1876">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1877">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1877">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1878">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1878">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1879">未処理の <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> 添付イベントがこの要素で発生したときに呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1879">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="c3caa-1880">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1880">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1881">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1881">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1882">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1882">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1883">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1883">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c3caa-1884">このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1884">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1885">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1885">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1886">通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1886">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1887">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1887">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1888">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1888">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1889">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1889">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1890">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1890">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1891">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1891">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1892">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1892">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1893">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1893">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1894">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1894">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1895">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1895">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1896">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1896">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1897">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1897">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1898">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1898">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1899">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1899">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1900">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1900">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1901">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1901">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1902">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1902">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1903">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1903">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1904">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1904">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1905">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1905">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1906">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1906">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1907">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1907">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1908">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1908">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1909">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1909">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1910">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1910">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1911">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1911">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1912">未処理の <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> 添付イベントがこの要素で発生したときに呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1912">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="c3caa-1913">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1913">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1914">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1914">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1915">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1915">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="c3caa-1916">呼び出すことが基本の前に、または後に特別な処理の要件に応じて、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1916">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="c3caa-1917">このメソッドの目的はのような[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1917">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1918">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1918">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1919">通常のインスタンス ハンドラーを禁止する場合にも役立ちますが、イベントを処理済みとしてマーク (が指定されていないもの`handledEventsToo`) が呼び出されているからです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1919">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1920">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1920">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1921">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusMove" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1921">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1922">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1922">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1923">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1923">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1924">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1924">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1925">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1925">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1926">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1926">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1927">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1927">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1928">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1928">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1929">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1929">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1930">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1930">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1931">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1931">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1932">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1932">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1933">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1933">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1934">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1934">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1935">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1935">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1936">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1936">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1937">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1937">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1938">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1938">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1939">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1939">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1940">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1940">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1941">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1941">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1942">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1942">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1943">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1943">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1944">イベント データを格納している <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1944">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1945">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1945">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1946">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1946">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1947">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1947">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1948">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1948">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1949">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1949">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1950">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1950">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1951">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1951">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1952">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1952">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1953">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1953">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1954">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1954">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1955">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1955">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1956">イベント データを格納している <see cref="T:System.Windows.Input.StylusEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1956">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1957">アタッチされた未処理の <see cref="E:System.Windows.Input.Stylus.StylusUp" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1957">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1958">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1958">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1959">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1959">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1960">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1960">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1961">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1961">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1962">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1962">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1963">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1963">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1964">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1964">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1965">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1965">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1966">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1966">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1967">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1967">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1968">イベント データを格納している <see cref="T:System.Windows.Input.TextCompositionEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1968">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1969">アタッチされた未処理の <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> イベントが、そのルート上で、このクラスから派生した要素に到達すると呼び出されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1969">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="c3caa-1970">このイベントに対するクラス処理を追加するには、このメソッドを実装します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1970">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1971">このメソッドには、既定の実装ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1971">This method has no default implementation.</span></span> <span data-ttu-id="c3caa-1972">継承の中間クラスには、このメソッドを実装可能性があります、ため、実装で基底の実装を呼び出すことをお勧めします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1972">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="c3caa-1973">このメソッドの目的がに似ていますが、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]でのイベント パターン \* メソッド: このメソッドは、インスタンス ハンドラーではなく、クラス ハンドラーを確立することによって派生クラスからの一致するイベントを処理するための手段を提供します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1973">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="c3caa-1974">ここでは、照合イベントは、ルーティングされたイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1974">In this case the matching event is a routed event.</span></span> <span data-ttu-id="c3caa-1975">On のメソッドの実装パターンは、必ずしもハンドラーを呼び出すの要素ではない子要素で、ルーティングされたイベントを発生させるためのルーティング イベントに異なります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1975">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="c3caa-1976">そのため、実装には、イベント データのソースのプロパティを点検する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1976">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="c3caa-1977">ほとんどの場合、イベントを reraise にはいけません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1977">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="c3caa-1978">ハンドラーのクラスか、このメソッドをオーバーライドすることで登録することによって<xref:System.Windows.EventManager.RegisterClassHandler%2A>、派生クラスの<xref:System.Windows.ContentElement>イベント ルート上でイベントが受け取られると、プライベート クラス ハンドラー メソッドを呼び出すことができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1978">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="c3caa-1979">イベント データを操作し、ルーティングされたイベントを処理済みとしてマークする 1 つのシナリオがクラス処理が適切です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1979">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1980">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1980">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1981">この要素の内部がタッチで押されたときに発生する <see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1981">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1982"><xref:System.Windows.ContentElement.OnTouchDown%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1982">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1983">オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchDown>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1983">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="c3caa-1984">必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchDown%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1984">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1985">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1985">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1986">この要素の境界の外部から内部にタッチが移動したときに発生する <see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1986">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1987"><xref:System.Windows.ContentElement.OnTouchEnter%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1987">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1988">オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchEnter>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1988">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="c3caa-1989">必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchEnter%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1989">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1990">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1990">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1991">この要素の境界の内部から外部にタッチが移動したときに発生する <see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1991">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1992"><xref:System.Windows.ContentElement.OnTouchLeave%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1992">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1993">オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchLeave>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1993">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="c3caa-1994">必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchLeave%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1994">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-1995">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1995">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-1996">タッチがこの要素の内部にある間にタッチが移動すると発生する <see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-1996">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-1997"><xref:System.Windows.ContentElement.OnTouchMove%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1997">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-1998">オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchMove>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1998">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="c3caa-1999">必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchMove%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-1999">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-2000">イベント データを格納している <see cref="T:System.Windows.Input.TouchEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2000">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-2001">この要素の内部のタッチが解放されたときに発生する <see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントのクラス処理を提供します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2001">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2002"><xref:System.Windows.ContentElement.OnTouchUp%2A>メソッドに既定の実装がありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2002">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="c3caa-2003">オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>を処理する派生クラスで、<xref:System.Windows.ContentElement.TouchUp>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2003">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="c3caa-2004">必ず、基本クラスの<xref:System.Windows.ContentElement.OnTouchUp%2A>を基底クラス メソッドがイベントを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2004">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="c3caa-2005">要求したフォーカス検査の方向。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2005">The direction of the requested focus traversal.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-2006">派生クラスでオーバーライドされると、指定したフォーカス検査方向のフォーカスを受け取ることになる要素を返します。実際にはフォーカスはその要素に移動しません。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2006">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-2007">
            <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> が実際に呼び出された場合にフォーカスを受け取る要素。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2007">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2008">このクラスでこのメソッドの既定の実装は完了せず、常に返します`null`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2008">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2009">この要素をドラッグ先とする、基になるドラッグ イベントが入力システムによって報告されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2009">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2010">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDragEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2010">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2011">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragEnter>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2011">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2012">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2012">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2013">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2013">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="c3caa-2014">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2014">Routing strategy</span></span>|<span data-ttu-id="c3caa-2015">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2015">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2016">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2016">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-2017">バブルの対応するイベントが<xref:System.Windows.ContentElement.DragEnter>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2017">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="c3caa-2018">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2018">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2019">
            <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2019">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2020">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2020">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2021">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2021">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2022">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2022">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2023">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2023">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2024">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2024">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2025">入力システムが、この要素をドラッグ元とする、基になるドラッグ イベントを報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2025">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2026">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDragLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2026">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2027">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragLeave>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2027">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2028">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2028">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2029">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2029">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="c3caa-2030">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2030">Routing strategy</span></span>|<span data-ttu-id="c3caa-2031">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2031">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2032">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2032">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-2033">バブルの対応するイベントが<xref:System.Windows.ContentElement.DragLeave>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2033">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="c3caa-2034">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2034">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2035">
            <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2035">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2036">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2036">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2037">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2037">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2038">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2038">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2039">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2039">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2040">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2040">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2041">この要素がドロップ先となる可能性のある、基になるドラッグ イベントを入力システムが報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2041">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2042">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDragOver>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2042">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2043">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDragOver>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2043">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2044">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2044">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2045">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2045">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="c3caa-2046">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2046">Routing strategy</span></span>|<span data-ttu-id="c3caa-2047">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2047">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2048">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2048">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-2049">バブルの対応するイベントが<xref:System.Windows.ContentElement.DragOver>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2049">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="c3caa-2050">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDragOver%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2050">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2051">
            <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2051">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2052">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2052">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2053">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2053">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2054">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2054">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2055">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2055">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2056">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2056">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2057">入力システムがこの要素をドロップ先とするドロップ イベントを報告したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2057">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2058">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewDrop>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2058">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2059">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewDrop>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2059">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2060">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2060">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2061">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2061">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="c3caa-2062">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2062">Routing strategy</span></span>|<span data-ttu-id="c3caa-2063">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2063">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2064">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2064">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="c3caa-2065">バブルの対応するイベントが<xref:System.Windows.ContentElement.Drop>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2065">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="c3caa-2066">オーバーライド<xref:System.Windows.ContentElement.OnPreviewDrop%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2066">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2067">
            <see cref="E:System.Windows.ContentElement.PreviewDrop" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2067">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2068">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2068">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2069">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2069">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2070">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2070">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2071">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2071">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2072">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2072">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2073">ドラッグ アンド ドロップ操作が開始されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2073">Occurs when a drag-and-drop operation is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2074"><xref:System.Windows.ContentElement.PreviewGiveFeedback>イベントにより、ドラッグ アンド ドロップ操作中にユーザーに視覚的フィードバックを提供するためにマウス ポインターの外観を変更するドラッグ イベントのソース。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2074">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="c3caa-2075">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewGiveFeedback>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2075">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2076">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewGiveFeedback>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2076">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2077">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2077">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2078">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2078">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="c3caa-2079">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2079">Routing strategy</span></span>|<span data-ttu-id="c3caa-2080">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2080">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2081">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2081">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="c3caa-2082">バブルの対応するイベントが<xref:System.Windows.ContentElement.GiveFeedback>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2082">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="c3caa-2083">オーバーライド<xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2083">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2084">
            <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2084">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2085">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2085">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2086">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2086">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2087">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2087">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2088">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2088">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2089">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2089">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2090">この要素にキーボード フォーカスが移動したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2090">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2091">このイベントは、ルーティング トンネリングを使用するため、フォーカスを持つ要素は、イベント ハンドラーが実際に添付されている要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2091">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-2092">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスのある実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2092">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="c3caa-2093">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2093">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2094">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2094">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2095">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2095">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2096">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2096">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="c3caa-2097">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2097">Routing strategy</span></span>|<span data-ttu-id="c3caa-2098">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2098">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2099">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2099">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c3caa-2100">バブルの対応するイベントが<xref:System.Windows.ContentElement.GotKeyboardFocus>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2100">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c3caa-2101">オーバーライド<xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2101">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2102">
            <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2102">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2103">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2103">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2104">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2104">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2105">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2105">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2106">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2106">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2107">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2107">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2108">この要素にキーボード フォーカスがある状態でいずれかのキーが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2108">Occurs when a key is pressed while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2109">キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2109">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="c3caa-2110"><xref:System.Windows.ContentElement.KeyDown>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2110">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="c3caa-2111">これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2111">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="c3caa-2112">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewKeyDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2112">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2113">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewKeyDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2113">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2114">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2114">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2115">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2115">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="c3caa-2116">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2116">Routing strategy</span></span>|<span data-ttu-id="c3caa-2117">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2117">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2118">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2118">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c3caa-2119">バブルの対応するイベントが<xref:System.Windows.ContentElement.KeyDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2119">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2120">オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2120">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2121">
            <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2121">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2122">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2122">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2123">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2123">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2124">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2124">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2125">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2125">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2126">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2126">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2127">この要素にキーボード フォーカスがある状態でキーが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2127">Occurs when a key is released while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2128">キーの処理は、コマンド実行やテキストの合成などの他のプラットフォーム機能と対話します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2128">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="c3caa-2129"><xref:System.Windows.ContentElement.KeyUp>イベントは、下位レベルのテキスト入力イベントを特定のコントロールで期待どおりに動作しない可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2129">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="c3caa-2130">これは、一部のコントロールがコントロールの複合か、テキストの上位レベルのバージョンを提供するクラスの処理が処理を入力し、関連するイベントです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2130">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="c3caa-2131">詳細については、個々 のコントロールのマニュアルを確認します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2131">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="c3caa-2132">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewKeyUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2132">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2133">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewKeyUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2133">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2134">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2134">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2135">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2135">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="c3caa-2136">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2136">Routing strategy</span></span>|<span data-ttu-id="c3caa-2137">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2137">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2138">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2138">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="c3caa-2139">バブルの対応するイベントが<xref:System.Windows.ContentElement.KeyUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2139">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2140">オーバーライド<xref:System.Windows.ContentElement.OnPreviewKeyUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2140">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2141">
            <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2141">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2142">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2142">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2143">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2143">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2144">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2144">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2145">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2145">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2146">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2146">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2147">この要素からキーボード フォーカスが離れたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2147">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2148">このイベントは、ルーティング トンネリングを使用しているために、フォーカスを失った要素は、イベント ハンドラーが実際に添付されている、要素ではなく子要素である可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2148">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="c3caa-2149">チェック、<xref:System.Windows.RoutedEventArgs.Source%2A>フォーカスが失われた実際の要素を特定のイベント データ。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2149">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="c3caa-2150">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2150">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2151">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2151">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2152">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2152">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2153">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2153">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="c3caa-2154">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2154">Routing strategy</span></span>|<span data-ttu-id="c3caa-2155">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2155">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2156">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2156">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="c3caa-2157">バブルの対応するイベントが<xref:System.Windows.ContentElement.LostKeyboardFocus>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2157">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="c3caa-2158">オーバーライド<xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2158">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2159">
            <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2159">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2160">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2160">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2161">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2161">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2162">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2162">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2163">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2163">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2164">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2164">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2165">この要素の上にポインターがある状態でマウス ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2165">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2166">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2166">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2167">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2167">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2168"><xref:System.Windows.ContentElement.PreviewMouseDown>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2168">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c3caa-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c3caa-2170">「解説」を参照してください<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2170">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2171">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2171">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2172">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2172">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="c3caa-2173">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2173">Routing strategy</span></span>|<span data-ttu-id="c3caa-2174">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2174">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2175">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2175">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2176">バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2176">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2177">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2177">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2178">
            <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2178">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2179">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2179">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2180">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2180">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2181">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2181">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2182">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2182">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2183">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2183">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2184">この要素の上にマウス ポインターがある状態でマウスの左ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2184">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2185">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2185">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-2186">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2186">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-2187">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2187">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-2188">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2188">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-2189">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2189">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-2190">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2190">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-2191">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2191">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2192">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2192">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2193">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2193">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="c3caa-2194">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2194">Routing strategy</span></span>|<span data-ttu-id="c3caa-2195">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2195">Direct</span></span>|  
|<span data-ttu-id="c3caa-2196">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2196">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2197">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2197">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2198">
            <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2198">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2199">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2199">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2200">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2200">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2201">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2201">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2202">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2202">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2203">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2203">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2204">この要素の上にマウス ポインターがある状態でマウスの左ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2204">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2205">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2205">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-2206">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2206">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-2207">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2207">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-2208">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2208">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-2209">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2209">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-2210">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2210">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-2211">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2211">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2212">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2212">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2213">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2213">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="c3caa-2214">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2214">Routing strategy</span></span>|<span data-ttu-id="c3caa-2215">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2215">Direct</span></span>|  
|<span data-ttu-id="c3caa-2216">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2216">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2217">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2217">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2218">
            <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2218">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2219">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2219">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2220">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2220">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2221">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2221">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2222">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2222">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2223">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2223">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2224">この要素上でマウス ポインターが動かされたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2224">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2225">このイベントは、どちらも要素の境界にマウス ポインターを最初に入力し、マウス ポインターが要素の境界内に残っているときに移動するともします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2225">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="c3caa-2226">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2226">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2227">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2227">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2228">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2228">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2229">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2229">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="c3caa-2230">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2230">Routing strategy</span></span>|<span data-ttu-id="c3caa-2231">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2231">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2232">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2232">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="c3caa-2233">バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2233">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2234">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2234">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2235">
            <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2235">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2236">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2236">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2237">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2237">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2238">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2238">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2239">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2239">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2240">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2240">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2241">この要素の上にマウス ポインターがある状態でマウスの右ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2241">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2242">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2242">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-2243">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2243">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-2244">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2244">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-2245">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2245">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-2246">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2246">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-2247">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2247">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-2248">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2248">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2249">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2249">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2250">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2250">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="c3caa-2251">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2251">Routing strategy</span></span>|<span data-ttu-id="c3caa-2252">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2252">Direct</span></span>|  
|<span data-ttu-id="c3caa-2253">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2253">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2254">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2254">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2255">
            <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2255">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2256">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2256">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2257">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2257">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2258">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2258">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2259">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2259">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2260">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2260">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2261">この要素の上にマウス ポインターがある状態でマウスの右ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2261">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2262">この[ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)、要素ツリーを通じてトンネリングのルートに従うように見えますが発生し、各によって、要素ツリーに沿って reraised を直接ルーティング イベントを実際には<xref:System.Windows.ContentElement>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2262">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="c3caa-2263">このイベントは、基になるのマウス ボタンの詳細を報告する複数の関連イベントの 1 つ<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント ルート上の各要素によって処理される添付イベントがイベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2263">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="c3caa-2264">このイベントの引数を公開、基になる引数<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2264">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c3caa-2265">そのイベントがイベント ルート上処理済みとしてマークすると、マウス ボタンの特定のイベントも発生します。ただし、明示的に呼び出すことによって、マウス ボタンの特定のイベント ハンドラーを追加する必要があります<xref:System.Windows.ContentElement.AddHandler%2A>、処理済みとしてマークされているイベントを処理する、イベント リスナーをするために、オプションを使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2265">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="c3caa-2266">概念的には、このイベントの待ち時間 (やその他のマウス ボタンのイベントに<xref:System.Windows.ContentElement>) マウス「サービス」である (によって提供される、サービス定義で、<xref:System.Windows.Input.Mouse>クラス)。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2266">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="c3caa-2267">イベントは、イベント データの元のマウス イベントのマウス ボタンの状態 (左から右に、アップダウン) を確認する必要はないの利便性を追加します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2267">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="c3caa-2268">非標準のボタンの状態のチェックなどの高度なシナリオを使用する必要があります、[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]上、<xref:System.Windows.Input.Mouse>ものではなくクラスに対する<xref:System.Windows.ContentElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2268">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2269">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2270">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2270">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="c3caa-2271">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2271">Routing strategy</span></span>|<span data-ttu-id="c3caa-2272">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2272">Direct</span></span>|  
|<span data-ttu-id="c3caa-2273">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2273">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2274">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2274">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2275">
            <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2275">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2276">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2276">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2277">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2277">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2278">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2278">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2279">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2279">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2280">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2280">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2281">この要素の上にマウス ポインターがある状態でいずれかのマウス ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2281">Occurs when any mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2282">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2282">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2283">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2283">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2284"><xref:System.Windows.ContentElement.PreviewMouseUp>イベントは、多くの場合、いずれかと共に<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>、2 つの標準のマウス ボタンのいずれかのキーを押してに対応します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2284">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="c3caa-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>も、ルーティング イベントをしています直接ルーティング イベントを適切なボタンに固有のイベントが発生したときに、<xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>イベント イベント ルート上には、この要素に到達します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="c3caa-2286">「解説」を参照してください<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>または<xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2286">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2287">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2287">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2288">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2288">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="c3caa-2289">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2289">Routing strategy</span></span>|<span data-ttu-id="c3caa-2290">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2290">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2291">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2291">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2292">バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2292">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2293">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2293">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2294">
            <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2294">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2295">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2295">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2296">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2296">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2297">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2297">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2298">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2298">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2299">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2299">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2300">この要素の上にマウス ポインターがある状態でユーザーがマウス ホイールを使用したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2300">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2301">フォーカスまたはマウスのキャプチャ、マウス ポインターが; よりも優先します。このため、対象を絞ったまたはキャプチャした要素からこのイベントを受信する場合、マウス ポインター実際にあります別の要素上です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2301">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="c3caa-2302">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewMouseMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2302">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2303">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewMouseMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2303">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2304">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2305">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2305">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="c3caa-2306">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2306">Routing strategy</span></span>|<span data-ttu-id="c3caa-2307">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2307">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2308">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2308">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="c3caa-2309">バブルの対応するイベントが<xref:System.Windows.ContentElement.MouseWheel>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2309">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="c3caa-2310">オーバーライド<xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2310">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2311">
            <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2311">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2312">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2313">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2314">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2315">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2316">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2317">ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2317">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2318"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを宣言します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2318">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="c3caa-2319">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2319">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2320">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2320">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2321">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2321">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2322">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2322">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="c3caa-2323">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2323">Routing strategy</span></span>|<span data-ttu-id="c3caa-2324">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2324">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2325">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2325">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="c3caa-2326">バブルの対応するイベントが<xref:System.Windows.ContentElement.QueryContinueDrag>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2326">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="c3caa-2327">オーバーライド<xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2327">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2328">
            <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2328">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2329">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2329">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2330">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2330">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2331">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2331">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2332">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2332">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2333">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2333">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2334">この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2334">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2335">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2335">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2336">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusButtonDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2336">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2337">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2337">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2338">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2338">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2339">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2339">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2340">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2340">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="c3caa-2341">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2341">Routing strategy</span></span>|<span data-ttu-id="c3caa-2342">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2342">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2343">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2343">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2344">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2344">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2345">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2345">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2346">
            <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2346">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2347">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2347">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2348">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2348">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2349">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2349">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2350">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2350">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2351">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2351">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2352">この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2352">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2353">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2353">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2354">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusButtonUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2354">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2355">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2355">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2356">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2356">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2357">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2357">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2358">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2358">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="c3caa-2359">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2359">Routing strategy</span></span>|<span data-ttu-id="c3caa-2360">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2360">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2361">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2361">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2362">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2362">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2363">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2363">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2364">
            <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2364">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2365">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2365">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2366">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2366">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2367">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2367">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2368">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2368">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2369">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2369">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2370">この要素上でスタイラスがデジタイザーに触れたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2370">Occurs when the stylus touches the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2371">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2371">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2372">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2372">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2373">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2373">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2374">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2374">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2375">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2375">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2376">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2376">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="c3caa-2377">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2377">Routing strategy</span></span>|<span data-ttu-id="c3caa-2378">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2378">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2379">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2379">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="c3caa-2380">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2380">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2381">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2381">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2382">
            <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2382">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2383">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2383">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2384">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2384">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2385">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2385">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2386">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2386">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2387">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2387">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2388">デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2388">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2389">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2389">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2390">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusInAirMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2390">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2391">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2391">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2392">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2392">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2393">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2393">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2394">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2394">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="c3caa-2395">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2395">Routing strategy</span></span>|<span data-ttu-id="c3caa-2396">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2396">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2397">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2397">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2398">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusInAirMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2398">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2399">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2399">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2400">
            <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2400">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2401">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2401">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2402">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2402">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2403">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2403">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2404">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2404">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2405">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2405">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2406">この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2406">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2407">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2407">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2408">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusInRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2408">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2409">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2409">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2410">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2410">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2411">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2411">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2412">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2412">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="c3caa-2413">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2413">Routing strategy</span></span>|<span data-ttu-id="c3caa-2414">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2414">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2415">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2415">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2416">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusInRange>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2416">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="c3caa-2417">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2417">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2418">
            <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2418">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2419">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2419">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2420">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2420">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2421">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2421">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2422">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2422">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2423">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2423">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2424">要素上にある間にスタイラスが移動すると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2424">Occurs when the stylus moves while over the element.</span>
          </span>
          <span data-ttu-id="c3caa-2425">このイベントを発生させるためには、デジタイザーによって検出されている間にスタイラスが移動する必要があります。それ以外の場合には、代わりに <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> が発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2425">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2426">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2426">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2427">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2427">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2428">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2428">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2429">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2429">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2430">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2430">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2431">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2431">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="c3caa-2432">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2432">Routing strategy</span></span>|<span data-ttu-id="c3caa-2433">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2433">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2434">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2434">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2435">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2435">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2436">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2436">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2437">
            <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2437">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2438">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2438">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2439">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2439">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2440">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2440">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2441">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2441">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2442">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2442">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2443">スタイラスがデジタイザーから離れすぎているために検出されないときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2443">Occurs when the stylus is too far from the digitizer to be detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2444">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2444">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2445">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2445">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2446">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2446">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2447">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2447">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2448">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2448">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2449">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2449">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="c3caa-2450">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2450">Routing strategy</span></span>|<span data-ttu-id="c3caa-2451">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2451">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2452">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2452">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2453">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusOutOfRange>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2453">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="c3caa-2454">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2454">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2455">
            <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2455">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2456">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2456">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2457">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2457">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2458">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2458">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2459">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2459">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2460">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2460">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2461">ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2461">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2462">スタイラス ジェスチャの詳細については、次を参照してください。<xref:System.Windows.Input.SystemGesture>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2462">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="c3caa-2463">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2463">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2464">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2464">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2465">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2465">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2466">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2466">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2467">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2467">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2468">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2468">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="c3caa-2469">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2469">Routing strategy</span></span>|<span data-ttu-id="c3caa-2470">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2470">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2471">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2471">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="c3caa-2472">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusSystemGesture>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2472">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="c3caa-2473">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2473">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2474">
            <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2474">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2475">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2475">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2476">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2476">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2477">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2477">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2478">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2478">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2479">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2479">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2480">ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2480">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2481">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewStylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2481">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2482">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewStylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2482">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2483">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2483">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2484">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2484">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2485">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2485">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2486">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2486">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="c3caa-2487">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2487">Routing strategy</span></span>|<span data-ttu-id="c3caa-2488">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2488">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2489">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2489">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2490">バブルの対応するイベントが<xref:System.Windows.ContentElement.StylusUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2490">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2491">オーバーライド<xref:System.Windows.ContentElement.OnPreviewStylusUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2491">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2492">
            <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2492">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2493">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2493">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2494">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2494">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2495">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2495">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2496">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2496">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2497">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2497">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2498">この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2498">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2499"><xref:System.Windows.ContentElement.PreviewTextInput>イベントにより、コンポーネントまたはアプリケーションをデバイスに依存しない方法で、テキスト入力をリッスンします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2499">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="c3caa-2500">キーボードは、主要な手段の<xref:System.Windows.ContentElement.PreviewTextInput>; が、音声認識、手書き認識、およびその他の入力デバイスも<xref:System.Windows.ContentElement.PreviewTextInput>します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2500">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="c3caa-2501">キーの組み合わせのため、既定のキーボードまたは入力方式エディターから — 複数のキー イベントが 1 つだけのテキスト入力イベントを発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2501">Because of key combinations—either in default keyboards or through input method editors—multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="c3caa-2502">このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.PreviewTextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2502">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2503">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.PreviewTextInput>イベントが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2503">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2504">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2504">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2505">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2505">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="c3caa-2506">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2506">Routing strategy</span></span>|<span data-ttu-id="c3caa-2507">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2507">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2508">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2508">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="c3caa-2509">バブルの対応するイベントが<xref:System.Windows.ContentElement.TextInput>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2509">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="c3caa-2510">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTextInput%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2510">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2511">
            <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2511">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2512">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2512">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2513">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2513">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2514">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2514">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2515">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2515">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2516">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2516">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2517">指がこの要素の上にある間に、その指で画面に触れると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2517">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2518">既定では、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>指が画面に触れるし、移動するまでのイベントが発生しません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2518">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="c3caa-2519">画面に指を押すと、キーを押すと、移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2519">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="c3caa-2520">プレス アンド ホールド動作は、マウスの右クリックに相当します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2520">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="c3caa-2521">により、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>、画面に触れると発生するイベントを設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティ`false`この要素のです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2521">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2522">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2522">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2523">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2523">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="c3caa-2524">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2524">Routing strategy</span></span>|<span data-ttu-id="c3caa-2525">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2525">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2526">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2526">Delegate</span></span>|<span data-ttu-id="c3caa-2527"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2527"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2528">バブルの対応するイベントが<xref:System.Windows.ContentElement.TouchDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2528">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2529">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2529">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2530">
            <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2530">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2531">この要素の上に指があるときに、その指を画面上で動かすと発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2531">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2532">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2532">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2533">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2533">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="c3caa-2534">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2534">Routing strategy</span></span>|<span data-ttu-id="c3caa-2535">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2535">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2536">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2536">Delegate</span></span>|<span data-ttu-id="c3caa-2537"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2537"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2538">バブルの対応するイベントが<xref:System.Windows.ContentElement.TouchMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2538">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2539">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2539">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2540">
            <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2540">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2541">この要素の上に指があるときに、その指が画面から離れると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2541">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2542">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2542">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2543">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2543">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="c3caa-2544">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2544">Routing strategy</span></span>|<span data-ttu-id="c3caa-2545">トンネリング</span><span class="sxs-lookup"><span data-stu-id="c3caa-2545">Tunneling</span></span>|  
|<span data-ttu-id="c3caa-2546">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2546">Delegate</span></span>|<span data-ttu-id="c3caa-2547"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2547"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2548">バブルの対応するイベントが<xref:System.Windows.ContentElement.TouchUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2548">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2549">オーバーライド<xref:System.Windows.ContentElement.OnPreviewTouchUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2549">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2550">
            <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2550">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2551">ドラッグ アンド ドロップ操作の実行中にキーボードまたはマウス ボタンの状態が変化したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2551">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2552"><xref:System.Windows.ContentElement.QueryContinueDrag>イベントにより、ドラッグ ソースがドラッグ アンド ドロップ操作を取り消す必要があるかどうかを判断します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2552">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="c3caa-2553">このイベントのエイリアスを作成する、<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.QueryContinueDrag>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2553">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2554">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.QueryContinueDrag>イベントが、基になるに関連付けられている<xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2554">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2555">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2555">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2556">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2556">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="c3caa-2557">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2557">Routing strategy</span></span>|<span data-ttu-id="c3caa-2558">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2558">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2559">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2559">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="c3caa-2560">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewQueryContinueDrag>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2560">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="c3caa-2561">オーバーライド<xref:System.Windows.ContentElement.OnQueryContinueDrag%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2561">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2562">
            <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2562">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2563">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2563">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2564">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2564">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2565">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2565">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2566">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2566">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2567">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2567">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2568">カーソルの表示が要求されると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2568">Occurs when the cursor is requested to display.</span>
          </span>
          <span data-ttu-id="c3caa-2569">このイベントは、マウス ポインターが別の位置へ移動するたびに要素上で発生します。したがって、場合によってはカーソル オブジェクトを移動先の位置に基づいて変更する必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2569">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2570">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.QueryCursor>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2570">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2571">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.QueryCursor>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2571">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2572">このイベント名によって参照されているカーソルは、必ずしも (カーソルとも呼ばれる) テキストのカーソルではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2572">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="c3caa-2573">代わりに、このコンテキストでのカーソルは、いくつかの可能な入力に関連するデバイスまたは Windows プログラミングの概念に関連する画面上のグラフィカル表示を宣言するオブジェクトです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2573">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="c3caa-2574">そのオブジェクトがによって表される、 <xref:System.Windows.Input.Cursor> wpf クラスです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2574">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="c3caa-2575">WPF 入力システムでは、マウス ポインターの画面上の位置を表す場合は、このカーソルを変更することができます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2575">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="c3caa-2576">定義済みの値を使用することができます、<xref:System.Windows.Input.Cursors>列挙型、または画像ファイルとしてカスタム カーソルを宣言できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2576">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="c3caa-2577">リッスンして、<xref:System.Windows.ContentElement.QueryCursor>イベントは、カーソル管理の効率的な方法ではありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2577">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="c3caa-2578">各要素がで独自のカーソル動作を定義する代わりに、<xref:System.Windows.FrameworkContentElement.Cursor%2A>と<xref:System.Windows.FrameworkContentElement.ForceCursor%2A>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2578">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="c3caa-2579">のみに依存する必要があります<xref:System.Windows.ContentElement.QueryCursor>かどうか WPF フレームワーク レベルの基本要素を使用していないまたはで特別な状況での要素ごとにカーソルの動作を定義するニーズを満たしていない、します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2579">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="c3caa-2580">応答でのカーソルの動作の実装の詳細については<xref:System.Windows.ContentElement.QueryCursor>を参照してください<xref:System.Windows.Input.QueryCursorEventHandler>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2580">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2581">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2581">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2582">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2582">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="c3caa-2583">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2583">Routing strategy</span></span>|<span data-ttu-id="c3caa-2584">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2584">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2585">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2585">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="c3caa-2586">対応する定義済みのトンネリング イベントはありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2586">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="c3caa-2587">オーバーライド<xref:System.Windows.ContentElement.OnQueryCursor%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2587">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2588">
            <see cref="E:System.Windows.ContentElement.QueryCursor" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2588">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2589">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2589">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2590">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2590">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2591">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2591">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2592">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2592">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2593">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2593">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="c3caa-2594">イベント データを格納し、発生させるイベントを識別する <see cref="T:System.Windows.RoutedEventArgs" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2594">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-2595">特定のルーティング イベントを発生させます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2595">Raises a specific routed event.</span>
          </span>
          <span data-ttu-id="c3caa-2596">発生する <see cref="T:System.Windows.RoutedEvent" /> は、指定した <see cref="T:System.Windows.RoutedEventArgs" /> インスタンス内で (そのイベント データの <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> プロパティとして) 識別されます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2596">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2597">`e`ルーティング イベントのすべてのデータの共通の基本型として型指定されたパラメーターです。 ただし、ために発生するイベントに使用される最も固有のイベント データの種類として、イベント データを指定してください<xref:System.Windows.RoutedEventArgs>派生クラスには、特定のイベントが発生するとは、特定の実際のデータ プロパティが含まれています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2597">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="c3caa-2598"><xref:System.Windows.RoutedEventArgs> イベントの状態のプロパティだけではありません。ルーティング イベントを発生させるも識別します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2598"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="c3caa-2599">このイベント発生パターンと、ルーティングされたイベント データの両方が異なる[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]イベントに関連するプロパティを通常だけが含まれるイベントやデータのクラスです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2599">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-2600">次の例は、イベント データを作成、データをイベントの識別子を追加して、インスタンスを使用して、イベント データをカスタム ルーティング イベントを発生させます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2600">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2601">キャプチャされているすべてのタッチ デバイスをこの要素から解放します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2601">Releases all captured touch devices from this element.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2602">この要素がマウス キャプチャを保持していた場合、キャプチャを解放します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2602">Releases the mouse capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2603">この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2603">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="c3caa-2604">値を確認してください<xref:System.Windows.ContentElement.IsMouseCaptured%2A>このメソッドを呼び出す前にします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2604">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c3caa-2605">次のハンドラーは、キャプチャまたはマウス ボタンの状態に従ってマウス キャプチャを解放します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2605">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="c3caa-2606">例マウス ポインターを移動するよりもその他の代替手段が目的でキャプチャされたマウスの動きを使用する方法を示します、[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2606">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2607">この要素がスタイラス デバイス キャプチャを保持していた場合、キャプチャを解放します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2607">Releases the stylus device capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2608">この要素がキャプチャを保持していない場合は、このメソッドを呼び出すも効果はありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2608">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="c3caa-2609">値を確認してください<xref:System.Windows.ContentElement.IsStylusCaptured%2A>このメソッドを呼び出す前にします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2609">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="c3caa-2610">解放の対象となるデバイス。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2610">The device to release.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-2611">指定されたタッチ デバイスをこの要素から解放することを試みます。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2611">Attempts to release the specified touch device from this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-2612">タッチ デバイスが解放された場合は <see langword="true" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2612">
              <see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="c3caa-2613">
            <paramref name="touchDevice" /> は <see langword="null" />です。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2613">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="c3caa-2614">ハンドラーがアタッチされているルーティング イベントの識別子。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2614">The identifier of the.routed event for which the handler is attached.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="c3caa-2615">この要素のイベント ハンドラー コレクションから削除する特定のハンドラー実装。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2615">The specific handler implementation to remove from the event handler collection on this element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="c3caa-2616">指定したルーティング イベント ハンドラーをこの要素から削除します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2616">Removes the specified routed event handler from this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2617">これを使用するための最も一般的なシナリオ[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]を実装する場合は、[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]カスタム ルーティング イベントのハンドラーの削除」ロジックを実装するときに特に関連付けられている「ラッパー」イベント、[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]レベル。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2617">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="c3caa-2618">これを次の例「解説」セクションでは、このシナリオを示しています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2618">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="c3caa-2619">このメソッドを呼び出しても何も起こりませんメソッドの呼び出しの入力パラメーターに一致する条件で登録されたハンドラーがない場合。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2619">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="c3caa-2620">数より多い場合に、イベント ハンドラーのストアの削除に最初のハンドラーのみ、条件に一致する 1 つのハンドラーがアタッチされます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2620">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="c3caa-2621">この動作は整合[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]の動作、`-=`演算子。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2621">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="c3caa-2622">どちらも`routedEvent`も`handler`あります`null`です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2622">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="c3caa-2623">いずれかの値として提供しようとしています。`null`で例外が発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2623">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="c3caa-2624">このメソッドは無視、`handledEventsToo`場合は、ハンドラーが最初に提供されているパラメーターについては、追加、<xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>処理済みのイベントの処理を有効に署名します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2624">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="c3caa-2625">ハンドラーのいずれかの型が削除されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2625">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2626">シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.ContentElement.CommandBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2626">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-2627">
            <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.CommandBindings" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2627">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2628">これは、戻り値は`true`場合<xref:System.Windows.ContentElement.CommandBindings%2A>ローカルに設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2628">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="c3caa-2629">これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.CommandBindings%2A>プロパティには、単純な既定値にありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2629">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="c3caa-2630">このメソッドは、既定値から、プロパティが変更されたかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2630">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="c3caa-2631">デザイナーを開発またはコントロールを組み込む独自の開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2631">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="c3caa-2632">詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2632">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2633">シリアル化プロセスが、このクラスのインスタンスに関する <see cref="P:System.Windows.ContentElement.InputBindings" /> プロパティの内容をシリアル化する必要があるかどうかを示す値を返します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2633">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="c3caa-2634">
            <see langword="true" /> プロパティ値をシリアル化する必要がある場合は <see cref="P:System.Windows.ContentElement.InputBindings" />。それ以外の場合は <see langword="false" />。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2634">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2635">これは、戻り値は`true`場合<xref:System.Windows.ContentElement.InputBindings%2A>ローカルに設定します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2635">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="c3caa-2636">これは、`ShouldSerialize`ためメソッドが用意されて、<xref:System.Windows.UIElement.InputBindings%2A>プロパティには、単純な既定値にありません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2636">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="c3caa-2637">このメソッドは、既定値から、プロパティが変更されたかどうかを示します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2637">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="c3caa-2638">デザイナーを開発またはコントロールを組み込む独自の開発する場合に通常、このメソッドが呼び出す、<xref:System.Windows.UIElement>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2638">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="c3caa-2639">詳細については、次を参照してください。 [ShouldSerialize メソッドとメソッドのリセットを既定値を定義する](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2639">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2640">この要素の上にポインターがある状態でスタイラス ボタンが押されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2640">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2641">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusButtonDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2641">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2642">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusButtonDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2642">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2643">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2644">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2644">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2645">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2645">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2646">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2646">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="c3caa-2647">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2647">Routing strategy</span></span>|<span data-ttu-id="c3caa-2648">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2648">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2649">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2649">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2650">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusButtonDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2650">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2651">オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2651">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2652">
            <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2652">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2653">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2653">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2654">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2654">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2655">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2655">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2656">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2656">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2657">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2657">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2658">この要素の上にポインターがある状態でスタイラス ボタンが離されたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2658">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2659">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusButtonUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2659">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2660">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusButtonUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2660">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2661">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2661">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2662">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2662">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2663">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2663">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2664">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2664">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="c3caa-2665">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2665">Routing strategy</span></span>|<span data-ttu-id="c3caa-2666">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2666">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2667">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2667">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="c3caa-2668">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusButtonUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2668">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2669">オーバーライド<xref:System.Windows.ContentElement.OnStylusButtonUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2669">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2670">
            <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2670">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2671">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2671">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2672">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2672">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2673">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2673">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2674">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2674">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2675">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2675">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2676">この要素上でスタイラスがデジタイザーに触れたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2676">Occurs when the stylus touches the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2677">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusDown>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2677">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2678">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusDown>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2678">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2679">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2679">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2680">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2680">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2681">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2681">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2682">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2682">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="c3caa-2683">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2683">Routing strategy</span></span>|<span data-ttu-id="c3caa-2684">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2684">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2685">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2685">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="c3caa-2686">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2686">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2687">オーバーライド<xref:System.Windows.ContentElement.OnStylusDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2687">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2688">
            <see cref="E:System.Windows.ContentElement.StylusDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2688">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2689">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2689">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2690">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2690">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2691">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2691">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2692">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2692">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2693">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2693">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2694">スタイラスがこの要素の境界内に入ったときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2694">Occurs when the stylus enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2695"><xref:System.Windows.ContentElement.StylusEnter> [ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2695"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c3caa-2696">ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2696">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c3caa-2697">ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2697">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c3caa-2698"><xref:System.Windows.ContentElement.StylusEnter>スタイラスがこのイベントをさらに、要素の境界に入った時点を追跡するレポート文字どおり、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`false`に`true`この要素上です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2698">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="c3caa-2699">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusEnter>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2699">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2700">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusEnter>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2700">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2701">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2701">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2702">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2702">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2703">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2703">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2704">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2704">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="c3caa-2705">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2705">Routing strategy</span></span>|<span data-ttu-id="c3caa-2706">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2706">Direct</span></span>|  
|<span data-ttu-id="c3caa-2707">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2707">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2708">オーバーライド<xref:System.Windows.ContentElement.OnStylusEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2708">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2709">
            <see cref="E:System.Windows.ContentElement.StylusEnter" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2709">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2710">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2710">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2711">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2711">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2712">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2712">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2713">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2713">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2714">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2714">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2715">デジタイザーに実際に触れることなく、要素上でスタイラスを動かしたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2715">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2716">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusInAirMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2716">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2717">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusInAirMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2717">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2718">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2718">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2719">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2719">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2720">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2721">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2721">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="c3caa-2722">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2722">Routing strategy</span></span>|<span data-ttu-id="c3caa-2723">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2723">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2724">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2724">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2725">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusInAirMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2725">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2726">オーバーライド<xref:System.Windows.ContentElement.OnStylusInAirMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2726">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2727">
            <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2727">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2728">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2728">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2729">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2729">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2730">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2730">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2731">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2731">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2732">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2732">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2733">この要素上で検出可能になるまでスタイラスがデジタイザーに近づいたときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2733">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2734">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusInRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2734">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2735">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusInRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2735">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2736">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2736">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2737">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2737">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2738">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2738">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2739">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2739">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="c3caa-2740">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2740">Routing strategy</span></span>|<span data-ttu-id="c3caa-2741">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2741">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2742">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2742">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2743">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusInRange>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2743">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="c3caa-2744">オーバーライド<xref:System.Windows.ContentElement.OnStylusInRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2744">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2745">
            <see cref="E:System.Windows.ContentElement.StylusInRange" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2745">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2746">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2746">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2747">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2747">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2748">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2748">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2749">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2749">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2750">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2750">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2751">スタイラスが要素の境界内から出たときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2751">Occurs when the stylus leaves the bounds of the element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2752"><xref:System.Windows.ContentElement.StylusLeave> [ルーティング イベントの概要](~/docs/framework/wpf/advanced/routed-events-overview.md)直接イベント ルーティング方法の処理を使用します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2752"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="c3caa-2753">ルート; 直接ルーティングされたイベントは発生しません代わりが処理される同じ要素では、発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2753">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="c3caa-2754">ただし、スタイルでのイベント トリガーなどのルーティング イベントの動作の他の側面を有効にする、操作を行います。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2754">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="c3caa-2755"><xref:System.Windows.ContentElement.StylusLeave>スタイラス境界から出た要素、このイベントの詳細時点を追跡するレポート文字どおり、<xref:System.Windows.ContentElement.IsStylusOver%2A>からプロパティ値が変更された`true`に`false`この要素上です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2755">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="c3caa-2756">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusLeave>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2756">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2757">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusLeave>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2757">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2758">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2758">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2759">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2759">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2760">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2760">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2761">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2761">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="c3caa-2762">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2762">Routing strategy</span></span>|<span data-ttu-id="c3caa-2763">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2763">Direct</span></span>|  
|<span data-ttu-id="c3caa-2764">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2764">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2765">オーバーライド<xref:System.Windows.ContentElement.OnStylusLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2765">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2766">
            <see cref="E:System.Windows.ContentElement.StylusLeave" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2766">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2767">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2767">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2768">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2768">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2769">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2769">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2770">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2770">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2771">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2771">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2772">スタイラスがこの要素上を移動すると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2772">Occurs when the stylus moves over this element.</span>
          </span>
          <span data-ttu-id="c3caa-2773">このイベントを発生させるには、デジタイザー上でスタイラスを移動する必要があります。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2773">The stylus must move while on the digitizer to raise this event.</span>
          </span>
          <span data-ttu-id="c3caa-2774">それ以外の場合は、代わりに <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> が発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2774">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2775">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusMove>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2775">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2776">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusMove>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2776">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2777">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2777">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2778">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2778">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2779">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2779">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2780">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2780">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="c3caa-2781">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2781">Routing strategy</span></span>|<span data-ttu-id="c3caa-2782">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2782">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2783">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2783">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2784">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2784">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2785">オーバーライド<xref:System.Windows.ContentElement.OnStylusMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2785">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2786">
            <see cref="E:System.Windows.ContentElement.StylusMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2786">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2787">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2787">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2788">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2788">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2789">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2789">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2790">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2790">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2791">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2791">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2792">この要素上でスタイラスが検出可能になるにはデジタイザーから離れすぎているときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2792">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2793">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusOutOfRange>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2793">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2794">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusOutOfRange>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2794">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2795">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2795">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2796">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2796">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2797">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2797">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2798">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2798">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="c3caa-2799">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2799">Routing strategy</span></span>|<span data-ttu-id="c3caa-2800">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2800">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2801">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2801">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2802">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusOutOfRange>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2802">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="c3caa-2803">オーバーライド<xref:System.Windows.ContentElement.OnStylusOutOfRange%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2803">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2804">
            <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2804">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2805">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2805">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2806">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2806">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2807">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2807">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2808">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2808">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2809">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2809">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2810">ユーザーがいずれかのスタイラス ジェスチャを実行したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2810">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2811">スタイラス ジェスチャの詳細については、次を参照してください。<xref:System.Windows.Input.SystemGesture>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2811">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="c3caa-2812">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusSystemGesture>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2812">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2813">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusSystemGesture>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2813">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2814">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2814">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2815">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2815">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2816">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2816">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2817">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2817">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="c3caa-2818">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2818">Routing strategy</span></span>|<span data-ttu-id="c3caa-2819">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2819">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2820">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2820">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="c3caa-2821">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusSystemGesture>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2821">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="c3caa-2822">オーバーライド<xref:System.Windows.ContentElement.OnStylusSystemGesture%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2822">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2823">
            <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2823">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2824">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2824">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2825">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2825">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2826">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2826">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2827">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2827">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2828">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2828">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2829">ユーザーがこの要素上でスタイラスをデジタイザーから離したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2829">Occurs when the user raises the stylus off the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2830">このイベントのエイリアスを作成する、<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.StylusUp>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2830">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2831">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.StylusUp>イベントが、基になるに関連付けられている<xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2831">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="c3caa-2832">タッチ、マウス、およびスタイラス入力は、特定のリレーションシップに存在します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2832">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="c3caa-2833">詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2833">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2834">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2834">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2835">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2835">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="c3caa-2836">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2836">Routing strategy</span></span>|<span data-ttu-id="c3caa-2837">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2837">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2838">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2838">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="c3caa-2839">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewStylusUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2839">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2840">オーバーライド<xref:System.Windows.ContentElement.OnStylusUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2840">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2841">
            <see cref="E:System.Windows.ContentElement.StylusUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2841">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2842">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2842">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2843">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2843">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2844">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2844">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2845">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2845">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2846">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2846">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2847">この要素がデバイスに依存しない方法でテキストを取得したときに発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2847">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="c3caa-2848">このイベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2848">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="c3caa-2849">以下の解説を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2849">See Remark below.</span></span>  
  
 <span data-ttu-id="c3caa-2850"><xref:System.Windows.ContentElement.TextInput>イベントは、複合コントロールの内部実装によって処理済みとして既にマーク可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2850">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="c3caa-2851">たとえば、<xref:System.Windows.Controls.TextBox>複合コントロールは、ここで、<xref:System.Windows.ContentElement.TextInput>イベントが処理済みとして以外の場合は、合成内に既にマークされています。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2851">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="c3caa-2852">コントロールは、コントロールがいくつかの種類のコントロールに特別な意味を持つものとして、方向キーなどの入力を解釈する必要があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2852">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="c3caa-2853">使用する場合<xref:System.Windows.ContentElement.PreviewTextInput>テキスト入力用のハンドラーをアタッチするイベント、としてより良い結果を受け取ることがあります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2853">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="c3caa-2854">この手法は、コントロールの複合ハンドル済みとしては、このイベントをマークが既にあり、ハンドラーがイベント ルート上でイベントを受信できないように、ほとんどの場合を回避できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2854">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="c3caa-2855"><xref:System.Windows.ContentElement.TextInput>イベントにより、コンポーネントまたはアプリケーションをデバイスに依存しない方法で、テキスト入力をリッスンします。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2855">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="c3caa-2856">キーボードは、主要な手段の<xref:System.Windows.ContentElement.TextInput>、音声認識、手書き認識、およびその他の入力デバイス上げることもできますが、<xref:System.Windows.ContentElement.TextInput>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2856">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="c3caa-2857">キーの組み合わせが原因: 既定のキーボードまたは入力方式エディターから — 複数のキー イベントが 1 つのテキスト入力イベントを発生させる可能性があります。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2857">Because of key combinations—either in default keyboards or through input method editors—multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="c3caa-2858">このイベントのエイリアスを作成する、<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントが、このクラスに対してように<xref:System.Windows.ContentElement.TextInput>一部であるクラスのメンバーのリスト<xref:System.Windows.ContentElement>基本要素として継承します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2858">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="c3caa-2859">イベント ハンドラーに関連付けられている、<xref:System.Windows.ContentElement.TextInput>イベントが、基になるに関連付けられている<xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType>添付イベントと同じイベント データ インスタンスを受信します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2859">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2860">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2860">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2861">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2861">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="c3caa-2862">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2862">Routing strategy</span></span>|<span data-ttu-id="c3caa-2863">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2863">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2864">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2864">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="c3caa-2865">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTextInput>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2865">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="c3caa-2866">オーバーライド<xref:System.Windows.ContentElement.OnTextInput%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2866">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2867">
            <see cref="E:System.Windows.ContentElement.TextInput" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2867">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2868">ルーティング イベントの識別子は、ルーティング イベントの登録時に作成されます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2868">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="c3caa-2869">これらの識別子には、識別名、所有者の種類、ハンドラーの型、ルーティング方法、およびイベントの所有者を追加するためのユーティリティ メソッドが含まれます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2869">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="c3caa-2870">これらの識別子を使用して、クラスのハンドラーを追加できます。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2870">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="c3caa-2871">ルーティング イベントの登録方法の詳細については、<xref:System.Windows.EventManager.RegisterRoutedEvent%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2871">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="c3caa-2872">ルーティング イベントの識別子を使用して、クラス ハンドラーを追加する方法の詳細については、<xref:System.Windows.EventManager.RegisterClassHandler%2A> を参照してください。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2872">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2873">指がこの要素の上にある間に、その指で画面に触れると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2873">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2874">既定では、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>指が画面に触れるし、移動するまでのイベントが発生しません。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2874">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="c3caa-2875">画面に指を押すと、キーを押すと、移動せずに保持しているとの動作を保持する<xref:System.Windows.Input.Stylus>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2875">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="c3caa-2876">プレス アンド ホールド動作は、マウスの右クリックに相当します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2876">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="c3caa-2877">により、<xref:System.Windows.ContentElement.PreviewTouchDown>と<xref:System.Windows.ContentElement.TouchDown>、画面に触れると発生するイベントを設定、<xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType>添付プロパティ`false`この要素のです。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2877">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2878">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2878">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2879">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2879">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="c3caa-2880">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2880">Routing strategy</span></span>|<span data-ttu-id="c3caa-2881">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2881">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2882">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2882">Delegate</span></span>|<span data-ttu-id="c3caa-2883"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2883"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2884">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTouchDown>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2884">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="c3caa-2885">オーバーライド<xref:System.Windows.ContentElement.OnTouchDown%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2885">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2886">
            <see cref="E:System.Windows.ContentElement.TouchDown" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2886">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2887">タッチがこの要素の境界の外部から内部に移動すると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2887">Occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c3caa-2888">このイベントはこの UI 要素にタッチ デバイスがキャプチャされるかどうか常に発生します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2888">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2889">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2890">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2890">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="c3caa-2891">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2891">Routing strategy</span></span>|<span data-ttu-id="c3caa-2892">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2892">Direct</span></span>|  
|<span data-ttu-id="c3caa-2893">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2893">Delegate</span></span>|<span data-ttu-id="c3caa-2894"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2894"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2895">オーバーライド<xref:System.Windows.ContentElement.OnTouchEnter%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2895">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2896">
            <see cref="E:System.Windows.ContentElement.TouchEnter" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2896">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2897">この要素にキャプチャされているすべてのタッチ デバイスを取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2897">Gets all touch devices that are captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-2898">この要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2898">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2899">この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされているすべてのタッチ デバイスを取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2899">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-2900">この要素またはそのビジュアル ツリー内のいずれかの子要素にキャプチャされている <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2900">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2901">この要素上にあるすべてのタッチ デバイスを取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2901">Gets all touch devices that are over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-2902">この要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2902">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2903">この要素またはそのビジュアル ツリー内のいずれかの子要素上にあるすべてのタッチ デバイスを取得します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2903">Gets all touch devices that are over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="c3caa-2904">この要素またはそのビジュアル ツリー内のいずれかの子要素上にある <see cref="T:System.Windows.Input.TouchDevice" /> オブジェクトの列挙体。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2905">タッチがこの要素の境界の内部から外部に移動すると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2905">Occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2906">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2906">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2907">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2907">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="c3caa-2908">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2908">Routing strategy</span></span>|<span data-ttu-id="c3caa-2909">直接</span><span class="sxs-lookup"><span data-stu-id="c3caa-2909">Direct</span></span>|  
|<span data-ttu-id="c3caa-2910">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2910">Delegate</span></span>|<span data-ttu-id="c3caa-2911"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2911"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2912">オーバーライド<xref:System.Windows.ContentElement.OnTouchLeave%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2912">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2913">
            <see cref="E:System.Windows.ContentElement.TouchLeave" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2913">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2914">この要素の上に指があるときに、その指を画面上で動かすと発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2914">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2915">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2915">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2916">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2916">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="c3caa-2917">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2917">Routing strategy</span></span>|<span data-ttu-id="c3caa-2918">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2918">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2919">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2919">Delegate</span></span>|<span data-ttu-id="c3caa-2920"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2920"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2921">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTouchMove>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2921">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="c3caa-2922">オーバーライド<xref:System.Windows.ContentElement.OnTouchMove%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2922">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2923">
            <see cref="E:System.Windows.ContentElement.TouchMove" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2923">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2924">この要素の上に指があるときに、その指が画面から離れると発生します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2924">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="c3caa-2925">ルーティングされたイベント情報</span><span class="sxs-lookup"><span data-stu-id="c3caa-2925">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="c3caa-2926">識別子のフィールド</span><span class="sxs-lookup"><span data-stu-id="c3caa-2926">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="c3caa-2927">ルーティング方法</span><span class="sxs-lookup"><span data-stu-id="c3caa-2927">Routing strategy</span></span>|<span data-ttu-id="c3caa-2928">バブル</span><span class="sxs-lookup"><span data-stu-id="c3caa-2928">Bubbling</span></span>|  
|<span data-ttu-id="c3caa-2929">Delegate</span><span class="sxs-lookup"><span data-stu-id="c3caa-2929">Delegate</span></span>|<span data-ttu-id="c3caa-2930"><xref:System.EventHandler%601> 型の <xref:System.Windows.Input.TouchEventArgs>。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2930"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="c3caa-2931">対応するトンネリング イベントが<xref:System.Windows.ContentElement.PreviewTouchUp>です。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2931">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="c3caa-2932">オーバーライド<xref:System.Windows.ContentElement.OnTouchUp%2A>を派生クラスでは、このイベントに対するクラス処理を実装します。</span><span class="sxs-lookup"><span data-stu-id="c3caa-2932">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="c3caa-2933">
            <see cref="E:System.Windows.ContentElement.TouchUp" /> ルーティング イベントを識別します。</span>
          <span class="sxs-lookup">
            <span data-stu-id="c3caa-2933">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>