<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="21f68e6f314d849540abfcb8c2deb7a7baf7fada" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36457561" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ルーティング イベントに関連付けられている状態情報とイベント データを格納します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なる<xref:System.Windows.RoutedEventArgs>、1 つで使用できる<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>です。 このクラスは、イベントのデータをパッケージ化する、 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>、余分なイベントの状態情報を提供すること、およびルーティング イベントに関連付けられたハンドラーを呼び出すことのイベント システムによって使用されます。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このパラメーターなしコンス トラクター、新しいすべてのパブリック プロパティを使用する場合<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は`null`します。  
  
 Null 値<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>のみからといって、<xref:System.Windows.RoutedEventArgs>データされないため、ソースを指定します。 呼び出しでのこのインスタンスを使用する場合<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生させるし、ルーティングをリスナー渡されますを要素に基づく値が設定されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードされたコンス トラクターを使用する場合に新しいプロパティが指定されていない<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>のみからといってこの<xref:System.Windows.RoutedEventArgs>されないため、ソースを指定します。 呼び出しでのこのインスタンスを使用する場合<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生させるし、ルーティングをリスナー渡されますを要素に基づく値が設定されます。  
  
   
  
## Examples  
 次の例は、新しい<xref:System.Windows.RoutedEventArgs>への呼び出しで使用するため<xref:System.Windows.UIElement.RaiseEvent%2A>です。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <param name="source">イベントの処理時に報告される代替ソース。 <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティに、このソースが事前設定されます。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。また、このコンストラクターでは、イベントに対して異なるソースを宣言することができます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードされたコンス トラクターを使用する場合に新しいプロパティが指定されていない<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>は、イベントを発生させるし、ルーティング経由で渡されますを要素に基づいて入力は読み取られます`null`呼び出しの前にします。  
  
 渡すときは、この署名を使用して<xref:System.Windows.RoutedEventArgs>などの仮想メソッドを<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>の呼び出しに引数を使用する場所、<xref:System.Windows.UIElement.RaiseEvent%2A>内部的にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ルーティング イベントがルートをたどる際のイベント処理の現在の状態を示す値を取得または設定します。</summary>
        <value>設定する場合に設定<see langword="true" />それ以外の処理済みとしてマークする場合は、イベント<see langword="false" />です。 この値を読み取る場合<see langword="true" />クラス ハンドラーまたは経路には、いくつかのインスタンス ハンドラーのいずれかがこのイベントを処理のマークでが既にあることを示します。 <see langword="false" /> は、いずれのハンドラーもイベントを処理済みとしてマークしていないことを示します。  既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを処理済みのマークを付けると、イベントのルーティング上のリスナーにルーティングされたイベントの可視性が制限されます。 イベントは、ルートの残りの部分を移動してもが、唯一のハンドラーは、特にを追加`HandledEventsToo``true`で、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>メソッドの呼び出しが応答で呼び出されます。 既定のインスタンスのリスナーのハンドラー (で表されるものなど[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) は呼び出されません。 処理済みとマークされているイベントの処理は、一般的なシナリオではないです。  
  
 コントロールの作成者の場合は、上の決定を行う独自のイベントを定義するイベントに関するクラス レベルで処理は影響、コントロールのユーザーだけでなく、派生のコントロールのすべてのユーザー、されているかその他の要素が、コントロールに含まれる可能性があります。または、コントロールが含まれています。 詳細については、「[ルーティング イベントの処理済みとしてのマーキング、およびクラス処理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)」を参照してください。  
  
 非常にまれな状況ではイベントを処理する適切な場所<xref:System.Windows.RoutedEventArgs.Handled%2A>がマークされている`true`、および変更することによって、イベント引数を変更<xref:System.Windows.RoutedEventArgs.Handled%2A>に`false`です。 キーを処理などのコントロールの入力イベントの特定の領域で構成に必要なできます<xref:System.Windows.UIElement.KeyDown>と<xref:System.Windows.UIElement.TextInput>それぞれ別のルーティング方法を使用しようと、下位レベルと高レベルの入力イベントの処理の競合が発生します。  
  
   
  
## Examples  
 次の例では、イベントを処理済みとしてマークするイベント ハンドラーを実装します。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">呼び出すジェネリック ハンドラー/デリゲート実装。</param>
        <param name="genericTarget">指定したハンドラーが呼び出されるターゲット。</param>
        <summary>派生クラスでオーバーライドされた場合、型固有の方法でイベント ハンドラーを呼び出す方法を提供します。これにより、基本実装よりも効率が向上する場合があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基底の実装には、いかなる場合においても、ハンドラーが行われていない文字どおりの右側のハンドラーを決定するためにリフレクションが組み込まれています。 <xref:System.Windows.RoutedEventHandler>、しており、このリフレクション手順がいくつかのパフォーマンスの影響。 呼び出しによってリフレクションに依存しないがより効率的な行われたことができます。 これは、このメソッドをオーバーライドすることを選択、ルーティングされたイベント引数クラスで使用されるこのメソッドを用途シナリオです。 実装呼び出す必要はありません、ベースこのメソッドの実装を既にタイプ セーフなハンドラーを呼び出すにする必要があります。  
  
   
  
## Examples  
 次に、擬似コードを実装するために使用できる基本的なパターンを示しています。 ここでは、`MyRoutedEventHandler`のサブクラスは、<xref:System.Windows.RoutedEventHandler>です。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>このメソッドは、デリゲートの呼び出しを効率化を提供する派生イベント データ クラスでオーバーライドされることを目的としています。実装が提供されている必要がありますキャスト<paramref name="genericHandler" />型固有を委任して、そのハンドラーを呼び出します。既定の実装にキャストしようとすると、指定したハンドラーを呼び出すしよう<see cref="T:System.Windows.RoutedEventHandler" />です。いずれか<paramref name="genericHandler" />または<paramref name="genericTarget" />として提供される<see langword="null" />例外が発生します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="P:System.Windows.RoutedEventArgs.Source" /> に設定する新しい値。</param>
        <summary>派生クラスでオーバーライドした場合、インスタンスの <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティの値が変更されるたびに、通知コールバックのエントリ ポイントを提供します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Reported イベントのソースをプログラムで変更するには、イベント内の型に固有のデータを更新する可能性があるが必要です。このため、<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />メソッドは、仮想保護されておりのサブクラスによってオーバーライドされるものでは<see cref="T:System.Windows.RoutedEventArgs" />します。このメソッドには、既定の実装ではありません。</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親クラスによって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、純粋なヒット テストで判断される元の報告ソースを取得します。</summary>
        <value>複合要素ツリーを平坦化するなどの目的でクラス処理によって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、元の報告ソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、クラスの前にイベント ハンドラーまたは任意のインスタンス ハンドラーが呼び出され、この時点以降は調整しないと、その値を取得します。 元のソース情報は、イベント データで報告されているのと同様はクラス ハンドラーまたはクラスの実装に対して読み取り専用です。  
  
 ソースを調整することが一般的なケースに含まれるコントロールのコンテンツ モデル内のコンテンツの要素 (たとえば、リスト項目の内容は、リスト項目要素としてを報告、<xref:System.Windows.RoutedEventArgs.Source%2A>一覧項目内で実際の要素には、 <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 さまざまな要素とのコンテンツ モデルでソース調整では、クラスによって異なります。 イベント ソースを調整する各クラスがソースは、最も役に立つの大半の入力シナリオと、クラスが対象とするシナリオをレポートを予測しようとして、セットをソースとして、<xref:System.Windows.RoutedEventArgs.Source%2A>です。 このソースがあるは、イベントの処理に関連でない場合は、確認してください。<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>代わりにする場合は報告いっそう適したものには、別のソースを参照してください。 入力イベントの詳細については、次を参照してください。[入力概要](~/docs/framework/wpf/advanced/input-overview.md)です。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> インスタンスに関連付けられている <see cref="T:System.Windows.RoutedEventArgs" /> を取得または設定します。</summary>
        <value>呼び出されたイベントの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値を設定することはできません、<xref:System.Windows.RoutedEventArgs>を既ににルーティングされました (たとえば、ハンドラーを引数を取得した) 場合。 これを行うにしようとすると、例外が生成されます。 イベントの呼び出しの生成に使用されていないインスタンスでのみ設定できます。  
  
 値<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>することはできません`null`いつでもできます。  
  
   
  
## Examples  
 次の例は、最初のコンス トラクターを持つ新しいルーティング イベントのデータを作成し、設定、<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>プロパティを後続の操作として。 必要があります<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>ルーティング イベントを発生させる前に設定します。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベントのルーティング中に <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 値を変更しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを発生させたオブジェクトへの参照を取得または設定します。</summary>
        <value>イベントを発生させたオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ルーティングされていないイベントまだ要素の値であることを発生させたまでトンネリングされたトンネリング任意のコードと、原因となった要素を超えるルートを実際に通過したイベントのルーティング、バブルの<xref:System.Windows.RoutedEventArgs.Source%2A>の値と異なるなります「c3/>イベント引数クラスのパラメーターです。 任意の特定のハンドラーで最も重要度はイベントに関連する 2 つの要素 (<xref:System.Windows.RoutedEventArgs.Source%2A>、原因となった要素または`sender`、処理は、現在の要素) は、ハンドラーがアプリケーション ロジックに依存アドレス指定します。  
  
 このプロパティの設定は通常ときにのみ実行オーバーライドまたは実装するその他の[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]ときなど、イベント ソースを調整するクラスのイベントを処理します。 特に、処理済みとして、ハンドラーが、イベントをマークしない場合に、インスタンス ハンドラーからイベント ソースのリセットはお勧めしません。  
  
 操作をリセットする場合<xref:System.Windows.RoutedEventArgs.Source%2A>、別のイベント ソースをレポートする<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>元によって最初にソースが発生したレポートは引き続き<xref:System.Windows.UIElement.RaiseEvent%2A>を呼び出します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>