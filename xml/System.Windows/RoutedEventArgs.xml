<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="bcf7dc63deeaebfa62a5b5e0578c3f64cef20e2d" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ja-JP" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69433629" /></Metadata><TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ルーティング イベントに関連付けられている状態情報とイベント データを格納します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 1 <xref:System.Windows.RoutedEventArgs> つ<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>ので異なるを使用できます。 このクラスは、 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>のイベントデータをパッケージ化し、追加のイベント状態情報を提供し、ルーティングイベントに関連付けられたハンドラーを呼び出すためにイベントシステムによって使用されます。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このパラメーターなしのコンストラクターを使用する場合、新しい<xref:System.Windows.RoutedEventArgs>インスタンスのすべてのパブリックプロパティは次の既定値を想定します。  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>既定値`null`はです。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>既定値`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>既定値`null`はです。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>既定値`null`はです。  
  
 との<xref:System.Windows.RoutedEventArgs.Source%2A> Null 値<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>は、データが<xref:System.Windows.RoutedEventArgs>ソースを指定しようとしていないことを意味します。 このインスタンスがの呼び出し<xref:System.Windows.UIElement.RaiseEvent%2A>で使用されている場合、および<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>の<xref:System.Windows.RoutedEventArgs.Source%2A>値は、イベントを発生させた要素に基づいて設定され、ルーティングを介してリスナーに渡されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードされたコンストラクターを使用する場合、 <xref:System.Windows.RoutedEventArgs>新しいインスタンスの未指定のプロパティは次の既定値を想定します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>既定値`false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A>既定値`null`はです。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>既定値`null`はです。  
  
 との<xref:System.Windows.RoutedEventArgs.Source%2A> Null 値は、ソースを<xref:System.Windows.RoutedEventArgs>指定しようとしていないことを意味し<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>ます。 このインスタンスがの呼び出し<xref:System.Windows.UIElement.RaiseEvent%2A>で使用されている場合、および<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>の<xref:System.Windows.RoutedEventArgs.Source%2A>値は、イベントを発生させた要素に基づいて設定され、ルーティングを介してリスナーに渡されます。  
  
   
  
## Examples  
 次の例では、 <xref:System.Windows.RoutedEventArgs>の<xref:System.Windows.UIElement.RaiseEvent%2A>呼び出しで使用する新しいを構築します。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <param name="source">イベントの処理時に報告される代替ソース。 <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティに、このソースが事前設定されます。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。また、このコンストラクターでは、イベントに対して異なるソースを宣言することができます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバーロードされたコンストラクターを使用する場合、 <xref:System.Windows.RoutedEventArgs>新しいインスタンスの未指定のプロパティは次の既定値を想定します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A>既定値`false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>既定値`null`はです。  
  
 の<xref:System.Windows.RoutedEventArgs.OriginalSource%2A> Null 値は、イベントを発生させてルーティングを通じて渡された要素に基づいて設定`null`されますが、呼び出しの前に読み取られます。  
  
 このシグネチャは、など<xref:System.Windows.RoutedEventArgs>の純粋に渡す<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>ときに使用します。この場合<xref:System.Windows.UIElement.RaiseEvent%2A> 、引数を使用して内部でを呼び出すことができます。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ルーティング イベントがルートをたどる際のイベント処理の現在の状態を示す値を取得または設定します。</summary>
        <value>設定時に、イベントを処理済みとしてマークする場合は <see langword="true" /> 、マークしない場合は <see langword="false" />に設定します。 この値を読み取る場合、 <see langword="true" /> は、クラス ハンドラーまたはルート上にある一部のインスタンス ハンドラーのいずれかが、このイベントを処理済みとして既にマークしていることを示します。 <see langword="false" />は、いずれのハンドラーもイベントを処理済みとしてマークしていないことを示します。  
  
既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを処理済みとしてマークすると、ルーティングイベントの可視性が、イベントルートに沿ったリスナーに制限されます。 イベントは引き続きルートの残りの部分を移動しますが、 `HandledEventsToo` <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>メソッド呼び出しでによって明示的に`true`追加されたハンドラーのみが応答として呼び出されます。 インスタンスリスナー (で[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]表されるものなど) の既定のハンドラーは呼び出されません。 処理済みとマークされたイベントの処理は、一般的なシナリオではありません。  
  
 独自のイベントを定義しているコントロール作成者は、クラスレベルでのイベント処理に関して行った決定によって、コントロールのユーザーと、コントロールに含まれている可能性のあるその他の要素に影響を与えます。または、コントロールを格納している。 詳細については、「[ルーティング イベントの処理済みとしてのマーキング、およびクラス処理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)」を参照してください。  
  
 非常にまれな状況で<xref:System.Windows.RoutedEventArgs.Handled%2A>は、がマーク`true`されているイベントを処理し、をに<xref:System.Windows.RoutedEventArgs.Handled%2A> `false`変更することによってイベント引数を変更します。 これは、コントロールの入力イベントの特定の領域で必要になる場合があり<xref:System.Windows.UIElement.KeyDown>ます<xref:System.Windows.UIElement.TextInput> 。たとえば、低レベルの入力イベントと上位レベルの入力イベントが処理に対して競合し、それぞれが異なるルーティング方法を使用しようとしている場合などです。  
  
   
  
## Examples  
 次の例では、イベントを処理済みとしてマークするイベントハンドラーを実装しています。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">呼び出すジェネリック ハンドラー/デリゲート実装。</param>
        <param name="genericTarget">指定したハンドラーが呼び出されるターゲット。</param>
        <summary>派生クラスでオーバーライドされた場合、型固有の方法でイベント ハンドラーを呼び出す方法を提供します。これにより、基本実装よりも効率が向上する場合があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本実装には、そのハンドラーが文字どおり<xref:System.Windows.RoutedEventHandler>でない場合の適切なハンドラーを決定するリフレクションが組み込まれており、このリフレクションステップにはパフォーマンスの問題があります。 呼び出しは、リフレクションに依存しないことで、より効率的に行うことができます。 これは、オーバーライドを選択する任意のルーティングイベント引数クラスでこのメソッドを使用できるようにためするシナリオです。 実装では、型セーフハンドラーを呼び出す必要があるため、このメソッドの基本を呼び出すことはできません。  
  
   
  
## Examples  
 次に示すのは、実装に使用できる基本的なパターンを示す擬似コードです。 ここで`MyRoutedEventHandler` 、はの<xref:System.Windows.RoutedEventHandler>サブクラスです。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>このメソッドは、派生イベントデータクラスによってオーバーライドされ、デリゲートのより効率的な呼び出しを提供するためのものです。 実装では、指定さ<paramref name="genericHandler" />れたを型固有のデリゲートにキャストし、そのハンドラーを呼び出す必要があります。  
  
既定の実装は、と<see cref="T:System.Windows.RoutedEventHandler" />してキャストしようとして、指定されたハンドラーを呼び出そうとします。 または<paramref name="genericHandler" /> <paramref name="genericTarget" />のいずれかが<see langword="null" />として指定されている場合、例外が発生します。</para></block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source"><see cref="P:System.Windows.RoutedEventArgs.Source" /> に設定する新しい値。</param>
        <summary>派生クラスでオーバーライドした場合、インスタンスの <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティの値が変更されるたびに、通知コールバックのエントリ ポイントを提供します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para>報告されたイベントソースをプログラムによって変更すると、イベント内の型固有のデータを更新する必要が生じる可能性があります。 このため、 <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />メソッドはプロテクト仮想であり、の<see cref="T:System.Windows.RoutedEventArgs" />サブクラスによってオーバーライドされることを意図しています。  
  
このメソッドには既定の実装がありません。</para></block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親クラスによって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、純粋なヒット テストで判断される元の報告ソースを取得します。</summary>
        <value>複合要素ツリーを平坦化するなどの目的でクラス処理によって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、元の報告ソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、クラスイベントハンドラーまたはインスタンスハンドラーが呼び出される前に値を1回取得し、この時点以降は調整されません。 元のソース情報は、イベントデータで報告される場合と同様に、クラスハンドラーまたはクラスの実装に対して読み取り専用になります。  
  
 ソースが調整される可能性のある一般的なケース<xref:System.Windows.RoutedEventArgs.Source%2A>としては、コントロールのコンテンツモデル内のコンテンツ要素 (リスト項目の内容など) によってリスト項目要素がとして報告され、リスト項目内の実際の要素は次のようになります<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>。  
  
 さまざまな要素およびコンテンツモデルによるソース調整は、クラスごとに異なります。 イベントソースを調整する各クラスは、ほとんどの入力シナリオおよびクラスが意図しているシナリオについてレポートするのに最も役に立つソースを予測し、その<xref:System.Windows.RoutedEventArgs.Source%2A>ソースをとして設定します。 このソースがイベントの処理に関連しているものではない場合は、代わりに<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>確認して、より適切な別のソースが報告されているかどうかを確認してください。 入力イベントの詳細については、「[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)」を参照してください。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="T:System.Windows.RoutedEventArgs" /> インスタンスに関連付けられている <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> を取得または設定します。</summary>
        <value>呼び出されたイベントの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 既にルーティングされて<xref:System.Windows.RoutedEventArgs>いるでは、この値を設定することはできません (たとえば、ハンドラーから引数を取得した場合)。 これを行おうとすると、例外が発生します。 イベントの呼び出しを生成するためにまだ使用されていないインスタンスでのみ設定できます。  
  
 の<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>値をいつで`null`も指定することはできません。  
  
   
  
## Examples  
 次の例では、初期コンストラクターを使用して新しいルーティングイベントデータ<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>を作成し、その後の操作としてプロパティを設定します。 ルーティングイベントを<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>発生させる前に、を設定しておく必要があります。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベントのルーティング中に <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 値を変更しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを発生させたオブジェクトへの参照を取得または設定します。</summary>
        <value>イベントを発生させたオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 バブルルーティングイベントのうち、ルートを発生させた要素を超えて実際に移動した場合、およびそのイベントを発生させたすべてのトンネリングルーティングイベントの場合、の<xref:System.Windows.RoutedEventArgs.Source%2A>値は、の値と異なります。 イベント引数クラスの `sender` パラメーター。 イベントに関連する2つの要素のうち、どのハンドラーで最も重要度が高い<xref:System.Windows.RoutedEventArgs.Source%2A>もの (、そのハンドラーを発生さ`sender`せた要素、または現在処理中の要素) は、ハンドラーがアプリケーションロジックに依存しています。取り組む.  
  
 このプロパティの設定は、通常、イベントソースを調整[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]する別のをオーバーライドまたは実装する場合 (クラスがイベントを処理する場合など) にのみ実行されます。 特にハンドラーがイベントを処理済みとしてマークしない場合、インスタンスハンドラーからの見かけ上のイベントソースのリセットは推奨されません。  
  
 別のイベントソース<xref:System.Windows.RoutedEventArgs.Source%2A>をレポートするようにリセットを<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>実行すると、は、元の<xref:System.Windows.UIElement.RaiseEvent%2A>呼び出しによって最初に発生したソースを報告し続けます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>
