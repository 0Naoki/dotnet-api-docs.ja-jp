<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="86f523bef7f76ecf3e0fc2ab9adc3b6f2590fe25" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ja-JP" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39915997" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type RoutedEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>ルーティング イベントに関連付けられている状態情報とイベント データを格納します。</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 異なる<xref:System.Windows.RoutedEventArgs>、1 つを併用<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>します。 イベントのイベント データをパッケージ化するため、このクラスは、 <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>、余分なイベントの状態情報を提供され、ルーティング イベントに関連付けられたハンドラーを呼び出すためイベント システムによって使用されます。  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このコンス トラクター、新しいすべてのパブリック プロパティを使用する場合<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> 既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>のみといって、<xref:System.Windows.RoutedEventArgs>データは、ソースを指定する操作を行わない。 呼び出しでこのインスタンスを使用するときに<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生し、ルーティングでリスナーに渡されます要素に基づいて値が設定されます。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs routedEvent" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードされたコンス トラクターを使用する場合に新しいプロパティが指定されていない<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> 既定値は`null`します。  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>のみからといってこれ<xref:System.Windows.RoutedEventArgs>ソースの指定を試みません。 呼び出しでこのインスタンスを使用するときに<xref:System.Windows.UIElement.RaiseEvent%2A>、<xref:System.Windows.RoutedEventArgs.Source%2A>と<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生し、ルーティングでリスナーに渡されます要素に基づいて値が設定されます。  
  
   
  
## Examples  
 次の例は、新しい<xref:System.Windows.RoutedEventArgs>への呼び出しで使用するため<xref:System.Windows.UIElement.RaiseEvent%2A>します。  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberSignature Language="F#" Value="new System.Windows.RoutedEventArgs : System.Windows.RoutedEvent * obj -&gt; System.Windows.RoutedEventArgs" Usage="new System.Windows.RoutedEventArgs (routedEvent, source)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <see cref="T:System.Windows.RoutedEventArgs" /> クラスのこのインスタンスに対するルーティング イベント識別子。</param>
        <param name="source">イベントの処理時に報告される代替ソース。 <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティに、このソースが事前設定されます。</param>
        <summary>指定されたルーティング イベント識別子を使用して、<see cref="T:System.Windows.RoutedEventArgs" /> クラスの新しいインスタンスを初期化します。また、このコンストラクターでは、イベントに対して異なるソースを宣言することができます。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このオーバー ロードされたコンス トラクターを使用する場合に新しいプロパティが指定されていない<xref:System.Windows.RoutedEventArgs>インスタンスには、次の既定値が前提としています。  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> 既定値は `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> 既定値は`null`します。  
  
 値は null<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>イベントを発生し、ルーティング渡す要素に基づいて設定されますが、読み取りは`null`呼び出しの前にします。  
  
 渡すときに、この署名を使用して<xref:System.Windows.RoutedEventArgs>などの仮想メソッドを<xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>呼び出しに引数を使用する場所、<xref:System.Windows.UIElement.RaiseEvent%2A>内部的にします。  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Handled : bool with get, set" Usage="System.Windows.RoutedEventArgs.Handled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>ルーティング イベントがルートをたどる際のイベント処理の現在の状態を示す値を取得または設定します。</summary>
        <value>設定する場合に設定<see langword="true" />それ以外の処理済みとしてマークする場合は、イベント<see langword="false" />します。 場合は、この値を読み取る<see langword="true" />クラス ハンドラーまたはルート上いくつかのインスタンス ハンドラーのいずれかがこのイベントを処理済みのマークでは既にことを示します。 <see langword="false" /> は、いずれのハンドラーもイベントを処理済みとしてマークしていないことを示します。  
  
既定値は <see langword="false" /> です。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 イベントを処理済みのマークを付けると、イベント ルート上のリスナーにルーティング イベントの可視性が制限されます。 イベントは、ルートの残りの部分を移動してもが、唯一のハンドラーは、特にを追加`HandledEventsToo``true`で、<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>応答でメソッドの呼び出しが呼び出されます。 既定のインスタンスのリスナーのハンドラー (で表されるものなど[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) は呼び出されません。 処理済みとマークされているイベントを処理は、一般的なシナリオではありません。  
  
 コントロールの作成者の場合は、上の決定を行う独自のイベントを定義、コントロールのユーザーと、派生コントロールのすべてのユーザー イベントに関して、クラス レベルでの処理に影響し、では、その他の要素が、コントロールに含まれる可能性があります。または、コントロールが含まれています。 詳細については、「[ルーティング イベントの処理済みとしてのマーキング、およびクラス処理](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)」を参照してください。  
  
 非常にまれな状況ではイベントを処理する適切な場所<xref:System.Windows.RoutedEventArgs.Handled%2A>がマークされている`true`、および変更することで、イベント引数を変更<xref:System.Windows.RoutedEventArgs.Handled%2A>に`false`します。 キーの処理などのコントロールの入力イベントの特定の領域で必要になるこのこと<xref:System.Windows.UIElement.KeyDown>と<xref:System.Windows.UIElement.TextInput>それぞれさまざまなルーティング方法を使用しようと、下位レベルと高レベルの入力イベントの処理では、競合が発生します。  
  
   
  
## Examples  
 次の例では、マークのイベントを処理するイベント ハンドラーを実装します。  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberSignature Language="F#" Value="abstract member InvokeEventHandler : Delegate * obj -&gt; unit&#xA;override this.InvokeEventHandler : Delegate * obj -&gt; unit" Usage="routedEventArgs.InvokeEventHandler (genericHandler, genericTarget)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">呼び出すジェネリック ハンドラー/デリゲート実装。</param>
        <param name="genericTarget">指定したハンドラーが呼び出されるターゲット。</param>
        <summary>派生クラスでオーバーライドされた場合、型固有の方法でイベント ハンドラーを呼び出す方法を提供します。これにより、基本実装よりも効率が向上する場合があります。</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 基本の実装には、場所、ハンドラーは文字どおりすべてのケースで適切なハンドラーを判断するためにリフレクションが組み込まれています。 <xref:System.Windows.RoutedEventHandler>、このリフレクション手順がいくつかのパフォーマンスの影響をが。 呼び出しでリフレクションに依存しないがより効率的な行われることができます。 これは、このメソッドをオーバーライドする任意のルーティング イベント引数クラスで使用されるこのメソッドの用途シナリオです。 実装、実装は既にこの型の安全なハンドラーを呼び出すために、ベースをこのメソッドは呼び出せませんする必要があります。  
  
   
  
## Examples  
 実装に使用できる基本的なパターンを示す疑似コードを次に示します。 ここでは、`MyRoutedEventHandler`のサブクラスは<xref:System.Windows.RoutedEventHandler>します。  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>このメソッドは、デリゲートの呼び出しを効率化を提供する派生イベント データ クラスでオーバーライドされます。実装は、指定されたキャストする必要があります<paramref name="genericHandler" />型固有に委任し、そのハンドラーを呼び出します。既定の実装としてそれをキャストしようとして、指定したハンドラーを呼び出すしよう<see cref="T:System.Windows.RoutedEventHandler" />します。いずれか<paramref name="genericHandler" />または<paramref name="genericTarget" />として提供されます<see langword="null" />例外が発生します。</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member OnSetSource : obj -&gt; unit&#xA;override this.OnSetSource : obj -&gt; unit" Usage="routedEventArgs.OnSetSource source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">
          <see cref="P:System.Windows.RoutedEventArgs.Source" /> に設定する新しい値。</param>
        <summary>派生クラスでオーバーライドした場合、インスタンスの <see cref="P:System.Windows.RoutedEventArgs.Source" /> プロパティの値が変更されるたびに、通知コールバックのエントリ ポイントを提供します。</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>イベントの報告ソースをプログラムで変更するには、イベント内で型固有のデータを更新する可能性がありますが必要です。このため、<see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />メソッドは、仮想保護されているしのサブクラスによってオーバーライドするためのものが<see cref="T:System.Windows.RoutedEventArgs" />します。このメソッドには、既定の実装がありません。</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalSource : obj" Usage="System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>親クラスによって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、純粋なヒット テストで判断される元の報告ソースを取得します。</summary>
        <value>複合要素ツリーを平坦化するなどの目的でクラス処理によって <see cref="P:System.Windows.RoutedEventArgs.Source" /> が調整される前の、元の報告ソース。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 このプロパティは、クラスの前にイベント ハンドラーやインスタンス ハンドラーが呼び出され、このポイント以降は調整しないと、その値を取得します。 元のソース情報は、イベント データで報告されているのと同様はクラス ハンドラーまたはクラスの実装に読み取り専用です。  
  
 一般的なソースを調整することができますが、コントロールのコンテンツ モデル内のコンテンツの要素が含まれます (たとえば、リスト項目の内容としてリスト項目要素が報告されます、<xref:System.Windows.RoutedEventArgs.Source%2A>リスト項目内の実際の要素は、されます<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 ソースの調整によって、さまざまな要素およびコンテンツ モデルでは、クラスによって異なります。 イベント ソースを調整する各クラスがどのソースが最も入力シナリオと、クラスが対象とするシナリオを報告する中で最も役に立つを予測しようし、し、セットをソースとして、<xref:System.Windows.RoutedEventArgs.Source%2A>します。 このソースがイベントの処理に関連性のある 1 つでない場合は、確認してください。<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>代わりにする場合に別のソースがより適しているのがレポートを参照してください。 入力イベントの詳細については、次を参照してください。[入力の概要](~/docs/framework/wpf/advanced/input-overview.md)します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RoutedEvent : System.Windows.RoutedEvent with get, set" Usage="System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>この <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> インスタンスに関連付けられている <see cref="T:System.Windows.RoutedEventArgs" /> を取得または設定します。</summary>
        <value>呼び出されたイベントの識別子。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 この値を設定することはできません、<xref:System.Windows.RoutedEventArgs>が既にルーティングされている (たとえば、ハンドラーを引数を取得した) 場合。 しようとすると、例外が発生します。 イベントの呼び出しの生成に使用されていないインスタンスでのみ設定できます。  
  
 値<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>することはできません`null`いつでもできます。  
  
   
  
## Examples  
 次の例は、最初のコンス トラクターを持つ新しいルーティング イベントのデータを作成し、設定、<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>プロパティを後続の操作として。 必要があります<xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>ルーティング イベントを発生させる前に設定します。  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">イベントのルーティング中に <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> 値を変更しようとしました。</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Source : obj with get, set" Usage="System.Windows.RoutedEventArgs.Source" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>イベントを発生させたオブジェクトへの参照を取得または設定します。</summary>
        <value>イベントを発生させたオブジェクト。</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 発生元の要素の次のルートを実際に通過したイベントのバブル ルーティングされると、トンネリング ルーティングされていないイベントまだトンネリングの値であることを発生させた要素までの<xref:System.Windows.RoutedEventArgs.Source%2A>は、の値とは異なります`sender`イベント引数クラスのパラメーター。 任意の特定のハンドラーで最も重要ではイベントに関連する 2 つの要素の (<xref:System.Windows.RoutedEventArgs.Source%2A>、それを発生させた要素または`sender`、処理は、現在の要素) は、ハンドラーは、アプリケーション ロジックに依存アドレスを指定します。  
  
 このプロパティの設定は通常ときにのみ実行オーバーライドまたは実装するその他の[!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)]場合など、イベント ソースを調整するクラス イベントを処理します。 特に、処理済みとしてハンドラーが、イベントをマークしない場合、インスタンス ハンドラーからイベント ソースのリセットはお勧めしません。  
  
 実行をリセットする場合<xref:System.Windows.RoutedEventArgs.Source%2A>、別のイベント ソースをレポートする<xref:System.Windows.RoutedEventArgs.OriginalSource%2A>として最初のソース、送信元によって生成されるレポートは引き続き<xref:System.Windows.UIElement.RaiseEvent%2A>を呼び出します。  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>